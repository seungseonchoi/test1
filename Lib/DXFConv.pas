{************************************************************}
{   CAD.VCL Cross Platform Library  for Delphi / Lazarus     }
{                                                            }
{    CAD Databse classes. CAD Entities, sections, objects.   }
{            TsgDXFConerter is the main class to store       }
{                 the drawing database                       }
{                                                            }
{     Copyright (c) 2002 - 2020 SoftGold software company    }
{                       CADSoftTools?                       }
{************************************************************}

unit DXFConv;
{$INCLUDE SGDXF.inc}
{$INCLUDE CADSoftTools.inc}
//{$DEFINE SG_USEDWGVERSION}
{$IFOPT D+}
{.$DEFINE CONV_REFCOUNT}
{.$DEFINE SG_CALC_INSTANCE_SIZES}
{$ENDIF}

{$IFDEF SG_INLINE}
  {$DEFINE USE_INLINE}
{$ENDIF}

{.$DEFINE SG_VERSION_OLD}

interface

uses
{$IFDEF MSWINDOWS}
  Windows,
{$ENDIF}
{$IFDEF SG_HAS_ACTIVEX}ActiveX, {$ELSE}Poifs,{$ENDIF}
{$IFDEF SGFPC}
  LCLIntf, LCLType, {$IFDEF SG_NON_WIN_PLATFORM}cwstring,{$ENDIF}
{$ENDIF}
{$IFDEF SG_USEGDIPLUS}
{$IFDEF SG_WINAPI_GDIPLUS}
  Winapi.GDIPAPI, Winapi.GDIPOBJ,// Winapi.GDIPUTIL,
{$ELSE}
  GDIPlus,
{$ENDIF}
{$ENDIF}
  SysUtils, Classes, Math, SyncObjs, Properties, sgConsts, sgLines, SHX,
  sgFunction, sgLists, sgXMLParser, ExtData, sgComparer, sgContext
{$IFNDEF SG_NO_USE_KERNEL3D}
  , sgMDefinitions, sgMFunctions, sgModeller, sgModellerIO, sgModImportACIS
{$ENDIF}

{$IFDEF SGDEL_XE2}
  , System.UITypes
{$ELSE}
{$ENDIF}

{$IFDEF SG_PLUGINSHOST}
  , PluginsConstants
{$ENDIF}
{$IFDEF SG_BTI}
  , sgClassifiers
{$ENDIF}
{$IFDEF SG_FIREMONKEY}
  ,FMX.Graphics, FMX.Types, sgFMXTypes, sgProxyGraphics
{$ELSE}
  ,Graphics
{$ENDIF}
{$IFDEF SGDEL_6}
  ,Types , Variants
{$ENDIF}
  ;

type
  EsgDXFHatchError = class(Exception);
  EsgCADCommonError = class(Exception);
  EsgLimitMemoryUsesException = class(Exception);
  EsgOverflowUsesException = class(Exception);
  EsgLimitTimeUsesException = class(Exception);
  EsgIncorrectNameLayer = class(Exception);
  EsgInvalidVersion = class(Exception);

//{$HPPEMIT '__interface IsgListOfEntities;'}
//{$HPPEMIT 'typedef System::DelphiInterface<IsgListOfEntities> _di_IsgListOfEntities;'}

  TsgCADCurvePolygon = class;
  TsgDXFAcadTable = class;
  TsgDXFAcadTableStyle = class;
  TsgDXFAttdef = class;
  TsgDXFAttrib = class;
  TsgDXFBlock = class;
  TsgDXFBlockRecord = class;
  TsgDXFBlockRecords = class;
  TsgDXFDimensionStyle = class;
  TsgDXFConverter = class;
  TsgDXFDictionary = class;
  TsgDXFEntity = class;
  TsgDXFField = class;
  TsgDXFFieldList = class;
  TsgDXFGroup = class;
  TsgDXFInsert = class;
  TsgDXFImageEnt = class;
  TsgDXFLayer = class;
  TsgDXFLayout = class;
  TsgDXFLineType = class;
  TsgDXFMaterial = class;
  TsgDXFMText = class;
  TsgDXFObjectEntity = class;
  TsgDXFOwneredItem = class;
  TsgDXFProxy = class;
  TsgDXFTable = class;
  TsgDXFText = class;
  TsgDXFSection = class;
  TsgDXFSortEntsTable = class;
  TsgDXFStyle = class;
  TsgDXFViewport = class;
  TsgDXFVport = class;
  TsgDXFXref = class;
  TsgDXFImageDef = class;
  TsgDXFScale = class;
  TsgObjEntity3D = class;
  TConvStatus = (stDefault, stLoading, stEditing, stClearing, stDestroying,
    stReading, stRegeneration);
  TConvSection = (csTables, csBlocks, csEntities, csAppID, csLTypes, csLayers,
    csStyles, csDimStyles, csBlockRecords, csVPorts, csMLineStyles, csImageDefs,
    csLayouts, csTableStyles, csObjects, csClasses);
  TsgDXFEntityClass = class of TsgDXFEntity;
  TFPointProc = procedure(const P: TFPoint) of object;
  TsgCADEntityProc = function(Entity: TsgDXFEntity): Integer of object;

  {$IFDEF SG_NO_USE_KERNEL3D}
  TsgModEntity = TObject;
  TsgModellerLinker = TObject;
  TsgModeller = TObject;
  TsgModPartCompound = TObject;
  TsgModTopoShape = TObject;
  TsgModTopoFace = TObject;
  TsgModTopoEdge = TObject;
  TsgModMeshPolyline = TObject;
  TsgModMeshPolylineNode = TObject;
  TsgModPartInstance = TObject;
  TsgModAttribColorBase = Pointer;
  TsgMatrix4d = TFMatrix;
  PsgMatrix4d = ^TsgMatrix4d;
  TsgModStaticMesh = TObject;
  {$ENDIF}
  
  TsgBrepModIterateParams = record
    Matrix: TsgMatrix4d;
    CADColor: TColor;
    PartColor: TsgModAttribColorBase;
    ShapeColor: TsgModAttribColorBase;
    CurrentFace: TsgModTopoFace;
    CurrentFaceSunNormal: TFPoint;
    Data: Pointer;
  end;
  TsgModBrepIterateProc = procedure(const AEnt: TsgModEntity;
    var AParams: TsgBrepModIterateParams) of object;

{$IFDEF SG_BTI}
  TsgExtendedBlockData = class;
{$ENDIF}
  TsgCADFindFont = procedure(const AEntity: TsgDXFEntity;
    const AConverter: TsgDXFConverter;
    const ABigFont: Boolean; const AFontName: string; var AFontNameNew: string);
  TsgCADLoadEntitiy = function(const Entity: TsgDXFEntity; const Converter: TsgDXFConverter): Boolean;
  TsgCADNotifyEvent = procedure(const ASender: TsgDXFEntity) of object;
  TsgCADImageDefResolver = procedure(AImageDef: TsgDXFImageDef; AConverter: TsgDXFConverter;
    var AFileName: string; var AIsResolve: Boolean) of object;
  TsgCADXRefResolver = procedure(AXRef: TsgDXFXref; var AFileName: string;
    var AIsResolve: Boolean) of object;
  TsgCADSHXResolver = procedure(AStyle: TsgDXFStyle; const ABigFont: Boolean;
    AFonts: TsgSHXFontList; var ASHXFont: string; var AIsResolve: Boolean) of object;
  TsgCADNotifyMessage = procedure(const AEntity: TObject;
    const AParams: TsgMessageParams) of object;
  TsgDXFTextPos = (csNone, csFraction, csIndexes, csDenominator, csWord, csHiWord, csLowWord,
    csDivision, csDivHi, csDivLow, csDivend);
  TsgDimTextPosVert = (pvCenter, pvAbove, pvOutSide, pvJIS);

  PsgCADIterate = ^TsgCADIterate;
  TsgCADIterate = record
    Matrix: TFMatrix;
    DrawMatrix: TFMatrix;
    Insert: TsgDXFInsert;
    Viewport: TsgDXFViewport;
    BlockStack: {$IFDEF SG_FIREMONKEY}TsgObjectList{$ELSE}TsgList{$ENDIF};
    ConvertMatrixCurrentInsertToWCS: TFMatrix;
    Color: TColor;
    XScale: Single;
    YScale: Single;
    Angle: Single;
    Additional: Integer;
    LType: TsgLines;
    RegenScale: TFMatrix;
    ViewPortRect: TFRect;
    Stopped: Boolean;
  end;

  PsgParagraphParams = ^TsgParagraphParams;
  TsgParagraphParams = packed record
    IsFirstLine: Boolean;
    IsFirstText: Boolean;
    I: TsgFloat;//offset by first line
    L: TsgFloat;//offset by all text in paragraph
    //R: TsgFloat;//offset from right all text in paragraph
    T: Integer; //count tab
    Tabs: array [0..15] of Single;
    TabsCount: Integer;
    PXQAlign: Byte;
    LineSpacingStyle: Integer;
    LineSpacingFactor: Double;
    BeforeSpacingFactor: Double;
    AfterSpacingFactor: Double;
    DecimalSymStyle: Char;
  end;

  PsgTextParse = ^TsgTextParse;
  TsgTextParse = packed record
    FontParams: TsgFontParams;
    HasLine: Boolean;
    Offset: TF2DPoint;
    ParagraphParams: TsgParagraphParams;
    TextPos: TsgDXFTextPos;
    IsEmpty: Boolean;
    Level: Integer;
    SpacesBefore: Integer;
    Spaces: Integer;
  end;

  TsgConverterParams = record
    CheckHandles: Boolean;
    UpdateEvent: TNotifyEvent;
    FileName: string;
  end;

  PsgPolyFaceVertexIndexes = ^TsgPolyFaceVertexIndexes;
  TsgPolyFaceVertexIndexes = array [1..4] of Integer;

  {IsgListOfEntities = interface
    [cnstGUID_ListOfEntities]
    function AddEntity(const AEntity: TsgDXFEntity): Integer;
    procedure Clear(const ADoFree: Boolean = True);
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity;
    function GetCount: Integer;
    function GetEntity(const AIndex: Integer): TsgDXFEntity;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity);
    procedure ExchangeEntity(AIndex1, AIndex2: Integer);
    function RemoveEntity(const AEntity: TsgDXFEntity): Boolean;
    property Count: Integer read GetCount;
    property Entities[const AIndex: Integer]: TsgDXFEntity read GetEntity write SetEntity; default;
  end;}

  TsgOwneredItem = class;

  TsgOwneredItemClass = class of TsgOwneredItem;

  TsgEntitiesList = class(TsgObjectList)
  private
    function GetEntity(const AIndex: Integer): TsgDXFEntity;
    procedure SetEntity(const AIndex: Integer; const Value: TsgDXFEntity);
  public
    property Entities[const AIndex: Integer]: TsgDXFEntity
      read GetEntity write SetEntity; default;
  end;

  TsgVertexesList = class(TsgObjectList, IsgArrayVertexes)
  public
    function GetFPoint(const AIndex: Integer): TFPoint;
    function GetFPointCount: Integer;
    function GetBulge(const AIndex: Integer): Double;
    property Bulges[const AIndex: Integer]: Double read GetBulge;
    property FPointCount: Integer read GetFPointCount;
  end;


  TsgMultiSortType = (mstCustom, mstInstance, mstName, mstHandle, mstDescription);

  TsgMultiSortItemsList = class(TsgObjectList)
  private
    FSearchElem: TsgOwneredItem;
    function GetByHandle(AHandle: UInt64): TsgOwneredItem;
    function GetByName(const AName: string): TsgOwneredItem;
    function GetSortType: TsgMultiSortType;
    procedure SetSortType(const Value: TsgMultiSortType);
    function GetByDescription(const ADescription: string): TsgOwneredItem;
  protected
    function CmpDescription(const Item1, Item2: Pointer): Integer;
    function CmpName(const Item1, Item2: Pointer): Integer;
    function CmpHandle(const Item1, Item2: Pointer): Integer;
  public
    constructor Create; override;
    destructor Destroy; override;
    class function IsEqualMethods(const AProc1, AProc2: TsgObjProcCompare): Boolean;
    property SortType: TsgMultiSortType read GetSortType write SetSortType;
    property ByName[const AName: string]: TsgOwneredItem read GetByName;
    property ByHandle[AHandle: UInt64]: TsgOwneredItem read GetByHandle;
    property ByDescription[const ADescription: string]: TsgOwneredItem read GetByDescription;
  end;

  TsgXDataProcs = class
  public
    constructor Create; virtual; abstract;
    function AddEntity(const AEntity: TsgDXFEntity): Integer; virtual; abstract;
    function LoadEntity(const AEntity: TsgDXFEntity): Boolean; virtual; abstract;
    procedure LinkEntity(const AEntity: TsgDXFEntity); virtual; abstract;
    procedure Initialize(const AConv: TsgDXFConverter); virtual; abstract;
    procedure Finalize; virtual; abstract;
    function Import(const AEntTypeNum: Integer;
      PXData: Pointer): TsgDXFEntity; virtual; abstract;
    function IsInternalCADImage(const AImg: Pointer): Boolean; virtual; abstract;
    function Warning(const AConv: TsgDXFConverter;
      const AType: Integer): Integer; virtual; abstract;
    function RestoreNames(const AConv: TsgDXFConverter): Integer; virtual; abstract;
  end;

  TsgClassXDataProcs = class of TsgXDataProcs;

  TsgStackObject = class(TList)
  public
    procedure Clear;{$IFNDEF SG_FIREMONKEY} override;{$ENDIF}
    function Pop: TsgDXFEntity;
    procedure Push(const AObject: TsgDXFEntity);
  end;

  TsgMapEntities = class
  private
    FConverter: TsgDXFConverter;
    FEntitiesWithGeneratedHandles: TsgList;

    FEntities: TsgList;
    FFindEntity: TsgDXFObjectEntity;
  protected
    function UseEntity(const AEntity: TsgDXFEntity): Boolean;
    procedure RegEntity(const AEntity: TsgDXFEntity);
    procedure UnRegEntity(const AEntity: TsgDXFEntity);
  public
    constructor Create(const AConverter: TsgDXFConverter);
    destructor Destroy; override;
    procedure ApplyAndFreeGeneratedList;
    procedure AddEntityToGeneratedList(const AEntity: TsgDXFEntity);
    procedure AddEntitiesToGeneratedList(const AEntities: TsgDXFEntity);
    procedure CreateGeneratedList;
    function RemoveEntityFromGeneratedList(const AEntity: TsgDXFEntity): Boolean;
    function HasGeneratedList: Boolean;

    procedure ActivateRegister;
    procedure UnActivateRegister;
    function GetEntityByHandle(const AHandle: UInt64): TsgDXFEntity;
  end;

  //??? TsgDXFConverter should be inherited from TsgDXFGroup but..
  //it has entities[] inside and they work not with sections.. what is why it is written here speciall  //

  TsgConverterExtented = class
  private
    FOwner: TsgDXFConverter;
    FHandleArray: TsgInt64List;
    FSelectedHandles: TsgObjectHandleList;
  protected
    function GetIndexHandle(const AValue: string): Integer;
  public
    constructor Create(const AOwner: TsgDXFConverter);
    destructor Destroy; override;
    function RestoreHandle(const AExtendHandle: string): Int64;
    procedure SaveHandle(const AValue: string; const AEntity: TsgDXFEntity);
    function GetSaveHandlesToNode(const ANode: TsgNode): Integer;
    property SelectedHandles: TsgObjectHandleList read FSelectedHandles;
  end;

  TsgDXFConverter = class(TsgListObject)
  private
    FUpdateTickStart: Cardinal;
    FUpdateTickCurrent: Cardinal;
    FConvExtended: TsgConverterExtented;
    FActiveVPort: TsgDXFVPort;
    FAddedDimensionsCount: Integer;
    FAddedTablesCount: Integer;
    FAfterRead: TNotifyEvent;
    FAllArcsAsCurves: Boolean;
    FAutoInsert: Boolean;
    FBlocksSection: TsgDXFSection;
    FClassesSection: TsgDXFSection;
    FBlockRecords: TsgDXFTable;
    FBeforeRead: TNotifyEvent;
    FCount: Integer;
    FContainerXref: TsgDXFXref;
    FDefaultLayoutIndex: Integer;
    FDimStyles: TsgDXFTable;
    FFieldList: TsgDXFFieldList;
    FFileName: string;
    FOnFindFont: TsgCADFindFont;
    FHeadEnd: PAnsiChar;
    FHeadVarStruct: TsgHeadVarStruct;
    FImportMode: TsgImportMode;
    FImageDefs: TsgDXFTable;
    FCrossoverMatrix: Boolean;
    FIsHaveActiveVPort: Boolean;
    FLayers: TsgDXFTable;
    FLayouts: TsgDXFTable;
    FGroups: TsgDXFEntity;
    FLimit: PAnsiChar;
    FLTypes: TsgDXFTable;
    FMain: TsgDXFSection;
    FMaxEntities: Integer;
    FMStyles: TsgDXFTable;
    FOnCreate: TNotifyEvent;
    FOnIterateBegin: TsgCADNotifyEvent;
    FOnIterateEnd: TsgCADNotifyEvent;
    FOnLayoutAdd: TNotifyEvent;
    FOnLayoutRemove: TNotifyEvent;
    FOnLoad: TsgCADEntityProc;
    FOnSetEntityPropError: TsgCADNotifyMessage;
    FOnRead: TNotifyEvent;
    FOnImageDefResolve: TsgCADImageDefResolver;
    FOnSHXResolve: TsgCADSHXResolver;
    FOnXRefResolve: TsgCADXRefResolver;
    FOnModellerMsg: TsgCADNotifyMessage;
    FAcisNumber: Integer;
    FOnAcisNumberMsg: TsgCADNotifyMessage;
    FOwnerConverter: TsgDXFConverter;
    FEntityProxyList: TsgObjectList;// TsgCollection;
{$IFDEF SG_OPENING_IN_THEADS}
    FCADIterateThreadParams: TsgCollection;
{$ELSE}
    FParams: PsgCADIterate;
{$ENDIF}
    FPos: PAnsiChar;
{$IFDEF CONV_REFCOUNT}
    FRefCount: Integer;
    FRefEnts: TsgList;
{$ENDIF}
    FRefs: Integer;
    FSHXFonts: TsgSHXFontList;
    FSource: TCustomMemoryStream;
    FStatus: TConvStatus;
    FStyles: TsgDXFTable;
    FTableStyles: TsgDXFTable;
    FTablesSection: TsgDXFSection;
    FHeaderSection: TsgDXFSection;
    FObjectsSection: TsgDXFSection;
    FEntitiesSection: TsgDXFSection;
    FTransform3D: TFMatrix;
    FViewTwistMatrix: TFMatrix;
    FUseSHXFonts: Boolean;
    FVPorts: TsgDXFTable;
    FAppIDs: TsgDXFTable;
    FXRefs: TList;
    FXRefSearchPaths: TsgStringList;
    FMaxHandle: UInt64;
    FOwnSource: Boolean;
    FDrwPropInfo: TStringList;
    FDrwPropCustomSummaryInfo: TStringList;
    FDrwPropCreatedDateTime: TDateTime;
    FDrwPropModifiedDateTime: TDateTime;
    FDrwPropTotalEditingTime: TTimeStamp;
    FLastSave: Double;
    FMapEntities: TsgMapEntities;
    FQualityRegenerate: Integer;
    FTotalACISLoading: Cardinal;
    FMeshQuality: Double;
{$IFDEF SG_BTI}
    FXDataProcs: TsgXDataProcs;
{$ENDIF}
    FEntityDictionaries: TsgCollection;
    FEntityEEDItems: TsgObjectCollection;
    FAnnoDesc: string;
    FAnnoScale: TsgDXFScale;
    FOleFrame: Byte;
    FCharset: Byte;
    FScaleList: TsgDXFEntity;
    FModellerLinker: TsgModellerLinker;
    FUpdateEvent: TNotifyEvent;
    FLoadStopped: Boolean;
    FRegenDelta: Double;
    FAppIdIntHandle: UInt64;
    function CheckUnicode: Boolean;
    function CheckEqualHandle(const AEntity: TsgDXFEntity;
      const AHandles: TsgInt64List; const ALog: TStrings = nil): Integer;
    function CheckEntName(var AName: string;
      const ASection: TConvSection; const AAfterLoad: Boolean): Boolean;
    function FEntities: TsgDXFBlock;
    function GetActiveVPort: TsgDXFVPort;
    function GetAngle: Single;
    function GetBlock(Index: Integer): TsgDXFBlock;
    function GetCodePage: Integer;
    function GetCount(Index: TConvSection): Integer;
    class function GetTableItemClasses(const AIndex: TConvSection): TsgDXFEntityClass;
    function GetCircleZoomPercent: Integer;
    function GetDefaultLayoutIndex: Integer;
    function GetDimStyle(Index: Integer): TsgDXFDimensionStyle;
    function GetDisplayImageFrame: Boolean;
    function GetEntity(const AIndex: Integer): TsgDXFEntity;
    function GetExtents: TFRect;
    function GetFieldList: TsgDXFFieldList;
    function GetHeadVarAsFPt(AName: string): TFPoint;
    function GetHideWipeouts: Boolean;
    function GetImageDef(const Index: Integer): TsgDXFImageDef;
    function GetLayer(Index: Integer): TsgDXFLayer;
    function GetLayout(const AIndex: Integer): TsgDXFLayout;
    function GetLayoutsCount: Integer;
    function GetLoadStopped: Boolean;
    function GetLType(Index: Integer): TsgDXFLineType;
    function GetMainConverter(AMatrix: PFMatrix): TsgDXFConverter; overload;
    function GetMainConverter: TsgDXFConverter; overload;
    function GetNumberOfPartsInCircle: Integer;
    function GetNumberOfPartsInSpline: Integer;
{$IFDEF SG_VERSION_OLD}
    function GetPaperSpace: Boolean; {$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version!'{$ENDIF};{$ENDIF}
{$ENDIF}
    function GetPointDisplayMode: Integer;
    function GetSection(Index: TConvSection): TsgDXFGroup;
    function GetSectionInt(const AIndex: TConvSection): TsgDXFGroup;
    function GetSHXFonts: TsgSHXFontList;
    function GetSHXFont(const AStyle: TsgDXFStyle; const ABigFont: Boolean;
      ASHXFont: string = ''; const AResolve: Boolean = True): TsgSHXFont;
    function GetStyle(Index: Integer): TsgDXFStyle;
    function GetTable(Index: Integer): TsgDXFTable;
    function GetVPort: TFPoint;
    function GetVPortByIndex(const AIndex: Integer): TsgDXFVPort;
    function GetIs3D: Boolean;
    function GetXRefSearchPath: string;
    function GetXRefSearchPaths: TStringList;
    function GetDrwHyperlinkBase: string;
    function GetDrwPropAuthor: string;
    function GetDrwPropComments: string;
    function GetDrwPropKeywords: string;
    function GetDrwPropSavedBy: string;
    function GetDrwPropSubject: string;
    function GetDrwPropTitle: string;
    function GetDrwRevisionNumber: string;
    function GetPHeadVarStruct: PsgHeadVarStruct;
    function GetDrwPropCustomSummaryInfo: TStringList;
    function IterateEntitiesInBlocks(const AProc: TsgCADLoadEntitiy): Boolean;
    procedure InitXRefConverter(const AXRefConv: TsgDXFConverter;
      const AXRef: TsgDXFXref);
    function NewTable(const AType: TConvSection): TsgDXFTable;
    procedure DeleteModelLayout;
    procedure DeletePaperLayout;
    procedure HeadVarStructInit;
    procedure SetSection(Index: TConvSection; Value: TsgDXFGroup);
    procedure FreeSource;
    procedure SetActiveVPort(const AValue: TsgDXFVPort);
    procedure SetAngle(const AAngle: Single);
    procedure SetCircleZoomPercent(const AVal: Integer);
    procedure SetDisplayImageFrame(const Value: Boolean);
    procedure SetHideWipeouts(const Value: Boolean);
    procedure SetImportMode(const Value: TsgImportMode);
    procedure SetNumberOfPartsInCircle(const ACount: Integer);
    procedure SetNumberOfPartsInCircleInternal(const ACount: Integer);
    procedure SetNumberOfPartsInSpline(const ACount: Integer);
    procedure SetNumberOfPartsInSplineInternal(const ACount: Integer);
    procedure SetSource(Value: TCustomMemoryStream);
    procedure SetOwnSource(Value: Boolean);
    procedure SetVPort(const APt: TFPoint);
{$IFDEF SG_VERSION_OLD}
    procedure SetPaperSpace(const AValue: Boolean);{$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version!'{$ENDIF};{$ENDIF}
{$ENDIF}
    procedure SetPointDisplayMode(const Value: Integer);
    procedure SetStatus(const AValue: TConvStatus);
    procedure SetLTScale(const Value: Double);
    procedure SetXRefSearchPath(const Value: string);
    procedure SetCrossoverMatrix(const AValue: Boolean);
    procedure SetDrwHyperlinkBase(const Value: string);
    procedure SetDrwPropAuthor(const Value: string);
    procedure SetDrwPropComments(const Value: string);
    procedure SetDrwPropKeywords(const Value: string);
    procedure SetDrwPropSavedBy(const Value: string);
    procedure SetDrwPropSubject(const Value: string);
    procedure SetDrwPropTitle(const Value: string);
    procedure SetDrwRevisionNumber(const Value: string);
    procedure SetExtents(const AValue: TFRect);
    procedure SetOleFrame(const AValue: Byte);
    procedure SetRegenerateArcs(const AValue: Boolean);
    function GetDrwPropInfo: TStringList;
    function GetXDataProcs: TsgXDataProcs;
    function GetConvExtended: TsgConverterExtented;
    function GetEEDItems(AEntHandle: UInt64): TsgObjectCollection;
    function GetDictionary(AEntHandle: UInt64): TsgDXFEntity;
    function GetRegenerateArcs: Boolean;
    function GetHighQualityRegenerateArcs: Boolean;
    procedure SetCurversQuality(const AValue: Integer);
    procedure SetHighQualityRegenerateArcs(const AValue: Boolean);
    procedure SetLoadStopped(const Value: Boolean);
    function GetVersion: TsgDWGVersion;
{$IFDEF SG_OPENING_IN_THEADS}
    function GetParams: PsgCADIterate;
    procedure SetParams(const Value: PsgCADIterate);
{$ENDIF}
  protected
    FNumberOfPartsInSpline: Integer;
    FNumberOfPartsInCircle: Integer;
{$IFDEF SG_BTI}
    FBTIExtDataVersion: TsgVersion;
    FPreclean: Boolean;
{$ENDIF}
    FMapExternal: IsgObjCollection;
{$IFDEF SG_OPENING_IN_THEADS}
    FLock: SyncObjs.TCriticalSection;
{$ENDIF}
    function AddAttribsByBlock(const AIns: TsgDXFInsert; const ABlock: TsgDXFBlock): Boolean;
    function AddEddNameValue(const AEnt: TsgDXFEntity;
      const AName, AValue: string): Boolean;
    function GetEddNameValue(const AEnt: TsgDXFEntity;
      var AName, AValue: string; const AStrings: TStrings = nil): Boolean;
    procedure ApplyXRecodData(AFreeList: TsgObjectList);
    procedure ApplyVariables;
    function ApplyCADHatchSettings(const AEntity: TsgDXFEntity): Boolean;
    procedure CompositeMLAtt;
    procedure DecompositeMLAtt;
    procedure DoCompositeMLAtt(ANode: TsgDXFEntity);
    procedure DoDecompositeMLAtt(ANode: TsgDXFEntity);
    procedure DoIterateBegin(ASender: TsgDXFEntity);
    procedure DoIterateEnd(ASender: TsgDXFEntity);
    procedure CreateEntitiesWithGeneratedHandles;
    procedure CreateXDataProcs(AClass: TsgClassXDataProcs = nil);
    procedure DestroyXDataProcs;
    procedure DoModellerMsg(const AObj: TObject; const ACode: Integer;
      const AMsg: string);
    procedure DoAcisNumberMsg;
{$IFDEF SG_OPENING_IN_THEADS}
    procedure PurgeCADIterateParams;
{$ENDIF}
    procedure ClearEED(const AAppID: Variant); overload;
    procedure ClearEED(const AAppID: UInt64); overload;
    procedure ClearBegin; virtual;
    procedure ClearEnd; virtual;
    class function CompareEntities(const AEnt1, AEnt2: Pointer): Integer;
    procedure FreeEntitiesWithGeneratedHandles;
    procedure AddEntitiesWithGeneratedHandles(const AEntity: TsgDXFEntity);
    function RemoveFromEntitiesWithGeneratedHandles(const AEntity: TsgDXFEntity): Boolean;
    procedure AddACADLayout(ALayout: TsgDXFLayout);
    function AddLineType(const ALTypeName: string;
      const AUniform: Integer; const ADashes: array of Double): TsgDXFEntity;
    function AddDrawingLayout(ACADImage: TObject; AName: string): TsgDXFLayout;
    function BlockRecordNameByHandle(const AHandle: UInt64): string;
//    function BlockRecordByName(const AName: string): TsgDXFBlockRecord;
    function BlockRecordByHandle(const AHandle: UInt64): TsgDXFBlockRecord;
    function CheckActiveVPort(const AbsHeight: Double): Boolean;
    function CheckHandle(var AHandle: UInt64): Boolean;
//    function CheckBlockByName(const ABlock: TsgDXFBlock; const AMaxHandle: UInt64): Integer;
    function CustomEntByName(const AName: string;
      const ASection: TConvSection;
      const ACreateNew: Boolean = True): TsgDXFEntity;
    function CheckEqualHandles(const ALog: TStrings = nil): Integer;

    function CreateAcadTableStyles(const AppLanguage: TsgLangugeID;
      const ACreate: Boolean): TsgDXFAcadTableStyle;
    function CreateDimStyles(const AppLanguage: TsgLangugeID;
      const ACreate: Boolean): TsgDXFDimensionStyle;
    function CreateTextStyles(const AppLanguage: TsgLangugeID;
      const ACreate: Boolean): TsgDXFStyle;

    function DoFindFont(const AEntity: TsgDXFEntity; const ABigFont: Boolean;
      const AFontName: string): string;
    procedure DoSetEntityPropError(const AEntity: TsgDXFEntity;
      const AParams: TsgMessageParams);
    procedure ClearBlocks;
    procedure CreateDefaultDrawingProp; virtual;
    function GetDWGVersion(const S: AnsiString; var AVersion: TsgDWGVersion): Integer; virtual;
    function GetModelLayout: TsgDXFLayout;
    function GetModelMatrix: TFMatrix;
    function GetDimStyleFromNode(const ANode: TsgNodeSample): TsgDXFDimensionStyle;
    function GetModeller: TsgModeller;
    function GetAppIDHandle(const AAppIp: string): UInt64;
    function GetAppIdIntHandle(const Add: Boolean = True): Int64;

    function GetNumberOfCirclePartsByRadius(const ARadius: Double): Integer;
    function GetNumberOfCirclePartsByBulge(const P1,P2: TFPoint;
      const ABulge: Double): Integer;
    procedure GenerateDisplayAndModelViewPort(const ALayout: TsgDXFLayout;
      const AWidth, AHeight: Double; const AMode: Integer; const ABox: PFRect = nil);
    function GetHeaderSection: TsgDXFSection;
    function GetUniqueBlockName(const ABaseName: string;
      AIndex: PInteger = nil): string;
    function GetBackGroundLayer: TsgDXFLayer;
    function GetActiveVPortUCSMatrix: TFMatrix;
    procedure Initialize; virtual;
    procedure IniProcResolve;
    property PHeadVarStruct: PsgHeadVarStruct read GetPHeadVarStruct;
//    procedure ResetBlockRecords;
    procedure ReLoadEntities(const AType: Integer; ABlockStack: TsgObjectList = nil);
    procedure ReplaceLayout(Index: Integer; ALayout: TsgDXFLayout);
    function ReInitBlockByEntities(const AInserts: TList): Boolean;
    procedure ResetHandles;
    procedure SetHandSeed(const AMaxHandle: UInt64);
    procedure SetHandle(E: TsgDXFEntity);
    procedure SetHandleGroup(E: TsgDXFEntity);
    procedure SetCodePage(ACodePage: Integer);
    procedure SetLoading(Value: Boolean; APos: PAnsiChar; const AOnUpdate: TNotifyEvent = nil);
    property TotalACISLoading: Cardinal read FTotalACISLoading //see procedure TsgDXFACISEntity.MeshBrepBuilder
      write FTotalACISLoading;
    // sections notifications
    procedure MainNotify(const Obj: TObject; Action: TListNotification);
    procedure ObjectsNotify(const Obj: TObject; Action: TListNotification);
    procedure TablesNotify(const Obj: TObject; Action: TListNotification);
    procedure LayoutsNotify(const Obj: TObject; Action: TListNotification);
    procedure EntityListNotify(const Obj: TObject; Action: TListNotification);

    class procedure SetLayerNameOfPassingInspection(const ALayer: TsgDXFlayer;
      const AName: string);

    // call for initialization reader classes (dxf/dwg)
    class procedure RegisterXRefGraphicClass(AExt: string; AGraphicClass: TGraphicClass);
    class procedure UnRegisterXRefGraphicClass(AGraphicClass: TGraphicClass);

    //xml functions
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function FromXMLSubEntities(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer; override;
    function GetLayerByNode(const ANode: TsgNodeSample): TsgDXFLayer;
    function GetLineTypeByNode(const ANode: TsgNodeSample): TsgDXFLineType;
    function ToXMLWithParamsBase(const AParentNode: TsgNode;
      const AParams: TsgXMLParams): TsgNode;
    procedure GetXmlSectionNames(const ANames: TStrings;
      const AParams: TsgXMLParams); virtual;

    procedure ResolveNotFoundImageDef(AImageDef: TsgDXFImageDef;
      var AFIleName: string; var AIsResolve: Boolean);
    procedure ResolveNotFoundSHX(AStyle: TsgDXFStyle; const ABigFont: Boolean;
      AFonts: TsgSHXFontList; var ASHXFont: string; var AIsResolve: Boolean);
    procedure ResolveNotFoundXRef(AXRef: TsgDXFXref; var AFileName: string;
      var AIsResolve: Boolean);

    procedure InitRegeneration(const ABlock: TsgDXFBlock; const ADelta: Double);

    function RestoreHandle(const ANode: TsgNodeSample): Int64; overload;
    function RestoreHandle(const AExtendHandle: string): Int64; overload;
    procedure SaveHandle(const AValue: string; const AEntity: TsgDXFEntity);

    function ForwardToModeler(const AHandle: string; const APathKey: string = ''): TsgObjEntity3D;


    function SetEntDict(const AEnt, ADict: TsgDXFEntity): Integer;
    function SetEntEED(const AEnt: TsgDXFEntity; AAppID: UInt64; AEEData: TsgCADExtendedData): Integer;
    procedure ClearEntEED(const AEnt: TsgDXFEntity);
    function GetEEDByHandle(const AAppID, AHandle: UInt64): TsgCADExtendedData;
    procedure ExcludeFromGroups(const AEnt: TsgDXFEntity);

    procedure CADExtendedDataToXMLNode(const AAppID: UInt64;
      const AExtData: TsgCADExtendedData; const ANode: TsgNode);

    procedure SetModellerLinker(const ALinker: TsgModellerLinker);
    class function CADHatchSetting: TsgHatchSettting;
    class function ObjToString(const Sender: TObject): string;
    procedure UpdateAcAuthEnvironBlockRecord(ABlockRecord: TsgDXFBlockRecord);
    procedure UpdateViewTwistMatrix;
    procedure UpdateProgressLoaded(AState: Integer);
    function ExchangeParams(AParams: PsgCADIterate): PsgCADIterate;
    function QueryXInfo(var AAppFileVer: string; var AVerified: Boolean): Boolean;
    property OnIterateBegin: TsgCADNotifyEvent read FOnIterateBegin write FOnIterateBegin;
    property OnIterateEnd: TsgCADNotifyEvent read FOnIterateEnd write FOnIterateEnd;
    property OnLoad: TsgCADEntityProc read FOnLoad write FOnLoad;
    property DrwPropInfo: TStringList read GetDrwPropInfo;
    property VPorts[const AIndex: Integer]: TsgDXFVPort read GetVPortByIndex;
    property Status: TConvStatus read FStatus write SetStatus;
    property XDataProcs: TsgXDataProcs read GetXDataProcs;
    property Dictionary[AEntHandle: UInt64]: TsgDXFEntity read GetDictionary;
    property EntityDictionaries: TsgCollection read FEntityDictionaries;
    property EntityEEDItems: TsgObjectCollection read FEntityEEDItems;
    property EEDItems[AEntHandle: UInt64]: TsgObjectCollection read GetEEDItems;
    property LastSave: Double read FLastSave write FLastSave;
    property ScaleList: TsgDXFEntity read FScaleList write FScaleList;
    property Groups: TsgDXFEntity read FGroups write FGroups;
    property LoadStopped: Boolean read GetLoadStopped write SetLoadStopped;
    property Version: TsgDWGVersion read GetVersion;
  public
    constructor Create; override;
    constructor CreateEx(const AParams: TsgConverterParams);
    constructor CreateFromFile(const AFileName: string);
    destructor Destroy; override;

    function ToXMLWithParams(const AParentNode: TsgNode;
      const AParams: TsgXMLParams): TsgNode; override;
    function FromXML(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer; override;

    function AddLayout(ALayout: TsgDXFLayout): Integer;
    procedure FillMainSection;
    function AddXRef(ACADFile: TObject; AName: string; APos, AScale: TFPoint; Rotation: Single;
      const ALayout: TsgDXFLayout = nil): TsgDXFInsert;
    function AddXRefEx(ACADFile: TObject; AName: string; APos, AScale: TFPoint;
      Rotation: Single; ALayout: TsgDXFLayout; const AddXrefLayers: Boolean = True): TsgDXFInsert;
    function BlockByName(const AName: string): TsgDXFBlock;
    function QueryCorrectBlockName(const AName, ABaseName: string; const ABlock: TsgDXFBlock): string;
    procedure CleaningLayouts(ADeletePSpace: Boolean);
    procedure Clear;
    procedure ClearDrawingProp;
    procedure ClearTimeStamps;
    function Count: TsgNativeUInt;
    procedure CustomSummaryInfoAdd(const Key, Value: string);
    procedure CustomSummaryInfoDelete(const Key: string);
    function RemoveEntity(AEntity: TsgDXFEntity; DoFree: Boolean): Boolean;
    function DeleteBlock(ABlock: TsgDXFBlock; DoFree: Boolean): Boolean;
    function DeleteDimStyle(AStyle: TsgDXFDimensionStyle; DoFree: Boolean): Boolean;
    function DeleteLayout(ALayout: TsgDXFLayout): Boolean;
    procedure DoCreate(Sender: TObject); dynamic;
    procedure DoExtents;
    function AnnoDesc: string;
    function ExtractFromTable(const ATable: TsgDXFGroup;
      const AEntity: TsgDXFEntity): TsgDXFEntity;
    function FindEntityByHandle(const AHandle: UInt64): TsgDXFEntity;
    function FindObjByHandle(const AHandle: UInt64): TsgDXFEntity;
    function FindObjByHandles(const AHandles: TsgInt64List;
      const AEntities: TList; const AGroup: TsgDXFEntity = nil): Integer; overload;
    function FindObjByHandles(const AHandles: TList;
      const AEntities: TList; const AGroup: TsgDXFEntity = nil): Integer; overload;
    function GenerateModelViewPort(const ACenter: TFPoint; const AWidth, AHeight: Double;
      const ALoad: Boolean; const AFitModel: Boolean = False): TsgDXFViewPort;
// Generates a standard ViewPort for Paper_Space (i.e. - basic display ViewPort)
    function GenerateDisplayViewPort(const AWidth, AHeight: Double): TsgDXFViewPort;
    procedure GetLayerNames(S: TStrings; DoClear, IncludeUnused: Boolean);
    function GetDynamicBlockTrueName(const AAnnonimusBlockName: string; var AName: string): Boolean;
    function GetLTScale: Double;
    function GetUCS(ALayout: TsgDXFLayout): TFMatrix;
    function GetTransform3d: TFMatrix;
    class function GetPropertyName: string; override;
    procedure GetSubEntities(const AList: TList);
    procedure ClearEntityProxy;
    function GetEntityProxy(const AEntity: TObject;
      const APathKey: string): TsgObjEntity3D;
    function GetReference(AClass: TsgObjectClass; AName: string): TsgListObject;
    function GetTextPolylines(AText: TsgDXFText; ACollection: TsgCustomPolyItemsCollection): Integer; overload;
    function GetTextPolylinesList(const AText: TsgDXFText; const AList: TsgObjectList): Integer;//AList has TFPointLists
    function GetTextPolylines(const AText: TsgDXFText; const AList: TList): Integer;overload; {$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version. Please, use the following procedure - function TsgDXFConverter.GetTextPolylines(AText: TsgDXFText; ACollection: TCustomPolyItemsCollection): Integer;!'{$ENDIF};{$ENDIF}
    function GetModPolylines(ACompound: TsgModPartCompound;
      ACollection: TsgCustomPolyItemsCollection;
      var AParams: TsgBrepModIterateParams): Integer;
    function IntToColor(Value: Integer): TColor;
    procedure InitializeSections; {$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version. Please, use the following procedure - InitializeSectionsBegin!'{$ENDIF};{$ENDIF}
    procedure InitializeSectionsBegin;
    procedure InitializeSectionsEnd(const AfinalizationLoading: Boolean = False);
    procedure Iterate(Proc, FinishProc: TsgCADEntityProc; var AParams: TsgCADIterate);
    function LayerByName(const AName: string): TsgDXFLayer;
    function LayoutByName(AName: string): TsgDXFLayout;
    function LinesByName(const AName: string): TsgLines;
    procedure Loads(E: TsgDXFEntity);
    procedure LoadsGroup(E: TsgDXFEntity);
    procedure LoadsByClasses(const AEntityClasses: array of TsgDXFEntityClass);
    procedure LockLayers;
    function LTypeByName(const AName: string): TsgDXFLineType;
    function NewNamedEntity(AOwner: TsgDXFEntity; AClass: TsgDXFEntityClass;
      const AName: string): TsgDXFEntity;
    function NewNamedTable(const AName: string; AClassType: TsgDXFEntityClass): TsgDXFTable;
    function NewEntity(AOwner: TsgDXFEntity; AClass: TsgDXFEntityClass): TsgDXFEntity;
    function Pos: TsgNativeUInt;
    procedure Reference;
    procedure Release;
    procedure SetTransform3d(AMatrix: TFMatrix);
    procedure SortEntities;
    function SortEntitiesInZDepth: Boolean;
    procedure SortEntitiesByHandle(const ATable, ABlock: TsgDXFEntity);
    procedure StopLoading; virtual;
    procedure SetSourceStream(S: TStream);
    function DimensionStyleByName(const AName: string): TsgDXFDimensionStyle;
    function StyleByName(const AName: string): TsgDXFStyle;
    function StyleByPrimaryFont(const AName: string): TsgDXFStyle;
    function TableStyleByName(const AName: string): TsgDXFAcadTableStyle;
    function ViewTwistMatrix: TFMatrix;
    function QueryModeller(const ATryCreate: Boolean): TsgModeller;
    property AfterRead: TNotifyEvent read FAfterRead write FAfterRead;
    property AllArcsAsCurves: Boolean read FAllArcsAsCurves write FAllArcsAsCurves;
    property Angle: Single read GetAngle write SetAngle;
    property AnnoScale: TsgDXFScale read FAnnoScale write FAnnoScale;
    property AutoInsert: Boolean read FAutoInsert write FAutoInsert;
    property ActiveVPort: TsgDXFVPort read GetActiveVPort write SetActiveVPort;
    property BeforeRead: TNotifyEvent read FBeforeRead write FBeforeRead;
    property Blocks [Index: Integer]: TsgDXFBlock read GetBlock;
    property CircleZoomPercent: Integer read GetCircleZoomPercent write SetCircleZoomPercent;
    property CodePage: Integer read GetCodePage;
    property Charset: Byte read FCharset;
    property Counts [Index: TConvSection]: Integer read GetCount;
    property DefaultLayoutIndex: Integer read GetDefaultLayoutIndex write FDefaultLayoutIndex;
    property DimensionStyles [Index: Integer]: TsgDXFDimensionStyle read GetDimStyle;
    property DisplayImageFrame: Boolean read GetDisplayImageFrame write SetDisplayImageFrame;
    //Summary info of the Drawing database
    property DrwPropAuthor: string read GetDrwPropAuthor write SetDrwPropAuthor;
    property DrwPropComments: string read GetDrwPropComments write SetDrwPropComments;
    property DrwPropHyperlinkBase: string read GetDrwHyperlinkBase write SetDrwHyperlinkBase;
    property DrwPropKeywords: string read GetDrwPropKeywords write SetDrwPropKeywords;
    property DrwPropRevisionNumber: string read GetDrwRevisionNumber write SetDrwRevisionNumber;
    property DrwPropSavedBy: string read GetDrwPropSavedBy write SetDrwPropSavedBy;
    property DrwPropSubject: string read GetDrwPropSubject write SetDrwPropSubject;
    property DrwPropTitle: string read GetDrwPropTitle write SetDrwPropTitle;
    property DrwPropCustomSummaryInfo: TStringList read GetDrwPropCustomSummaryInfo;
    property DrwPropCreatedDateTime: TDateTime read FDrwPropCreatedDateTime
      write FDrwPropCreatedDateTime;
    property DrwPropModifiedDateTime: TDateTime read FDrwPropModifiedDateTime
      write FDrwPropModifiedDateTime;
    property DrwPropTotalEditingTime: TTimeStamp read FDrwPropTotalEditingTime
      write FDrwPropTotalEditingTime;
    property FieldList: TsgDXFFieldList read GetFieldList;
    property FileName: string read FFileName write FFileName;
    property HeadVarStruct: TsgHeadVarStruct read FHeadVarStruct write FHeadVarStruct;
    property IsCrossoverMatrix: Boolean read FCrossoverMatrix write SetCrossoverMatrix;
    property IsHaveActiveVPort: Boolean read FIsHaveActiveVPort write FIsHaveActiveVPort;
    property Entities [const AIndex: Integer]: TsgDXFEntity read GetEntity;
    property Extents: TFRect read GetExtents write SetExtents;
    property OnFindFont: TsgCADFindFont read FOnFindFont write FOnFindFont;
    property HeadEnd: PAnsiChar read FHeadEnd write FHeadEnd;
    property HideWipeouts: Boolean read GetHideWipeouts write SetHideWipeouts;
    property ImportMode: TsgImportMode read FImportMode write SetImportMode;
    property Is3D: Boolean read GetIs3D;
    property Layers [Index: Integer]: TsgDXFLayer read GetLayer;
    property Layouts [const AIndex: Integer]: TsgDXFLayout read GetLayout;
    property ImageDefs[const Index: Integer]: TsgDXFImageDef read GetImageDef;
    property LayoutsCount: Integer read GetLayoutsCount;
    property LTScale: Double read GetLTScale write SetLTScale;
    property LTypes [Index: Integer]: TsgDXFLineType read GetLType;
    property Main: TsgDXFSection read FMain;
    property MaxHandle: UInt64 read FMaxHandle write FMaxHandle;
    property MaxEntities: Integer read FMaxEntities write FMaxEntities;
    property MeshQuality: Double read FMeshQuality write FMeshQuality;
    property NumberOfPartsInSpline: Integer read GetNumberOfPartsInSpline write SetNumberOfPartsInSpline;
    property NumberOfPartsInCircle: Integer read GetNumberOfPartsInCircle write SetNumberOfPartsInCircle;
    property OnCreate: TNotifyEvent read FOnCreate write FOnCreate;
    property OnSetEntityPropError: TsgCADNotifyMessage
      read FOnSetEntityPropError write FOnSetEntityPropError;
    property OnRead: TNotifyEvent read FOnRead write FOnRead;
    property OnLayoutAdd: TNotifyEvent read FOnLayoutAdd write FOnLayoutAdd;
    property OnLayoutRemove: TNotifyEvent read FOnLayoutRemove write FOnLayoutRemove;
    property OnImageDefResolve: TsgCADImageDefResolver read FOnImageDefResolve
      write FOnImageDefResolve;
    property OnSHXResolve: TsgCADSHXResolver read FOnSHXResolve
      write FOnSHXResolve;
    property OnXRefResolve: TsgCADXRefResolver read FOnXRefResolve
      write FOnXRefResolve;
    property OnModellerMsg: TsgCADNotifyMessage read FOnModellerMsg
      write FOnModellerMsg;
    property OnAcisNumberMsg: TsgCADNotifyMessage read FOnAcisNumberMsg
      write FOnAcisNumberMsg;
{$IFDEF SG_VERSION_OLD}
    property PaperSpace: Boolean read GetPaperSpace write SetPaperSpace;
{$ENDIF}
{$IFDEF SG_OPENING_IN_THEADS}
    property Params: PsgCADIterate read GetParams write SetParams;
{$ELSE}
    property Params: PsgCADIterate read FParams write FParams;
{$ENDIF}
    property PointDisplayMode: Integer read GetPointDisplayMode write SetPointDisplayMode;
    property RegenerateArcs: Boolean read GetRegenerateArcs write SetRegenerateArcs;
    property HighQualityRegenerateArcs: Boolean read GetHighQualityRegenerateArcs write SetHighQualityRegenerateArcs;
    property QualityRegenerate: Integer read FQualityRegenerate write SetCurversQuality;
    property Sections [Index: TConvSection]: TsgDXFGroup read GetSection write SetSection;
    property SHXFonts: TsgSHXFontList read GetSHXFonts;
    property Source: TCustomMemoryStream read FSource write SetSource;
    property OwnSource: Boolean read FOwnSource write SetOwnSource;
    property Styles [Index: Integer]: TsgDXFStyle read GetStyle;
    property Tables [Index: Integer]: TsgDXFTable read GetTable;
    //property Transform3D: TFMatrix read FTransform3D write FTransform3D;
    property UseSHXFonts: Boolean read FUseSHXFonts write FUseSHXFonts;
    property VPort: TFPoint read GetVPort write SetVPort;
    property XRefs: TList read FXRefs;
    property XRefSearchPath: string read GetXRefSearchPath write SetXRefSearchPath;
    property XRefSearchPaths: TStringList read GetXRefSearchPaths;
    property ConvExtended: TsgConverterExtented read GetConvExtended;//for internal using
    property OleFrame: Byte read FOleFrame write SetOleFrame default cnstOleFrameDefault;
  end;

  TsgDXFEntity = class(TsgListObject, IsgXMLSubObjects, IsgXMLSupportBuildKey{, IsgListOfEntities})
  private
    function GetEEDItems: TsgObjectCollection;
    function GetDestroyNotifications(out AList: TsgNotifyEventsList;
      ACreateNew: Boolean = False; AAttributesIntfPtr: Pointer = nil): Boolean;
{$IFDEF SG_CALC_INSTANCE_SIZES}
  private
    class var TotalAllocated: Integer;
{$ENDIF}
  protected
    {$IFDEF SG_GLOBALHANDLE}
    GlobalHandle: Integer;
    {$ENDIF}
    procedure AssignExtendedData(const ASource: TsgDXFEntity);
    class function ExtractEEDTypeEx(AExtData: TObject;
      var AGroupName: string; var AEntTypeNum: Integer;
      const AMaxDataIndex: Integer = 4): Integer; virtual;
    function CanAddedToXMLParams: Boolean; override;
    function AddEntUseInsert(const AEntity: TsgDXFEntity): Integer;{$IFDEF SG_INLINE}inline;{$ENDIF}
    function AddItem(const AItem: TObject): Integer; virtual;
    function AddHandleItem(const AItem: TsgDXFEntity): Integer; virtual;
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; virtual;
    function CanDraw: Boolean; virtual;
    function CanHaveHandle: Boolean; virtual;

    function DeleteItem(const AItem: TObject): Integer; virtual;
    function DeleteHandleItem(const AItem: TsgDXFEntity): Integer; virtual;
    procedure EndExtData(const AData: TsgCADExtendedData); virtual;
    function HasDimesionStyle(const AStyle: Pointer = Pointer($1)): Boolean;
    function HasTextStyle(const AStyle: Pointer = Pointer($1)): Boolean;
    function IsEqualExtDataName(const AData: TsgCADExtendedData; const AName: string): Boolean;
    function GetAnnotationScales: TsgDXFEntity; virtual; // must be dictionary of ObjectContextData
    function GetAnnotative: Boolean; virtual;
    function GetBox: TFRect; virtual;
    function GetColor: TColor;
    function GetColorCAD: TsgColorCAD; virtual;
    function GetComplex: Boolean; virtual;
    function GetConverter: TsgDXFConverter; virtual;
    function GetCount: Integer; virtual;
    function GetEED(const AAppID: UInt64): TsgCADExtendedData; virtual;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; virtual;
    function GetEntType: TsgCADEntities; virtual;
    function GetEntTypeEx: Integer; virtual;
    function GetEntClassEx: TsgEntClass; virtual;
    function GetExtrusion: TFPoint; virtual;
    function GetExtensionDictionary(const Index: Variant): TsgDXFEntity; virtual;
    function GetDescription: string; virtual;
    function GetDictionary: TsgDXFEntity; virtual;
    function GetDimStyleInternal: Pointer; virtual;
    function GetObjectType: Integer; override;
    function GetTextStyleInternal: Pointer; virtual;
    procedure GroupClear; virtual; //methods Group* only for Direct export using
    function GetMaterial: TsgDXFMaterial; virtual;
    function GetLinkClass: TsgOwneredItemClass; virtual;
    function GetNamedItem: TObject; virtual;
    function GroupCreate(AConverter: TsgDXFConverter = nil): Boolean; virtual;
    function GroupExists: Boolean; virtual;
    function GroupHasAddedEntities: Boolean; virtual;
    function GroupGet: TsgDXFGroup; virtual;
    function GetInternalFlags: Word; virtual;
    function GetHandle: UInt64; virtual;
    function GetHLink: string; virtual;
    function GetHyperLink: string;
    function GetHyperLinkName: string;
    function GetHyperLinkValue: string;
    function GetLines: TsgLines; virtual;
    function GetLayer: TsgDXFLayer; virtual;
    function GetLineCap: Word; virtual;
    function GetLineJoin: Word; virtual;
    function GetLineType: TsgDXFLineType; virtual;
    function GetLineTypeScale: Double; virtual;
    function GetLineWeight: Double; virtual;
    function GetLineWeightScaled: Boolean; virtual;
    function GetName: string; virtual;
    function GetOnDraw: TNotifyEvent; virtual;
    function GetOwner: TsgDXFEntity; virtual;
    function GetPaperSpace: Integer; virtual;
    function GetSrcEnd: PAnsiChar;{$IFDEF SG_USEDXFSRC}virtual;{$ENDIF}
    function GetSrcStart: PAnsiChar;{$IFDEF SG_USEDXFSRC}virtual;{$ENDIF}
    function GetThicknessInt: Double; virtual;
    function GetFlags: Integer; override;
    function GetVisible: Boolean; virtual;
    function GetVisibility: Boolean; override;
    procedure ChangeHandle(AConverter: TsgDXFConverter); virtual;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); virtual;
    function IsInvoke(AConverter: TsgDXFConverter): Boolean; virtual;
    function Is3dObject: Integer; virtual;
    class function IsConverterClearing(const AConv: TsgDXFConverter): Boolean;

    function HasLineWeight: Boolean; virtual;

    procedure ClearReferences; virtual;
    procedure FreeReferences; virtual;
    procedure Loaded(AConverter: TsgDXFConverter);
    procedure LoadedInternal(AConverter: TsgDXFConverter); virtual;
    procedure Link(AConverter: TsgDXFConverter); virtual;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); virtual;
    procedure RemoveReferenceNotification(const ARefObj: TsgDXFEntity); virtual;
    procedure ClearEED;
    procedure ExcludeFromGroups;

    procedure SetColor__(const Value: TColor);
    procedure SetAnnotative(AValue: Boolean); virtual;
    procedure SetColorCAD(const Value: TsgColorCAD); virtual;
    procedure SetConverter(const AConverter: TsgDXFConverter); virtual;
    procedure SetDescription(const AValue: string); virtual;
    procedure SetDictionary(const AValue: TsgDXFEntity); virtual;
    procedure SetEED(const AAppID: UInt64; const AValue: TsgCADExtendedData); virtual;
    procedure SetExtrusion(const Value: TFPoint); virtual;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); virtual;
    procedure SetInternalFlags(const Value: Word); virtual;
    procedure SetHandle(const Value: UInt64); virtual;
    procedure SetHLink(const AValue: string); virtual;
    procedure SetHyperLink(const AValue: string);
    procedure SetLayer(const Value: TsgDXFLayer); virtual;
    procedure SetLineCap(const Value: Word); virtual;
    procedure SetLineJoin(const Value: Word); virtual;
    procedure SetLineType(const AValue: TsgDXFLineType); virtual;
    procedure SetLineTypeScale(Value: Double); virtual;
    procedure SetLineWeight(Value: Double); virtual;
    procedure SetLineWeightScaled(Value: Boolean); virtual;
    procedure SetMaterial(const Value: TsgDXFMaterial); virtual;
    procedure SetName(const AName: string); virtual;
    procedure SetOnDraw(const Value: TNotifyEvent); virtual;
    procedure SetOwner(const Value: TsgDXFEntity); virtual;
    procedure SetPaperSpace(const Value: Integer); virtual;
    procedure SetSrcEnd(const Value: PAnsiChar);{$IFDEF SG_USEDXFSRC}virtual;{$ENDIF}
    procedure SetSrcStart(const Value: PAnsiChar);{$IFDEF SG_USEDXFSRC}virtual;{$ENDIF}
    procedure SetThicknessInt(const AValue: Double); virtual;
    procedure SetFlags(const Value: Integer); virtual;
    procedure SetVisible(Value: Boolean); virtual;
    procedure SetVisibility(const Value: Boolean); virtual;
    procedure StyleChanged(Sender: TObject); dynamic;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function EEDItemsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
    procedure ToXMLSubEntities(const AParentNode: TsgNode;
      const AParams: TsgXMLParams); virtual;
    function GetSubEntitiesNode(const AParentNode: TsgNode;
      var AParams: TsgXMLParams; const AHasSubEntities: Boolean = False): TsgNode; virtual;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function FromXMLSubEntities(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer; override;
    procedure EntityLoaded; override;

    //IsgXMLSupportBuildKey
    function IsUsedInKeyConstruction: Boolean; virtual;

    function GetLayerInspInternal: TsgDXFlayer; virtual;
    procedure SetLayerInspInternal(const ALayer: TsgDXFlayer); virtual;
    procedure SetFlagsXml(const ANum: Integer; const ABit: Byte; AFlags: PInteger);

    procedure NotifyDestroing; virtual;
    function AddDestroyNotification(const ANotify: TNotifyEvent): Integer; virtual;
    function RemoveDestroyNotification(const ANotify: TNotifyEvent): Integer; virtual;
    procedure NameChanging(var NewName: string; var AAllow: Boolean); virtual;

    property EED[const AAppID: UInt64]: TsgCADExtendedData read GetEED write SetEED;
    property EEDItems: TsgObjectCollection read GetEEDItems;
    property Group: TsgDXFGroup read GroupGet;
    property LineCap: Word read GetLineCap write SetLineCap;
    property LineJoin: Word read GetLineJoin write SetLineJoin;
    property LineWeightScaled: Boolean read GetLineWeightScaled write SetLineWeightScaled;
    property InternalFlags: Word read GetInternalFlags write SetInternalFlags;
  public
    constructor Create; override;
    destructor Destroy; override;
{$IFDEF SG_CALC_INSTANCE_SIZES}
    class function NewInstance: TObject; override;
{$ENDIF}
    procedure FreeInstance; override;
    procedure AssignEntity(Source: TsgDXFEntity); virtual;
    procedure Clone(const Source: TsgDXFEntity);

    // functions of IsgListOfEntities
    procedure Clear(const ADoFree: Boolean = True); virtual;
    function AddEntity(const AEntity: TsgDXFEntity): Integer; virtual;
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; virtual;
    procedure ExchangeEntity(AIndex1, AIndex2: Integer); virtual;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer; virtual;
    function IndexOfHandle(const AHandle: UInt64): Integer;
    function IndexOfName(const AName: string): Integer; virtual;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; virtual;
    function RemoveEntity(const AEntity: TsgDXFEntity): Boolean;

    function FindEntByName(const AName: string): TsgDXFEntity; virtual;
    function FindChildByHandle(const AHandle: UInt64; ADeep: Integer = 0): TsgDXFEntity; virtual;
    function FindEntByHandle(const AHandle: UInt64; ADeep: Integer = 0;
      const AIterateInsert: Boolean = False): TsgDXFEntity;
    function FindEntByDescription(const ADescription: string): TsgDXFEntity; virtual;

    procedure Draw; virtual;
    function EntName: string; virtual;

    //IsgXMLSubObjects
    procedure ToSubEntities(const AParentNode: TsgNode;
      const AParams: TsgXMLParams);
    function ToXMLWithParams(const AParentNode: TsgNode;
      const AParams: TsgXMLParams): TsgNode; override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; virtual;
    function GetExtDataHyperLink(const AData: TsgCADExtendedData): Boolean;
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; virtual;
    function GetThickness: Double;
    function GetLayerInsp: TsgDXFlayer;//for internal using
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    procedure SetLayerInsp(const ALayer: TsgDXFlayer);//for internal using
    function IsInsert: Boolean; virtual;
    function IsOnePixelOptimisationValid: Boolean; virtual;
    function BoxForLayout(ALayout: TsgDXFLayout; AConv: TsgDXFConverter): TFRect; virtual;
    procedure SetColor(Value: TColor); {$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version. Please, use the following property - ColorCAD!'{$ENDIF};{$ENDIF}
    procedure SetExtData(const AData: TsgCADExtendedData); virtual;
    procedure SetExtDataHyperLink(const AData: TsgCADExtendedData);
    procedure SetLType(Value: TsgDXFEntity);
    procedure SetLWeight(Value: Integer); virtual;
    procedure SetThickness(const AValue: Double);
    property Annotative: Boolean read GetAnnotative write SetAnnotative;
    property Box: TFRect read GetBox;
    property Complex: Boolean read GetComplex;
    property Converter: TsgDXFConverter read GetConverter;
    property Count: Integer read GetCount;
    property Color: TColor read GetColor write SetColor__;
    property ColorCAD: TsgColorCAD read GetColorCAD write SetColorCAD;
    property Dictionary: TsgDXFEntity read GetDictionary write SetDictionary;
    property Description: string read GetDescription write SetDescription;
    property Entities[const AIndex: Integer]: TsgDXFEntity read GetEntity; default;
    property EntType: TsgCADEntities read GetEntType;
    property EntClass: TsgEntClass read GetEntClassEx;
    property Flags: Integer read GetFlags write SetFlags;
    property Handle: UInt64 read GetHandle write SetHandle;
    property Lines: TsgLines read GetLines;
    property LineType: TsgDXFLineType read GetLineType write SetLineType;
    property LineTypeScale: Double read GetLineTypeScale write SetLineTypeScale;
    property LineWeight: Double read GetLineWeight write SetLineWeight;
    property Layer: TsgDXFLayer read GetLayer write SetLayer;
    property Material: TsgDXFMaterial read GetMaterial write SetMaterial;
    property Name: string read GetName write SetName;
    property OnDraw: TNotifyEvent read GetOnDraw write SetOnDraw;
    property Owner: TsgDXFEntity read GetOwner;
    property PaperSpace: Integer read GetPaperSpace write SetPaperSpace;
    property SrcEnd: PAnsiChar read GetSrcEnd write SetSrcEnd;
    property SrcStart: PAnsiChar read GetSrcStart write SetSrcStart;
    property Visible: Boolean read GetVisible write SetVisible;
    property Visibility: Boolean read GetVisibility write SetVisibility;
    property HyperLink: string read GetHyperLink write SetHyperLink;
  end;

  TsgDXFEntitySampleCustom = class(TsgDXFEntity)
  private
    FConverter: TsgDXFConverter;
    FOnAfterChange: TsgObjChangeProperties;
    FOnBeforeChange: TsgObjChangeProperties;
  protected
    procedure AfterChange(const AType: TsgPropertyType);
    procedure BeforeChange(const AType: TsgPropertyType);
    function GetActiveHeadVar: PsgHeadVarStruct;
    function GetConverter: TsgDXFConverter; override;
    procedure SetConverter(const AConverter: TsgDXFConverter); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property OnAfterChange: TsgObjChangeProperties read FOnAfterChange
      write FOnAfterChange;
    property OnBeforeChange: TsgObjChangeProperties read FOnBeforeChange
      write FOnBeforeChange;
  end;

  TsgSupportPathKey = class
  public
    class function GetPathKeyByFullXMLNode(const AXMLNode: TsgNodeSample): string;
    class procedure GetObjectListByPathStrKey(APathStrKey: string;
      AObjectList: TsgObjectList);
    class function GetPathKeyByObject(AObject: TObject): string;
    class function GetPathKeyByObjectList(
      AObjectList: TsgObjectList): string;
    class function GetDXFEntityByPathStrKey(APathStrKey: string):TsgDXFEntity;
  end;

  TsgObjEntity3D = class(TsgDXFEntity)
  private
    //Since we have two branches of objects
    FOriginalEntity: TObject;
    FInspectorEntity: TsgDXFEntity;
    //Path that represents the object's position in the rendering tree
    FPathKey: String;
    FHandle: UInt64;
    //inspector properties
    FInpName: string;
    FInspArea: Double;
    FInspVolume: Double;
    FInspBox: TFRect;
    FInspSize: TFPoint;
    FFaceGeom: TsgNodeSample;
    FFaceGeomType: Integer;
    FAlpaBlend: Integer;
    FInspColor: Integer;
    FInspCustomColor: Integer;
    function GetInspectorEntity: TsgDXFEntity;
    procedure SetInspectorEntity;
    procedure UpdateInspectorProps(const AUpdate: Boolean = False);
  protected
    FlagsChanges: Integer;
    function GetBox: TFRect; override;
    function GetColorInt: TsgColorCAD;
    function GetCustomColorInt: TsgColorCAD;
    function GetInsName: string;
    function GetEntType: TsgCADEntities; override;
    function GetPathKeyShort: UInt64;
    function CanDraw: Boolean; override;
    function GetAlphaBlend: Integer;
    function GetArea: Double;
    procedure SetColorInt(const AVAlue: TsgColorCAD);
    procedure SetCustomColorInt(const AVAlue: TsgColorCAD);
    function GetVolume: Double;
    function GetSize: TFPoint;
    function GetFaceType: Integer;
    function GetFaceGeom: TsgNodeSample;
    procedure SetAlphaBlend(const AValue: Integer);
    procedure SetOrgEntityAndKey(const AEntity: TObject; const APathKey: string);
    procedure SetPathKey(const Value: String);
    procedure RefreshInspectorProps;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure SetHandle(const AValue: UInt64); override;
    function ToXMLWithParams(const AParentNode: TsgNode;
      const AParams: TsgXMLParams): TsgNode; override;
    function FromXML(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer; override;
    property Handle: UInt64 read FHandle write SetHandle;
    property PathKey: String read FPathKey;
    property InspectorEntity: TsgDXFEntity read GetInspectorEntity;
    property OriginalEntity: TObject read FOriginalEntity;
    property Area: Double read GetArea;
  end;

  TsgDXFEntitySample = class(TsgDXFEntitySampleCustom)
  private
    FBackGroundImage: TsgDXFImageEnt;
    FTextRotation: Double;
    function GetDimArrowType(const ADimProps: TsgDimStyle; const ANameValue: TsgDimNameVal): TsgDimArrowType;
    procedure CheckArroyType(const AValue: TsgDimArrowType);
    procedure SetDimArrowType(var ADimProps: TsgDimStyle; const ANameValue: TsgDimNameVal; const AType: TsgDimArrowType);
  protected
    function GetAnalogyDistance: Double;
    function GetArrowSize: Double;
    function GetBackGroundImage: TsgDXFImageEnt;
    function GetColorCAD: TsgColorCAD; override;
    function GetDimBlk1: Byte;
    function GetDimBlk2: Byte;
    function GetDimLrBlk: Byte;
    function GetDimForceText: Integer;
    function GetDimExtLineExt: TsgFloat;
    function GetDimExtLineOffset: TsgFloat;
    function GetDimLFac: Double;
    function GetDimPrecision: Integer;
    function GetDimScale: Double;
    function GetDimStyle: TsgDXFDimensionStyle;
    function GetDimTextAlign: Integer;
    function GetDimTextColor: TsgColorCAD;
    function GetDimTextHeight: TsgFloat;
    function GetDimTextOffset: Double;
    function GetDimTextPosVert: TsgDimTextPosVert;
    function GetFontHeight: TsgFloat;
    function GetFontName: string;
    function GetLayer: TsgDXFLayer; override;
    function GetFilletRadius: Double;
    function GetLineType: TsgDXFLineType; override;
    function GetLineTypeScale: Double; override;
    function GetLineWeight: Double; override;
    function GetPointDisplayMode: Integer;
    function GetPointDisplaySize: Double;
    function GetTextStyle: TsgDXFStyle;
    function GetTextRotation: TsgFloat;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetAnalogyDistance(const Value: Double);
    procedure SetArrowSize(const Value: Double);
    procedure SetBackGroundImage(const Value: TsgDXFImageEnt);
    procedure SetDimBlk1(const Value: Byte);
    procedure SetDimBlk2(const Value: Byte);
    procedure SetDimLrBlk(const Value: Byte);
    procedure SetDimForceText(const Value: Integer);
    procedure SetDimExtLineExt(const Value: TsgFloat);
    procedure SetDimExtLineOffset(const Value: TsgFloat);
    procedure SetDimLFac(const Value: Double);
    procedure SetDimPrecision(const Value: Integer);
    procedure SetDimScale(const Value: Double);
    procedure SetDimStyle(const Value: TsgDXFDimensionStyle);
    procedure SetDimTextAlign(const Value: Integer);
    procedure SetDimTextColor(const Value: TsgColorCAD);
    procedure SetDimTextHeight(const Value: TsgFloat);
    procedure SetDimTextOffset(const Value: Double);
    procedure SetDimTextPosVert(const Value: TsgDimTextPosVert);
    procedure SetFilletRadius(const Value: Double);
    procedure SetFontHeight(const Value: TsgFloat);
    procedure SetLayer(const Value: TsgDXFLayer); override;
    procedure SetLineType(const AValue: TsgDXFLineType); override;
    procedure SetLineTypeScale(Value: Double); override;
    procedure SetLineWeight(Value: Double); override;
    procedure SetPointDisplayMode(const Value: Integer);
    procedure SetPointDisplaySize(const Value: Double);
    procedure SetColorCAD(const Value: TsgColorCAD); override;
    procedure SetTextStyle(const Value: TsgDXFStyle);
    procedure SetTextRotation(const AValue: TsgFloat);
    function UseTextStyleFixedHeight: Boolean;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property BackGroundImage: TsgDXFImageEnt read GetBackGroundImage write SetBackGroundImage;
    property ArrowSize: Double read GetArrowSize write SetArrowSize;
    property BevelSize: Double read GetFilletRadius write SetFilletRadius;
    property AnalogyDistance: Double read GetAnalogyDistance write SetAnalogyDistance;
    property DimBlk1: Byte read GetDimBlk1 write SetDimBlk1;
    property DimBlk2: Byte read GetDimBlk2 write SetDimBlk2;
    property DimLrBlk: Byte read GetDimLrBlk write SetDimLrBlk;
    property DimStyle: TsgDXFDimensionStyle read GetDimStyle write SetDimStyle;
    property DimTextHeight: TsgFloat read GetDimTextHeight write SetDimTextHeight;
    property DimForceText: Integer read GetDimForceText write SetDimForceText;
    property DimExtLineExt: TsgFloat read GetDimExtLineExt write SetDimExtLineExt;
    property DimExtLineOffset: TsgFloat read GetDimExtLineOffset write SetDimExtLineOffset;
    property DimLFac: Double read GetDimLFac write SetDimLFac;
    property DimPrecision: Integer  read GetDimPrecision write SetDimPrecision;
    property DimScale: Double read GetDimScale write SetDimScale;
    property DimTextAlign: Integer read GetDimTextAlign write SetDimTextAlign;
    property DimTextColor: TsgColorCAD read GetDimTextColor write SetDimTextColor;
    property DimTextOffset: Double read GetDimTextOffset write SetDimTextOffset;
    property DimTextPosVert: TsgDimTextPosVert read GetDimTextPosVert write SetDimTextPosVert;
    property FilletRadius: Double read GetFilletRadius write SetFilletRadius;
    property FontName: string read GetFontName;
    property FontHeight: TsgFloat read GetFontHeight write SetFontHeight;
    property LineType: TsgDXFLineType read GetLineType write SetLineType;
    property LineTypeScale: Double read GetLineTypeScale write SetLineTypeScale;
    property PointDisplayMode: Integer read GetPointDisplayMode write SetPointDisplayMode;
    property PointDisplaySize: Double read GetPointDisplaySize write SetPointDisplaySize;
    property TextStyle: TsgDXFStyle read GetTextStyle write SetTextStyle;
    property TextRotation: TsgFloat read GetTextRotation write SetTextRotation;
  end;

  TsgExtendedDefault = class(TsgDXFEntitySampleCustom)
  end;

  TsgBTIExtendedDefault = class(TsgExtendedDefault)
  private
    FTemplateElementCarvedScale: Double;
  protected
    function GetTemplateElementCarvedScale: Double;
    procedure SetTemplateElementCarvedScale(const Value: Double);
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Reset; virtual;
    property TemplateElementCarvedScale: Double read GetTemplateElementCarvedScale write SetTemplateElementCarvedScale;
  end;

  TsgInventoryDefault = class(TsgBTIExtendedDefault)
  private
    FCadastralNumber: Integer;
    FNumberArea: Integer;
    FNumberComplexArea: Integer;
    FLetterNumberArea: string;
    FLetterNumberCompexArea: string;
    FAttribHeight: Double;
    function GetNumbers(const AComplex: Boolean): Integer;
    function GetLetterNumbers(const AComplex: Boolean): string;
    procedure SetNumbers(const AComplex: Boolean; const AValue: Integer);
    procedure SetLetterNumbers(const AComplex: Boolean; const AValue: string);
  protected
    function GetAttribHeight: Double;
    function GetCadastralNumber: Integer;
    function GetNumberArea: Integer;
    function GetNumberComplexArea: Integer;
    function GetLetterNumberArea: string;
    function GetLetterNumberComplexArea: string;
    procedure SetAttribHeight(const AValue: Double);
    procedure SetCadastralNumber(const AValue: Integer);
    procedure SetNumberArea(const AValue: Integer);
    procedure SetNumberComplexArea(const AValue: Integer);
    procedure SetLetterNumberArea(const AValue: string);
    procedure SetLetterNumberComplexArea(const AValue: string);
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Reset; override;
    property Numbers[const AComplex: Boolean]: Integer read GetNumbers write SetNumbers;
    property LetterNumbers[const AComplex: Boolean]: string read GetLetterNumbers write SetLetterNumbers;
    property NumberArea: Integer read GetNumberArea write SetNumberArea;
    property NumberComplexArea:Integer read GetNumberComplexArea write SetNumberComplexArea;
    property CadastralNumber: Integer read GetCadastralNumber write SetCadastralNumber;
    property AttribHeight: Double read GetAttribHeight write SetAttribHeight;
  end;

  TsgEvacuationDefault = class(TsgBTIExtendedDefault)
  private
    FPathEvacucationColor: TsgColorCAD;
    FPathEvacucationLineTypeScale: Double;
    FPathEvacucationWidth: Double;
  protected
    function GetPathEvacColor: TsgColorCAD;
    function GetPathEvacLayer: string;
    function GetPathEvacLineTypeScale: Double;
    function GetPathEvacWidth: Double;
    procedure SetPathEvacColor(const Value: TsgColorCAD);
    procedure SetPathEvacLineTypeScale(const Value: Double);
    procedure SetPathEvacWidth(const Value: Double);
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Reset; override;
    property PathEvacucationColor: TsgColorCAD read GetPathEvacColor write SetPathEvacColor;
    property PathEvacucationLayer: string read GetPathEvacLayer;
    property PathEvacucationLineTypeScale: Double read GetPathEvacLineTypeScale write SetPathEvacLineTypeScale;
    property PathEvacucationWidth: Double read GetPathEvacWidth write SetPathEvacWidth;
  end;

  TsgTableItem = class(TObject)
  private
    {$IFDEF AUTOREFCOUNT}[Weak]{$ENDIF}FItem: TsgOwneredItem;
    procedure SetItem(const Value: TsgDXFEntity); virtual;
    function GetItem: TsgDXFEntity;
  protected
    procedure SetItemObj(const Value: TsgOwneredItem); virtual;
  public
{$IFDEF SG_CALC_INSTANCE_SIZES}
    class function NewInstance: TObject; override;
    procedure FreeInstance; override;
{$ENDIF}
    property Item: TsgDXFEntity read GetItem write SetItem;
    property ItemObj: TsgOwneredItem read FItem write SetItemObj;
  end;

  TsgOwneredItem = class(TObject)
  private
    {$IFDEF AUTOREFCOUNT}[Weak]{$ENDIF}FOwner: TObject;
{$IFDEF AUTOREFCOUNT}
    function _GetObjectRefCount: Integer; inline;
{$ELSE}
    FRefCount: Integer;
{$ENDIF}
    procedure SetOwner(const AOwner: TObject);
  protected
    FHandle: UInt64;
    function GetAncestor: TsgDXFEntity; virtual;
    function GetName: string; virtual;
    procedure SetName(const AName: string); virtual;
    function GetDescription: string; virtual;
    procedure SetDescription(const AValue: string); virtual;
    function AddItem(const AItem: TObject): Integer; virtual;
    function RemoveItem(const AItem: TObject): Integer; virtual;
    procedure SetHandle(const AValue: UInt64); virtual;
  public
    constructor Create(AAncestor: TsgDXFEntity); virtual;
{$IFDEF SG_CALC_INSTANCE_SIZES}
    class function NewInstance: TObject; override;
    procedure FreeInstance; override;
{$ENDIF}
    function ObjAddRef: Integer;{$IFDEF USE_INLINE} inline;{$ENDIF}
    function ObjRelease: Integer;{$IFDEF USE_INLINE} inline;{$ENDIF}
    property Owner: TObject read FOwner write SetOwner;
    property RefCount: Integer read {$IFDEF AUTOREFCOUNT}_GetObjectRefCount{$ELSE}FRefCount{$ENDIF};
    property Ancestor: TsgDXFEntity read GetAncestor;
    property Description: string read GetDescription write SetDescription;
    property Handle: UInt64 read FHandle write SetHandle;
    property Name: string read GetName write SetName;
  end;

  TsgNamedItem = class(TsgOwneredItem)
  private
    {$IFDEF AUTOREFCOUNT}[Weak]{$ENDIF}FAncestor: TsgDXFEntity;
    FName: string;
  protected
    function GetName: string; override;
    procedure SetName(const AName: string); override;
    function GetAncestor: TsgDXFEntity; override;
  public
    constructor Create(AAncestor: TsgDXFEntity); override;
  end;

  TsgDescriptedNamedItem = class(TsgNamedItem)
  private
    FDescription: string;
  protected
    function GetDescription: string; override;
    procedure SetDescription(const AValue: string); override;
  end;

  TsgIrdDescriptedNamedItem = class(TsgDescriptedNamedItem)
  end;

  TsgSortedItem = class(TsgDescriptedNamedItem)
  private
    FSortList: TsgMultiSortItemsList;
  protected
    function AddItem(const AItem: TObject): Integer; override;
    function RemoveItem(const AItem: TObject): Integer; override;
    property SortList: TsgMultiSortItemsList read FSortList;
  public
    constructor Create(AAncestor: TsgDXFEntity); override;
    destructor Destroy; override;
  end;

  TsgDXFOwneredItem = class(TsgDXFEntity)
  private
    FLinkID: TsgOwneredItem;
    FAnnotative: Boolean;
  protected
    function CanHaveHandle: Boolean; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetAnnotative: Boolean; override;
    function GetConverter: TsgDXFConverter; override;
    function GetHandle: UInt64; override;
    function GetLinkClass: TsgOwneredItemClass; override;
    function GetDescription: string; override;
    procedure SetDescription(const AValue: string); override;
    function GetName: string; override;
    function GetNamedItem: TObject; override;
    function GetOwner: TsgDXFEntity; override;
    procedure SetAnnotative(AValue: Boolean); override;
    procedure SetHandle(const Value: UInt64); override;
    procedure SetName(const AName: string); override;
    procedure SetOwner(const AValue: TsgDXFEntity); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function EntName: string; override;
    function GetStrValue: string; override;
  end;

  TsgDXFObjectEntity = class(TsgDXFEntity)
  private
    FConverter: TsgDXFConverter;
    FGroup: TsgDXFGroup;
    FLinkID: TsgOwneredItem;
    FLayerItem: TsgTableItem;
    FMaterialItem: TsgTableItem;
    FInternalFlags: Word;  // use high byte in UseEntityInvisible
    FFlag: Integer; // use AUTOCAD
    FPenStyle: Word; // by GDI
    FAnnotative: Boolean;
{$IFDEF SG_USEDXFSRC}
    FSrcEnd: PAnsiChar;
    FSrcStart: PAnsiChar;
{$ENDIF}
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function CanHaveHandle: Boolean; override;
    procedure GroupClear; override;
    function GroupCreate(AConverter: TsgDXFConverter = nil): Boolean; override;
    function GroupFill(AConverter: TsgDXFConverter = nil): Boolean; virtual;
    function GroupGet: TsgDXFGroup; override;
    function GetAnnotative: Boolean; override;
    function GetConverter: TsgDXFConverter; override;
    function GetHandle: UInt64; override;
    function GetInternalFlags: Word; override;
    function GetFlags: Integer; override;
    function GetLayer: TsgDXFLayer; override;
    function GetLineCap: Word; override;
    function GetLineJoin: Word; override;
    function GetLineWeightScaled: Boolean; override;
    function GetMaterial: TsgDXFMaterial; override;
    function GetVisibility: Boolean; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure SetAnnotative(AValue: Boolean); override;
    procedure SetConverter(const AConverter: TsgDXFConverter); override;
    procedure SetInternalFlags(const Value: Word); override;
    procedure SetFlags(const Value: Integer); override;
    procedure SetHandle(const Value: UInt64); override;
    procedure SetLayer(const Value: TsgDXFLayer); override;
    procedure SetLineCap(const Value: Word); override;
    procedure SetLineJoin(const Value: Word); override;
    procedure SetLineWeightScaled(Value: Boolean); override;
    procedure SetMaterial(const Value: TsgDXFMaterial); override;
    procedure SetOwner(const Value: TsgDXFEntity); override;
    procedure SetVisibility(const Value: Boolean); override;
{$IFDEF SG_USEDXFSRC}
    function GetSrcEnd: PAnsiChar; override;
    function GetSrcStart: PAnsiChar; override;
    procedure SetSrcEnd(const Value: PAnsiChar); override;
    procedure SetSrcStart(const Value: PAnsiChar); override;
{$ENDIF}
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    procedure UpdateBox; virtual;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
  end;

  TsgDXFObjectEntityColor = class(TsgDXFObjectEntity)
  private
    FColor: TsgColorCAD;
    FHyperLink: string;
  protected
    function GetColorCAD: TsgColorCAD; override;
    function GetHLink: string; override;
    procedure SetColorCAD(const Value: TsgColorCAD); override;
    procedure SetHLink(const AValue: string); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
  end;

  TsgDXFSeqend = class(TsgDXFObjectEntity)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  TsgDXFPlotSettings = class(TsgDXFOwneredItem)
  private
    FData: TsgPlotSettingsData;
    function GetPlotData: PsgPlotSettingsData;
    function GetCustomPrintScaleKoef: Double;
    function GetPaperArea: TFRect;
    function GetCadMargins: TF2DRect;
    function GetCadOffset: TF2DPoint;
    function GetMagrinsArea: TFRect;
    function GetStartPoint: TF2DPoint;
    function GetPrintableArea: TFRect;
    function GetPlotFrameArea: TFRect;
    function GetCustomPrintScale: TsgPlotScale;
    procedure SetCustomPrintScale(const AValue: TsgPlotScale);
    function GetIsLandscapePaper: Boolean;
    function GetLandScape: Boolean;
    procedure SetLandScape(const AValue: Boolean);
    function GetIsCenter: Boolean;
    function GetIsFitToPaper: Boolean;
    procedure SetUnprintableMargin(const Value: TF2DRect);
  protected
    function GetName: string; override;
    procedure SetName(const AName: string); override;
    procedure RecalcScale(const APrinter, APaper: string; const AOffset: TF2DPoint;
      const AUnits: TsgPlotPaperUnits; const ALandscape, AFit: Boolean;
      const AExtents, ADisplay: TFRect; const AIndexFormat: Integer;
      const AFormats: TStrings; const APlotScale: PsgPlotScale;
      const CalcMargins: TsgCalcMargins);
    function CalculatePlotScale(const AExtents: TFRect;
      const ADisplay: TFRect): TsgPlotScale;
    procedure SetPaperImageOriginPoint(const AExtents, ADisplay: TFRect);
    function FillCentringOffset(const AExtents, ADisplay: TFRect): TF2DPoint;
    function CalculateCentringOffset(const AExtents: TFRect): TF2DPoint;
    function ToXMLNode(const ANode: TsgNode;
      const AParams: TsgXMLParams): Integer; override;
    function PlotSettingsDataToXMLNode(const AData: PsgPlotSettingsData;
      const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function PlotSettingsDataFromXMLNode(const AData: PsgPlotSettingsData;
      const AType: TsgXMLType; const ANode: TsgNodeSample;
      const AIsChild: Boolean; const AResult: IsgResultNode = nil): Integer;
    Procedure UpdateExtents(const AExtents: TFRect);
    property PlotData: PsgPlotSettingsData read GetPlotData;
    property IsLandscapePaper: Boolean read GetIsLandscapePaper;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function GetRotatedMargin: TF2DRect;
    procedure ResetForDefaultValue(ADefaultValue: PsgPlotSettingsData = nil);
    function SetDefaultValueByExtents(const ABox: TFRect;
      const ANeedSaveSize: Boolean = False): Boolean;
//Standart PlotSettings Property
    property CurrentStyleSheet: string read FData.CurrentStyleSheet write FData.CurrentStyleSheet;

    property DenominatorOfCustomPrintScale: Double read FData.DenominatorOfCustomPrintScale write FData.DenominatorOfCustomPrintScale;
    property FloatingPointScaleFactor: Double read FData.FloatingPointScaleFactor write FData.FloatingPointScaleFactor;
    property NumeratorOfCustomPrintScale: Double read FData.NumeratorOfCustomPrintScale write FData.NumeratorOfCustomPrintScale;
    property CustomPrintScale: TsgPlotScale read GetCustomPrintScale write SetCustomPrintScale;
    property PaperImageOrigin: TF2DPoint read FData.PaperImageOrigin write FData.PaperImageOrigin;
    property PageSetupName: string read FData.PageSetupName write SetName;
    property PaperSize: string read FData.PaperSize write FData.PaperSize;
    property PlotLayoutFlags: TsgPlotLayoutFlags read FData.PlotLayoutFlags write FData.PlotLayoutFlags;
    property PlotOrigin: TF2DPoint read FData.PlotOrigin write FData.PlotOrigin;
    property PlotPaperSize: TF2DPoint read FData.PlotPaperSize write FData.PlotPaperSize;
    property PlotPaperUnits: TsgPlotPaperUnits read FData.PlotPaperUnits write FData.PlotPaperUnits;
    property PlotRotation: TsgPlotRotation read FData.PlotRotation write FData.PlotRotation;
    property PlotType: TsgPlotType read FData.PlotType write FData.PlotType;
    property PlotViewName: string read FData.PlotViewName write FData.PlotViewName;
    property PlotWindowAreaMax: TF2DPoint read FData.PlotWindowAreaMax write FData.PlotWindowAreaMax;
    property PlotWindowAreaMin: TF2DPoint read FData.PlotWindowAreaMin write FData.PlotWindowAreaMin;
    property PrintOrConfigName: string read FData.PrintOrConfigName write FData.PrintOrConfigName;
    property ShadePlotCustomDPI: Integer read FData.ShadePlotCustomDPI write FData.ShadePlotCustomDPI;
    property ShadePlotMode: Integer read FData.ShadePlotMode write FData.ShadePlotMode;
    property ShadePlotResolutionLevel: Integer read FData.ShadePlotResolutionLevel write FData.ShadePlotResolutionLevel;
    property StandardScaleType: Byte read FData.StandardScaleType write FData.StandardScaleType;
    property UnprintableMargin: TF2DRect read FData.UnprintableMargin write SetUnprintableMargin;
//Get area property
    property PlotFrameArea: TFRect read GetPlotFrameArea;
    property PlotMarginsArea: TFRect read GetMagrinsArea;
    property PlotPaperArea: TFRect read GetPaperArea;
    property PlotPrintableArea: TFRect read GetPrintableArea; // Main export Area
    property LandScape: Boolean read GetLandScape write SetLandScape; // before set this prop Set paper size
//
    property IsCenter: Boolean read GetIsCenter;
    property IsFitToPaper: Boolean read GetIsFitToPaper;
    property CustomPrintScaleKoef: Double read GetCustomPrintScaleKoef;
  end;

  TsgDXFPenEntity = class(TsgDXFObjectEntityColor)
  private
    FLineTypeScale: Double;
  protected
    function GetLineTypeScale: Double; override;
    procedure SetLineTypeScale(Value: Double); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    function IsOnePixelOptimisationValid: Boolean; override;//evg
  end;

  TsgDXFObjectEntityLineType = class(TsgDXFPenEntity)
  private
    FLineTypeItem: TsgTableItem;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetLines: TsgLines; override;
    function GetLineType: TsgDXFLineType; override;
    procedure SetLineType(const AValue: TsgDXFLineType); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
  end;

  TsgDXFPenTableItem = class(TsgDXFOwneredItem)
  private
    FFlags: Integer;
  protected
    function GetFlags: Integer; override;
    procedure SetFlags(const Value: Integer); override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
  end;

  TsgDXFAppID = class(TsgDXFPenTableItem)
  protected
    procedure ClearReferences; override;
  end;

  TsgDXFCustomColor = class(TsgDXFPenTableItem)
  private
    FColor: TsgColorCAD;
  protected
    function GetColorCAD: TsgColorCAD; override;
    procedure SetColorCAD(const Value: TsgColorCAD); override;
    function FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample;
      const AIsChild: Boolean; const AResult: IsgResultNode = nil): Integer;override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
  end;

  TsgDXFClass = class(TsgDXFOwneredItem)
  private
    FIsEntity: Boolean;
    FCppClassName: string;
    FFlags: Integer;
  protected
    function GetLinkClass: TsgOwneredItemClass; override;
    function GetFlags: Integer; override;
    procedure SetFlags(const Value: Integer); override;
  public
    property IsEntity: Boolean read FIsEntity write FIsEntity;
    property CppClassName: string read FCppClassName write FCppClassName;
  end;

  TsgDXFScale = class(TsgDXFOwneredItem)
  private
    FModelScale: Double;
    FLayoutScale: Double;
    procedure SetLayoutScale(const AValue: Double);
    procedure SetModelScale(const AValue: Double);
  protected
    function GetLinkClass: TsgOwneredItemClass; override;
    function FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample;
      const AIsChild: Boolean; const AResult: IsgResultNode = nil): Integer;override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function GetScaleFactor: Extended;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property LayoutScale: Double read FLayoutScale write SetLayoutScale;
    property ModelScale: Double read FModelScale write SetModelScale;
  end;

  TsgDXFObjectContextData = class(TsgDXFOwneredItem)
  private
    FScaleItem: TsgTableItem;
    procedure SetScale(const Value: TsgDXFScale);
    function GetScale: TsgDXFScale;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetDescription: string; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Scale: TsgDXFScale read GetScale write SetScale;
  end;

  TsgCADBlkRefObjectContextData = class(TsgDXFObjectContextData)
  private
    FAngle: Double;
    FPoint: TFPoint;
    FScaleFactor: TFPoint;
  protected
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Angle: Double read FAngle write FAngle;
    property Point: TFPoint read FPoint write FPoint;
    property ScaleFactor: TFPoint read FScaleFactor write FScaleFactor;
  end;

{$IFDEF SGDEL_2005}{$REGION 'Multileader objects interface'}{$ENDIF}
// -------------------------- Multileader objects interface --------------------------

  TsgCustomMLeaderItemClass = class of TsgCustomMLeaderItem;

  PsgMLeaderBreakLine = ^TsgMLeaderBreakLine;
  TsgMLeaderBreakLine = TsgLine;

  TsgCustomMLeaderItem = class(TPersistent)
  private
    FStartEndCount: Integer;
    FStartEnd: array of TsgMLeaderBreakLine;
    FIdx: Integer;
    function GetStartEnd(Index: Integer): TsgLine;
  protected
    procedure Link(AConverter: TsgDXFConverter); virtual;
    function AddStartEnd(const ALine: TsgMLeaderBreakLine): Integer;
    function Clone: TsgCustomMLeaderItem;
    function Item(Index: Integer): PsgMLeaderBreakLine;{$IFDEF SG_INLINE} inline;{$ENDIF}
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure Clear; virtual;
    property Idx: Integer read FIdx write FIdx;
    property StartEndCount: Integer read FStartEndCount;
    property StartEnd[Index: Integer]: TsgMLeaderBreakLine read GetStartEnd;
  end;

  TsgMLeaderLine = class(TsgCustomMLeaderItem)
  private
    FPoints: TFPointList;
    FSegmentIndex: Integer;
    FLeaderType: Integer;
    FColor: TsgColorCAD;
    FLineType: TsgTableItem;
    FLineWeight: Double;
    FArrowSize: Double;
    FArrow: TsgTableItem;
    FOverrideFlags: Integer;//(1=leader type, 2=line Color, 4=line type, 8=line weight, 16=arrow size, 32=arrow symbol (handle)
    function GetArrow: TsgDXFBlockRecord;
    function GetLineType: TsgDXFLineType;
    procedure SetArrow(const Value: TsgDXFBlockRecord);
    procedure SetLineType(const Value: TsgDXFLineType);
  protected
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure ToXMLNode(const ANode: TsgNode);
    procedure FromXMLNode(const ANode: TsgNodeSample; const AConv: TsgDXFConverter);
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure Clear; override;
    property Points: TFPointList read FPoints;
    property SegmentIndex: Integer read FSegmentIndex write FSegmentIndex;
    property OverrideFlags: Integer read FOverrideFlags write FOverrideFlags;
    property LeaderType: Integer read FLeaderType write FLeaderType;
    property Color: TsgColorCAD read FColor write FColor;
    property LineType: TsgDXFLineType read GetLineType write SetLineType;
    property LineWeight: Double read FLineWeight write FLineWeight;
    property ArrowSize: Double read FArrowSize write FArrowSize;
    property Arrow: TsgDXFBlockRecord read GetArrow write SetArrow;
  end;

  TsgMLeader = class(TsgCustomMLeaderItem)
  private
    FConnectionPoint: TFPoint;
    FDirection: TFPoint;
    FLandingDistance: Double;
    FLines: array of TsgMLeaderLine;
    FIsVertical: Boolean;
    function GetLines(Index: Integer): TsgMLeaderLine;{$IFDEF SG_INLINE} inline;{$ENDIF}
    function GetLinesCount: Integer;{$IFDEF SG_INLINE} inline;{$ENDIF}
    procedure ClearLines;
  protected
    procedure Link(AConverter: TsgDXFConverter); override;
    function AddMLeaderLine(const AMLeaderLine: TsgMLeaderLine): Integer;
    procedure ToXMLNode(const ANode: TsgNode);
    procedure FromXMLNode(const ANode: TsgNodeSample; const AConv: TsgDXFConverter);
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear; override;
    property ConnectionPoint: TFPoint read FConnectionPoint write FConnectionPoint;
    property Direction: TFPoint read FDirection write FDirection;
    property LandingDistance: Double read FLandingDistance write FLandingDistance;
    property LinesCount: Integer read GetLinesCount;
    property Lines[Index: Integer]: TsgMLeaderLine read GetLines;
    property IsVertical: Boolean read FIsVertical write FIsVertical;
  end;

  TsgMLeaderContextData = class(TPersistent)
  private
    FMLeaders: array of TsgMLeader;
    FOverallScale: Double;
    FContentBasePoint: TFPoint;
    FTextHeight: Double;
    FArrowHeadSize: Double;
    FLandingGap: Double;
    FLeftAttachment: Integer;
    FRightAttachment: Integer;
    FTextAlignType: Integer;
    FAttachmentType: Integer;
    FHasTextContents: Boolean;
    FTextLabel: string;
    FTextNormal: TFPoint;
    FStyleItem: TsgTableItem;
    FTextLocation: TFPoint;
    FTextDirection: TFPoint;
    FTextRotation: Double;
    FBoundaryWidth: Double;
    FBoundaryHeight: Double;
    FLineSpacingFactor: Double;
    FLineSpacingStyle: Integer;
    FTextColor: TsgColorCAD;
    FAlignment: Integer;
    FFlowDirection: Integer;
    FBackgroundColor: TsgColorCAD;
    FBackgroundScaleFactor: Double;
    FBackgroundTransparency: Integer;
    FIsBackgroundEnabled: Boolean;
    FIsBackgroundMaskFillOn: Boolean;
    FColumnType: Integer;
    FIsTextHeightAutomatic: Boolean;
    FColumnWidth: Double;
    FColumnGutter: Double;
    FColumnFlowReversed: Boolean;
    FColumnSizes: TsgDoubleList;
    FWordBreak: Boolean;
    FHasContentsBlock: Boolean;
    FBlockRecordItem: TsgTableItem;
    FBlkNormal: TFPoint;
    FBlkLocation: TFPoint;
    FBlkScale: TFPoint;
    FBlkRotation: Double;
    FBlockColor: TsgColorCAD;
    FBlkMatrix: TFMatrix;
    FBasePoint: TFPoint;
    FBaseDirection: TFPoint;
    FBaseVertical: TFPoint;
    FIsNormalReversed: Boolean;
    FTopAttachment: Integer;
    FBottomAttachment: Integer;
    function GetBlockRecord: TsgDXFBlockRecord;
    function GetMLeaders(Index: Integer): TsgMLeader;
    function GetMLeadersCount: Integer;
    function GetTextStyle: TsgDXFStyle;
    procedure SetBlockRecord(const Value: TsgDXFBlockRecord);
    procedure SetTextStyle(const Value: TsgDXFStyle);
    procedure BlockrecordDestroing(Sender: TObject);
  protected
    procedure ClearReferences;
    procedure Link(AConverter: TsgDXFConverter);
    function AddMLeader(AMLeader: TsgMLeader): Integer;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure Assign(Source: TPersistent); override;
    property MLeadersCount: Integer read GetMLeadersCount;
    property MLeaders[Index: Integer]: TsgMLeader read GetMLeaders;
    property OverallScale: Double read FOverallScale write FOverallScale;
    property ContentBasePoint: TFPoint read FContentBasePoint write FContentBasePoint;
    property TextHeight: Double read FTextHeight write FTextHeight;
    property ArrowHeadSize: Double read FArrowHeadSize write FArrowHeadSize;
    property LandingGap: Double read FLandingGap write FLandingGap;
    property LeftAttachment: Integer read FLeftAttachment write FLeftAttachment;
    property RightAttachment: Integer read FRightAttachment write FRightAttachment;
    property TextAlignType: Integer read FTextAlignType write FTextAlignType;
    property AttachmentType: Integer read FAttachmentType write FAttachmentType;
    property HasTextContents: Boolean read FHasTextContents write FHasTextContents;
    // ---------------- text content properties ----------------
    property TextLabel: string read FTextLabel write FTextLabel;
    property TextNormal: TFPoint read FTextNormal write FTextNormal;
    property TextStyle: TsgDXFStyle read GetTextStyle write SetTextStyle;
    property TextLocation: TFPoint read FTextLocation write FTextLocation;
    property TextDirection: TFPoint read FTextDirection write FTextDirection;
    property TextRotation: Double read FTextRotation write FTextRotation;
    property BoundaryWidth: Double read FBoundaryWidth write FBoundaryWidth;
    property BoundaryHeight: Double read FBoundaryHeight write FBoundaryHeight;
    property LineSpacingFactor: Double read FLineSpacingFactor write FLineSpacingFactor;
    property LineSpacingStyle: Integer read FLineSpacingStyle write FLineSpacingStyle;
    property TextColor: TsgColorCAD read FTextColor write FTextColor;
    property Alignment: Integer read FAlignment write FAlignment;
    property FlowDirection: Integer read FFlowDirection write FFlowDirection;
    property BackgroundColor: TsgColorCAD read FBackgroundColor write FBackgroundColor;
    property BackgroundScaleFactor: Double read FBackgroundScaleFactor write FBackgroundScaleFactor;
    property BackgroundTransparency: Integer read FBackgroundTransparency write FBackgroundTransparency;
    property IsBackgroundEnabled: Boolean read FIsBackgroundEnabled write FIsBackgroundEnabled;
    property IsBackgroundMaskFillOn: Boolean read FIsBackgroundMaskFillOn write FIsBackgroundMaskFillOn;
    property ColumnType: Integer read FColumnType write FColumnType;
    property IsTextHeightAutomatic: Boolean read FIsTextHeightAutomatic write FIsTextHeightAutomatic;
    property ColumnWidth: Double read FColumnWidth write FColumnWidth;
    property ColumnGutter: Double read FColumnGutter write FColumnGutter;
    property ColumnFlowReversed: Boolean read FColumnFlowReversed write FColumnFlowReversed;
    property ColumnSizes: TsgDoubleList read FColumnSizes;
    property WordBreak: Boolean read FWordBreak write FWordBreak;
    // property Unknown: Boolean;
    // ---------------- text content properties ----------------
    property HasContentsBlock: Boolean read FHasContentsBlock write FHasContentsBlock;
    // ---------------- block content properties ----------------
    property BlockRecord: TsgDXFBlockRecord read GetBlockRecord write SetBlockRecord;
    property BlkNormal: TFPoint read FBlkNormal write FBlkNormal;
    property BlkLocation: TFPoint read FBlkLocation write FBlkLocation;
    property BlkScale: TFPoint read FBlkScale write FBlkScale;
    property BlkRotation: Double read FBlkRotation write FBlkRotation;
    property BlockColor: TsgColorCAD read FBlockColor write FBlockColor;
    property BlkMatrix: TFMatrix read FBlkMatrix write FBlkMatrix;
    // ---------------- block content properties ----------------
    property BasePoint: TFPoint read FBasePoint write FBasePoint;
    property BaseDirection: TFPoint read FBaseDirection write FBaseDirection;
    property BaseVertical: TFPoint read FBaseVertical write FBaseVertical;
    property IsNormalReversed: Boolean read FIsNormalReversed write FIsNormalReversed;
    // 2010+
    property TopAttachment: Integer read FTopAttachment write FTopAttachment;
    property BottomAttachment: Integer read FBottomAttachment write FBottomAttachment;
  end;

  TsgCADMLeaderAnnotContext = class(TsgDXFObjectContextData)
  private
    FItem: TsgMLeaderContextData;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Item: TsgMLeaderContextData read FItem;
  end;

  TsgDXFMLeaderProp = (mlpLeaderLineType, mlpLineColor, mlpLineType,
    mlpLineWeight, mlpEnabledLanding, mlpLandingGap, mlpEnabledDogLeg,
    mlpDogLegLen, mlpArrow, mlpArrowSize, mlpContentType, mlpTextStyle,
    mlpTextLeftAttachment, mlpTextAngleType, mlpTextAlignmentType,
    mlpTextColor, mlpTextHeight, mlpEnabledTextFrame, mlpEnabledUseDefMText,
    mlpBlock, mlpBlockColor, mlpBlockScale, mlpBlockRotation,
    mlpBlockConnectionType, mlpScale, mlpTextRightAttachment,
    mlpTextSwitchAlignmentType, mlpTextAttachmentDirection,
    mlpTextTopAttachment, mlpTextBottomAttachment);

  TsgDXFMLeaderProps = set of TsgDXFMLeaderProp;

  TsgCADMLeaderStyle = class(TsgDXFOwneredItem)
  private
    FContentType: Integer;//0=None, 1=Block, 2=MTEXT, 3=TOLERANCE
    FDrawMLeaderOrder: Integer;
    FDrawLeaderOrder: Integer;
    FMaxNumberOfPoints: Integer;
    FFirstSegmentAngle: Double;
    FSecondSegmentAngle: Double;
    FLeaderLineType: Integer;
    FColor: TsgColorCAD;
    FLineTypeItem: TsgTableItem;
    FLineWeight: Double;
    FLandingEnabled: Boolean;
    FLandingGap: Double;
    FDogLegEnabled: Boolean;
    FLandingDistance: Double;
    FStyleDescription: string;
    FArrowItem: TsgTableItem;
    FArrowHeadSize: Double;
    FText: string;
    FTextStyleItem: TsgTableItem;
    FLeftAttachment: Integer;
    FRightAttachment: Integer;
    FTextAngleType: Integer;
    FAttachmentDirection: Integer;
    FTopAttachment: Integer;
    FBottomAttachment: Integer;
    FTextAlignmentType: Integer;
    FTextColor: TsgColorCAD;
    FTextHeight: Double;
    FTextFrameEnabled: Boolean;
    FAlwaysAlignTextLeft: Boolean;
    FAlignSpace: Double;
    FBlockRecordItem: TsgTableItem;
    FBlockColor: TsgColorCAD;
    FBlockScale: TFPoint;
    FIsBlockScaleEnabled: Boolean;
    FBlockRotation: Double;
    FIsBlockRotationEnabled: Boolean;
    FBlockConnectionType: Integer;
    FScaleFactor: Double;
    FBreakSize: Double;
    function GetArrow: TsgDXFBlockRecord;
    function GetBlockRecord: TsgDXFBlockRecord;
    function GetTextStyle: TsgDXFStyle;
    procedure SetArrow(const Value: TsgDXFBlockRecord);
    procedure SetBlockRecord(const Value: TsgDXFBlockRecord);
    procedure SetTextStyle(const Value: TsgDXFStyle);
    procedure ArrowDestroing(Sender: TObject);
    procedure BlockrecordDestroing(Sender: TObject);
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function GetPropertiesInit: TsgDXFMLeaderProps; virtual;
    function GetLineWeight: Double; override; //92
    procedure SetLineWeight(Value: Double); override; //92
    function GetColorCAD: TsgColorCAD; override; //91
    procedure SetColorCAD(const Value: TsgColorCAD); override; //91
    function GetLineType: TsgDXFLineType; override;//340
    procedure SetLineType(const AValue: TsgDXFLineType); override;//340
    procedure SetConsistentStyle(const AStyle: TsgCADMLeaderStyle);
    procedure SetPropertiesInit(const AValue: TsgDXFMLeaderProps); virtual;
    function IsProperties: Boolean; virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function ToXMLAsProperties(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
    function FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function FromXMLAsProperties(const ANode: TsgNodeSample; const AResult: IsgResultNode = nil): Integer;
    property PropertiesInit: TsgDXFMLeaderProps read GetPropertiesInit;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property ContentType: Integer read FContentType write FContentType;//170
    property DrawMLeaderOrder: Integer read FDrawMLeaderOrder write FDrawMLeaderOrder;//171
    property DrawLeaderOrder: Integer read FDrawLeaderOrder write FDrawLeaderOrder;//172
    property MaxNumberOfPoints: Integer read FMaxNumberOfPoints write FMaxNumberOfPoints;//90
    property FirstSegmentAngle: Double read FFirstSegmentAngle write FFirstSegmentAngle;//40
    property SecondSegmentAngle: Double read FSecondSegmentAngle write FSecondSegmentAngle;//41
    property LeaderLineType: Integer read FLeaderLineType write FLeaderLineType;//173
    property LeaderLineColor: TsgColorCAD read GetColorCAD write SetColorCAD;//91
    property LandingEnabled: Boolean read FLandingEnabled write FLandingEnabled;//290
    property LandingGap: Double read FLandingGap write FLandingGap;//42
    property DogLegEnabled: Boolean read FDogLegEnabled write FDogLegEnabled;//291 (is dog-leg enabled?)
    property LandingDistance: Double read FLandingDistance write FLandingDistance;//43
    property StyleDescription: string read FStyleDescription write FStyleDescription;//3
    property Arrow: TsgDXFBlockRecord read GetArrow write SetArrow;//341
    property ArrowHeadSize: Double read FArrowHeadSize write FArrowHeadSize;//44
    property Text: string read FText write FText;//300
    property TextStyle: TsgDXFStyle read GetTextStyle write SetTextStyle;//342
    property LeftAttachment: Integer read FLeftAttachment write FLeftAttachment; //174
    property RightAttachment: Integer read FRightAttachment write FRightAttachment;//178
    property TextAngleType: Integer read FTextAngleType write FTextAngleType;//175
    property TextAlignmentType: Integer read FTextAlignmentType write FTextAlignmentType;//176
    property TextColor: TsgColorCAD read FTextColor write FTextColor;//93
    property TextHeight: Double read FTextHeight write FTextHeight;//45
    property TextFrameEnabled: Boolean read FTextFrameEnabled write FTextFrameEnabled;//292
    property AlwaysAlignTextLeft: Boolean read FAlwaysAlignTextLeft write FAlwaysAlignTextLeft;//297
    property AlignSpace: Double read FAlignSpace write FAlignSpace;//46
    property BlockRecord: TsgDXFBlockRecord read GetBlockRecord write SetBlockRecord;//343
    property BlockColor: TsgColorCAD read FBlockColor write FBlockColor;//94
    property BlockScale: TFPoint read FBlockScale write FBlockScale;//47,49,140
    property IsBlockScaleEnabled: Boolean read FIsBlockScaleEnabled write FIsBlockScaleEnabled;//293
    property BlockRotation: Double read FBlockRotation write FBlockRotation;//141
    property IsBlockRotationEnabled: Boolean read FIsBlockRotationEnabled write FIsBlockRotationEnabled;//294
    property BlockConnectionType: Integer read FBlockConnectionType
      write FBlockConnectionType;//177  (0 = MLeader connects to the block extents, 1 = MLeader connects to the block base point)
    property ScaleFactor: Double read FScaleFactor write FScaleFactor;//142
    //property PropertyChanged: Boolean read FPropertyChanged write FPropertyChanged;//295
    property BreakSize: Double read FBreakSize write FBreakSize;//143
    // 2010+
    property AttachmentDirection: Integer read FAttachmentDirection write FAttachmentDirection;//271
    property TopAttachment: Integer read FTopAttachment write FTopAttachment;//273
    property BottomAttachment: Integer read FBottomAttachment write FBottomAttachment;//272
  end;

{
  1 << 0 = Leader line type,
  1 << 1 = Leader line color,
  1 << 2 = Leader line type handle,
  1 << 3 = Leader line weight,
  1 << 4 = Enabled landing,
  1 << 5 = Landing gap,
  1 << 6 = Enabled dog-leg,
  1 << 7 = Dog-leg length,
  1 << 8 = Arrow symbol handle,
  1 << 9 = Arrow size,
  1 << 10 = Conent type,
  1 << 11 = Text style handle,
  1 << 12 = Text left attachment type (of MTEXT),
  1 << 13 = Text angle type (of MTEXT),
  1 << 14 = Text alignment type (of MTEXT),
  1 << 15 = Text color (of MTEXT),
  1 << 16 = Text height (of MTEXT),
  1 << 17 = Enable text frame,
  1 << 18 = Enable use of default MTEXT (from MLEADERSTYLE),
  1 << 19 = Content block handle,
  1 << 20 = Block content color,
  1 << 21 = Block content scale,
  1 << 22 = Block content rotation,
  1 << 23 = Block connection type,
  1 << 24 = Scale,
  1 << 25 = Text right attachment type (of MTEXT),
  1 << 26 = Text switch alignment type (of MTEXT),
  1 << 27 = Text attachment direction (of MTEXT),
  1 << 28 = Text top attachment type (of MTEXT),
  1 << 29 = Text bottom attachment type (of MTEXT)     }

  TsgCADMLeaderProperties = class(TsgCADMLeaderStyle)
  private
    FPropertiesInit: TsgDXFMLeaderProps;
  protected
    function GetPropertiesInit: TsgDXFMLeaderProps; override;
    procedure SetPropertiesInit(const AValue: TsgDXFMLeaderProps); override;
    function IsProperties: Boolean; override;
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
  end;

  TsgDXFEntityArray = array of TsgDXFEntity;

  PsgMLeaderLabel = ^TsgMLeaderLabel;
  TsgMLeaderLabel = record
    Attdef: TsgDXFAttdef;
    Text: string;
    ID: Integer;
    Width: Double;
  end;

  TsgMLeaderLabels = array of TsgMLeaderLabel;

  TsgCADMultiLeader = class(TsgDXFObjectEntityColor)
  private
    FStyleItem: TsgTableItem;
    FProperties: TsgCADMLeaderStyle;
    FArrows: TsgDXFEntityArray;
    FLabels: TsgMLeaderLabels;
    FIsTextDirectionNegative: Boolean;
    FJustification: Integer;
    FLeaderExtendedToText: Boolean;
    FContext: TsgCADMLeaderAnnotContext;
    FTextAlignIPE: Integer;
    FRenderObject: TsgDXFEntity;
    function GetStyle: TsgCADMLeaderStyle;
    procedure SetStyle(const Value: TsgCADMLeaderStyle);
    function GetProperties: TsgCADMLeaderStyle;
    function GetRenderObject: TsgDXFEntity;
    function HasProperties: Boolean;
    function GetOverrideFlags: TsgDXFMLeaderProps;
    procedure SetOverrideFlags(const Value: TsgDXFMLeaderProps);
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function GetBox: TFRect; override;
    function GetEntType: TsgCADEntities; override;
    function GetLineWeight: Double; override; //171
    procedure SetLineWeight(Value: Double); override; //171
    procedure SetLineType(const Value: TsgDXFLineType); override; //341
    function GetLineType: TsgDXFLineType; override; //341
    function GetConsistentStyle: TsgCADMLeaderStyle;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    function FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    procedure ToXMLSubEntities(const AParentNode: TsgNode; const AParams: TsgXMLParams); override;
    function FromXMLSubEntities(const ANode: TsgNodeSample; const AResult: IsgResultNode = nil): Integer; override;
    property OverrideFlags: TsgDXFMLeaderProps read GetOverrideFlags write SetOverrideFlags;//90
    property Arrows: TsgDXFEntityArray read FArrows write FArrows;//(94;)345
    property Labels: TsgMLeaderLabels read FLabels write FLabels;//330;302;177;44
    property Context: TsgCADMLeaderAnnotContext read FContext;
    property Properties: TsgCADMLeaderStyle read GetProperties;
    property RenderObject: TsgDXFEntity read GetRenderObject;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Style: TsgCADMLeaderStyle read GetStyle write SetStyle;//340
    property IsTextDirectionNegative: Boolean read FIsTextDirectionNegative write FIsTextDirectionNegative;//294
    property TextAlignIPE: Integer read FTextAlignIPE write FTextAlignIPE;//178
    property Justification: Integer read FJustification write FJustification;//179
    property LeaderExtendedToText: Boolean read FLeaderExtendedToText write FLeaderExtendedToText;//295
  end;

// -------------------------- Multileader objects interface --------------------------
{$IFDEF SGDEL_2005}{$ENDREGION}{$ENDIF}

  TsgDXFLineType = class(TsgDXFPenTableItem)
  private
    FLines: TsgLines;
    FNameID: TsgStandardLineTypeName;
  protected
    function GetLines: TsgLines; override;
    procedure FreeReferences; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure SetLineTypeScale(Value: Double); override;
    procedure NameChanging(var NewName: string; var AAllow: Boolean); override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    property NameID: TsgStandardLineTypeName read FNameID;
  public
    constructor Create; override;
    procedure AddComplexElement(const AComplexType: Byte;
      const ADash, ARotation, AScale, AXOffset, AYOffset: Double;
      AStyle: TsgDXFStyle; const AShapeNumber: Byte; const AText: string = '';
      AScaleFactor: Double = cnstLTScale);
    procedure AddDashElement(const ADash: Double;
      AScaleFactor: Double = cnstLTScale);
    procedure AssignEntity(Source: TsgDXFEntity); override;
  end;

  TsgDXFLayer = class(TsgDXFCustomColor)
  private
    FLineTypeItem: TsgTableItem;
    FAnnoScaleItem: TsgTableItem;
    FMaterialItem: TsgTableItem;
    FLineWeight: Double;
    { TODO: can be union as one field }
    FIsPlotting: Boolean;
    FFrozenByViewPort: Boolean;
    FIsCheckName: Boolean;
    FVisible: Boolean;
    FNameID: TsgStandardLayerName;
{$IFDEF SG_FIREMONKEY}[Weak]{$ENDIF}FContainerLayer: TsgDXFlayer;
    function GetUsed: Boolean;
    function GetAnnoScale: TsgDXFScale;
    procedure UpdateAnnoScale(AConverter: TsgDXFConverter);
  protected
    procedure FreeReferences; override;
    procedure ClearReferences; override;
    function GetContainerLayer: TsgDXFLayer;
    function GetLocked: Boolean;
    function GetVisible: Boolean; override;
    function GetFrozen: Boolean;
    function GetFrozenByNewViewPort: Boolean;
    function GetIsPlotting: Boolean;
    function GetLines: TsgLines; override;
    function GetLineType: TsgDXFLineType; override;
    function GetLineWeight: Double; override;
    function GetMaterial: TsgDXFMaterial; override;
    function GetXrefLink: Boolean;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure SetFrozen(AFrozen: Boolean);
    procedure SetFrozenByNewViewPort(const Value: Boolean);
    procedure SetLineType(const AValue: TsgDXFLineType); override;
    procedure SetLineWeight(Value: Double); override;
    procedure SetLocked(const Value: Boolean);
    procedure SetMaterial(const Value: TsgDXFMaterial); override;
    procedure SetXrefLink(const Value: Boolean);
    procedure SetVisible(Value: Boolean); override;
    property ContainerLayer: TsgDXFLayer read GetContainerLayer;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
    function SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
      const AType: TsgPlcType; const AValue: Variant): Integer; override;
{$ENDIF}
    procedure NameChanging(var NewName: string; var AAllow: Boolean); override;
    property NameID: TsgStandardLayerName read FNameID;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Frozen: Boolean read GetFrozen write SetFrozen;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property IsFrozenByViewPort: Boolean read FFrozenByViewPort write FFrozenByViewPort;
    property IsFrozenByNewViewPort: Boolean read GetFrozenByNewViewPort write SetFrozenByNewViewPort;
    property Locked: Boolean read GetLocked write SetLocked;
    property XrefLink: Boolean read GetXrefLink write SetXrefLink;
    property IsPlotting: Boolean read GetIsPlotting write FIsPlotting;
    property IsCheckName: Boolean read FIsCheckName write FIsCheckName;
    property Used: Boolean read GetUsed;
    property AnnoScale: TsgDXFScale read GetAnnoScale;
  end;

  TsgDXFBlockRecord = class(TsgDXFPenTableItem)
  private
    FBlock: TsgDXFBlock;
{$IFDEF SG_BLOCK_PREVIEW}
    FPreview: TPicture;
{$ENDIF}
    procedure AuthEnvironDestroing(Sender: TObject);
  protected
    FDestroyNotifications: TsgNotifyEventsList;
{$IFDEF SG_FIREMONKEY}[Weak]{$ENDIF}FAuthEnviron: TsgDXFBlockRecord;
    procedure ClearReferences; override;
    function GetLinkClass: TsgOwneredItemClass; override;
    function GetDescription: string; override;
    procedure FreeReferences; override;

    procedure NotifyDestroing; override;
    function AddDestroyNotification(const ANotify: TNotifyEvent): Integer; override;
    function RemoveDestroyNotification(const ANotify: TNotifyEvent): Integer; override;

    function GetAcAuthEnvironBlockRecord: TsgDXFBlockRecord;
    function GetBlockRepBTagBlockRecord: TsgDXFBlockRecord;
    procedure SetDescription(const AValue: string); override;
    property Block: TsgDXFBlock read FBlock write FBlock;
{$IFDEF SG_BLOCK_PREVIEW}
    property PreviewRef: TPicture read FPreview write FPreview;
{$ENDIF}
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function EntName: string; override;
    function AddEntity(const AEntity: TsgDXFEntity): Integer; override;
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure ExchangeEntity(AIndex1, AIndex2: Integer); override;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer; override;
//    function IndexOfHandle(const AHandle: UInt64): Integer;
    function IndexOfName(const AName: string): Integer; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
{$IFDEF SG_BLOCK_PREVIEW}
    property Preview: TPicture read FPreview;
{$ENDIF}
  end;

  TsgDXFGroup = class(TsgDXFObjectEntity)
  private
//    FSortHandles: TsgCollection;
    FEntities: TsgEntitiesList;
    FOnListNotify: TsgObjectListNotify;
  protected
    procedure AddEntities(const ASource: TsgDXFEntity;
      AConverter: TsgDXFConverter = nil);
    function CanAddedToXMLParams: Boolean; override;
//    function AddHandleItem(const AItem: TsgDXFEntity): Integer; override;
//    function DeleteHandleItem(const AItem: TsgDXFEntity): Integer; override;
    procedure DoListNotify(Ptr: Pointer; Action: TListNotification); dynamic;
    procedure FreeReferences; override;
    function GetCount: Integer; override;
    function GetUseEntityInvisible: Boolean;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure UpdateBox; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;
    procedure SetUseEntityInvisible(AValue: Boolean);
    procedure SortEntByHandle;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;
    property OnListNotify: TsgObjectListNotify read FOnListNotify write FOnListNotify;
    property UseEntityInvisible: Boolean read GetUseEntityInvisible write SetUseEntityInvisible;
  public
    constructor Create; override;
    procedure Iterate(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); virtual;
    function GetStrValue: string; override;
        // functions of IsgListOfEntities
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure ExchangeEntity(AIndex1, AIndex2: Integer); override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer; override;
    function IndexOfName(const AName: string): Integer; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
{$IFDEF SGDEL_2005}
//    function GetEnumerator: TListEnumerator;
{$ENDIF}
  end;

  TsgDXFGroupEntity = class(TsgDXFGroup)
  private
    FBox: TFRect;
  protected
    function GetBox: TFRect; override;
    procedure UpdateBox; override;
    class function IsAttdef(const AEntity: Pointer): Pointer;
  public
    constructor Create; override;
    procedure LoadIntities(const AConverter: TsgDXFConverter; ALoadSelf: Boolean = True);
    function FindEntity(const AProc: TsgObjProc; const AList: TList): TsgDXFEntity;
  end;

  TsgDXFCustomVertex = class(TsgDXFObjectEntityLineType)
  private
    FPoint: TFPoint;
  protected
    function HasPoint: Boolean; virtual;
    function CanDraw: Boolean; override;
    function GetBox: TFRect; override;
    function GetPoint: TFPoint; virtual;
    procedure SetPoint(AValue: TFPoint); virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Point: TFPoint read GetPoint write SetPoint;
  end;

  TsgDXFVertex = class(TsgDXFEntity)
  private
    FFlags: Integer;
    FHandle: UInt64;
    FPoint: TFPoint;
    function GetPolyFaceIndex1: Integer;
    function GetPolyFaceIndex2: Integer;
    function GetPolyFaceIndex3: Integer;
    function GetPolyFaceIndex4: Integer;
    procedure NewPolyFaceIndexes;
    procedure SetPolyFaceIndex1(const Value: Integer);
    procedure SetPolyFaceIndex2(const Value: Integer);
    procedure SetPolyFaceIndex3(const Value: Integer);
    procedure SetPolyFaceIndex4(const Value: Integer);
    function GetPolyFaceIndex(Index: Integer): Integer;
    procedure SetPolyFaceIndex(Index: Integer; const Value: Integer);
  protected
    FBulge: Double;
    FEndWidth: Double;
    FPolyFaceIndexes: PsgPolyFaceVertexIndexes;
    FStartWidth: Double;
    function CanHaveHandle: Boolean; override;
    procedure FreeReferences; override;
    function GetBox: TFRect; override;
    function GetInternalFlags: Word; override;
    function GetHandle: UInt64; override;
    function GetPoint: TFPoint;
    function GetFlags: Integer; override;
    function GetIs3DVertex: Boolean;
    function GetBulge: Double;
    function GetEndWidth: Double;
    function GetStartWidth: Double;
    function IsEqualPointBulge(const AVertex: TsgDXFVertex): Boolean;
    procedure SetHandle(const AValue: UInt64); override;
    procedure SetPoint(const AValue: TFPoint);
    procedure SetFlags(const Value: Integer); override;
    procedure SetIs3DVertex(const Value: Boolean);
    procedure SetBulge(const Value: Double);
    procedure SetEndWidth(const Value: Double);
    procedure SetStartWidth(const Value: Double);
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function IsSplineFrameControlPoint: Boolean;
    function IsPolyfaceMeshVertex: Boolean;
    function HasBulge: Boolean;
    property Bulge: Double read GetBulge write SetBulge;
    property EndWidth: Double read GetEndWidth write SetEndWidth;
    property Is3DVertex: Boolean read GetIs3DVertex write SetIs3DVertex;
    property Point: TFPoint read FPoint write FPoint;
    property PolyFaceVertexIndex1: Integer read GetPolyFaceIndex1 write SetPolyFaceIndex1;
    property PolyFaceVertexIndex2: Integer read GetPolyFaceIndex2 write SetPolyFaceIndex2;
    property PolyFaceVertexIndex3: Integer read GetPolyFaceIndex3 write SetPolyFaceIndex3;
    property PolyFaceVertexIndex4: Integer read GetPolyFaceIndex4 write SetPolyFaceIndex4;
    property PolyFaceVertexIndex[Index: Integer]: Integer read GetPolyFaceIndex
      write SetPolyFaceIndex;
    property StartWidth: Double read GetStartWidth write SetStartWidth;
  end;

  TsgDXFPenLine = class(TsgDXFCustomVertex)
  private
    FExtrusion: PFPoint;
    FLineWeight: Double;
    FZThick: Double;
  protected
    procedure AddThickness(var R: TFRect);
    procedure ApplyExtrusionByPoint; virtual;
    procedure FreeReferences; override;
    function IsExtruded: Boolean; virtual;
    function GetBox: TFRect; override;
    function GetExtrusion: TFPoint; override;
    function GetLineWeight: Double; override;
    function GetZThick: Double;
    function GetThicknessInt: Double; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetExtrusion(const Value: TFPoint); override;
    procedure SetLineWeight(Value: Double); override;
    procedure SetThicknessInt(const AValue: Double); override;
    procedure SetZThick(const Value: Double);
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Extrusion: TFPoint read GetExtrusion write SetExtrusion;
    procedure SetLWeight(Value: Integer); override;
    property ZThick: Double read GetZThick write SetZThick;
  end;

  TsgDXFLine = class(TsgDXFPenLine)
  private
    FPoint1: TFPoint;
  protected
    procedure ApplyExtrusionByPoint; override;
    function GetAngle: TsgFloat;
    function GetBox: TFRect; override;
    function GetEntType: TsgCADEntities; override;
    function GetLength: TsgFloat;
    function GetLine: TsgLine;
    function GetPoint1: TFPoint;
    function GetPoints(const AIndex: Integer): TFPoint;
    procedure AddZThick(var R: TFRect);
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetAngle(const Value: TsgFloat);
    procedure SetLine(const AValue: TsgLine);
    procedure SetLength(const Value: TsgFloat);
    procedure SetPoint1(AValue: TFPoint);
    procedure SetPoints(const AIndex: Integer; const AValue: TFPoint);
    function ToXMLOverloadedData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Angle: TsgFloat read GetAngle write SetAngle;
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; override;
    property Line: TsgLine read GetLine write SetLine;
    property Points[const AIndex: Integer]: TFPoint read GetPoints write SetPoints;
    property Point1: TFPoint read FPoint1 write FPoint1;
    property Length: TsgFloat read GetLength write SetLength;
  end;

  TsgDXFRay = class(TsgDXFLine)
  private
    FStartPoint: TFPoint;
    FDirection: TFPoint;
    function DoUpdatePoints(const ADirection: TFPoint; const AViewport: TRect;
      const AMatrix: TFMatrix): TFPoint;
  protected
    procedure ApplyExtrusionByPoint; override;
    function GetBox: TFRect; override;
    function GetEntType: TsgCADEntities; override;
    function GetDirection: TFPoint;
    function GetStartPoint: TFPoint;
    procedure SetDirection(const Value: TFPoint);
    procedure SetStartPoint(const Value: TFPoint);
    procedure UpdatePoints(const ADirection: TFPoint; const AViewport: TRect;
      const AMatrix: TFMatrix); virtual;
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property StartPoint: TFPoint read GetStartPoint write SetStartPoint;
    property Direction: TFPoint read GetDirection write SetDirection;
  end;

  TsgDXFXline = class(TsgDXFRay)
  protected
    function GetEntType: TsgCADEntities; override;
    procedure UpdatePoints(const ADirection: TFPoint; const AViewport: TRect;
      const AMatrix: TFMatrix); override;
  end;

  TsgDXFPoint = class(TsgDXFPenLine)
  private
    FPoints: TList;
  protected
    procedure ApplyExtrusionByPoint; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure ClearPoints;
    function GetBox: TFRect; override;
    function GetEntType: TsgCADEntities; override;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    property Points: TList read FPoints;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; override;
    function GetPoints(const AList: TsgObjectList): Integer;
  end;

  // InternalFlags: Integer;
  //
  // $40 - n(Point, Point1, Point2) = 0;
  // $10 - n(Point, Point1, Point2) - dir to front
  //
  // $80 - n(Point, Point2, Point3) = 0;
  // $20 - n(Point, Point2, Point3) - dir to front

  TsgDXFSolid = class(TsgDXFLine)
  private
    FPoint2: TFPoint;
    FPoint3: TFPoint;
    FMatrix: PFMatrix;
  protected
    procedure CalcState; virtual;
    procedure FreeReferences; override;
    function GetEntType: TsgCADEntities; override;
    function GetBox: TFRect; override;
    function GetMatrix: TFMatrix; virtual;
    function GetPoint2: TFPoint;
    function GetPoint3: TFPoint;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetExtrusion(const Value: TFPoint); override;
    procedure SetPoint2(AValue: TFPoint);
    procedure SetPoint3(AValue: TFPoint);
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; override;
    function GetPoints(var APoints4: TsgPoints4;
      const AAddZThick: Boolean = False; const AExtruding: Boolean = False): Integer;
    function GetDrawPoints(const APoints: TFPointList): Boolean;
    property Point2: TFPoint read GetPoint2 write SetPoint2;
    property Point3: TFPoint read GetPoint3 write SetPoint3;
  end;

  TsgDXFSortEntsTable = class(TsgDXFOwneredItem)
  private
    FObject: TsgDXFEntity;
    FHandlesNew: TsgInt64List;
    FHandlesOld: TsgInt64List;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure FindMinMaxHandles(const AEntities: TsgObjectList;
      var AHandleMin, AHandleMax: UInt64);
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure ReplaceHandles(const AEntities: TsgObjectList;
      const ACurrent, ANew: TsgInt64List);
    procedure SortEntitiesList(const AEntities: TsgObjectList);
    procedure SortSmallList(const AEntities: TsgObjectList;
      const AHandleMin, AHandleMax: UInt64);
    procedure SortByQwickMetod(const AEntities: TsgObjectList);
  public
    constructor Create; override;
    function SortEntities(const AGroup: TsgDXFEntity): Boolean;
    function ReplaceHandle(AEntity: TsgDXFEntity): Boolean;
    property HandlesNew: TsgInt64List read FHandlesNew;
    property HandlesOld: TsgInt64List read FHandlesOld;
    property SortObject: TsgDXFEntity read FObject write FObject;
  end;

  TsgCADSpatialFilter = class(TsgDXFOwneredItem)
  private
    FInvBlkTransform: TFMatrix;
    FClip: TFMatrix;
    FBounds: TFPointList;
    FExtrusion: TFPoint;
    FBackClip: Boolean;
    FBackDist: Double;
    FClipbdorg: TFPoint;
    FDisplayBounds: Boolean;
    FFrontClip: Boolean;
    FFrontDist: Double;
  protected
    function GetExtrusion: TFPoint; override;
    procedure SetExtrusion(const Value: TFPoint); override;
    function GetBoundTransformation(const ABlkRefTransformation: TFMatrix): TFMatrix;
  public
    constructor Create; override;
    destructor Destroy; override;
    property InvBlkTransform: TFMatrix read FInvBlkTransform write FInvBlkTransform;
    property Clip: TFMatrix read FClip write FClip;
    property Bounds: TFPointList read FBounds;
    property BackClip: Boolean read FBackClip write FBackClip;
    property BackDist: Double read FBackDist write FBackDist;
    property Clipbdorg: TFPoint read FClipbdorg write FClipbdorg;
    property DisplayBounds: Boolean read FDisplayBounds write FDisplayBounds;
    property Extrusion: TFPoint read GetExtrusion write SetExtrusion;
    property FrontClip: Boolean read FFrontClip write FFrontClip;
    property FrontDist: Double read FFrontDist write FFrontDist;
  end;

  TsgDXFTrace = class(TsgDXFSolid)
  protected
    function GetEntType: TsgCADEntities; override;
  public
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
  end;

  TsgDXF3dFace = class(TsgDXFSolid)
  private
    FFlags: Integer;
  protected
    function GetBox: TFRect; override;
    function GetEntType: TsgCADEntities; override;
    function GetFlags: Integer; override;
    function IsHidden: Boolean;
    procedure SetFlags(const Value: Integer); override;
    function ToXMLOverloadedData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  end;

  TsgCADBasePolyline = class(TsgDXFPenLine)
  private
    FPolyPoints: TFPointList;
    FFlags: Integer;
    FBox: TFRect;
    procedure DoExtrusions;
    function GetPolyPoint(Index: Integer): TFPoint;
    function GetIsPolyZThickness: Boolean;
  protected
    procedure AddZTicks(AList: TFPointList);
    procedure DoZThickAndElevation; virtual;
    procedure ClearReferences; override;
    procedure CheckDispersionFactor;
    procedure FreeReferences; override;
    procedure DoZThickness(const APointsCounts: TsgIntegerList);
    function GetBox: TFRect; override;
    function GetClosed: Boolean; virtual;
    function GetElevation: Double; virtual;
    function GetLinkEntity: TsgDXFEntity; virtual;//for gcode
    function GetIsMeshMClosed: Boolean;
    function GetIsMeshNClosed: Boolean;
    function GetIsPolygonMesh: Boolean; virtual;
    function GetIsPLinegen: Boolean;
    function GetFlags: Integer; override;
    function GetPolySign: Integer;
    procedure SetClosed(const AClosed: Boolean); virtual;
    procedure SetPLineGen(const APLineGen: Boolean); virtual;
    procedure SetFlags(const Value: Integer); override;
    procedure SetPolySign(const AValue: Integer);
    procedure UpdateBox; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure ReloadPolyPoints(const AConverter: TsgDXFConverter); virtual;
    function IsPathEvacuation: Boolean;
    function IsPolyPointsSolid: Boolean;
    function GetArea: Double; virtual;
    function GetLength: Double; virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
    property IsMeshMClosed: Boolean read GetIsMeshMClosed;
    property IsMeshNClosed: Boolean read GetIsMeshNClosed;
    property IsPolygonMesh: Boolean read GetIsPolygonMesh;
    property PolySign: Integer read GetPolySign write SetPolySign;
  public
    constructor Create; override;
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; override;
    function PointCount: Integer;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function HasWidth(const AFull: Boolean = True): Boolean; virtual;
    property Closed: Boolean read GetClosed write SetClosed;
    property IsPLinegen: Boolean read GetIsPLinegen write SetPLineGen;
    property IsPolyZThickness: Boolean read GetIsPolyZThickness;
    property PolyPoints: TFPointList read FPolyPoints;
    property Points[Index: Integer]: TFPoint read GetPolyPoint; default;
  end;

  TsgDXFPolyline = class(TsgCADBasePolyline)
  private
    FArrows: TFPointList;
    FArrowsLines: TsgLines;
    FEntities: TsgEntitiesList;
    FMeshM: Integer;
    FMeshN: Integer;
    FPolyFaceVertexIndexes: TsgIntegerList;
    FPolyLineEntities: TsgEntitiesList;
    FStartW: Double;
    FEndW: Double;
    FGlobalW: Double;
    FPointsCounts: TsgIntegerList;//evg
    function AddVertextEx(const AVertex: TsgDXFVertex; const AForce: Boolean = False): Boolean;{$IFDEF USE_INLINE}inline;{$ENDIF}
    function InsVertexEx(const AVertex: TsgDXFVertex; const AForce: Boolean = False): Boolean;{$IFDEF USE_INLINE}inline;{$ENDIF}
    procedure ApplyBulgeByPoint(P1,P2: TFPoint; Bulge: Double;
      AList: TFPointList; ANumberOfCircleParts: Integer);
    procedure DoVertexes;
    function GetBulgeHeight(const AIndex: Integer): Double;
    function GetEntities: TsgEntitiesList;
    function GetIsPolyFaceMesh: Boolean;
    function GetVertex(Index: Integer): TsgDXFVertex;
    procedure SetBulgeHeight(const AIndex: Integer; const AHeight: Double);
    procedure SetPointsCounts(const Value: TsgIntegerList);
    procedure SetPolyline3D(const Value: Boolean);
    procedure SetNewIndexPoint(const AIndex: Integer; const AGCode: Boolean;
      const AIsStart: Boolean);
  protected
    function HasPoint: Boolean; override;
    function DeleteDuplicateVertexes(ADuplicateVertexesAccuracy: Double): Boolean;
    procedure DoLoadVertexes(AConverter: TsgDXFConverter);
    procedure DoZThickAndElevation; override;
    procedure ClearReferences; override;
    function CopyVertexes(const APoly: TsgDXFPolyline;
      const ASaveHandles: Boolean = False): Integer;
    function CopyVertexesExt(const APoly: TsgDXFPolyline;
      const Adding, AForward: Boolean): Integer;
    procedure SetStartIndexPoint(const AIndex: Integer; const AGcode: Boolean);
    procedure SetEndIndexPoint(const AIndex: Integer);

    procedure FreeReferences; override;
    procedure DoArrows(const ALines: TsgLines; const AMatrix: PFMatrix);
    function GetCount: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    function GetEntType: TsgCADEntities; override;
    function GetElevation: Double; override;
    function GetGlobalWidth: Double;
    function GetIsPolygonMesh: Boolean; override;
    procedure GetVertexListForPolygonMesh(MeshM , MeshN: Integer;
      AVertexList: TFPointList; AVertexIndexList: TsgIntegerList);
    procedure GetVertexListForPolyFaceMesh(AVertexList: TFPointList);
    function IsExtruded: Boolean; override;
    function Is3dPolyline: Boolean;
    function Is3dPolygonMesh: Boolean;
    function IsPolyFaceParamsValid: Boolean;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;
    procedure SetElevation(const AValue: Double);
    procedure SetGlobalWidth(AValue: Double);
    procedure UpdateBox; override;
    procedure ReloadPolyPoints(const AConverter: TsgDXFConverter); override;
    function GetArea: Double; override;
    function GetLength: Double; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_CLIENTSVG}
    class function GetCopyExtData: Boolean;
    class procedure SetCopyExtData(const AValue: Boolean);
{$ENDIF}
    property ArrowsLines: TsgLines read FArrowsLines;
    property BulgeHeight[const AIndex: Integer]: Double read GetBulgeHeight write SetBulgeHeight;
    property List: TsgEntitiesList read FEntities;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;

    // functions of IsgListOfEntities
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure Clear(const ADoFree: Boolean = True); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;

    procedure Iterate(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); virtual;
    function HasWidth(const AFull: Boolean = True): Boolean; override;
    property Arrows: TFPointList read FArrows write FArrows;
    property EndWidth: Double read FEndW write FEndW;
    property Elevation: Double read GetElevation write SetElevation;
    property GlobalWidth: Double read FGlobalW write FGlobalW;
    property Polyline3D: Boolean read Is3dPolyline write SetPolyline3D;
    property IsMeshMClosed;
    property IsMeshNClosed;
    property IsPolyFaceMesh: Boolean read GetIsPolyFaceMesh;
    property IsPolygonMesh;
    property MeshM: Integer read FMeshM write FMeshM;
    property MeshN: Integer read FMeshN write FMeshN;
    property PolyFaceVertexIndexes: TsgIntegerList read FPolyFaceVertexIndexes;
    property PolyLineEntities: TsgEntitiesList read FPolyLineEntities;
    property StartWidth: Double read FStartW write FStartW;
    property PointsCounts: TsgIntegerList read FPointsCounts write SetPointsCounts; //evg
    property Vertexes[Index: Integer]: TsgDXFVertex read GetVertex;
  end;

  TsgDXFLWPolyline = class(TsgDXFPolyline)
//evg//  TsgDXFLWPolyline = class(TsgDXFBasePolyline)
  protected
    function GetEntType: TsgCADEntities; override;
    function HasLineWeight: Boolean; override;
  public
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
  end;

  TsgDWGPolyline = class(TsgDXFPolyline)
  public
    constructor Create; override; {$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This class will be deleted in the next version. Please, use the following class - TsgDXFPolyline!'{$ENDIF};{$ENDIF}
  end;

  TsgDXFSplineProc = procedure(const P: TFPoint) of object;

  TsgDXFSpline = class(TsgCADBasePolyline)
  private
    FBeginningTangent: TFPoint;
    FControls: TFPointList;
    FDegree: Byte;
    FEndingTangent: TFPoint;
    FFit: TFPointList;
    FKnots: TsgDoubleList;
    FLen: Double;
    FWeights: TsgDoubleList;
    FFlagsExtented: Integer;
    FKnotTol: Double;
    FCtrlTol: Double;
    FFitTol: Double;
    function GetIsByAngles: Boolean;
    function GetControlPoint(Index: Integer): TFPoint;
    function GetFitPoint(Index: Integer): TFPoint;
    function GetKnot(const AIndex: Integer): Double;
    procedure SetKnot(const AIndex: Integer; const Value: Double);
    function GetWeight(const AIndex: Integer): Double;
    procedure SetWeight(const AIndex: Integer; const Value: Double);
  protected
    function HasPoint: Boolean; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure AddKnot(const X: Extended);
    function GetBeginningTangent: TFPoint;
    function GetEndingTangent: TFPoint;
    function GetEntType: TsgCADEntities; override;
    function GetDegree: Byte;
    //extented data
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure EndExtData(const AData: TsgCADExtendedData); override;

    procedure SetBeginningTangent(AValue: TFPoint);
    procedure SetEndingTangent(AValue: TFPoint);
    procedure SetDegree(const Value: Byte);
    procedure BuildSplineAsPoly;
    procedure BuildSplineByAngles(const ANumberOfParts: Integer);
    procedure GetSpline(const ANumberOfParts: Integer);
    function IsRational: Boolean;
    function IsPeriodic: Boolean;
    function IsPolyline: Boolean; virtual;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure ReloadPolyPoints(const AConverter: TsgDXFConverter); override;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property FlagsExtented: Integer read FFlagsExtented write FFlagsExtented;
  public
    constructor Create; override;
    procedure AddWeight(const W: Extended);
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function ControlCount: Integer;
    function FitCount: Integer;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    function KnotCount: Integer;
    function WeightCount: Integer;
    procedure GetPoints(Proc: TsgDXFSplineProc; XScale, YScale: Extended);
    property BeginningTangent: TFPoint read FBeginningTangent write FBeginningTangent;
    property ControlPoints [Index: Integer]: TFPoint read GetControlPoint;
    property Controls: TFPointList read FControls{ write FControls};
    property Degree: Byte read GetDegree write SetDegree;
    property EndingTangent: TFPoint read FEndingTangent write FEndingTangent;
    property FitPoints [Index: Integer]: TFPoint read GetFitPoint;
    property Fit: TFPointList read FFit;
    property IsByAngles: Boolean read GetIsByAngles;
    property Knot[const AIndex: Integer]: Double read GetKnot write SetKnot;
    property Knots: TsgDoubleList read FKnots;
    property Length: Double read FLen;
    property Weight[const AIndex: Integer]: Double read GetWeight write SetWeight;
    property Weights: TsgDoubleList read FWeights;
    property KnotTol: Double read FKnotTol write FKnotTol;
    property CtrlTol: Double read FCtrlTol write FCtrlTol;
    property FitTol: Double read FFitTol write FFitTol;
  end;

  TsgDXFCircle = class(TsgCADBasePolyline)
  private
    FRadius: TsgFloat;
  protected
    function GetEntType: TsgCADEntities; override;
    function GetRadius: TsgFloat;
    function GetClosed: Boolean; override;
    procedure SetClosed(const AClosed: Boolean); override;
    procedure SetRadius(AValue: TsgFloat);
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure GeneratePoints(AConverter: TsgDXFConverter);
    procedure Params(var A, B, AStart, AEnd, ASin, ACos: Double); virtual;
    procedure ReloadPolyPoints(const AConverter: TsgDXFConverter); override;
    function  CircleParamsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; virtual;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
    function GetArea: Double; override;
    function GetLength: Double; override;
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property Radius: TsgFloat read GetRadius write SetRadius;
    property Area: Double read GetArea;
    property Length: Double read GetLength;
  end;

  TsgDXFArc = class(TsgDXFCircle)
  private
    FEndAngle: TsgFloat;
    FStartAngle: TsgFloat;
    procedure SetArc(const AValue: TsgArcR);
    function RotPt(Angle: Extended): TFPoint;
  protected
    function GetArc: TsgArcR;
    function GetClosed: Boolean; override;
    function GetEndAngle: TsgFloat;
    function GetStartAngle: TsgFloat;
    function GetHeight: Double; virtual;
    function GetEndingPoint: TFPoint;
    function GetEntType: TsgCADEntities; override;
    function GetStartingPoint: TFPoint;
    procedure SetHeight(const AValue: Double);
    procedure SetEndAngle(AValue: TsgFloat);
    procedure SetStartAngle(AValue: TsgFloat);
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Params(var A, B, AStart, AEnd, ASin, ACos: Double); override;
    function  CircleParamsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
    function GetArea: Double; override;
    function GetLength: Double; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property EndAngle: TsgFloat read GetEndAngle write SetEndAngle;
    property EndPoint: TFPoint read GetEndingPoint;
    property StartAngle: TsgFloat read GetStartAngle write SetStartAngle;
    property StartPoint: TFPoint read GetStartingPoint;
    property Arc: TsgArcR read GetArc write SetArc;
  end;

  TsgDXFEllipse = class(TsgDXFArc)
  private
    FRadPt: TFPoint;
    FRatio: TsgFloat;
    function GetRadiuses(var AR1, AR2: Double): Boolean;
  protected
    FIsExtruded: Boolean;
    function GetAxisAngle: Double;
    function GetAxisAngleRad: Double;
    function GetRadPt: TFPoint;
    function GetRatio: TsgFloat;
    function GetEntType: TsgCADEntities; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Params(var A, B, AStart, AEnd, ASin, ACos: Double); override;
    procedure SetAxisAngle(const AAngle: Double);
    procedure SetAxisAngleRad(const AAngle: Double);
    procedure SetExtrusion(const Value: TFPoint); override;
    procedure SetRatio(AValue: TsgFloat);
    procedure SetRadPt(AValue: TFPoint);
    function CircleParamsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
    function GetArea: Double; override;
    function GetLength: Double; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property Angle: TsgFloat read GetAxisAngleRad;
    property EndPoint: TFPoint read GetRadPt write SetRadPt;
    property RadPt: TFPoint read GetRadPt write SetRadPt;
    property Ratio: TsgFloat read GetRatio write SetRatio;
  end;

  PsgHatchPatternData = ^TsgHatchPatternData;
  TsgHatchPatternData = record
    LineAngle: Double;
    BaseP: TFPoint;
    Offset: TFPoint;
    DashNum: Integer;
    Lines: TsgDoubleList;
    IsDash: Boolean;
  end;

  Tsg2DCurve = class(TsgListObject)
  private
    FOwner: TsgDXFEntity;//this boundary data
  protected
    procedure Assign(const AVal: Tsg2DCurve); virtual;
    procedure ClearPoints; virtual;
    function GetConverter: TsgDXFConverter;
    function GetCount: Integer; virtual;
    function GetEndPoint: TF2DPoint; virtual;
    function GetEdgeType: Byte; virtual;
    function GetPoints(const AIndex: Integer): TF2DPoint; virtual;
    function GetStartPoint: TF2DPoint; virtual;
    function IsImportMode: Boolean;
    procedure LoadedInt; virtual;
    procedure Reverse(ANeedLoad: Boolean); virtual;
    procedure SetOwner(const AValue: TsgDXFEntity);
    function FromXMLNode(const AType: TsgXMLType;
     const ANode: TsgNodeSample; const AIsChild: Boolean;
     const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    function IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean; virtual;
    procedure Loaded(const AOwner: TsgDXFEntity{ = nil});
    property Owner: TsgDXFEntity read FOwner write SetOwner;
    property EdgeType: Byte read GetEdgeType;
    property Count: Integer read GetCount;
    property EndPoint: TF2DPoint read GetEndPoint;
    property Points[const AIndex: Integer]: TF2DPoint read GetPoints;
    property StartPoint: TF2DPoint read GetStartPoint;
  end;

  Tsg2DLine = class(Tsg2DCurve)
  private
    FEndPoint: TF2DPoint;
    FStartPoint: TF2DPoint;
  protected
    procedure Assign(const AVal: Tsg2DCurve); override;
    function GetCount: Integer; override;
    function GetEdgeType: Byte; override;
    function GetEndPoint: TF2DPoint; override;
    function GetPoints(const AIndex: Integer): TF2DPoint; override;
    function GetStartPoint: TF2DPoint; override;
    procedure Reverse(ANeedLoad: Boolean); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
     const ANode: TsgNodeSample; const AIsChild: Boolean;
     const AResult: IsgResultNode = nil): Integer; override;
  public
    function IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean; override;
    procedure SetEndPoint(const AVal: TF2DPoint);
    procedure SetStartPoint(const AVal: TF2DPoint);
  end;

  Tsg2DPoints = class(Tsg2DCurve)//abstruct class by container FPoints
  private
    FPoints: TF2DPointList;
    function GetPointsCount: Integer;
  protected
    procedure Assign(const AVal: Tsg2DCurve); override;
    procedure ClearPoints; override;
    function GetCount: Integer; override;
    function GetEndPoint: TF2DPoint; override;
    function GetPoints(const AIndex: Integer): TF2DPoint; override;
    function GetStartPoint: TF2DPoint; override;
    procedure LoadedInt; override;
  public
    destructor Destroy; override;
  end;

  Tsg2DArc = class(Tsg2DPoints)
  private
    FCenterPoint: TF2DPoint;
    FEndParam: TsgFloat;
    FFlag: Byte;
    FRadius: TsgFloat;
    FStartParam: TsgFloat;
    procedure AngleParams(var AStartParam,AEndParam: Double);
    function GetCounterClockWise: Boolean;
    procedure SetCounterClockWise(const AVal: Boolean);
  protected
    procedure Assign(const AVal: Tsg2DCurve); override;
    function GetCount: Integer; override;
    function GetEdgeType: Byte; override;
    function GetNumberPartsOfCircle: Integer;
    function GetParamByAngle(const Angle: Double): Double; virtual;
    function GetArcRec(out AArcR: TsgArcR): Boolean; virtual;
    procedure LoadedInt; override;
    procedure Reverse(ANeedLoad: Boolean); override;
    procedure Params(var A, B, ASin, ACos: Double); virtual;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
     const ANode: TsgNodeSample; const AIsChild: Boolean;
     const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    function IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean; override;
    property CenterPoint: TF2DPoint read FCenterPoint write FCenterPoint;
    property CounterClockWise: Boolean read GetCounterClockWise write SetCounterClockWise;
    property EndParam: TsgFloat read FEndParam write FEndParam;
    property Radius: TsgFloat read FRadius write FRadius;
    property StartParam: TsgFloat read FStartParam write FStartParam;
  end;

  Tsg2DEllipse = class(Tsg2DArc)
  private
    FMajorPoint: TF2DPoint;
    function GetIsAngleInParam: Boolean;
    procedure SetIsAngleInParam(const AVal: Boolean);
  protected
    procedure Assign(const AVal: Tsg2DCurve); override;
    function GetEdgeType: Byte; override;
    function GetParamByAngle(const Angle: Double): Double; override;
    procedure Params(var A, B, ASin, ACos: Double); override;
    procedure Reverse(ANeedLoad: Boolean); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
     const ANode: TsgNodeSample; const AIsChild: Boolean;
     const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    function IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean; override;
    property IsAngleInParam: Boolean read GetIsAngleInParam write SetIsAngleInParam;
    property MajorPoint: TF2DPoint read FMajorPoint write FMajorPoint;
  end;

  Tsg2DPolyline = class(Tsg2DPoints)
  private
    FBulges: TsgSingleList;
    FProps: Byte;
    FVertexes: TF2DPointList;
    procedure ApplyBulge(const AP1, AP2: TF2DPoint; const ABulge: Double);
    function GetBulge(const AIndex: Integer): Single;
    function GetBulgesCount: Integer;
    function GetClosed: Boolean;
    function GetHasBulge: Boolean;
    function GetVertex(const AIndex: Integer): TF2DPoint;
    function GetVertexesCount: Integer;
    procedure SetBulge(const AIndex: Integer; const AVal: Single);
    procedure SetClosed(const AVal: Boolean);
    procedure SetVertex(const AIndex: Integer; const APoint: TF2DPoint);
  protected
    procedure Assign(const AVal: Tsg2DCurve); override;
    function GetEndPoint: TF2DPoint; override;
    function GetStartPoint: TF2DPoint; override;
    function GetEdgeType: Byte; override;
    procedure LoadedInt; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property Bulges[const AIndex: Integer]: Single read GetBulge write SetBulge;
    property Vertexes[const AIndex: Integer]: TF2DPoint read GetVertex write SetVertex;
    property BulgesCount: Integer read GetBulgesCount;
    property VertexesCount: Integer read GetVertexesCount;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Clear;
    procedure AddBulge(const AVal: Single);
    procedure AddVertex(const APoint: TF2DPoint);
    function GetLastVertex: PF2DPoint;
    function IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean; override;
    property Closed: Boolean read GetClosed write SetClosed;
    property HasBulge: Boolean read GetHasBulge;
  end;

  Tsg2DSpline = class(Tsg2DPoints)
  private
    FControls: TF2DPointList;
    FKnots: TsgDoubleList;
    FParams: Cardinal;
    FWeights: TsgDoubleList;
    function GetDegree: Byte;
    function GetKnot(const AIndex: Integer): Double;
    function GetPeriodic: Boolean;
    function GetRational: Boolean;
    function GetControl(const AIndex: Integer): TF2DPoint;
    function GetControlsCount: Integer;
    function GetKnotsCount: Integer;
    function GetWeight(const AIndex: Integer): Double;
    function GeWeightsCount: Integer;
    procedure SetControl(const AIndex: Integer; const APoint: TF2DPoint);
    procedure SetKnot(const AIndex: Integer; const AVal: Double);
    procedure SetDegree(const Value: Byte);
    procedure SetRational(const Value: Boolean);
    procedure SetPeriodic(const Value: Boolean);
    procedure SetWeight(const AIndex: Integer; const Value: Double);
  protected
    procedure Assign(const AVal: Tsg2DCurve); override;
    procedure LoadedInt; override;
    function GetEdgeType: Byte; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
     const ANode: TsgNodeSample; const AIsChild: Boolean;
     const AResult: IsgResultNode = nil): Integer; override;
    property Controls[const AIndex: Integer]: TF2DPoint read GetControl write SetControl;
    property Knots[const AIndex: Integer]: Double read GetKnot write SetKnot;
    property Weights[const AIndex: Integer]: Double read GetWeight write SetWeight;
    property ControlsCount: Integer read GetControlsCount;
    property KnotsCount: Integer read GetKnotsCount;
    property WeightsCount: Integer read GeWeightsCount;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AddControl(const APoint: TF2DPoint);
    procedure AddKnot(const AVal: Double);
    procedure AddWeight(const AVal: Double);
    function GetLastVertex: PF2DPoint;
    function IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean; override;
    property Degree: Byte read GetDegree write SetDegree;
    property Periodic: Boolean read GetPeriodic write SetPeriodic;
    property Rational: Boolean read GetRational write SetRational;
  end;

  Tsg2DBoundaryList = class(TsgListObject)
  private
    FBoundaryType: Byte;
    FObjects: TsgObjectList;
    function GetCount: Integer;
    function GetItem(const AIndex: Integer): Tsg2DCurve;
    procedure SetCount(const AValue: Integer);
    procedure SetItem(const AIndex: Integer; const AValue: Tsg2DCurve);
  protected
    function IsTextBox: Boolean;
    function ViewType(const ALine: PsgF2DLine = nil): Integer;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignBoundary(const AObject: TObject);
    procedure Add(const AValue: Tsg2DCurve);
    procedure Clear;
    procedure CopyFrom(const AList: Tsg2DBoundaryList;
      const AIndex, ACount: Integer);
    procedure Delete(const AIndex: Integer);
    procedure Insert(const AIndex: Integer; const AValue: Tsg2DCurve);
    function IsBoundaryEqual(const AList: Tsg2DBoundaryList): Boolean;
    property Count: Integer read GetCount write SetCount;
    property Items[const AIndex: Integer]: Tsg2DCurve read GetItem
      write SetItem; default;
    property BoundaryType: Byte read FBoundaryType write FBoundaryType;
  end;

  TsgCADPolyPolygon = class(TsgDXFObjectEntityLineType)
  private
    FBox: TFRect;
    FBoundaryPolylines: TsgObjectList;
  protected
    function ApplyAngle(const AngleRel: Double): Boolean; virtual;
    function ApplyScale(const AScaleRel: Double): Boolean; virtual;
    function CanDraw: Boolean; override;
    procedure CalcFMatrix; virtual;
    procedure ClearBoundaryData; virtual;
    procedure CloseBoundary; virtual;
    function BoxTransformation(AConverter: TsgDXFConverter; const ABox: TFRect): TFRect; virtual;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetBox: TFRect; override;
    function GetEntType: TsgCADEntities; override;
    function GetHatchName: string; virtual;
    function GetSolidFill: Boolean; virtual;
    function IsEmptykBox(const AConverter: TsgDXFConverter): Boolean; virtual;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure MakeBorderPolylines(AConverter: TsgDXFConverter); virtual;
    procedure ParseLines; virtual;
    procedure SetHatchName(const AHatchName: string); virtual;
    procedure SetSolidFill(const Value: Boolean); virtual;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; override;
    property Boundaries: TsgObjectList read FBoundaryPolylines;
    property HatchName: string read GetHatchName write SetHatchName;
    property SolidFill: Boolean read GetSolidFill write SetSolidFill;
  end;

  TsgCADGradientPolygon = class(TsgCADPolyPolygon)
  private
    FGradientColor: array[0..1] of TsgColorCAD;
    FGradientAngle: TsgFloat;
    FGradientUseCenter: Boolean;
  protected
    FType: TsgGradientType;
    function GetEntType: TsgCADEntities; override;
    function GetHatchName: string; override;
    function GetGradientName: string;
    function GetGradientAngle: TsgFloat;
    function GetGradientColor(const AIndex: Byte): TColor;
    function GetGradientColorCAD(const AIndex: Byte): TsgColorCAD;
    function IsEmptykBox(const AConverter: TsgDXFConverter): Boolean; override;
    procedure SetGradientAngle(const Value: TsgFloat);
    procedure SetGradientName(const AName: string);
    procedure SetGradientColorCAD(const AIndex: Byte; const Value: TsgColorCAD);
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property GradientAngle: TsgFloat read GetGradientAngle write SetGradientAngle;
    property GradientColor[const AIndex: Byte]: TColor read GetGradientColor;
    property GradientColorCAD[const AIndex: Byte]: TsgColorCAD
      read GetGradientColorCAD write SetGradientColorCAD;
    property GradientName: string read GetGradientName write SetGradientName;
    property GradientUseCenter: Boolean read FGradientUseCenter write FGradientUseCenter;
  end;

  TsgCADBoundaryData = class(TsgDXFEntity)
  private
    FParentEntity: TsgDXFEntity;
    FBoundaries: TsgObjectList;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;

    function CanUseBoundaryList(const AList: Tsg2DBoundaryList;
      const ASolidFill: Boolean): Boolean;
    function GenerateListOfBoundaries(const AObjects: TsgObjectList;
      AExplodePolyline: Boolean = False): TFRect;
    procedure MakeBorderPolylines(const AConverter: TsgDXFConverter;
      const ABoundaryPolylines: TsgObjectList; const ASolidFill: Boolean;
      AProgress: IsgProgress = nil);
    function GetConverter: TsgDXFConverter; override;
    function GetNodeName: string; override;
    function BoundaryToXMLNode(const ABoundary: Tsg2DBoundaryList;
      const ANode: TsgNode): Integer;
    function BoundaryToFromNode(const ABoundary: Tsg2DBoundaryList;
      const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer;
    procedure SetParentEntity(const AValue: TsgDXFEntity);
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
     const ANode: TsgNodeSample; const AIsChild: Boolean;
     const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function AddBoundaryList(const AFlags: Byte = 0): Tsg2DBoundaryList;
    procedure CopyBoundaries(const ABoundaryData: TsgCADBoundaryData);
    procedure ClearBoundaries(const AClearCapacity: Boolean = True);
    property Boundaries: TsgObjectList read FBoundaries;
    property ParentEntity: TsgDXFEntity read FParentEntity write SetParentEntity;
  end;

  TsgCADHatchPatternData = class(TsgDXFEntity)
  private
    FAngle: Double;
    FName: string;
    FScale: Double;
    FPatterns: TList;
    FConverter: TsgDXFConverter;
    procedure HatchLine(AList: TsgDoubleList; Pt1, Pt2, BasePt: TFPoint;
      DottedSingPts: TFPointList);
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;

    procedure ApplyAngle(const AngleRel: Double);
    procedure ApplyScale(const AScaleRel: Double);
    function ParseLines(const AParsedLines: TF2DPointList;
     const ABoundaryPolylines: TsgObjectList; const ABox: TFRect;
     const AHatchStyle: TsgHatchStyle): TsgHatchStyle;
    function GetNodeName: string; override;
    function HatchPatternDataToXMLNode(const AData: PsgHatchPatternData;
      const ANode: TsgNode): Integer;
    function HatchPatternDataFromToXMLNode(const AData: PsgHatchPatternData;
      const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function GetConverter: TsgDXFConverter; override;
    procedure SetConverter(const AConverter: TsgDXFConverter); override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function AddPatternData(const ABasePoint: TFPoint;
      const Angle: Double; const ASign: Integer): PsgHatchPatternData;
    procedure CopyPatterns(const APatterns: TsgCADHatchPatternData);
    procedure ClearPatterns(const AClearCapacity: Boolean = True);
    procedure DoAngle(const AValue: Double);
    procedure DoScale(const AValue: Double);
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property Angle: Double read FAngle write FAngle;
    property Name: string read FName write FName;
    property Scale: Double read FScale write FScale;
    property Patterns: TList read FPatterns;
  end;

  TsgCADCurvePolygon = class(TsgCADGradientPolygon)
  private
    FBoundaryData: TsgCADBoundaryData;
    FElevation: TFPoint;
    FExtrusion: TFPoint;
    FMatrix: TFMatrix;
    FTransparency: Single;
    function GetBoundaryData(const AIndex: Integer): Tsg2DBoundaryList;
    function GetBoundaryDataCount: Integer;
    function GetBoundaryDataLast: Tsg2DBoundaryList;
    procedure SetTransparency(const Value: Single);
  protected
    procedure CalcFMatrix; override;
    procedure CopyBoundaryData(const APolygon: TsgCADCurvePolygon);
    procedure ChechBoundaryData(const AHatch: TsgCADCurvePolygon);
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function BoxTransformation(AConverter: TsgDXFConverter; const ABox: TFRect): TFRect; override;
    function GenerateListOfBoundaries(const AList: TsgObjectList;
      AExplodePolyline: Boolean = False): TFRect;
    function GetElevation: TFPoint;
    function GetEntType: TsgCADEntities; override;
    function GetExtrusion: TFPoint; override;
    function GetFillColor: TsgColorCAD; virtual;
    function GetMatrix: TFMatrix;
    function GetOffset: TFPoint; virtual;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    function IsInvoke(AConverter: TsgDXFConverter): Boolean; override;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;
    procedure MakeBorderPolylines(AConverter: TsgDXFConverter); override;
    procedure MakeBorderPolylinesWithProgress(const AConverter: TsgDXFConverter;
      AProgress: IsgProgress = nil);
    function IsViewAsLine(const ALine: PsgLine = nil): Boolean;
    procedure RemoveIncorrectBoundaries(const ARemoveLine: Boolean);
    procedure SetElevation(const Value: TFPoint);
    procedure SetExtrusion(const Value: TFPoint); override;
    procedure SetFillColor(const Value: TsgColorCAD); virtual;
    procedure SetOffset(const Value: TFPoint); virtual;
    function UseMatrix: Boolean; virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;

    function InsertEntity(const AIndex: Integer;
      const AEntity: TsgDXFEntity): Boolean; override;

    procedure ClearBoundaryData; override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; override;
    function AddBoundaryList(const AFlags: Byte = 0): Tsg2DBoundaryList;
    property BoundaryData[const AIndex: Integer]: Tsg2DBoundaryList read GetBoundaryData;
    property BoundaryDataCount: Integer read GetBoundaryDataCount;
    property BoundaryDataLast: Tsg2DBoundaryList read GetBoundaryDataLast;
    property Elevation: TFPoint read GetElevation write SetElevation;
    property Extrusion: TFPoint read GetExtrusion write SetExtrusion;
    property FillColor: TsgColorCAD read GetFillColor write SetFillColor;
    property Transparency: Single read FTransparency write SetTransparency;//in %
    property Offset: TFPoint read GetOffset Write SetOffset;
  end;

  TsgCADHatch = class(TsgCADCurvePolygon)
  private
    FHatchPatternData: TsgCADHatchPatternData;
    FHatchStyles: Integer;
    // Ptt - pattern values
    FParsedLines: TF2DPointList;
    FLineWeight: Double;
    FDoubleHatch: Boolean;
    function GetHatchStyle: TsgHatchStyle;
    function GetHatchPatternData: TList;
    function GetDrawAsSolid: Boolean;
    function GetParseLineOnDraw: Boolean;
    procedure SetHatchStyle(const Value: TsgHatchStyle);
    procedure SetDrawOnSolid(const Value: Boolean);
    procedure SetParseLineOnDraw(const Value: Boolean);
  protected
    function AddPatternData(const ABasePoint: TFPoint;
      const Angle: Double; const ASign: Integer = 1): PsgHatchPatternData;
    procedure ApplyFillStyle(const AFillStyle: TsgFillStyle;
      const ABasePoint: TFPoint);
    function ApplyAngle(const AngleRel: Double): Boolean; override;
    function ApplyScale(const AScaleRel: Double): Boolean; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetEntType: TsgCADEntities; override;
    function GetFillStyle: TsgFillStyle;
    function GetHatchName: string; override;
    function GetLineWeight: Double; override;
    function GetPatternAngle: TsgFloat;
    function GetPatternScale: TsgFloat;
    function GetSolidFill: Boolean; override;
    function GetThicknessInt: Double; override;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;
    procedure ParseLines; override;
    procedure SetConverter(const AConverter: TsgDXFConverter); override;
    procedure SetFillStyle(const Value: TsgFillStyle);
    procedure SetFillStyleWithApplyStyle(const Value: TsgFillStyle);
    procedure SetHatchName(const AHatchName: string); override;
    procedure SetLineWeight(Value: Double); override;
    procedure SetPatternAngle(const AVal: TsgFloat);
    procedure SetPatternScale(const AVal: TsgFloat);
    procedure SetThicknessInt(const AValue: Double); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
    property PatternData: TsgCADHatchPatternData read FHatchPatternData;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;

    function InsertEntity(const AIndex: Integer;
      const AEntity: TsgDXFEntity): Boolean; override;

    //property HatchLines: TList read FHatchPatternData;
    procedure ClearHatchPatternData;
    procedure CopyHatchPatternData(const AHatch: TsgCADHatch);
    property DoubleHatch: Boolean read FDoubleHatch write FDoubleHatch;
    property DrawAsSolid: Boolean read GetDrawAsSolid write SetDrawOnSolid;
    property ParseLineOnDraw: Boolean read GetParseLineOnDraw write SetParseLineOnDraw;
    property FillStyle: TsgFillStyle read GetFillStyle write SetFillStyleWithApplyStyle;
    property HatchPatternData: TList read GetHatchPatternData;
    property HatchStyle: TsgHatchStyle read GetHatchStyle write SetHatchStyle;
    property ParsedLines: TF2DPointList read FParsedLines;
    property PatternAngle: TsgFloat read GetPatternAngle write SetPatternAngle;
    property PatternScale: TsgFloat read GetPatternScale write SetPatternScale;
  end;

  TsgCADMPolygon = class(TsgCADHatch)
  private
    FOffset: TF2DPoint;
    FFillColor: TsgColorCAD;
  protected
    procedure CalcFMatrix; override;
    function GetFillColor: TsgColorCAD; override;
    function GetEntType: TsgCADEntities; override;
    function GetOffset: TFPoint; override;
    function GetSolidFill: Boolean; override;
    procedure SetFillColor(const Value: TsgColorCAD); override;
    procedure SetOffset(const Value: TFPoint); override;
    procedure SetSolidFill(const Value: Boolean); override;
    function UseMatrix: Boolean; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
  end;  

  (*
  TsgDXFGradient = class(TsgCADCurvePolygon)
  private
    FPData1: TF2DPoint;
    FPData2: TF2DPoint;
    FRadius: Double;
    FGFlags: Byte;
    FColors: TList;
    FPositions: TList;
    FMatrix: PFMatrix;
  protected
    function GetAbsParam: Boolean;
    function GetEntType: TsgCADEntities; override;
    function GetHatchName: string; override;
    function GetPData1: TFPoint;
    function GetPData2: TFPoint;
    function GetRadius: Double;
    function GetTransform: TFMatrix;    
    procedure SetAbsParams(const Value: Boolean);
    procedure SetPData1(const Value: TFPoint);
    procedure SetPData2(const Value: TFPoint);
    procedure SetRadius(const Value: Double);
    procedure SetTransform(const Value: TFMatrix);
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function IsHorizontal: Boolean;
    function IsSpheric: Boolean;
    function IsVertical: Boolean;
    function HasMatrix: Boolean;
    property Colors: TList read FColors;
    property Positions: TList read FPositions;
    property AbsParams: Boolean Read GetAbsParam write SetAbsParams;
    property Point1: TFPoint read GetPData1 write SetPData1;
    property Point2: TFPoint read GetPData2 write SetPData2;
    property PointC: TFPoint read GetPData1 write SetPData1;
    property PointF: TFPoint read GetPData2 write SetPData2;
    property Radius: Double read GetRadius write SetRadius;
    property Transform: TFMatrix read GetTransform write SetTransform;
  end;
  *)
  TsgStyleFillUnits = (sfUserSpaceOnUse, sfObjectBoundingBox);
  TsgStyleGradSpreadMethod = (smPad, smReflect, smRepeat);

  TsgCADStyleFill = class
  private
    FFlags: Byte;
    FRef: TsgCADStyleFill;
    FTransform: PFMatrix;
    FValues: array [0..4] of Double;
  protected
    function GetLocal: Boolean;
    function GetTransform: TFMatrix;
    function GetUnits: TsgStyleFillUnits;
    function GetV0: Double;
    function GetV1: Double;
    function GetV2: Double;
    function GetV3: Double;
    function GetV4: Double;
    function GetPoint1: TFPoint;
    procedure SetLocal(const Value: Boolean);
    procedure SetRef(const Value: TsgCADStyleFill); virtual;
    procedure SetTransform(const Value: TFMatrix);
    procedure SetUnits(const Value: TsgStyleFillUnits);
    procedure SetV0(const Value: Double);
    procedure SetV1(const Value: Double);
    procedure SetV2(const Value: Double);
    procedure SetV3(const Value: Double);
    procedure SetV4(const Value: Double);
    procedure SetPoint1(const Value: TFPoint);    
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Assign(const AObj: TObject); virtual;
    procedure CheckParams; virtual;
    property Local: Boolean read GetLocal write SetLocal;
    property Units: TsgStyleFillUnits read GetUnits write SetUnits;
    property Transform: TFMatrix read GetTransform write SetTransform;
    property HRef: TsgCADStyleFill read FRef write SetRef;
    property X1: Double read GetV0 write SetV0;
    property Y1: Double read GetV1 write SetV1;
    property Point1: TFPoint read GetPoint1 write SetPoint1;
  end;
  
  TsgClassOfCADStyleFill = class of TsgCADStyleFill;

  TsgCADStyleGradient = class(TsgCADStyleFill)
  private
    FStops: TsgSingleList;
  protected
    function GetLinear: Boolean;
    function GetSpreadMethod: TsgStyleGradSpreadMethod;
    function GetStopsCount: Integer;
    function GetStopList: TsgSingleList;
    function GetPoint2: TFPoint;
    procedure SetLinear(const Value: Boolean);
    procedure SetRef(const Value: TsgCADStyleFill); override;
    procedure SetSpreadMethod(const Value: TsgStyleGradSpreadMethod);
    procedure SetPoint2(const Value: TFPoint);
  public
    destructor Destroy; override;
    procedure Assign(const AObj: TObject); override;
    procedure AddStops(const AColor: Integer; const AOffset: Double);
    procedure CheckParams; override;
    procedure GetPositionColors(const APos: TsgSingleList;
      const AColor: TsgIntegerList);
    function HasStops: Boolean;
    property SpreadMethod: TsgStyleGradSpreadMethod read GetSpreadMethod write SetSpreadMethod;
    property Linear: Boolean read GetLinear write SetLinear;
    property X2: Double read GetV2 write SetV2;
    property Y2: Double read GetV3 write SetV3;
    property CX: Double read GetV0 write SetV0;
    property CY: Double read GetV1 write SetV1;
    property FX: Double read GetV2 write SetV2;
    property FY: Double read GetV3 write SetV3;
    property R: Double read GetV4 write SetV4;

    property Point2: TFPoint read GetPoint2 write SetPoint2;
    property PointC: TFPoint read GetPoint1 write SetPoint1;
    property PointF: TFPoint read GetPoint2 write SetPoint2;
  end;

  TsgCADStylePattern = class(TsgCADStyleFill)
  private
    FBox: TFRect;
    FEntities: TList;
    FViewBox: PsgViewBox;
    function GetCount: Integer;
    function GetEntity(const AIndex: Integer): TsgDXFENtity;
  protected
    function GetContainerSize: TFRect;
    function GetContainerBox: TFRect;
//    function GetContainerByHatch: TList;
    function GetContentUnits: TsgStyleFillUnits;
    function GetSize: TFPoint;
    function GetViewBox: TsgViewBox;
    procedure SetContentUnits(const Value: TsgStyleFillUnits);
    procedure SetRef(const Value: TsgCADStyleFill); override;
    procedure SetSize(const Value: TFPoint);
    procedure SetViewBox(const Value: TsgViewBox);
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(const AObj: TObject); override;
    procedure AddEntity(const AEntity: TsgDXFEntity);
    procedure CheckParams; override;
    procedure Iterate(AConverter: TsgDXFConverter;  Proc, FinishProc: TsgCADEntityProc);
    procedure Loaded(const AConverter: TsgDXFConverter);
    property Box: TFRect read FBox;
    property ContentUnits: TsgStyleFillUnits read GetContentUnits write SetContentUnits;
    property Count: Integer read GetCount;
    property ContainerBox: TFRect read GetContainerBox;
    property ContainerSize: TFRect read GetContainerSize;
    property Entities[const AIndex: Integer]: TsgDXFEntity read GetEntity; default;
    property Width: Double read GetV2 write SetV2;
    property Height: Double read GetV3 write SetV3;
    property ViewBox: TsgViewBox read GetViewBox write SetViewBox;
    property Size: TFPoint read GetSize write SetSize;
  end;

  TsgCADFill = class(TsgCADCurvePolygon)
  private
    FCADFillFlags: Byte;
    FStyleFill: TsgCADStyleFill;
    FImage: TBitmap;
    function GetStyleFill: TsgCADStyleFill;
    function GetBackground: TColor;
    function GetUseBuffer: Boolean;
    procedure SetStyleFill(const Value: TsgCADStyleFill);
    procedure SetUseBuffer(const Value: Boolean);
    function CreateInsertAndBlock(const AImg: TObject): TsgDXFInsert;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetBush(const W, H: Integer; AClass: TClass): TBitmap;
    function GroupExists: Boolean; override;
    function GroupFill(AConverter: TsgDXFConverter = nil): Boolean; override;
    function GroupHasAddedEntities: Boolean; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetBackgroundColor(const ABmp: TBitmap);
    procedure SetTransparentColor(const ABmp: TBitmap);
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function CreateBMPFill(const AMatrix: TFMatrix; const AClass: TClass): Boolean;
    function CreateBMPPattern(AWidth, AHeight: Integer; const AClass: TClass): TBitmap;
    function ConvertToImageEnt(const AConverter: TsgDXFConverter): TsgDXFImageEnt;
    property Background: TColor read GetBackground;
    property BMPImage: TBitmap read FImage;
    property StyleFill: TsgCADStyleFill read GetStyleFill write SetStyleFill;
    property UseBuffer: Boolean read GetUseBuffer write SetUseBuffer;
  end;

  TsgDXFTable = class(TsgDXFGroup)
  protected
    function AddItem(const AItem: TObject): Integer; override;
    procedure UpdateBox; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;

    function GetName: string; override;
    function GetLinkClass: TsgOwneredItemClass; override;
    function GetNamedItem: TObject; override;
    function GetOwner: TsgDXFEntity; override;
    procedure SetName(const AName: string); override;
    procedure SetOwner(const Value: TsgDXFEntity); override;

    function GetComplex: Boolean; override;
    function DeleteItem(const AItem: TObject): Integer; override;

    procedure Link(AConverter: TsgDXFConverter); override;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;

    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function FindEntByName(const AName: string): TsgDXFEntity; override;
    function FindChildByHandle(const AHandle: UInt64; ADeep: Integer = 0): TsgDXFEntity; override;
    function FindEntByDescription(const ADescription: string): TsgDXFEntity; override;
    // functions of IsgListOfEntities
    procedure Clear(const ADoFree: Boolean = True); override;
    function EntName: string; override;
  end;

  TsgDXFBlockRecords = class(TsgDXFTable)
  private
    FBlocks: TsgDXFGroup;
    function GetBlocks: TsgDXFGroup;
    procedure SetBlocks(const Value: TsgDXFGroup);
  protected
    function GetLinkClass: TsgOwneredItemClass; override;
    function GetName: string; override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    property Blocks: TsgDXFGroup read GetBlocks write SetBlocks;
  public
    constructor Create; override;
    function AddEntity(const AEntity: TsgDXFEntity): Integer; override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure ExchangeEntity(AIndex1, AIndex2: Integer); override;
    function GetCount: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;

    function IndexOfName(const AName: string): Integer; override;
  end;

  TsgDXFBlock = class(TsgDXFGroupEntity)
  private
    FBlockRecord: TsgDXFBlockRecord;
//    FFlags: Integer;
    FOffset: TFPoint;
    FReferences: TsgList;
    FXref: TsgDXFXref;
    FXrefPath: string;
    FLayout: TsgDXFEntity;
    function IterateEx(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc): TList;
    procedure AddFromXrefPath(AConverter: TsgDXFConverter);
    procedure CheckAttdefFlag;
//    procedure CheckSpecPaperSpaceName;
    function GetBlockRecord: TsgDXFBlockRecord;
    function GetLoaded: Boolean;
    function GetReferences: TsgList;
{$IFDEF SG_VERSION_OLD}
    function GetSpecPaperSpace: Boolean;{$IFDEF SGDEL_6} deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version. Please, use the following property - Layout!'{$ENDIF};{$ENDIF}
{$ENDIF}
    procedure SetLoaded(const Value: Boolean);
    //procedure SetSpecPaperSpace(const Value: Boolean);
    function GetLayout: TsgDXFEntity;
    procedure SetLayout(const Value: TsgDXFEntity);
    procedure SetViewPortProperty(const AViewPort: TsgDXFViewPort;
      const APaperSpaceBlock: Boolean);
  protected
    FViewPortOrdIndex: Integer;
    FViewPortWithMinIndex: TsgDXFViewPort;
    FRegenFlags: Integer;
    function GetComplex: Boolean; override;
    function GetDescription: string; override;
    function GetLinkClass: TsgOwneredItemClass; override;
    function GetName: string; override;
    function GetNamedItem: TObject; override;
    function GetOwner: TsgDXFEntity; override;
    function GetXrefPath: string;
    procedure UpdateBox; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;
    procedure SetBoxInternal(const ABox: TFRect);//for internal using
    procedure SetDescription(const AValue: string); override;
    procedure SetName(const AName: string); override;
    procedure SetOwner(const AValue: TsgDXFEntity); override;
    procedure SetXrefPath(const Value: string);
{$IFDEF SG_BTI}
    function GetExtendedData: TObject; virtual;
    function GetExtendedLayer: string; virtual;
{$ENDIF}
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    // functions of IsgListOfEntities
    function AddEntity(const AEntity: TsgDXFEntity): Integer; override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function EntName: string; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
    property BlockRecord: TsgDXFBlockRecord read GetBlockRecord;
    function IsBlockIntetnal: Boolean;
    function IsBlockByXRef: Boolean;
    function IsBlockXrefOverlay: Boolean;
    function IsAcadTableBlock: Boolean;
    function IsModalSpaceBlock: Boolean;
    property IsLoaded: Boolean read GetLoaded write SetLoaded;// not documented, only for internal using (!)
    property Offset: TFPoint read FOffset write FOffset;
    property References: TsgList read GetReferences;
{$IFDEF SG_VERSION_OLD}
    property SpecPaperSpace: Boolean read GetSpecPaperSpace;  // not documented, only for internal using (!)
{$ENDIF}
    property Layout: TsgDXFEntity read GetLayout write SetLayout;
    property Xref: TsgDXFXRef read FXref;
    property XrefPath: string read GetXrefPath write SetXrefPath;
  end;

  TsgDXFSection = class(TsgDXFTable)
  protected
    function GetHandle: UInt64; override;
    procedure SetHandle(const Value: UInt64); override;
    procedure ChangeHandle(AConverter: TsgDXFConverter); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    function IsTablesBelongSection(ATable: TConvSection): Boolean; virtual;
  end;

  TsgDXFSectionTables = class(TsgDXFSection)
  protected
    function IsTablesBelongSection(ATable: TConvSection): Boolean; override;
  public
    constructor Create; override;
  end;

  TsgDXFSectionObjects = class(TsgDXFSection)
  protected
    function IsTablesBelongSection(ATable: TConvSection): Boolean; override;
  public
    constructor Create; override;
  end;

  TsgDXFSectionBlocks = class(TsgDXFSection)
  protected
    function AddItem(const AItem: TObject): Integer; override;
    function DeleteItem(const AItem: TObject): Integer; override;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;
  public
    constructor Create; override;
    function FindEntByName(const AName: string): TsgDXFEntity; override;
  end;

  TsgDXFSectionForXMLExport = class(TsgDXFSection)
  protected
    function AddItem(const AItem: TObject): Integer; override;
    function DeleteItem(const AItem: TObject): Integer; override;
    procedure Link(AConverter: TsgDXFConverter); override;
  public
    constructor CreateByConverter(const AConverter: TsgDXFConverter); virtual;
    function FindEntByName(const AName: string): TsgDXFEntity; override;
  end;

  TsgDXFSectionForXMLExportClass = class of TsgDXFSectionForXMLExport;

  TsgDXFSectionHeader = class(TsgDXFSectionForXMLExport)
  private
    FAccess: TsgDXFEntitySample;
  protected
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    class function ToXMLNodeDimProps(const AProps: TsgDimStyle;
      const ANode: TsgNode; const AParams: TsgXMLParams;
      const AInit: TsgDimNameVals = []): Integer;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    class function FromXMLNodeDimProps(var AProps: TsgDimStyle;
      const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer;
  public
    constructor CreateByConverter(const AConverter: TsgDXFConverter); override;
    destructor Destroy; override;
    function GetPHeadVarStruct(const AGetDefault: Boolean = True): PsgHeadVarStruct;
  end;

  TsgDXFSectionEntities = class(TsgDXFSectionForXMLExport)
  private
    function GetEntities: TsgDXFEntity;
  public
    constructor CreateByConverter(const AConverter: TsgDXFConverter); override;
    function FromXML(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer; override;
    function ToXMLWithParams(const AParentNode: TsgNode;
      const AParams: TsgXMLParams): TsgNode; override;
  end;

  TsgDXFInsert = class(TsgDXFCustomVertex, IsgVisibleObjectByPath)
  private
    // For 3d visulization
    FVisualization: TObject;
    //
    FAttribs: TsgEntitiesList;
    FBlockRecord: TsgDXFBlockRecord;
    FExtrusion: TFPoint;
    FLineWeight: Double;
    FOwnerInsert: TsgDXFInsert;
    FSceneElement: Integer;
    function GetBlock: TsgDXFBlock;
    function GetDelayedLoadAttribs: Boolean;
    procedure SetDelayedLoadAttribs(const Value: Boolean);
    procedure LinkBlockRecord(AConverter: TsgDXFConverter);
    function GetAttribs: TsgEntitiesList;
    procedure DoBlockLoad(const AConverter: TsgDXFConverter; const ABlock: TsgDXFBlock);
  protected
    FAngle: Double;
    FBox: TFRect;
    FMatrix: TFMatrix;
    FScale: TFPoint;

    function CanShow: Boolean; override;
    function GetVisibleRepresentation(const AKey: UInt64): Boolean; override;
    procedure SetVisibleRepresentation(const AKey: UInt64; const AValue: Boolean); override;
    function GetAlphaBlendRepresentation(const AKey: UInt64): Integer; override;
    procedure SetAlphaBlendRepresentation(const AKey: UInt64; const AValue: Integer); override;
    function GetCustomColorRepresentation(const AKey: UInt64): Cardinal; override;
    procedure SetCustomColorRepresentation(const AKey: UInt64; const AValue: Cardinal); override;
    //IsgVisibleObjectByPath
    procedure GetSetVisibleRepresentation(const AKey: UInt64; var AValue: Boolean;
      const AIsGet: Boolean = True);
    function GetArea(const AKey: UInt64): Double;
    function GetBox3D(const AKey: UInt64): TFRect;
    function GetAlphaBlend(const AKey: UInt64): Integer;
    procedure SetAlphaBlend(const AKey: UInt64; const AValue: Integer);
    function GetCustomColor(const AKey: UInt64): Cardinal;
    procedure SetCustomColor(const AKey: UInt64; const AValue: Cardinal);
    procedure NormalizeVisibilityTree;

    function CanAddedToXMLParams: Boolean; override;
    procedure AssignAttrib(Dest, Source: TsgDXFEntity); virtual;
    procedure CalculateMatrix;
    function CheckBlock(AConverter: TsgDXFConverter): Boolean;
    procedure ClearAttribs(const ADoFree: Boolean = True);
    procedure ClearReferences; override;
    procedure CopyItems(const ASource: TsgDXFEntity); virtual;
    procedure FreeReferences; override;
    function DoClearReferences(var AConv: TsgDXFConverter;
      var ABlock: TsgDXFBlock): Boolean;
    class function FreeBlockInternal(const AConv: TsgDXFConverter;
      const ABlock: TsgDXFBlock): Boolean;
    procedure DoDelayedLoad(AConverter: TsgDXFConverter); virtual;
    function DoSetBlockAfter(const ASetBlock: TsgDXFBlock): Integer; virtual;
    function DoSetBlockBefore(const ASetBlock: TsgDXFBlock): Integer; virtual;
    function IndexAttribOfName(const AName: string; const AMode: Integer = 0): Integer;
    function GetAngle: Double; virtual;
    function GetActualBlockRecord: TsgDXFBlockRecord; virtual;
    function GetBlockOffset: TFPoint; virtual;
    function GetBox: TFRect; override;
    function GetCount: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    function GetEntType: TsgCADEntities; override;
    function GetHasAttribs: Boolean;
    function GetNameOfBlockPattern: string; virtual;//by inspector
{$IFDEF SG_BTI}
    function GetArcOfCenter: TsgArcR; virtual;
    function GetExtendedBlockData: TsgExtendedBlockData; virtual;
    function GetOwnerConstruction: TsgDXFEntity; virtual;
    procedure GetArcsParams(var Arcs: TsgArcsParams); virtual;
    function GetBoundariesPoints(const AList: TsgObjectList;
      AConverter: TsgDXFConverter = nil): Integer;
    function __GetBoundariesPointsInternal(const AList: TsgObjectList;
      AConverter: TsgDXFConverter = nil): Integer; virtual;
    procedure GetPts(var APts: TsgPoints4); virtual;
    procedure GetPtsEx(const AList: TFPointList); virtual;
    function GetSelectedIndex: Integer; virtual;
    function GetMarkControlPoints: Integer; virtual;
    function GetVertexModeInsp: Boolean; virtual;
    function IsDraw: Boolean; virtual;
    function IsRealCircular: Boolean; virtual;
    function BlockIsPattern(const ABlock: TsgDXFBlock): Boolean; virtual;
    procedure SetSelectedIndex(const AIndex: Integer); virtual;
    function SetBtiProps(const AID: Integer; const AValue: Pointer): Integer; virtual;
{$ENDIF}
    function BTIDataToXMLNode(const ANode: TsgNode;
      const AParams: TsgXMLParams): Integer; virtual;
    function BTIDataFromXMLNode(const ANode: TsgNode;
      const AResult: IsgResultNode = nil): Integer; virtual;
    function GetExtrusion: TFPoint; override;
    function GetLineWeight: Double; override;
    function GetName: string; override;
    function GetNodeName: string; override;
    function GetScale: TFPoint;
    class function GetXMLNameOfSceneElement: string;
    procedure InitializeMatrix; virtual;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    function Is3dObject: Integer; override;
    procedure OffsetAttribs(const ADelta: TFPoint);
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;
    procedure ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord); virtual;
    procedure ReloadAttribs(AConverter: TsgDXFConverter);
    procedure Resolve(AConverter: TsgDXFConverter);
    procedure RemoveReferenceNotification(const ARefObj: TsgDXFEntity); override;
    procedure SetAngle(const Value: Double); virtual;
    procedure SetBlock(const Value: TsgDXFBlock);
    procedure SetBlockRecord(const Value: TsgDXFBlockRecord); virtual;
    procedure SetExtrusion(const Value: TFPoint); override;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;
    procedure SetLineWeight(Value: Double); override;
    procedure SetPoint(AValue: TFPoint); override;
    procedure SetPointAndMoveAttribs(const AValue: TFPoint; const AMoveAttribs: Boolean);
    procedure SetScale(const Value: TFPoint); virtual;
    procedure SetOwnerInsert(const AValue: TsgDXFInsert);
    function ToXMLGeoData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function IsUsedInKeyConstruction: Boolean; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
    function SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
      const AType: TsgPlcType; const AValue: Variant): Integer;  override;
{$ENDIF}
    property DelayedLoadAttribs: Boolean read GetDelayedLoadAttribs
      write SetDelayedLoadAttribs;
    property Visualization: TObject read FVisualization write FVisualization;
    property SceneElement: Integer read FSceneElement write FSceneElement;//for internal using
  public
    constructor Create; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function Attrib(const S: string; var P: TFPoint): TsgDXFAttrib;
    procedure Clear(const ADoFree: Boolean = True); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function EntName: string; override;
    function BoxForLayout(ALayout: TsgDXFLayout; AConv: TsgDXFConverter): TFRect; override;
    function FindBlock(AConverter: TsgDXFConverter; const AName: string): TsgDXFBlock;
    function GetMatrix: TFMatrix;
    function ExtractParamsFromMatrix2D(var P, S: TFPoint; var A: Double): Boolean;
    function IsInsert: Boolean; override; //evg
    function IsOnePixelOptimisationValid: Boolean; override; //evg
    function RealColor(AColor: TColor): TColor;
    function RealLayer: TsgDXFLayer;
    property Angle: Double read GetAngle write SetAngle;
    property Attribs: TsgEntitiesList read GetAttribs;
    property Block: TsgDXFBlock read GetBlock write SetBlock;
    property BlockRecord: TsgDXFBlockRecord read FBlockRecord write SetBlockRecord;
    property Extrusion: TFPoint read GetExtrusion write SetExtrusion;
    property HasAttribs: Boolean read GetHasAttribs;
    property Scale: TFPoint read GetScale write SetScale;
    property OwnerInsert: TsgDXFInsert read FOwnerInsert;
  end;

  TsgCADCustomApplicationBlockReference = class(TsgDXFInsert)
  private
    procedure ViewportDestroing(Sender: TObject);
  protected
    procedure ClearReferences; override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
  end;

  TsgCADAcIdBlockReference = class(TsgCADCustomApplicationBlockReference)
  end;

  TsgCADAcDbViewRepBlockReference = class(TsgCADCustomApplicationBlockReference)
  end;

  TsgDXFInsertXRef = class(TsgDXFInsert)
  private
    FNameFile: string;
    FOwner: TsgDXFEntity;
    FRealInsert: TsgDXFInsert;
  protected
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
  public
    property RealInsert: TsgDXFInsert read FRealInsert;
    property Owner: TsgDXFEntity read FOwner write FOwner;
  end;

  TsgCADClipInsert = class(TsgDXFInsert)
  private
  protected
    FClipBox: TFRect;
    function GetBox: TFRect; override;
    function GetClipBox: TFRect;
    procedure SetClipBox(const Value: TFRect);
    procedure SetPoint(AValue: TFPoint); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property ClipBox: TFRect read GetClipBox write SetClipBox;
  end;

  TsgCADMInsert = class(TsgDXFInsert)
  private
    FNumCols: Word;
    FNumRows: Word;
    FColSpacing: Double;
    FRowSpacing: Double;
  protected
    function GetBox: TFRect; override;
    function GetColSpacing: Double;
    function GetNumCols: Integer;
    function GetNumRows: Integer;
    function GetRowSpacing: Double;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    procedure SetColSpacing(const Value: Double);
    procedure SetNumCols(const Value: Integer);
    procedure SetNumRows(const Value: Integer);
    procedure SetRowSpacing(const Value: Double);
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property NumCols: Integer read GetNumCols write SetNumCols;
    property NumRows: Integer read GetNumRows write SetNumRows;
    property ColSpacing: Double read GetColSpacing write SetColSpacing;
    property RowSpacing: Double read GetRowSpacing write SetRowSpacing;
  end;

  TsgMLineEntry = class(TsgDXFEntity)
  private
    FColor: TsgColorCAD;
    FLineTypeItem: TsgTableItem;
    FOffset: Double;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetColorCAD: TsgColorCAD; override;
    procedure SetColorCAD(const Value: TsgColorCAD); override;
    function GetLineType: TsgDXFLineType; override;
    procedure SetLineType(const AValue: TsgDXFLineType); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    property Offset: Double read FOffset write FOffset;
  end;

  TsgMLineStyle = class(TsgDXFCustomColor)
  private
    FEntries: TsgEntitiesList;
    function GetEntry(Index: Integer): TsgMLineEntry;
  protected
    procedure FreeReferences; override;
    function GetCount: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure NewEntry(AOffset: Double; AColor: TsgColorCAD; ALType: TsgDXFLineType);
    property Entries[Index: Integer]: TsgMLineEntry read GetEntry; default;
  end;

  TsgMVertex = class(TsgDXFEntity)
  private
    FPoint: TFPoint;
    FDirection: TFPoint;
    FMiter: TFPoint;
    FParams: TsgObjectList;
    function GetPCount(Index: Integer): Integer;
    function GetParam(I1,I2: Integer): Single;
    function GetParamsCount: Integer;
    procedure SetParam(I1,I2: Integer; Value: Single);
    function GetParamsList: TsgObjectList;
    procedure SetDirection(const AValue: TFPoint);
    procedure SetMiter(const AValue: TFPoint);
    procedure SetPoint(const AValue: TFPoint);
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    property ParamsList: TsgObjectList read GetParamsList;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure Add(Value: Single);
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Complete;
    function NewList: TsgSingleList;
    property Point: TFPoint read FPoint write SetPoint;
    property Direction: TFPoint read FDirection write SetDirection;
    property Miter: TFPoint read FMiter write SetMiter;
    property ParamsCount: Integer read GetParamsCount;
    property PCounts[Index: Integer]: Integer read GetPCount;
    property Params[I1,I2: Integer]: Single read GetParam write SetParam; default;
  end;

  TsgCADMLine = class(TsgDXFInsert)
  private
    FFlags: Integer;
    FJustify: Byte;
    FItems: TsgEntitiesList;
    FStyle: TsgMLineStyle;
    FScaleFactor: Double;
    FStartPoint: TFPoint;
    function GetItem(Index: Integer): TsgMVertex;
    procedure SetFill;
  protected
    procedure CopyItems(const ASource: TsgDXFEntity); override;
    procedure FreeReferences; override;
    function GetItemsCount: Integer;
    function GetCount: Integer; override;
    function GetEntType: TsgCADEntities; override;
    function GetJustify: Byte;
    function GetScaleFactor: Double;
    function GetStyle: TsgMLineStyle;
    function GetFlags: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord); override;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;
    procedure SetJustify(const Value: Byte);
    procedure SetPoint(AValue: TFPoint); override;
    procedure SetScaleFactor(const Value: Double);
    procedure SetStyle(const Value: TsgMLineStyle);
    procedure SetFlags(const Value: Integer); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function ToXMLGeoData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList; AProgID: TsgProgID); override;
    property Style: TsgMLineStyle read GetStyle write SetStyle;
    property ScaleFactor: Double read GetScaleFactor write SetScaleFactor;
    property StartPoint: TFPoint read FStartPoint write FStartPoint;
    property Justify: Byte read GetJustify write SetJustify;
    property Items[Index: Integer]: TsgMVertex read GetItem; default;
    property ItemsCount: Integer read GetItemsCount;
  end;

  TsgCADHelix = class(TsgDXFSpline)
  private
    FStart: TFPoint;
    FRadius: Double;
    FTurns: Double;
    FTurnHeight: Double;
    FClockwise: Boolean;
    FQuality: Integer;
    procedure SetQuality(const Value: Integer);
  protected
    function GetEntType: TsgCADEntities; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property Quality: Integer read FQuality write SetQuality;//for internal using
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property Start: TFPoint read FStart write FStart;
    property Radius: Double read FRadius write FRadius;
    property Turns: Double read FTurns write FTurns;
    property TurnHeight: Double read FTurnHeight write FTurnHeight;
    property Clockwise: Boolean read FClockwise write FClockwise;
  end;

  TsgDXFField = class(TsgDXFOwneredItem)
  private
    FCache: TsgCADExtendedData;
    FChildFields: TList;
    FDataSet: TsgCADExtendedData;
    FEvaluatorID: string;
    FExpression: string;
    FFieldCode: string;
    FFormat2Digits: Boolean;
    FObjectIDs: TsgInt64List;
    FOverflowFieldCode: string;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure GenerateFieldCode;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    property Expression: string read FExpression write FExpression;
    property Format2Digits: Boolean read FFormat2Digits write FFormat2Digits;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function EntName: string; override;
    property ChildFields: TList read FChildFields;
    property Cache: TsgCADExtendedData read FCache;
    property DataSet: TsgCADExtendedData read FDataSet;
    property EvaluatorID: string read FEvaluatorID write FEvaluatorID;
    property FieldCode: string read FFieldCode write FFieldCode;
    property ObjectIDs: TsgInt64List read FObjectIDs;
    property OverflowFieldCode: string read FOverflowFieldCode
      write FOverflowFieldCode;
  end;

  TsgDXFDictionary = class(TsgDXFTable)
  protected
    function GetValue: string; virtual;
    procedure SetValue(const AValue: string); virtual;
  public
    property Value: string read GetValue write SetValue;
    function Item(Index: Variant): TsgDXFEntity;
  end;

  TsgDXFXRecord = class(TsgDXFOwneredItem)
  private
    FData: TsgCADExtendedData;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
    property Data: TsgCADExtendedData read FData write SetExtData;
  end;

  TsgDXFDictionaryVar = class(TsgDXFOwneredItem)
  private
    FIntVal: Integer;
    FValue: string;
  protected
    function GetValue: string;
    procedure SetValue(const AValue: string);
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function EntName: string; override;
    property IntVal: Integer read FIntVal write FIntVal;
    property Value: string read GetValue write SetValue;
  end;

  TsgCADWipeoutVariables = class(TsgDXFOwneredItem)
  private
    FDisplayImageFrame: Boolean;
  public
    constructor Create; override;
    property DisplayImageFrame: Boolean read FDisplayImageFrame write FDisplayImageFrame;
  end;

  TsgCADRasterVariables = class(TsgCADWipeoutVariables)
  private
    FImageDisplayQuality: Boolean;
    FUnitsForInsertingImages: Integer;
  public
    constructor Create; override;
    property ImageDisplayQuality: Boolean read FImageDisplayQuality write FImageDisplayQuality;
    property UnitsForInsertingImages: Integer read FUnitsForInsertingImages write FUnitsForInsertingImages;
  end;

  TsgCADDataLink = class(TsgDXFOwneredItem)
  private
    FFileName: string;
  public
    constructor Create; override;
    property FileName: string read FFileName write FFileName;
  end;

  TsgDXFFieldList = class(TsgDXFDictionary)
  protected
    procedure ListNotify(const Obj: TObject; Action: TListNotification); override;
  end;

  TsgDXFDimension = class(TsgDXFInsert)
  private
    FArcDefPoint: TFPoint;
    FAssociated: TsgDXFEntity;
    FDefPoint: TFPoint;
    FDimRot: Double;
    FDimStyleItem: TsgTableItem;
    FFlags: Integer;
    FLinDefPoint1: TFPoint;
    FLinDefPoint2: TFPoint;
    FMiddlePoint: TFPoint;
    FRadDefPoint: TFPoint;
    FTextOverride: string;
    FTextRotation: Double;
    FPropertiesItem: TsgTableItem;
    procedure ApplyElevation;
    function GetActualDimStyle: TsgDXFDimensionStyle;
    function GetInternalBlockName(const AConverter: TsgDXFConverter): string;
    function GetDimBlockName(const AConv: TsgDXFConverter; const APrefix: string): string;
    function GetProperties: TsgDXFDimensionStyle;
    function GetDimType: TsgDimensionType;
    function GetElevation: Double;
    procedure SetElevation(const Value: Double);
  protected
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure CreateBlock(const AConverter: TsgDXFConverter);
    procedure EndExtData(const AData: TsgCADExtendedData); override;
    function GetArcDefPoint: TFPoint;
    function GetArrowSize: TsgFloat;
    function GetArrowType: Byte;
    function GetArrowType1: Byte;
    function GetArrowType2: Byte;
    function GetArrowTypeL: Byte;
    function GetBlockOffset: TFPoint; override;
    function GetEntText: TsgDXFEntity;
    procedure GenerateBlock(const AConverter: TsgDXFConverter);
    function GetDefPoint: TFPoint;
    function GetDimStyleInternal: Pointer; override;
    function GetTextStyleInternal: Pointer; override;
    function GetDimArrowType1: TsgDimArrowType;
    function GetDimArrowType2: TsgDimArrowType;
    function GetDIMBLK: TsgDXFBlock;
    function GetDIMBLK1: TsgDXFBlock;
    function GetDIMBLK2: TsgDXFBlock;
    function GetDIMLDRBLK: TsgDXFBlock;
    function GetDIMBLKT: TsgDimArrowType;
    function GetDIMBLK1T: TsgDimArrowType;
    function GetDIMBLK2T: TsgDimArrowType;
    function GetDIMLDRBLKT: TsgDimArrowType;
    function GetDIMSAH: Boolean;
    function GetDIMSD1: Boolean;
    function GetDIMSD2: Boolean;
    function GetDIMSE1: Boolean;
    function GetDIMSE2: Boolean;
    function GetDIMTIH: Boolean;
    function GetDIMTOH: Boolean;
    function GetDIMCLRD: TsgColorCAD;
    function GetDIMCLRE: TsgColorCAD;
    function GetDIMCLRT: TsgColorCAD;
    function GetDIMLWD: TsgFloat;
    function GetDIMLWE: TsgFloat;
    function GetDIMDSEP: Char;
    function GetDIMLUNIT: TsgDimLimitUnits;
    function GetExtLineExt: TsgFloat;
    function GetExtLineOffset: TsgFloat;
    function GetStyle: TsgDXFDimensionStyle;
    function GetEntType: TsgCADEntities; override;
    function GetForceText: Integer;
    function GetLinDefPoint1: TFPoint;
    function GetLinDefPoint2: TFPoint;
    function GetMeasurementsScale: Double;
    function GetPrecision: Integer;
    function GetRadDefPoint: TFPoint;
    function GetTextAlign: Integer;
    function GetTextHeight: TsgFloat;
    function GetTextHeightReal: TsgFloat;
    function GetTextOffset: TsgFloat;
    function GetTextOverride: string;
    function GetTextPosVert: TsgDimTextPosVert;
    function GetTextRotation: Double;
    function GetTextStyle: TsgDXFStyle;
    function GetFlags: Integer; override;
    function GetTextFromBlock: string;
    function IsInternalDimension: Boolean;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord); override;
    procedure SetArcDefPoint(const Value: TFPoint);
    procedure SetArrowSize(const Value: TsgFloat);
    procedure SetArrowType(const Value: Byte);
    procedure SetArrowType1(const Value: Byte);
    procedure SetArrowType2(const Value: Byte);
    procedure SetArrowTypeL(const Value: Byte);
    procedure SetConverter(const AConverter: TsgDXFConverter); override;
    procedure SetDefPoint(const Value: TFPoint);
    procedure SetDimArrowType1(const Value: TsgDimArrowType);
    procedure SetDimArrowType2(const Value: TsgDimArrowType);
    procedure SetDIMBLK(const Value: TsgDXFBlock);
    procedure SetDIMBLK1(const Value: TsgDXFBlock);
    procedure SetDIMBLK2(const Value: TsgDXFBlock);
    procedure SetDIMLDRBLK(const Value: TsgDXFBlock);
    procedure SetDIMBLKT(const Value: TsgDimArrowType);
    procedure SetDIMBLK1T(const Value: TsgDimArrowType);
    procedure SetDIMBLK2T(const Value: TsgDimArrowType);
    procedure SetDIMLDRBLKT(const Value: TsgDimArrowType);
    procedure SetDIMSAH(const Value: Boolean);
    procedure SetDIMSD1(const Value: Boolean);
    procedure SetDIMSD2(const Value: Boolean);
    procedure SetDIMSE1(const Value: Boolean);
    procedure SetDIMSE2(const Value: Boolean);
    procedure SetDIMTIH(const Value: Boolean);
    procedure SetDIMTOH(const Value: Boolean);
    procedure SetDIMCLRD(const Value: TsgColorCAD);
    procedure SetDIMCLRE(const Value: TsgColorCAD);
    procedure SetDIMCLRT(const Value: TsgColorCAD);
    procedure SetDIMLWD(const Value: TsgFloat);
    procedure SetDIMLWE(const Value: TsgFloat);
    procedure SetDIMDSEP(const Value: Char);
    procedure SetDIMLUNIT(const Value: TsgDimLimitUnits);
    procedure SetExtLineExt(const Value: TsgFloat);
    procedure SetExtLineOffset(const Value: TsgFloat);
    procedure SetForceText(const Value: Integer);
    procedure SetLinDefPoint1(const Value: TFPoint);
    procedure SetLinDefPoint2(const Value: TFPoint);
    procedure SetMeasurementsScale(const Value: Double);
    procedure SetPrecision(const Value: Integer);
    procedure SetRadDefPoint(const Value: TFPoint);
    procedure SetStyle(ADimStyle: TsgDXFDimensionStyle);
    procedure SetStyleInternal(const AValue: TsgDXFDimensionStyle);
    procedure SetTextAlign(const Value: Integer);
    procedure SetTextHeight(const Value: TsgFloat);
    procedure SetTextOffset(const Value: TsgFloat);
    procedure SetTextOverride(const Value: string);
    procedure SetTextPosVert(const Value: TsgDimTextPosVert);
    procedure SetTextRotation(const Value: Double);
    procedure SetTextStyle(const Value: TsgDXFStyle);
    procedure SetFlags(const Value: Integer); override;
    procedure CopyProperties(const ADim: TsgDXFDimension);
    function UseTextStyleFixedHeight: Boolean;

    function ToXMLGeoData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
    function SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
      const AType: TsgPlcType; const AValue: Variant): Integer; override;
{$ENDIF}
    property ActualDimStyle: TsgDXFDimensionStyle read GetActualDimStyle;
    property Properties: TsgDXFDimensionStyle read GetProperties;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
    property ArcDefPoint: TFPoint read GetArcDefPoint write SetArcDefPoint;    
    property ArrowSize: TsgFloat read GetArrowSize write SetArrowSize;
    property ArrowType: Byte read GetArrowType write SetArrowType;
    property ArrowTypeL: Byte read GetArrowTypeL write SetArrowTypeL;
    property ArrowType1: Byte read GetArrowType1 write SetArrowType1;
    property ArrowType2: Byte read GetArrowType2 write SetArrowType2;

    property DimArrowType1: TsgDimArrowType read GetDimArrowType1 write SetDimArrowType1;
    property DimArrowType2: TsgDimArrowType read GetDimArrowType2 write SetDimArrowType2;

    property DimRot: Double read FDimRot write FDimRot;  // DIMENSION (LINEAR) (21): Linear dimension rotation;
    property DimType: TsgDimensionType read GetDimType;

    property Associated: TsgDXFEntity read FAssociated write FAssociated;
    property DefPoint: TFPoint read GetDefPoint write SetDefPoint;
    property DIMLDRBLK: TsgDXFBlock read GetDIMLDRBLK write SetDIMLDRBLK;
    property DIMLDRBLKT: TsgDimArrowType read GetDIMLDRBLKT write SetDIMLDRBLKT;
    property DIMBLK: TsgDXFBlock read GetDIMBLK write SetDIMBLK;
    property DIMBLKT: TsgDimArrowType read GetDIMBLKT write SetDIMBLKT;
    property DIMBLK1: TsgDXFBlock read GetDIMBLK1 write SetDIMBLK1;
    property DIMBLK1T: TsgDimArrowType read GetDIMBLK1T write SetDIMBLK1T;
    property DIMBLK2: TsgDXFBlock read GetDIMBLK2 write SetDIMBLK2;
    property DIMBLK2T: TsgDimArrowType read GetDIMBLK2T write SetDIMBLK2T;
    property DIMSAH: Boolean read GetDIMSAH write SetDIMSAH;
    property DIMSD1: Boolean read GetDIMSD1 write SetDIMSD1;
    property DIMSD2: Boolean read GetDIMSD2 write SetDIMSD2;
    property DIMSE1: Boolean read GetDIMSE1 write SetDIMSE1;
    property DIMSE2: Boolean read GetDIMSE2 write SetDIMSE2;
    property DIMTIH: Boolean read GetDIMTIH write SetDIMTIH;
    property DIMTOH: Boolean read GetDIMTOH write SetDIMTOH;
    property DIMCLRD: TsgColorCAD read GetDIMCLRD write SetDIMCLRD;
    property DIMCLRE: TsgColorCAD read GetDIMCLRE write SetDIMCLRE;
    property DIMCLRT: TsgColorCAD read GetDIMCLRT write SetDIMCLRT;
    property DIMLWD: TsgFloat read GetDIMLWD write SetDIMLWD;
    property DIMLWE: TsgFloat read GetDIMLWE write SetDIMLWE;
    property DIMDSEP: Char read GetDIMDSEP write SetDIMDSEP;
    property DIMLUNIT: TsgDimLimitUnits read GetDIMLUNIT write SetDIMLUNIT;
    property ExtLineExt: TsgFloat read GetExtLineExt write SetExtLineExt;
    property ExtLineOffset: TsgFloat read GetExtLineOffset write SetExtLineOffset;
    property ForceText: Integer read GetForceText write SetForceText;
    property LinDefPoint1: TFPoint read GetLinDefPoint1 write SetLinDefPoint1;
    property LinDefPoint2: TFPoint read GetLinDefPoint2 write SetLinDefPoint2;
    property MeasurementsScale: Double read GetMeasurementsScale write SetMeasurementsScale;
    property MiddlePoint: TFPoint read FMiddlePoint write FMiddlePoint;
    property Style: TsgDXFDimensionStyle read GetStyle write SetStyle;
    property Precision: Integer read GetPrecision write SetPrecision;
    property RadDefPoint: TFPoint read GetRadDefPoint write SetRadDefPoint;
    property TextAlign: Integer read GetTextAlign write SetTextAlign;
    property TextHeight: TsgFloat read GetTextHeight write SetTextHeight;
    property TextOffset: TsgFloat read GetTextOffset write SetTextOffset;
    property TextOverride: string read GetTextOverride write SetTextOverride;
    property TextPosVert: TsgDimTextPosVert read GetTextPosVert write SetTextPosVert;
    property TextRotation: Double read GetTextRotation write SetTextRotation;
    property TextStyle:  TsgDXFStyle read GetTextStyle write SetTextStyle;
    property Elevation: Double read GetElevation write SetElevation;
  end;

  TsgDXFDimensionStyle = class(TsgDXFPenTableItem)
  private
    FBlks: array[vnDIMBLK .. vnDIMLRBLK] of TsgDXFBlock;
    FTextStyleItem: TsgTableItem;
    function GetASZ: TsgFloat;
    function GetArrowType: Byte; //deprecated;
    function GetArrowType1: Byte; //deprecated;
    function GetArrowType2: Byte; //deprecated;
    function GetArrowTypeL: Byte; //deprecated;
    function GetArrowTypeByBlock(const ABlock: TsgDXFBlock): TsgDimArrowType;
    function GetDimArrowType1: TsgDimArrowType;
    function GetDimArrowType2: TsgDimArrowType;
    function GetDIMBLKT: TsgDimArrowType;
    function GetDIMBLK1T: TsgDimArrowType;
    function GetDIMBLK2T: TsgDimArrowType;
    function GetDIMLDRBLKT: TsgDimArrowType;
    function GetDIMBLK: TsgDXFBlock;
    function GetDIMBLK1: TsgDXFBlock;
    function GetDIMBLK2: TsgDXFBlock;
    function GetDIMLDRBLK: TsgDXFBlock;
    function GetDIMSD1: Boolean;
    function GetDIMSD2: Boolean;
    function GetDIMSAH: Boolean;
    function GetDIMSE1: Boolean;
    function GetDIMSE2: Boolean;
    function GetDIMTIH: Boolean;
    function GetDIMTOH: Boolean;
    function GetDIMPOST: string;
    function GetDIMTP: Double;
    function GetDIMTM: Double;
    function GetCLRD: TsgColorCAD;
    function GetCLRE: TsgColorCAD;
    function GetCLRT: TsgColorCAD;
    function GetDEC: Integer;
    function GetEXE: TsgFloat;
    function GetEXO: TsgFloat;
    function GetLFAC: Double;
    function GetLWD: TsgFloat;
    function GetLWE: TsgFloat;
    function GetScale: Double;
    function GetCEN: TsgFloat;
    function GetTextAlign: Integer;
    function GetTXT: TsgFloat;
    function GetGAP: TsgFloat;
    function GetTAD: TsgDimTextPosVert;
    function GetTXSTY: TsgDXFStyle;
    function GetTIX: Integer;
    function GetDIMDSEP: Char;
    function GetDIMLUNIT: TsgDimLimitUnits;
    function GetFRAC: Integer;
    procedure SetArrows(AArrows: TsgArrows);
    procedure SetASZ(const Value: TsgFloat);
    procedure SetArrowTypeEx(const AValue: TsgDimArrowType; const APropName: TsgDimNameVal); overload;
    procedure SetArrowTypeEx(const AValue: string; const APropName: TsgDimNameVal; AValueType: TsgDimArrowType = datUndefined); overload;
    procedure SetArrowType(const Value: Byte); //deprecated;
    procedure SetArrowType1(const Value: Byte); //deprecated;
    procedure SetArrowType2(const Value: Byte); //deprecated;
    procedure SetArrowTypeL(const Value: Byte); //deprecated;
    procedure SetBlocksInternal(const AType: TsgDimNameVal; const AValue: TsgDXFBlock);
    procedure SetDimArrowType1(const Value: TsgDimArrowType);
    procedure SetDimArrowType2(const Value: TsgDimArrowType);
    procedure SetDIMBLKT(const Value: TsgDimArrowType);
    procedure SetDIMBLK1T(const Value: TsgDimArrowType);
    procedure SetDIMBLK2T(const Value: TsgDimArrowType);
    procedure SetDIMLDRBLKT(const Value: TsgDimArrowType);
    procedure SetDIMBLK(const Value: TsgDXFBlock);
    procedure SetDIMBLK1(const Value: TsgDXFBlock);
    procedure SetDIMBLK2(const Value: TsgDXFBlock);
    procedure SetDIMLDRBLK(const Value: TsgDXFBlock);
    procedure SetDIMSD1(const Value: Boolean);
    procedure SetDIMSD2(const Value: Boolean);
    procedure SetDIMSAH(const Value: Boolean);
    procedure SetDIMSE1(const Value: Boolean);
    procedure SetDIMSE2(const Value: Boolean);
    procedure SetDIMTIH(const Value: Boolean);
    procedure SetDIMTOH(const Value: Boolean);
    procedure SetDIMPOST(const Value: string);
    procedure SetDIMTP(const Value: Double);
    procedure SetDIMTM(const Value: Double);
    procedure SetCLRD(const Value: TsgColorCAD);
    procedure SetCLRE(const Value: TsgColorCAD);
    procedure SetCLRT(const Value: TsgColorCAD);
    procedure SetDEC(const Value: Integer);
    procedure SetEXE(const Value: TsgFloat);
    procedure SetEXO(const Value: TsgFloat);
    procedure SetLFAC(const Value: Double);
    procedure SetLWD(const Value: TsgFloat);
    procedure SetLWE(const Value: TsgFloat);
    procedure SetScale(const Value: Double);
    procedure SetCEN(const Value: TsgFloat);
    procedure SetTextAlign(const Value: Integer);
    procedure SetTXT(const Value: TsgFloat);
    procedure SetGAP(const Value: TsgFloat);
    procedure SetTAD(const Value: TsgDimTextPosVert);
    procedure SetTXSTY(const Value: TsgDXFStyle);
    procedure SetTIX(const Value: Integer);
    procedure SetDIMDSEP(const Value: Char);
    procedure SetDIMLUNIT(const Value: TsgDimLimitUnits);
    procedure SetFRAC(const Value: Integer);
  protected
    FDimProps: TsgDimStyle;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function GetBlocks(const AType: TsgDimNameVal): TsgDXFBlock;
    function GetActualStyle(const ANameValue: TsgDimNameVal;
      const ASetValue: Boolean = False): TsgDXFDimensionStyle; virtual;
    function GetTextHeightReal(var AHeight: Double): Boolean;
    function GetOwnerStyle: TsgDXFDimensionStyle; virtual;
    function GetOwnerStyleInternal: TsgDXFDimensionStyle; virtual;
    function GetPropertiesInit: TsgDimNameVals; virtual;
    procedure RemoveReferenceNotification(const ARefObj: TsgDXFEntity); override;
    procedure SetBlocks(const AType: TsgDimNameVal; const AValue: TsgDXFBlock); overload;
    procedure SetBlocks(const AType: TsgDimNameVal; const AValue: string; AConverter: TsgDXFConverter); overload;
    procedure SetOwnerStyle(const AValue: TsgDXFDimensionStyle); virtual;
    procedure SetOwnerStyleInternal(const AValue: TsgDXFDimensionStyle); virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function ToXMLAsProperties(const ANode: TsgNode;
      const AParams: TsgXMLParams): Integer;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function FromXMLAsProperties(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer;
    procedure UpdateDimProps(ADimProps: TsgDimStyle);
    property TextAlign: Integer read GetTextAlign write SetTextAlign;
    property PropertiesInit: TsgDimNameVals read GetPropertiesInit;
    property OwnerStyle: TsgDXFDimensionStyle read GetOwnerStyle write SetOwnerStyle;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure InitProps(AHeader: PsgHeadVarStruct);
    function ReplaceBlock(const ABlockPrev, ABlockNew: TsgDXFBlock): Boolean;
    property ArrowSize: TsgFloat read GetASZ write SetASZ;//used DIMASZ
    property ArrowType: Byte read GetArrowType write SetArrowType;//used DIMBLKT
    property ArrowType1: Byte read GetArrowType1 write SetArrowType1;//used DIMBLK1T
    property ArrowType2: Byte read GetArrowType2 write SetArrowType2;//used DIMBLK2T
    property ArrowTypeL: Byte read GetArrowTypeL write SetArrowTypeL;//used DIMLDRBLKT

    property DimArrowType1: TsgDimArrowType read GetDimArrowType1 write SetDimArrowType1;
    property DimArrowType2: TsgDimArrowType read GetDimArrowType2 write SetDimArrowType2;

    property ExtLineExt: TsgFloat read GetEXE write SetEXE;//used DIMEXE
    property ExtLineOffset: TsgFloat read GetEXO write SetEXO;//used DIMEXO
    property Scale: Double read GetScale write SetScale;//used  DIMSCALE
    property TextOffset: TsgFloat read GetGAP write SetGAP;//used DIMGAP
    property TextHeight: TsgFloat read GetTXT write SetTXT;//used DIMTXT
    property TextPosVert: TsgDimTextPosVert read GetTAD write SetTAD;//used DIMTAD
    property TextStyle: TsgDXFStyle read GetTXSTY write SetTXSTY;//used DIMTXSTY
    property SizeCenterMark: TsgFloat read GetCEN write SetCEN;//used DIMCEN

    property DIMASZ: TsgFloat read GetASZ write SetASZ;
    property DIMCEN: TsgFloat read GetCEN write SetCEN;
    property DIMCLRD: TsgColorCAD read GetCLRD write SetCLRD;
    property DIMCLRE: TsgColorCAD read GetCLRE write SetCLRE;
    property DIMCLRT: TsgColorCAD read GetCLRT write SetCLRT;
    property DIMLDRBLK: TsgDXFBlock read GetDIMLDRBLK write SetDIMLDRBLK;
    property DIMLDRBLKT: TsgDimArrowType read GetDIMLDRBLKT write SetDIMLDRBLKT;
    property DIMBLK: TsgDXFBlock read GetDIMBLK write SetDIMBLK;
    property DIMBLKT: TsgDimArrowType read GetDIMBLKT write SetDIMBLKT;
    property DIMBLK1: TsgDXFBlock read GetDIMBLK1 write SetDIMBLK1;
    property DIMBLK1T: TsgDimArrowType read GetDIMBLK1T write SetDIMBLK1T;
    property DIMBLK2: TsgDXFBlock read GetDIMBLK2 write SetDIMBLK2;
    property DIMBLK2T: TsgDimArrowType read GetDIMBLK2T write SetDIMBLK2T;
    property DIMDEC: Integer read GetDEC write SetDEC;
    property DIMEXE: TsgFloat read GetEXE write SetEXE;
    property DIMEXO: TsgFloat read GetEXO write SetEXO;
    property DIMLFAC: Double read GetLFAC write SetLFAC;
    property DIMLWD: TsgFloat read GetLWD write SetLWD;
    property DIMLWE: TsgFloat read GetLWE write SetLWE;
    property DIMGAP: TsgFloat read GetGAP write SetGAP;
    property DIMTAD: TsgDimTextPosVert read GetTAD write SetTAD;
    property DIMTIX: Integer read GetTIX write SetTIX;
    property DIMTIH: Boolean read GetDIMTIH write SetDIMTIH;
    property DIMTOH: Boolean read GetDIMTOH write SetDIMTOH;
    property DIMTXT: TsgFloat read GetTXT write SetTXT;
    property DIMTXSTY: TsgDXFStyle read GetTXSTY write SetTXSTY;
    property DIMSAH: Boolean read GetDIMSAH write SetDIMSAH;
    property DIMSCALE: Double read GetScale write SetScale;
    property DIMSD1: Boolean read GetDIMSD1 write SetDIMSD1;
    property DIMSD2: Boolean read GetDIMSD2 write SetDIMSD2;
    property DIMSE1: Boolean read GetDIMSE1 write SetDIMSE1;
    property DIMSE2: Boolean read GetDIMSE2 write SetDIMSE2;
    property DIMPOST: string read GetDIMPOST write SetDIMPOST;
    property DIMTP: Double read GetDIMTP write SetDIMTP;
    property DIMTM: Double read GetDIMTM write SetDIMTM;
    property DIMDSEP: Char read GetDIMDSEP write SetDIMDSEP;
    property DIMLUNIT: TsgDimLimitUnits read GetDIMLUNIT write SetDIMLUNIT;
    property DIMFRAC: Integer read GetFRAC write SetFRAC;
  end;

  TsgDXFDimensionProperties = class(TsgDXFDimensionStyle)
  private
    FOwnerStyleItem: TsgTableItem;
    FPropertiesInit: TsgDimNameVals;
    procedure OwnerStyleDestroyed(Sender: TObject);
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetConverter: TsgDXFConverter; override;
    function GetActualStyle(const ANameValue: TsgDimNameVal;
      const ASetValue: Boolean = False): TsgDXFDimensionStyle; override;
    function GetOwnerStyle: TsgDXFDimensionStyle; override;
    function GetOwnerStyleInternal: TsgDXFDimensionStyle; override;
    function GetPropertiesInit: TsgDimNameVals; override;
    procedure SetOwnerStyle(const AValue: TsgDXFDimensionStyle); override;
    procedure SetOwnerStyleInternal(const AValue: TsgDXFDimensionStyle); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
  end;

  TsgDXFLeader = class(TsgDXFSpline)
  private
    FArrowhead: Boolean;
    FArrowPoint: TFPoint;
    FDimStyleItem: TsgTableItem;
    FInsert: TsgDXFInsert;
    FIsSpline: Boolean;
    FPropertiesItem: TsgTableItem;
    FTextPoint: TFPoint;
    function GetActualDimStyle: TsgDXFDimensionStyle;
    function GetDIMBLK: TsgDXFBlock;
    function GetDIMBLK1: TsgDXFBlock;
    function GetDIMBLK2: TsgDXFBlock;
    function GetDIMLDRBLK: TsgDXFBlock;
    function GetProperties: TsgDXFDimensionStyle;
    function GetTextStyle: TsgDXFStyle;
    procedure LoadInsert(AConverter: TsgDXFConverter; NextControl: Integer; const ALineAngle: Double);
    procedure SetDIMBLK(const AValue: TsgDXFBlock);
    procedure SetDIMBLK1(const AValue: TsgDXFBlock);
    procedure SetDIMBLK2(const AValue: TsgDXFBlock);
    procedure SetDIMLDRBLK(const AValue: TsgDXFBlock);
    procedure SetTextStyle(const AValue: TsgDXFStyle);
  protected
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure DoAdditionalLine(const AHookLine: Integer;
      const AHookLineVector: TFPoint; const ATAD: Integer;
       const AGAP, AWidth: Double);
    procedure EndExtData(const AData: TsgCADExtendedData); override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetArrowSize: Double;
    function GetArrowScale: Double;
    function GetArrowType: Byte;
    function GetDimArrowType: TsgDimArrowType;
    function GetEntType: TsgCADEntities; override;
    function GetDimStyle: TsgDXFDimensionStyle;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure SetArrowSize(AValue: Double);
    procedure SetArrowScale(const AValue: Double);
    procedure SetArrowType(const AValue: Byte);
    procedure SetDimArrowType(const AValue: TsgDimArrowType);
    procedure SetColorCAD(const Value: TsgColorCAD); override;
    procedure SetConverter(const AConverter: TsgDXFConverter); override;
    procedure SetVisibility(const Value: Boolean); override;
    procedure SetDimStyle(const AValue: TsgDXFDimensionStyle);
    procedure SetDimStyleInternal(const AValue: TsgDXFDimensionStyle);
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property ActualDimStyle: TsgDXFDimensionStyle read GetActualDimStyle;
    property Properties: TsgDXFDimensionStyle read GetProperties;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    property Insert: TsgDXFInsert read FInsert;
    property IsSpline: Boolean read FIsSpline write FIsSpline;
    property Arrowhead: Boolean read FArrowhead write FArrowhead;
    property ArrowSize: Double read GetArrowSize write SetArrowSize;
    property ArrowScale: Double read GetArrowScale write SetArrowScale;
    property ArrowType: Byte read GetArrowType write SetArrowType;
    property DimArrowType: TsgDimArrowType read GetDimArrowType write SetDimArrowType;
    property DIMLDRBLK: TsgDXFBlock read GetDIMLDRBLK write SetDIMLDRBLK;
    property DIMBLK: TsgDXFBlock read GetDIMBLK write SetDIMBLK;
    property DIMBLK1: TsgDXFBlock read GetDIMBLK1 write SetDIMBLK1;
    property DIMBLK2: TsgDXFBlock read GetDIMBLK2 write SetDIMBLK2;
    property TextStyle: TsgDXFStyle read GetTextStyle write SetTextStyle;
    property DimStyle: TsgDXFDimensionStyle read GetDimStyle write SetDimStyle;
  end;

  TsgDXFText = class(TsgDXFCustomVertex)
  private
    FPoint1: TFPoint;
    FMatrix: TFMatrix;
    FBox: TFRect;
    FExtrusion: TFPoint;
    FStartPoint: TFPoint;
    FLineWeight: Double;
    FMText: TsgDXFMText;
    FTextParse: PsgTextParse;
    FSHXMap: TsgSymbolsMap;
    FTextStyleItem: TsgTableItem;
    FText: string;
    FUnicodeText: WideString;
    FPropertiesItem: TsgTableItem;
    FRotation: Single;
    FTracking: Single;
    FTextOrigin: Single;
    FCharset: TFontCharset;
    FPitch: Byte;
    FVAlign: Byte;
    FHAlign: Byte;
    FInternalFlags: TsgInternalTextFlags;
    procedure ApplyRotation;
    function GetSHXBoxI(ASHXFontsList: TsgSHXFontList; var AFontParams: TsgFontParams): Boolean;
    function Expand(AWidth, AHeight, AHeightMax: Extended;
      const ASign: TFPoint): Boolean;
    procedure SetGeneration(const Value: Byte);
    function GetGeneration: Byte;
    function GetFontName: string;
    function GetFontStyle: TmvFontStyles;
    function GetSymbolFromMultibyte(const AConverter: TsgDXFConverter;
      const ALeft, ARight: Byte; const ANumber: Integer;
      const AUnicodeAlways: Boolean; const ACheckByNumber: Boolean = True): WideChar;
    function GetUnicodeText: WideString;
    function GetIsUnicodeText: Boolean;

    { internal flags methods }
    function GetInsideDimension: Boolean;
    function GetInsideMText: Boolean;
    function GetIsSHXFont: Boolean;
    function GetUseDefaultFontName: Boolean;
    function GetWinFont: Boolean;
    procedure SetInsideMText(const AValue: Boolean);
    procedure SetInsideDimension(const AValue: Boolean);
    procedure SetInternalFlag(const AInternalFlag: TsgInternalTextFlag; const AValue: Boolean);
    procedure SetInternalTextFlags(const AValue: TsgInternalTextFlags);
    procedure SetIsSHXFont(const AValue: Boolean);
    procedure SetUseDefaultFontName(const AValue: Boolean);
    procedure SetWinFont(const AValue: Boolean);
    procedure SetStyleRef(const Value: TsgDXFStyle);
    procedure SetProperties(const Value: TsgDXFStyle);
    procedure SetScale(const Value: Double);
    function GetScale: Double;
    function GetProperties: TsgDXFStyle;
    procedure ParseUnicodeText(const AConverter: TsgDXFConverter;
      const AText: string);
    procedure ParseUnicodeText2(const ACodePage: Integer; const AText: string;
      const AFont, ABigFont: TsgSHXFont; const AParsePercentSymbols: Boolean);
    function GetInternalSHXFont: string;
  protected
    FIndices: array of Word;
    procedure ApplyStyle(const AStyle: TsgDXFStyle);
    procedure ApplyStyleProps(const AStyle: TsgDXFStyle);
    procedure CreateTextParse;
    procedure CreateMText(const AConverter: TsgDXFConverter);
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetAnsiText(const AText: string; ACodePage: Integer): sgRawByteString; virtual;
    function GetBackward: Boolean;
    function GetFFontName: string;
    function GetHeight: TsgFloat;
    function GetOblique: Single;
    function GetPoint1: TFPoint;
    function GetRotation: Single;
    function GetXScale: Single;
    function GetStyle: TsgDXFStyle;
    function GetSHXFont: string; virtual;
    function GetText: string;
    function GetTextStyleInternal: Pointer; override;
    function GetUpsideDown: Boolean;
    procedure ChangeByStyle(AStyle: TsgDXFStyle);
    procedure SetBackward(const AValue: Boolean);
    procedure SetHeight(AValue: TsgFloat);
    procedure SetOblique(Value: Single);
    procedure SetPoint1(AValue: TFPoint);
    procedure SetRotation(AValue: Single);
    procedure SetXScale(const Value: Single);
    procedure SetStyle(AStyle: TsgDXFStyle);
    procedure SetFontName(const AFontName: string; AStyles: TFontStyles);
    procedure SetSHXFont(const AFontName: string);
    procedure SetTTFFont(const AFontName: string; AStyles: TFontStyles);
    procedure SetTextValue(const Value: string);
    procedure SetUpsideDown(const Value: Boolean);
    function GetBox: TFRect; override;
    function GetEntType: TsgCADEntities; override;
    function GetExtrusion: TFPoint; override;
    function GetIsEmpty: Boolean; virtual;
    function GetLineWeight: Double; override;
    function GetThicknessInt: Double; override;
    function HasSecond: Boolean;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    function IsNotSetFontName: Boolean;
    function IsMText(const ADiamUni: Boolean): Boolean;
    function IsMultiText: Boolean; virtual;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure SetDefaulParams(AConverter: TsgDXFConverter);
    procedure SetExtrusion(const Value: TFPoint); override;
    procedure SetLineWeight(Value: Double); override;
    procedure StyleChanged(Sender: TObject); override;
    procedure SetThicknessInt(const AValue: Double); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
    procedure UpdateProperties(AConverter: TsgDXFConverter);
    procedure GetSHXLinesI(ASHXFontsList: TsgSHXFontList; AList: TsgSHXVertexList;
      var AFontParams: TsgFontParams; const AParams: PsgCADIterate = nil);
    property UseDefaultFontName: Boolean read GetUseDefaultFontName write SetUseDefaultFontName;
    property InternalTextFlags: TsgInternalTextFlags read FInternalFlags write SetInternalTextFlags;
    property Properties: TsgDXFStyle read GetProperties write SetProperties;
    property StyleRef: TsgDXFStyle read GetStyle write SetStyleRef;
    property InsideDimension: Boolean read GetInsideDimension write SetInsideDimension;
    property InternalSHXFont: string read GetInternalSHXFont;
    property MTextRef: TsgDXFMText read FMText write FMText;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function EntName: string; override;
    function IsOnePixelOptimisationValid: Boolean; override;
    function SHXMatrix: TFMatrix;
    procedure DoNewText(const ANewText: string);
    procedure GetBase(AWidth, AHeight: Extended; var Base, Start: TFPoint); virtual;
    function GetMatrix: TFMatrix;
    procedure GetSHXLinesExI(ASHXFontsList: TsgSHXFontList; AList: TList;
      AMatrix: PFMatrix; const APolyPolyline: TsgIntegerList;
      const ACounts: TsgIntegerList);
    procedure GetSHXLinesEx(ASHXFontsList: TsgSHXFontList; ACollection: TsgCustomPolyItemsCollection;
      const AGDI: Boolean = False; const AParams: PsgCADIterate = nil);
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
    procedure SetLWeight(Value: Integer); override;
    property Backward: Boolean read GetBackward;
    property Charset: TFontCharset read FCharset;
    property Extrusion: TFPoint read GetExtrusion write SetExtrusion;
    property FontName: string read GetFontName;
    property FontStyle: TmvFontStyles read GetFontStyle;
    property Generation: Byte read GetGeneration write SetGeneration;
    property HAlign: Byte read FHAlign write FHAlign;
    property Height: TsgFloat read GetHeight write SetHeight;
    property InsideMText: Boolean read GetInsideMText write SetInsideMText;
    property IsEmpty: Boolean read GetIsEmpty;
    property IsUnicodeText: Boolean read GetIsUnicodeText;
    property IsSHXFont: Boolean read GetIsSHXFont write SetIsSHXFont;
    property MText: TsgDXFMText read FMText;
    property ObliqueAngle: Single read GetOblique write SetOblique;
    property Point1: TFPoint read GetPoint1 write SetPoint1;
    property Rotation: Single read FRotation write FRotation;
    property Scale: Double read GetScale write SetScale;
    property SHXFont: string read GetSHXFont;
    property StartPoint: TFPoint read FStartPoint;
    property Style: TsgDXFStyle read GetStyle write SetStyle;
    property Text: string read FText write SetTextValue;
    property Tracking: Single read FTracking write FTracking;
    property UnicodeText: WideString read GetUnicodeText;
    property UpsideDown: Boolean read GetUpsideDown;
    property VAlign: Byte read FVAlign write FVAlign;
    property WinFont: Boolean read GetWinFont write SetWinFont;
    property XScale: Single read GetXScale write SetXScale;
  end;

  TsgDXFShape = class(TsgDXFText)
  private
    FShapeName: string;
    FShapeNumber: Word;
  protected
    function GetAnsiText(const AText: string; ACodePage: Integer): sgRawByteString; override;
    function GetEntType: TsgCADEntities; override;
    function GetIsEmpty: Boolean; override;
    function GetSHXFont: string; override;
    function GetShapeName: string;
    function GetShapeNumber: Word;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetShapeName(const Value: string);
    procedure SetShapeNumber(const Value: Word);
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property ShapeName: string read GetShapeName write SetShapeName;
    property ShapeNumber: Word read GetShapeNumber write SetShapeNumber;
  end;

  TsgDXFMText = class(TsgDXFInsert)
  private
    FAlign: Byte;
    FHeight: TsgFloat;
    FHyphenation: Boolean;
    FLineSpacingFactor: Single;
    FLineSpacingStyle: Byte;
    FPoint1: TFPoint;
    FRectWidth: Single;
    FTextStyleItem: TsgTableItem;
    FText: string;
    FBackgroundFlags: Integer;
    FBackgroundColor: TsgColorCAD;
    FBackgroundScaleFactor: Single;
    FBackgroundTransparency: Integer;
    function GetRealAngle(const AExtrusion: PFPoint): Double;
    function IsAngleBySecondPoint: Boolean;
  protected
    procedure AddBackground(const AConverter: TsgDXFConverter);
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetAlign: Byte;
    function GetAngleInsp: Single;
    function GetEntType: TsgCADEntities; override;
    function GetBackgroundColor: TsgColorCAD;
    function GetBackgroundFlags: Byte;
    function GetBackgroundTransparency: Integer;
    function GetBackgroundScaleFactor: Double;
    function GetHeight: TsgFloat;
    function GetLineSpacingFactor: Single;
    function GetLineSpacingStyle: Byte;
    function GetRectWidth: Single;
    function GetStyle: TsgDXFStyle;
    function GetText: string;
    function GetTextStyleInternal: Pointer; override;
    function GetThicknessInt: Double; override;
    function HasSecond: Boolean;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function Parsing(const AConverter: TsgDXFConverter; AList: TsgEntitiesList;
      const AColor: TsgColorCAD; ASize: Double;
      const AAlign: Byte): Boolean; virtual;
    procedure ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord); override;
    procedure SetAlign(const Value: Byte);
    procedure SetAngleInsp(const AValue: Single);
    procedure SetAngle(const Value: Double); override;
    procedure SetBackgroundFlags(const AValue: Byte);
    procedure SetBackgroundColor(const AColor: TsgColorCAD);
    procedure SetBackgroundTransparency(const AColor: Integer);
    procedure SetBackgroundScaleFactor(AValue: Double);
    procedure SetHeight(AValue: TsgFloat);
    procedure SetHyphenation(const AValue: Boolean);
    procedure SetLineSpacingFactor(const Value: Single);
    procedure SetLineSpacingStyle(const Value: Byte);
    procedure SetRectWidth(const Value: Single);
    procedure SetStyle(AValue: TsgDXFStyle);
    procedure SetTextValue(AValue: string);
    procedure SetThicknessInt(const AValue: Double); override;
    function ToXMLGeoData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
    function SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
      const AType: TsgPlcType; const AValue: Variant): Integer; override;
{$ENDIF}
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function EntName: string; override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    function HasBackgroundColor: Boolean;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
    procedure SetLWeight(Value: Integer); override;
    property Align: Byte read GetAlign write SetAlign;
    property Height: TsgFloat read FHeight write FHeight;
    property Hyphenation: Boolean read FHyphenation write SetHyphenation;
    property LineSpacingFactor: Single read GetLineSpacingFactor write SetLineSpacingFactor;
    property LineSpacingStyle: Byte read GetLineSpacingStyle write SetLineSpacingStyle;
    property Point1: TFPoint read FPoint1 write FPoint1;
    property RectHeight: Single read GetLineSpacingFactor write SetLineSpacingFactor;
    property RectWidth: Single read GetRectWidth write SetRectWidth;
    property Style: TsgDXFStyle read GetStyle write SetStyle;
    property Text: string read FText write FText;
    property BackgroundFlags: Byte read GetBackgroundFlags write SetBackgroundFlags;
    property BackgroundColor: TsgColorCAD read GetBackgroundColor write SetBackgroundColor;
    property BackgroundTransparency: Integer read GetBackgroundTransparency write SetBackgroundTransparency;
    property BackgroundScaleFactor: Double read GetBackgroundScaleFactor write SetBackgroundScaleFactor;
  end;

  TsgDXFTolerance = class(TsgDXFMText)
  private
    FDimlineColor: TsgColorCAD;
    FDimStyleItem: TsgTableItem;
    FDimScaleOverall: PDouble;
    FGAP: PDouble;
  protected
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure EndExtData(const AData: TsgCADExtendedData); override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetBlockOffset: TFPoint; override;
    function GetDimlineColor: TsgColorCAD;
    function GetDimScaleOverall: Single;
    function GetDimScaleAct: Double;
    function GetDimStyle: TsgDXFDimensionStyle;
    function GetEntType: TsgCADEntities; override;
    function GetDimGap: Double;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function Parsing(const AConverter: TsgDXFConverter; AList: TsgEntitiesList;
      const AColor: TsgColorCAD; ASize: Double;
      const AAlign: Byte): Boolean; override;
    procedure SetDimlineColor(const Value: TsgColorCAD);
    procedure SetDimScaleOverall(const Value: Single);
    procedure SetDimStyle(const Value: TsgDXFDimensionStyle);
    procedure SetDimGap(const Value: Double);
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    property DimlineColor: TsgColorCAD read GetDimlineColor write SetDimlineColor;
    property DimScaleOverall: Single read GetDimScaleOverall write SetDimScaleOverall;
    property DimStyle: TsgDXFDimensionStyle read GetDimStyle write SetDimStyle;
    property GAP: Double read GetDimGap write SetDimGap;
  end;

  TsgDXFOle2Frame = class(TsgDXFCustomVertex)
  private
    FBinaryData: AnsiString;
    FOleObject: {$IFDEF SG_HAS_ACTIVEX}IOleObject{$ELSE}IUnknown{$ENDIF};
    FStorage: {$IFDEF SG_HAS_ACTIVEX}IStorage{$ELSE}IUnknown{$ENDIF};
    FMoniker: {$IFDEF SG_HAS_ACTIVEX}IMoniker{$ELSE}IUnknown{$ENDIF};
    FPoint1: TFPoint;
    FOLEObjectType: Byte;
    FOLEBitmap: {$IFDEF SG_FIREMONKEY}FMX.{$ENDIF}Graphics.TBitmap;
    FAspect: Byte;
    FTileModeDescriptor: Integer;
    FTID: Cardinal;
    procedure DestroyOleObject;
    function GetFileName: string;
    function GetIsLink: Boolean;
  protected
    procedure ClearReferences; override;
    function GetEntType: TsgCADEntities; override;
    function GetBox: TFRect; override;
    function GetPoint1: TFPoint;
    function GetPosition: TFPoint;
    function GetSize: TFPoint;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetPoint1(const Value: TFPoint);
    procedure SetPosition(const APoint: TFPoint);
    procedure SetSize(const APoint: TFPoint);
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    procedure ConvertOleToBitmap(AOleObject: {$IFDEF SG_HAS_ACTIVEX}IOleObject{$ELSE}IUnknown{$ENDIF};
      const AWidth, AHeight: Double; ADrawingRect: TRect; const ABitmap: TBitmap);
    property FileName: string read GetFileName;
    property IsLink: Boolean read GetIsLink;
    property TID: Cardinal read FTID;
    property Storage: {$IFDEF SG_HAS_ACTIVEX}IStorage{$ELSE}IUnknown{$ENDIF} read FStorage;
    property Moniker: {$IFDEF SG_HAS_ACTIVEX}IMoniker{$ELSE}IUnknown{$ENDIF} read FMoniker;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property OleBitmap: {$IFDEF SG_FIREMONKEY}FMX.{$ENDIF}Graphics.TBitmap read FOLEBitmap;
    property OleObject: {$IFDEF SG_HAS_ACTIVEX}IOleObject{$ELSE}IUnknown{$ENDIF} read FOleObject;
    property OleObjectType: Byte read FOLEObjectType write FOLEObjectType;
    property Aspect: Byte read FAspect write FAspect;
    property Point1: TFPoint read GetPoint1 write SetPoint1;
    property BinaryData: AnsiString read FBinaryData write FBinaryData;
    property TileModeDescriptor: Integer read FTileModeDescriptor
      write FTileModeDescriptor;
  end;

  TsgAttribType = (atString, atEnum, atSoftLink, atXMLLink,
    atInteger, atDouble, atPoint, atMText, atVertex);

  TsgDXFAttdef = class(TsgDXFText)
  private
    FHasChanging: Boolean;
    FValue: string;
    FFlags: Integer;
    FLockPosition: Boolean;
    FType: TsgAttribType;
    function GetControlled: Boolean;
    function GetPreset: Boolean;
    procedure SetControlled(const Value: Boolean);
    procedure SetPreset(const Value: Boolean);
  protected
    procedure FreeReferences; override;
    function GetConstant: Boolean;
    function GetEntType: TsgCADEntities; override;
    function GetNotAppear: Boolean;
    function GetOwner: TsgDXFEntity; override;
    function GetTag: string;
    function GetValue: string;
    function GetFlags: Integer; override;
    function GetTypeValue: TsgAttribType; virtual;
    function GetDeletable: Boolean; virtual;
    function GetReadOnly: Boolean; virtual;
    function GetRequiredField: Boolean; virtual;
    function GetIdValueIndex: Integer; virtual;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    function IsMultiText: Boolean; override;
    procedure SetConstant(const Value: Boolean);
    procedure SetIdValueByIndex(const AIndexInValues: Integer); virtual;
    function GetLinkClass: TsgOwneredItemClass; override;
    procedure SetNotAppear(const Value: Boolean);
    procedure SetOwner(const Value: TsgDXFEntity); override;
    procedure SetTag(const ATag: string); virtual;
    procedure SetValue(const AValue: string); virtual;
    procedure SetFlags(const Value: Integer); override;
    procedure SetTypeValue(const AValue: TsgAttribType); virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
    function SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
      const AType: TsgPlcType; const AValue: Variant): Integer; override;
{$ENDIF}
    procedure CheckValue;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function EntName: string; override;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
    function GetStrValue: string; override;
    function SetStrValue(const S: string): Boolean; override;
    property Constant: Boolean read GetConstant write SetConstant;
    property Controlled: Boolean read GetControlled write SetControlled;
    property Preset: Boolean read GetPreset write SetPreset;
    property Tag: string read GetTag write SetTag;
    property Value: string read GetValue write SetValue;
    property LockPosition: Boolean read FLockPosition write FLockPosition;
    property NotAppear: Boolean read GetNotAppear write SetNotAppear;
    property TypeValue: TsgAttribType read GetTypeValue write SetTypeValue;//for internal using
  end;

  TsgDXFAttrib = class(TsgDXFAttdef)
  protected
    function GetEntType: TsgCADEntities; override;
    function GetOwnerInsert: TsgDXFInsert; virtual;
    procedure SetTag(const ATag: string); override;
    procedure SetValue(const AValue: string); override;
    procedure SetOwnerInsert(const AValue: TsgDXFInsert); virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    function SetStrValue(const S: string): Boolean; override;
  end;

  TsgDXFViewport = class(TsgDXFPenEntity)
  private
    FBackClipPlane: Single;
    FBox: TFRect;
    {$IFDEF SG_FM_MOBILE}[Weak]{$ENDIF}FClippingBoundary: TsgDXFEntity;
    FFlags: Integer;
    FFrontClipPlane: Single;
    FFrozenLayers: TsgInt64List;
    FMatrix: TFMatrix;
    FMSpaceCenter: TFPoint;
    FMSpaceHeight: Double;
    FOrdIndexInt: Integer;
    FPSpaceCenter: TFPoint;
    FPSpaceHeight: Double;
    FPSpaceWidth: Double;
    FRect: TFRect;
    FStatusField: Integer;
    FThisID: Integer;
    FViewDirection: TFPoint;
    FViewTarget: TFPoint;
    FViewTwistAngle: Single;
    FVisibleBoundary: Boolean;
    function IsOwnerModel: Boolean;
    function IsOwnerLayout: Boolean;
    procedure SetClippingBoundary(AValue: TsgDXFEntity);
  protected
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    function CanDraw: Boolean; override;
    function GetBackClipPlane: Single;
    function GetBox: TFRect; override;
    function CalcMatrix: TFMatrix;
    procedure EndExtData(const AData: TsgCADExtendedData); override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetClipBoundary(AConverter: TsgDXFConverter): TsgDXFEntity;
    function GetDrawModel: Boolean;
    function GetEntType: TsgCADEntities; override;
    function GetFrontClipPlane: Single;
    function GetMSpaceCenter: TFPoint;
    function GetOwner: TsgDXFEntity; override;
    function GetPSpaceCenter: TFPoint;
    function GetPSpaceHeight: Double;
    function GetPSpaceWidth: Double;
    function GetScale: Double;
    function GetTurnsOff: Boolean;
    function GetViewDirection: TFPoint;
    function GetViewTarget: TFPoint;
    function GetViewTwistAngle: Single;
    function GetVisibleBoundary: Boolean;
    function GetFlags: Integer; override;
    function HasLineWeight: Boolean; override;
    procedure SetBackClipPlane(const Value: Single);
    procedure SetFrontClipPlane(const Value: Single);
    procedure SetMSpaceCenter(const Value: TFPoint);
    procedure SetOrdIndex(const Value: Integer);
    procedure SetOwner(const Value: TsgDXFEntity); override;
    procedure SetPSpaceCenter(const Value: TFPoint);
    procedure SetPSpaceHeight(const Value: Double);
    procedure SetPSpaceWidth(const Value: Double);
    procedure SetScale(const Value: Double);
    procedure SetTurnsOff(const Value: Boolean);
    procedure SetViewDirection(const Value: TFPoint);
    procedure SetViewTarget(const Value: TFPoint);
    procedure SetViewTwistAngle(const Value: Single);
    procedure SetVisibleBoundary(const Value: Boolean);
    procedure SetFlags(const Value: Integer); override;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property TurnsOff: Boolean read GetTurnsOff write SetTurnsOff;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function GetBoundariesAsPoints(AConverter: TsgDXFConverter): TList;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    function IsDraw: Boolean;
    procedure Offset(const P: TFPoint);
    property BackClipPlane: Single read GetBackClipPlane write SetBackClipPlane;
    property ClippingBoundary: TsgDXFEntity read FClippingBoundary write SetClippingBoundary;
    property FrontClipPlane: Single read GetFrontClipPlane write SetFrontClipPlane;
    property FrozenLayers: TsgInt64List read FFrozenLayers write FFrozenLayers;
    property MSpaceCenter: TFPoint read GetMSpaceCenter write SetMSpaceCenter;
    property MSpaceHeight: Double read FMSpaceHeight write FMSpaceHeight;
    property OrdIndex: Integer read FOrdIndexInt write SetOrdIndex;
    property PSpaceCenter: TFPoint read GetPSpaceCenter write SetPSpaceCenter;
    property PSpaceHeight: Double read GetPSpaceHeight write SetPSpaceHeight;
    property PSpaceWidth: Double read GetPSpaceWidth write SetPSpaceWidth;
    property Rect: TFRect read FRect;
    property StatusField: Integer read FStatusField write FStatusField;
    property ThisID: Integer read FThisID write FThisID;
    property ViewDirection: TFPoint read GetViewDirection write SetViewDirection;
    property ViewTarget: TFPoint read GetViewTarget write SetViewTarget;
    property ViewTwistAngle: Single read GetViewTwistAngle write SetViewTwistAngle;
    property VisibleBoundary: Boolean read GetVisibleBoundary write SetVisibleBoundary;
  end;

  TsgDXFVport = class(TsgDXFPenTableItem)
  protected
    FCircleZoomPercent: Integer;
    FViewAspectRatio: TsgFloat;
    FViewCenterPoint: TFPoint;
    FViewDirection: TFPoint;
    FViewHeight: TsgFloat;
    FViewTarget: TFPoint;
    FViewTwistAngle: Double;
    FUCSOrigin: TFPoint;
    FUCSYDir: TFPoint;
    FUCSXDir: TFPoint;
    FUCSVP: Boolean;
    function GetViewDirection: TFPoint;
    function GetViewHeight: TsgFloat;
    function GetViewTwistAngle: Double;
    procedure SetViewDirection(const Value: TFPoint);
    procedure SetViewHeight(const Value: TsgFloat);
    procedure SetViewTwistAngle(const Value: Double);
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property CircleZoomPercent: Integer read FCircleZoomPercent write FCircleZoomPercent;
    property ViewAspectRatio: TsgFloat read FViewAspectRatio write FViewAspectRatio;
    property ViewCenterPoint: TFPoint read FViewCenterPoint write FViewCenterPoint;
    property ViewDirection: TFPoint read GetViewDirection write SetViewDirection;
    property ViewHeight: TsgFloat read GetViewHeight write SetViewHeight;
    property ViewTarget: TFPoint read FViewTarget write FViewTarget;
    property ViewTwistAngle: Double read GetViewTwistAngle write SetViewTwistAngle;
    property UCSOrigin: TFPoint read FUCSOrigin write FUCSOrigin;
    property UCSXDir: TFPoint read FUCSXDir write FUCSXDir;
    property UCSYDir: TFPoint read FUCSYDir write FUCSYDir;
    property UCSVP: Boolean read FUCSVP write FUCSVP;
  end;

  TsgDXFXRef = class(TsgDXFOwneredItem)
  private
    FInvokeConverters: TsgList;
    FCADImage: TGraphic;
    FBox: TFRect;
    FPath: string;
//    FOwnerProgress: TProgressEvent;
//    procedure GraphicChange(Sender: TObject);
//    procedure ProgressEvent(Sender: TObject; Stage: TProgressStage;
//      PercentDone: Byte; RedrawNow: Boolean; const R: TRect; const Msg: string);
  protected
    function AddCADImage(const AMainConv: TsgDXFConverter;
      const AFilePath: string; ASearchPaths: TStrings = nil): Boolean;
    function CanDraw: Boolean; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetBox: TFRect; override;
    function GetBlock: TsgDXFBlock;
    function GetEntType: TsgCADEntities; override;
    function GetLayer: TsgDXFLayer; override;
    procedure Invoke(AConverter: TsgDXFConverter; Proc,
      FinishProc: TsgCADEntityProc); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property Block: TsgDXFBlock read GetBlock;
  public
    constructor Create; override;
    property CADImage: TGraphic read FCADImage;
    property Path: string read FPath;
  end;

  TsgDXFLayout = class(TsgDXFOwneredItem)
  private
    FBox: TFRect;
    FCADSpace: TsgCADSpace;
    FPaperSpaceBlock: TsgDXFBlock;
    FPlotSettings: TsgDXFPlotSettings;
    FRotMatrix: TFMatrix;
    FRotZAngle: Double;
    FUCSOrigin: TFPoint;
    FUCSXDir: TFPoint;
    FUCSYDir: TFPoint;
    FView: TsgView;
    FLimMax: TFPoint;
    FLimMin: TFPoint;
    procedure DoExtents(AConverter: TsgDXFConverter);
    function GetBlockName(const AIndex: Integer = -1): string;
    function GetEmpty: Boolean;
    function GetIsModel: Boolean;
    function GetPaperSpaceBlock: TsgDXFBlock;
    procedure SetPaperSpaceBlock(ABlock: TsgDXFBlock);
    function GetExtMax: TFPoint;
    function GetExtMin: TFPoint;
{$IFDEF SG_VERSION_OLD}
    function GetPlotPaperUnits: Integer; {$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version. Please, use the following property - PlotSettings!'{$ENDIF};{$ENDIF}
    procedure SetPlotPaperUnits(const Value: Integer); {$IFDEF SGDEL_6}deprecated{$IFDEF SGDEL_2009}'This procedure is obsolete and will be deleted in the next version. Please, use the following property - PlotSettings!'{$ENDIF};{$ENDIF}
{$ENDIF}
    procedure SetPlotSettings(const Value: TsgDXFPlotSettings);
    function GetIndex: Integer;
    function GetBlockRecord: TsgDXFEntity;
  protected
    function CanAddedToXMLParams: Boolean; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function ForceSetPaperSpaceBlock(const AConverter: TsgDXFConverter): TsgDXFBlock;//for internal using
    function GetBox: TFRect; override;
    function GetCount: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    function IsInvisible(E: TsgDXFEntity; AConv: TsgDXFConverter; const ARays: TsgObjectList;
      const AHeadVarStruct: TsgHeadVarStruct): Boolean;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetBox(const ABox: TFRect);
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    procedure ToXMLSubEntities(const AParentNode: TsgNode;
      const AParams: TsgXMLParams); override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function FromXMLSubEntities(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer; override;
    procedure UpdatePlotSettingsByExtents;
{$IFDEF SG_PLUGINSHOST}
    function ExportToPluginsInternal(ANode: IsgNodeFrame): Integer; override;
{$ENDIF}
    property View: TsgView read FView;
    property BlockRecord: TsgDXFEntity read GetBlockRecord;
  public
    constructor Create; override;
    destructor Destroy; override;
    // functions of IsgListOfEntities
    function AddEntity(const AEntity: TsgDXFEntity): Integer; override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; override;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer; override;
    function IndexOfName(const AName: string): Integer; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
    function IsLayerInVisible(ALayer: TsgDXFLayer; AConv: TsgDXFConverter; AnnOnly: Boolean=False): Boolean;
    function UsingPlotSettings: Boolean;
//    function GetPlotWindowArea: TFRect;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Iterate(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
    function RotMatrix: TFMatrix;
    procedure SetRotMatrix(ARotMatrix: TFMatrix);
    procedure GetExtents(var AMin, AMax: array of TsgFloat);
    property CADSpace: TsgCADSpace read FCADSpace write FCADSpace;
    property ExtMax: TFPoint read GetExtMax;
    property ExtMin: TFPoint read GetExtMin;
    property Index: Integer read GetIndex;
    property IsEmpty: Boolean read GetEmpty;
    property IsModel: Boolean read GetIsModel;
    property LimMax: TFPoint read FLimMax write FLimMax;
    property LimMin: TFPoint read FLimMin write FLimMin;
    property PaperSpaceBlock: TsgDXFBlock read GetPaperSpaceBlock write SetPaperSpaceBlock;
    property PlotSettings: TsgDXFPlotSettings read FPlotSettings write SetPlotSettings;
{$IFDEF SG_VERSION_OLD}
    property PlotPaperUnits: Integer read GetPlotPaperUnits write SetPlotPaperUnits;
{$ENDIF}
    property RotZAngle: Double read FRotZAngle write FRotZAngle;
    property UCSOrigin: TFPoint read FUCSOrigin write FUCSOrigin;
    property UCSXDir: TFPoint read FUCSXDir write FUCSXDir;
    property UCSYDir: TFPoint read FUCSYDir write FUCSYDir;
  end;

  TsgCADCustomRectangle = class(TsgCADBasePolyline)
  private
    FClippingBoundaryType: Byte;
    FClipPoints: TF2DPointList;
    FSize: TFPoint;
    FUseClipping: Boolean;
    FUVector: TFPoint;
    FVVector: TFPoint;
    procedure CheckUVVectors;
    function GetClipPointsCount: Integer;
    function GetPoint1: TFPoint;
    function GetPoint2: TFPoint;
    function GetPoint3: TFPoint;
    procedure SetPoint1(const AValue: TFPoint);{$IFDEF USE_INLINE} inline;{$ENDIF}
    procedure SetPoint2(const AValue: TFPoint);{$IFDEF USE_INLINE} inline;{$ENDIF}
    procedure SetPoint3(const AValue: TFPoint);{$IFDEF USE_INLINE} inline;{$ENDIF}
  protected
    procedure ChangeSizes(K: Double);
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample;
      const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    function GetClosed: Boolean; override;
    function GetHeight: Double;
    function GetMatrix: TFMatrix;
    function GetPointInternal(X, Y: Double): TFPoint;
    function GetWidth: Double;
    function GetWipeOutClipPoint(const AParam: Double; const APoint: TFPoint): TF2DPoint;
    function GetWipeOutParam: Double;
    procedure ReloadPolyPoints(const AConverter: TsgDXFConverter); override;
    procedure SetClosed(const AClosed: Boolean); override;
    procedure SetHeight(const AValue: Double);
    procedure SetHeightInternal(const AValue: Double);
    procedure SetWidth(const AValue: Double);
    procedure SetWidthInternal(const AValue: Double);
    function ToXMLNode(const ANode: TsgNode;
      const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure AddPoint(X, Y: Double); overload;
    procedure AddPoint(const APoinst: TFPoint); overload;
    property ClippingBoundaryType: Byte read FClippingBoundaryType write FClippingBoundaryType;
    property ClipPoints: TF2DPointList read FClipPoints;
    property ClipPointsCount: Integer read GetClipPointsCount;
    property Height: Double read GetHeight write SetHeight;
    property Point1: TFPoint read GetPoint1 write SetPoint1;
    property Point2: TFPoint read GetPoint2 write SetPoint2;
    property Point3: TFPoint read GetPoint3 write SetPoint3;
    property Size: TFPoint read FSize write FSize;
    property UseClipping: Boolean read FUseClipping write FUseClipping;
    property UVector: TFPoint read FUVector write FUVector;
    property VVector: TFPoint read FVVector write FVVector;
    property Width: Double read GetWidth write SetWidth;
  end;

  TsgCADWipeout = class(TsgCADCustomRectangle)
  protected
    function GetEntType: TsgCADEntities; override;
  public
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
  end;

  TsgDXFImageDef = class(TsgDXFOwneredItem)
  private
    FPicture: TPicture;
    FFileName: string;
    FReferences: TsgList;
    function GetReferences: TsgList;
    procedure UpdateReferences(AResetPictureRef: Boolean; AImageEnts: TsgList);
    function LoadImageInternal(const AResolve: Boolean): Boolean;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetSize: TFPoint;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property PictureRef: TPicture read FPicture write FPicture;
    class function GetGraphicParams(AGraphic: TPersistent;
      var ATransparentColor: TColor; var AMonochrome: Boolean;
      var ATransparency: Boolean): TFPoint;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function EntName: string; override;
    property FileName: String read FFileName write FFileName;
    property Picture: TPicture read FPicture;
    property Size: TFPoint read GetSize;
    property References: TsgList read GetReferences;
  end;

  TsgDXFImageEnt = class(TsgCADCustomRectangle)
  private
    FFlagsEx: Byte;
    FPicture: TPicture;
    FImageDef: TsgDXFImageDef;
    FTransparentColor: Cardinal;
    procedure SetMonoChrome;
    procedure SetMnChrome(const AValue: Boolean);
    function GetInternal: Boolean;
    function GetMnChrome: Boolean;
    function GetRotate: Double;
    procedure SetImageDef(const Value: TsgDXFImageDef);
    procedure SetInternal(const AValue: Boolean);
    procedure SetRotate(const Value: Double);
    procedure SetDefaultTransparentColor(const Image: TGraphic;
      const ImageDef: TsgDXFImageDef);
  protected
    FImageProperties: PsgImageProperties;
    FDirectExportConverImageToOLE: Boolean; //Only for Direct export using
    FDirectExportImageFileIndex: Integer;
{$IFNDEF  SG_FIREMONKEY}
    FBitMap: TGraphic;
{$ENDIF}
    FScaleMode: Integer;
{$IFDEF SG_USEGDIPLUS}
    FGDIPImage: TGPImage;
    procedure GDIPCreate;
    procedure GDIPFree;
{$ENDIF}
    procedure ChangeGraphic; virtual;
    procedure ConvertToBitmap(const ABitmap: TBitmap; const AMode: Integer);
{$IFNDEF SG_FIREMONKEY}
    procedure CreateImgLittle(const Scale: Integer);
{$ENDIF}
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure FreeGraphics;
{$IFNDEF SG_FIREMONKEY}
    procedure SetImgLittle(const ABitmap: TBitmap);
{$ENDIF}
    function DoRotate(const Angle: Double; const AConverter: TsgDXFConverter): Boolean;
    procedure DoRotateVectors(const Angle: Double);
    function GetAnimate: Boolean; virtual;
    function GetEmpty: Boolean;
    function GetEntType: TsgCADEntities; override;
    function GetTransparency: Boolean;
    function GetTransparentColor: Cardinal;
    function GetFileName: string;
    function GroupExists: Boolean; override;
    procedure GroupClear; override;
    function GroupCountEntities: Integer;
    function GroupFill(AConverter: TsgDXFConverter = nil): Boolean; override;
    function GroupHasAddedEntities: Boolean; override;
    function IsEmpty: Boolean; virtual;
    procedure SetTransparency(const Value: Boolean);
    procedure SetTransparentColor(const AValue: Cardinal);
    procedure UpdateBox; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function PictureUpdate(const ACADImage: TObject): Boolean; virtual;
    procedure RemoveReferenceNotification(const ARefObj: TsgDXFEntity); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    property ImageDefRef: TsgDXFImageDef read FImageDef write FImageDef; //only for internal using in the CADExport;
    property Internal: Boolean read GetInternal write SetInternal;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Clear(const ADoFree: Boolean = True); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function IsOnePixelOptimisationValid: Boolean; override; //evg
    function GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean; override;
    function EntName: string; override;
    procedure SetImage(Image: TGraphic);
    property Empty: Boolean read GetEmpty;
    property ImageDef: TsgDXFImageDef read FImageDef write SetImageDef;
    property IsMonoChrome: Boolean read GetMnChrome write SetMnChrome;
    property Picture: TPicture read FPicture;
    property Rotate: Double read GetRotate write SetRotate;
    property Transparency: Boolean read GetTransparency write SetTransparency;
    property TransparentColor: Cardinal read GetTransparentColor write SetTransparentColor;
  end;

  TsgDXFStyle = class(TsgDXFPenTableItem)
  private
    FFixedHeight: Double;
    FBigFont: string;
    FFontName: string;
    FPrimaryFont: string;
    FSHXStyle: TsgSHXTextStyle;
    FWidthFactor: Single;
    FLastHeightUsed: Single;
    FObliqueAngle: Single;
    FFontStyle: TmvFontStyles;
    FTextGenFlags: Byte;
    function GetBackward: Boolean;
    function GetUpsideDown: Boolean;
    procedure SetPrimaryFont(const AValue: string);
    procedure SetFontNameByPrimaryFont;
  protected
    FFontGlyphRef: TObject;
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure EndExtData(const AData: TsgCADExtendedData); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetBackward(const AValue: Boolean);
    procedure SetUpsideDown(const AValue: Boolean);
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    procedure UpdateFontGlyphRef(ACharset: TFontCharset; APitch: Byte);
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function GetPrimaryFontName: string;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    property Backward: Boolean read GetBackward write SetBackward;
    property BigFont: string read FBigFont write FBigFont;
    property FixedHeight: Double read FFixedHeight write FFixedHeight;
    property FontName: string read FFontName write FFontName;
    property FontStyle: TmvFontStyles read FFontStyle write FFontStyle;
    property LastHeightUsed: Single read FLastHeightUsed write FLastHeightUsed;
    property ObliqueAngle: Single read FObliqueAngle write FObliqueAngle;
    property PrimaryFont: string read FPrimaryFont write SetPrimaryFont;
    property SHXStyle: TsgSHXTextStyle read FSHXStyle write FSHXStyle;
    property TextGenFlags: Byte read FTextGenFlags write FTextGenFlags;
    property WidthFactor: Single read FWidthFactor write FWidthFactor;
    property UpsideDown: Boolean read GetUpsideDown write SetUpsideDown;
  end;

  TTableSubclassMarker = (AcDbEntity, AcDbBlockReference, AcDbTable);

  TsgEnumCellsProc = function(ACol, ARow: Integer; AParam: Pointer): Boolean of object;

(*$HPPEMIT 'struct TRange;'*)
(*$HPPEMIT 'typedef TRange *PRange;'*)

(*$HPPEMIT '#pragma pack(push,1)  '*)
(*$HPPEMIT 'struct TRange         '*)
(*$HPPEMIT '{                     '*)
(*$HPPEMIT 'union                 '*)
(*$HPPEMIT '{                     '*)
(*$HPPEMIT '		struct            '*)
(*$HPPEMIT '		{                 '*)
(*$HPPEMIT '			int Start[2];   '*)
(*$HPPEMIT '			int Finish[2];  '*)
(*$HPPEMIT '		};                '*)
(*$HPPEMIT '		struct            '*)
(*$HPPEMIT '		{                 '*)
(*$HPPEMIT '#ifdef __BORLANDC__'*)
(*$HPPEMIT '	#if (__BORLANDC__ >= 0x0640)'*)
(*$HPPEMIT '  			System::Types::TRect R;'*)
(*$HPPEMIT '	#else'*)
(*$HPPEMIT '  			Types::TRect R;'*)
(*$HPPEMIT '	#endif'*)
(*$HPPEMIT '#else'*)
(*$HPPEMIT '  			TRect R;'*)
(*$HPPEMIT '#endif'*)
(*$HPPEMIT '		}*RANGE;                '*)
(*$HPPEMIT '	};                  '*)
(*$HPPEMIT '} ;                   '*)
(*$HPPEMIT '#pragma pack(pop)     '*)

  PRange = ^TRange;
  {$EXTERNALSYM PRange}
  TRange = packed record
  case Integer of
    0: (R: TRect);
    1: (Start, Finish: array[Boolean] of Integer);
  end;
  {$EXTERNALSYM TRange}

  TsgBorderProp = (bpColor, bpLineweight, bpVisible);

  PsgCellBorderParam = ^TsgCellBorderParam;
  TsgCellBorderParam = packed record
    Color: TsgColorCAD;
    LineWeight: Double;
    Visible: Boolean;
  end;

  TsgAcadTableCellType = (cttData, cttTitle, cttHeader);

  TsgCellProp = (cpCellAllignment, cpBkColorOn, cpTextStyle,
    cpTextColor, cpDataType, cpFillColor, cpUnitType);

  TsgAcadTableCellStyle = class;

  TsgAcadTableCell = class(TPersistent)
  private
    FAcadTable: TsgDXFAcadTable;
    FAttdefHandle: UInt64;
    FAttdefValue: string;
    FAutoFit: Boolean;
    FBlockRecordHandle: UInt64;
    FBlockScale: Single;
    FCellProps: TsgAcadTableCellStyle;
    FCellType: TsgAcadTableCellType;
    FCol: Integer;
    FField: TsgDXFField;
    FFlags: Integer;
    FIsTextType: Boolean;
    FMergedHeight: Integer;
    FMergedValue: Integer;
    FMergedWidth: Integer;
    FNumAttdefs: Integer;
    FOverrideFlag: Integer;
    FRotation: Single;
    FRow: Integer;
    FSpanX: Integer;
    FSpanY: Integer;
    FText: string;
    FVirtualEgdeFlag: Boolean;
    function GetBaseCell: TsgAcadTableCell;
    function GetBaseCellRange: TRect;
    function GetBkColorOn: Boolean;
    function GetBorderColor(Index: Integer): TsgColorCAD;
    function GetBorderLineWeight(Index: Integer): Double;
    function GetBorderPropOverridenMask(const ABorderProp: TsgBorderProp;
      const AIndex: Integer): Integer;
    function GetBorderVisible(Index: Integer): Boolean;
    function GetCellAlignment: Integer;
    function GetCellRange: TRect;
    function GetCellType: TsgAcadTableCellType;
    function GetDataType: Integer;
    function GetFillColor: TsgColorCAD;
    function GetFlags: Integer;
    function GetIsBaseCell: Boolean;
    function GetMerged: Boolean;
    function GetOwnerStyle: TsgAcadTableCellStyle;
    function GetTextColor: TsgColorCAD;
    function GetTextHeight: Double;
    function GetTextStyle: TsgDXFStyle;
    function GetUnitType: Integer;
    function IsBorderColorOverriden(const AIndex: Integer): Boolean;
    function IsBorderLineweightOverriden(const AIndex: Integer): Boolean;
    function IsBorderPropOverriden(const ABorderProp: TsgBorderProp;
      const AIndex: Integer): Boolean;
    function IsBorderVisibleOverriden(const AIndex: Integer): Boolean;
    procedure SetAttdefHandle(const AValue: UInt64);
    procedure SetAttdefValue(const AValue: string);
    procedure SetAutoFit(const AValue: Boolean);
    procedure SetBkColorOn(const AValue: Boolean);
    procedure SetBlockRecordHandle(const AValue: UInt64);
    procedure SetBlockScale(const AValue: Single);
    procedure SetBorderColor(Index: Integer; const AValue: TsgColorCAD);
    procedure SetBorderLineWeight(Index: Integer; const AValue: Double);
    procedure SetBorderVisible(Index: Integer; const AValue: Boolean);
    procedure SetCellAlignment(const AValue: Integer);
    procedure SetCellType(const AValue: TsgAcadTableCellType);
    procedure SetDataType(const AValue: Integer);
    procedure SetField(const AValue: TsgDXFField);
    procedure SetFillColor(const AValue: TsgColorCAD);
    procedure SetFlags(const AValue: Integer);
    procedure SetIsBaseCell(const AValue: Boolean);
    procedure SetIsTextType(const AValue: Boolean);
    procedure SetMergedHeight(const AValue: Integer);
    procedure SetMergedValue(const AValue: Integer);
    procedure SetMergedWidth(const AValue: Integer);
    procedure SetNumAttdefs(const AValue: Integer);
    procedure SetOverrideFlag(const AValue: Integer);
    procedure SetRotation(const AValue: Single);
    procedure SetText(const AValue: string);
    procedure SetTextColor(const AValue: TsgColorCAD);
    procedure SetTextHeight(const AValue: Double);
    procedure SetTextStyle(const AValue: TsgDXFStyle);
    procedure SetUnitType(const AValue: Integer);
    procedure SetVirtualEgdeFlag(const AValue: Boolean);
    function StyleByProp(const ACellProp: TsgCellProp): TsgAcadTableCellStyle;
    procedure UpdateFlags(const AIndex: Integer);
  protected
    function HasOwnerStyle: Boolean;
    function IsBorderEq(const AIndex: Integer;
      const ACell: TsgAcadTableCell): Boolean;
    function IsBorderEqEx(const AIndex: Integer;
      const AAdjacentCell: TsgAcadTableCell;
      const AAdjacentIndex: Integer): Boolean;
    function IsPropInit(const ACellProp: TsgCellProp): Boolean;
    function GenerateMText(const AConv: TsgDXFConverter;
      const AAcadTable: TsgDXFAcadTable): TsgDXFMText;
    function GetFlagsMask(AIndex: Integer): Integer;
    procedure Link(AConverter: TsgDXFConverter); virtual;
    property CellProps: TsgAcadTableCellStyle read FCellProps;
  public
    constructor Create(AAcadTable: TsgDXFAcadTable; const ACol, ARow: Integer;
      const ACellType: TsgAcadTableCellType = cttData);
    destructor Destroy; override;
    procedure Assign(ASource: TPersistent); override;
    function GetRect: TFRect;
    function GetMergedRect: TFRect;
    property AcadTable: TsgDXFAcadTable read FAcadTable;
    property AutoFit: Boolean read FAutoFit write SetAutoFit;
    property AttdefHandle: UInt64 read FAttdefHandle write SetAttdefHandle;
    property AttdefValue: string read FAttdefValue write SetAttdefValue;
    property BaseCell: TsgAcadTableCell read GetBaseCell;
    property BkColorOn: Boolean read GetBkColorOn
      write SetBkColorOn;
    property BlockRecordHandle: UInt64 read FBlockRecordHandle
      write SetBlockRecordHandle;
    property BlockScale: Single read FBlockScale write SetBlockScale;
    property BorderColor[Index: Integer]: TsgColorCAD read GetBorderColor
      write SetBorderColor;
    property BorderLineWeight[Index: Integer]: Double read GetBorderLineWeight
      write SetBorderLineWeight;
    property BorderVisible[Index: Integer]: Boolean read GetBorderVisible
      write SetBorderVisible;
    property BaseCellRange: TRect read GetBaseCellRange;
    property Col: Integer read FCol;
    property CellAlignment: Integer read GetCellAlignment write SetCellAlignment;
    property CellType: TsgAcadTableCellType read GetCellType write SetCellType;
    property CellRange: TRect read GetCellRange;
    property DataType: Integer read GetDataType write SetDataType;
    property Field: TsgDXFField read FField write SetField;
    property FillColor: TsgColorCAD read GetFillColor write SetFillColor;
    property Flags: Integer read GetFlags write SetFlags;
    property IsBaseCell: Boolean read GetIsBaseCell write SetIsBaseCell;
    property IsTextType: Boolean read FIsTextType write SetIsTextType;
    property Merged: Boolean read GetMerged;
    property MergedHeight: Integer read FMergedHeight write SetMergedHeight;
    property MergedValue: Integer read FMergedValue write SetMergedValue;
    property MergedWidth: Integer read FMergedWidth write SetMergedWidth;
    property NumAttdefs: Integer read FNumAttdefs write SetNumAttdefs;
    property OverrideFlag: Integer read FOverrideFlag write SetOverrideFlag;
    property Rotation: Single read FRotation write SetRotation;
    property Row: Integer read FRow;
    property SpanX: Integer read FSpanX write FSpanX;
    property SpanY: Integer read FSpanY write FSpanY;
    property Text: string read FText write SetText;
    property TextColor: TsgColorCAD read GetTextColor write SetTextColor;
    property TextHeight: Double read GetTextHeight write SetTextHeight;
    property TextStyle: TsgDXFStyle read GetTextStyle write SetTextStyle;
    property UnitType: Integer read GetUnitType write SetUnitType;
    property VirtualEgdeFlag: Boolean read FVirtualEgdeFlag write
      SetVirtualEgdeFlag;
  end;

  TsgDXFAcadTable = class(TsgDXFInsert)
  private
    FColWidth: TsgDoubleList;
    FFlags: Integer;
    FOverrideFlags: Byte;
    FProperties: TsgDXFAcadTableStyle;
    FRowHeight: TsgDoubleList;
    FRows: TsgObjectList;
    FStyleRef: TsgDXFAcadTableStyle;
    function GetBaseCell(ACol, ARow: Integer): TsgAcadTableCell;
    function GetCell(ACol, ARow: Integer): TsgAcadTableCell;
    function GetColWidth(Index: Integer): Double;
    function GetNumCols: Integer;
    function GetNumRows: Integer;
    function GetPropertiesAcadTableStyle: TsgDXFAcadTableStyle;
    function GetRowHeight(Index: Integer): Double;
    function GetSizes(ANeedRowSize: Boolean; Index: Integer): Double;
    function GetStyle: TsgDXFAcadTableStyle;
    procedure SetCell(ACol, ARow: Integer; const AValue: TsgAcadTableCell);
    procedure SetColWidth(Index: Integer; const AValue: Double);
    procedure SetNumCols(const AValue: Integer);
    procedure SetNumRows(const AValue: Integer);
    procedure SetOverrideFlags(const AValue: Byte);
    procedure SetProperties(const AValue: TsgDXFAcadTableStyle);
    procedure SetRowHeight(Index: Integer; const AValue: Double);
    procedure SetSizes(ANeedRowSize: Boolean; Index: Integer; const AValue: Double);
    procedure SetStyle(const AValue: TsgDXFAcadTableStyle);
    { Enumeration handlers }
    function AssignCell(ACol, ARow: Integer; AParam: Pointer): Boolean;
    function MergeCell(ACol, ARow: Integer; AParam: Pointer): Boolean;
    function SetCellTextStyle(ACol, ARow: Integer; AParam: Pointer): Boolean;
    function SplitCell(ACol, ARow: Integer; AParam: Pointer): Boolean;
  protected
    FLockGenerateBlock: Boolean;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function CreateBlock(AConv: TsgDXFConverter): TsgDXFBlock;
    function EnumCells(AEnumCellsProc: TsgEnumCellsProc; AParam: Pointer): Boolean;
    function EnumRange(ARange: TRect; AEnumCellsProc: TsgEnumCellsProc;
      AParam: Pointer): Boolean;
    function GenerateMText(const AConv: TsgDXFConverter; ACol, ARow: Integer): TsgDXFMText;
    function GetEntType: TsgCADEntities; override;
    function GetFlags: Integer; override;
    function GetUniqueBlockName(const AConv: TsgDXFConverter): string;
    function IsBlockInternal: Boolean;
    function ReleaseBlock: TsgDXFBlock;
    procedure SetFlags(const AValue: Integer); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
    procedure ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord); override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    procedure Clear(const ADoFree: Boolean = True); override;
    procedure MergeCells(const ACol, ARow, ASpanX, ASpanY: Integer);
    procedure SplitCells(ACol, ARow: Integer);

    function AddCol: Integer;
    function AddRow: Integer;
    procedure DeleteCol(ACol: Integer);
    procedure DeleteCols(AColFrom, AColTo: Integer);
    procedure DeleteRow(ARow: Integer);
    procedure DeleteRows(ARowFrom, ARowTo: Integer);
    procedure InsertRow(AIndex: Integer);
    procedure InsertCol(AIndex: Integer);

    procedure Resize(const AColCount, ARowCount: Integer);
    property BaseCell[ACol, ARow: Integer]: TsgAcadTableCell read GetBaseCell;
    property Cell[ACol, ARow: Integer]: TsgAcadTableCell read GetCell write SetCell;
    property ColWidth[Index: Integer]: Double read GetColWidth write SetColWidth;
    property NumCols: Integer read GetNumCols write SetNumCols;
    property NumRows: Integer read GetNumRows write SetNumRows;
    property OverrideFlags: Byte read FOverrideFlags write SetOverrideFlags;
    property Properties: TsgDXFAcadTableStyle read GetPropertiesAcadTableStyle write SetProperties;
    property RowHeight[Index: Integer]: Double read GetRowHeight write SetRowHeight;
    property Sizes[ANeedRowSize: Boolean; Index: Integer]: Double read GetSizes write SetSizes;
    property Style: TsgDXFAcadTableStyle read GetStyle write SetStyle;
  end;

  TsgAcadTableCellStyle = class(TPersistent)
  private
    FAcadTableStyle: TsgDXFAcadTableStyle;
    FBkColorOn: Boolean;
    FBorderParams: TList;
    FCellAlignment: Integer;
    FCellType: TsgAcadTableCellType;
    FDataType: Integer;
    FFillColor: TsgColorCAD;
    FCellInitProps: set of TsgCellProp;
    FTextColor: TsgColorCAD;
    FTextHeight: Double;
    FTextStyleItem: TsgTableItem;
    FUnitType: Integer;
    function GetBorderColor(Index: Integer): TsgColorCAD;
    function GetBorderCount: Integer;
    function GetBorderLineWeight(Index: Integer): Double;
    function GetBorderVisible(Index: Integer): Boolean;
    function GetTextStyle: TsgDXFStyle;
    procedure SetBkColorOn(const AValue: Boolean);
    procedure SetBorderColor(Index: Integer; const AValue: TsgColorCAD);
    procedure SetBorderLineWeight(Index: Integer; const AValue: Double);
    procedure SetBorderVisible(Index: Integer; const AValue: Boolean);
    procedure SetCellAlignment(const AValue: Integer);
    procedure SetCellType(const AValue: TsgAcadTableCellType);
    procedure SetDataType(const AValue: Integer);
    procedure SetFillColor(const AValue: TsgColorCAD);
    procedure SetTextColor(const AValue: TsgColorCAD);
    procedure SetTextHeight(const AValue: Double);
    procedure SetTextStyle(const AValue: TsgDXFStyle);
    procedure SetUnitType(const AValue: Integer);
  protected
    function IsPropInit(const ACellProp: TsgCellProp): Boolean;
    procedure SetPropInit(const ACellProp: TsgCellProp; const AInclude: Boolean);
    procedure Link(AConverter: TsgDXFConverter); virtual;
  public
    constructor Create(AAcadTableStyle: TsgDXFAcadTableStyle); overload;
    constructor Create(AAcadTableStyle: TsgDXFAcadTableStyle;
      const ACellType: TsgAcadTableCellType); overload;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property AcadTableStyle: TsgDXFAcadTableStyle read FAcadTableStyle;
    property BkColorOn: Boolean read FBkColorOn
      write SetBkColorOn;
    property BorderColor[Index: Integer]: TsgColorCAD read GetBorderColor
      write SetBorderColor;
    property BorderCount: Integer read GetBorderCount;
    property BorderLineWeight[Index: Integer]: Double read GetBorderLineWeight
      write SetBorderLineWeight;
    property BorderVisible[Index: Integer]: Boolean read GetBorderVisible
      write SetBorderVisible;
    property CellAlignment: Integer read FCellAlignment write SetCellAlignment;
    property CellType: TsgAcadTableCellType read FCellType write SetCellType;
    property DataType: Integer read FDataType write SetDataType;
    property FillColor: TsgColorCAD read FFillColor write SetFillColor;
    property TextStyle: TsgDXFStyle read GetTextStyle write SetTextStyle;
    property TextColor: TsgColorCAD read FTextColor write SetTextColor;
    property TextHeight: Double read FTextHeight write SetTextHeight;
    property UnitType: Integer read FUnitType write SetUnitType;
  end;

  TsgDXFAcadTableStyle = class(TsgDXFOwneredItem)
  private
    FCellStyle: array[TsgAcadTableCellType] of TsgAcadTableCellStyle;
    FFlags: Integer;
    FFlowDirection: Integer;
    FHeaderSuppressed: Boolean;
    FHorzCellMargin: Double;
    FTitleSuppressed: Boolean;
    FVertCellMargin: Double;
    function GetCellStyle(Index: TsgAcadTableCellType): TsgAcadTableCellStyle;
    procedure SetCellStyle(Index: TsgAcadTableCellType;
      const AValue: TsgAcadTableCellStyle);
    procedure SetFlowDirection(const AValue: Integer);
    procedure SetHeaderSuppressed(const AValue: Boolean);
    procedure SetHorzCellMargin(const AValue: Double);
    procedure SetTitleSuppressed(const AValue: Boolean);
    procedure SetVertCellMargin(const AValue: Double);
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetLinkClass: TsgOwneredItemClass; override;
    function GetFlags: Integer; override;
    procedure SetFlags(const Value: Integer); override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property HeaderSuppressed: Boolean read FHeaderSuppressed
      write SetHeaderSuppressed;
    property FlowDirection: Integer read FFlowDirection write SetFlowDirection;
    property HorzCellMargin: Double read FHorzCellMargin
      write SetHorzCellMargin;
    property TitleSuppressed: Boolean read FTitleSuppressed
      write SetTitleSuppressed;
    property VertCellMargin: Double read FVertCellMargin
      write SetVertCellMargin;
    property CellStyle[Index: TsgAcadTableCellType]: TsgAcadTableCellStyle
      read GetCellStyle write SetCellStyle;
  end;

  TsgDXFProxy = class(TsgDXFPenLine)
  private
    FBox: TFRect;
    FEntities: TsgEntitiesList;
  protected
    function CanAddedToXMLParams: Boolean; override;
    procedure FreeReferences; override;
    function GetBox: TFRect; override;
    function GetCount: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    function GetEntType: TsgCADEntities; override;
    procedure Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc); override;
    function GroupExists: Boolean; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;
    procedure UpdateBox; override;
  public
    constructor Create; override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
  end;

  TsgDXFMesh = class(TsgDXFProxy)
  private
    FVertices: TFPointList;
    FVertexIndices: TsgIntegerList;
    FTexCoords: TFPointList;
    procedure SetTexCoords(const Value: TFPointList);
    procedure SetVertexIndices(const Value: TsgIntegerList);
    procedure SetVertices(const Value: TFPointList);
  protected
    procedure FreeReferences; override;
    function GetEntType: TsgCADEntities; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    { GetFaceIndices:
      AInlineFaceIndices - array of PsgInlineFace where Item is
        TsgInlineFace - sizeof(TsgInlineFace.Count) == TsgVertexIndices;
      ACountIndicesByFace - if positive then count of all faces; 0 - closure face;
       if ngative, then -(ACountIndicesByFace+1) - count vertices of first face;
      Result - faces count }
    function GetFaceIndices(out AInlineFaceIndices: TsgInlineFaceIndices;
      ACountIndicesByFace: PInteger = nil): Integer;
    function GroupExists: Boolean; override;
    procedure UpdateBox; override;
  public
    constructor Create; override;
    { ExtractFaceIndices - fill AVertexIndices array, nil to calc count of triangles
      AVertexIndices - pointer to array of trialgle indices
      Result - count of triangles }
    function ExtractFaceIndices(AVertexIndices: Pointer): Integer;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    property Vertices: TFPointList read FVertices write SetVertices;
    property VertexIndices: TsgIntegerList read FVertexIndices write SetVertexIndices;
    property TexCoords: TFPointList read FTexCoords write SetTexCoords;
  end;

{ TsgFlatEntity }

  TsgFlatEntity = class(TsgDXFObjectEntityColor)
  private
    FBox: TFRect;
    FCounts: TsgIntegerList;
    FPoints: TsgBaseList;
    function GetXYLast: TFPoint;
  protected
    procedure AddFPoint(const APoint: TFPoint);
    procedure AddLine(const ALine: TsgDXFLine);
    procedure AddPoint(const X, Y: Double;
      const Z: Double = 0); virtual;
    procedure AddPoints(const APoints: TFPointList;
      const AClosed: Boolean; const ABox: PFRect = nil);
    procedure AddPolygon(P: TsgCADPolyPolygon);
    procedure AddPolyline(P: TsgCADBasePolyline);
    function CanDraw: Boolean; override;
    function CanHaveHandle: Boolean; override;
    procedure CopyProperty(const AEntity: TsgDXFEntity);
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function GetBox: TFRect; override;
    function GetXY(Index: Integer): TFPoint; virtual;
    function GetPointsSignleList: TsgSingleList; virtual;
    function GetPointsClass: TClass; virtual;
    function GroupExists: Boolean; override;
    function GroupFill(AConverter: TsgDXFConverter = nil): Boolean; override;
    function GroupHasAddedEntities: Boolean; override;
    procedure SetBox(const ABox: TFRect);
    procedure SetHandle(const Value: UInt64); override;
    procedure SetXY(Index: Integer; const Value: TFPoint); virtual;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure ReCalcBox;
    procedure PoinsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams); virtual;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function Accepts(const AEntity: TsgDXFEntity): Boolean; virtual;
    function Add(const AEntity: TsgDXFEntity): Boolean;
    function AddSegment(const APoints: TFPointList; const AMerge: Boolean): Boolean;
    function AddSegmentPoint(const APoint: TFPoint; const ACreateNewSegment: Boolean = False): Integer;
    function PCount: Integer; virtual;
    property Counts: TsgIntegerList read FCounts;
    property Points: TsgSingleList read GetPointsSignleList;
    property XY[Index: Integer]: TFPoint read GetXY write SetXY;
    property XYLast: TFPoint read GetXYLast;
  end;

  TsgFlatEntity2D = class(TsgFlatEntity)
  protected
    procedure AddPoint(const X, Y: Double; const Z: Double = 0); override;
    function GetPointsSignleList: TsgSingleList; override;
    function GetPointsClass: TClass; override;
    function GetXY(Index: Integer): TFPoint; override;
    procedure SetXY(Index: Integer; const Value: TFPoint); override;
  public
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
    function PCount: Integer; override;
    property Points: TsgSingleList read GetPointsSignleList;
  end;

  TsgFlatPoly = class(TsgFlatEntity2D)
  private
    FLineWeight: Double;
  protected
    function GetEntType: TsgCADEntities; override;
    function GetLineWeight: Double; override;
    function GetThicknessInt: Double; override;
    function GroupFill(AConverter: TsgDXFConverter): Boolean; override;
    procedure SetLineWeight(Value: Double); override;
    procedure SetThicknessInt(const AValue: Double); override;
    procedure PoinsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams); override;
  public
    function Accepts(const AEntity: TsgDXFEntity): Boolean; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
  end;

  TsgFlatHatch = class(TsgFlatEntity2D)
  protected
    function GetEntType: TsgCADEntities; override;
    function GroupFill(AConverter: TsgDXFConverter = nil): Boolean; override;
    procedure PoinsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams); override;
  public
    function Accepts(const AEntity: TsgDXFEntity): Boolean; override;
  end;

  TsgFlatPoly3D = class(TsgFlatPoly)
  protected
    procedure AddPoint(const X, Y: Double; const Z: Double = 0); override;
    function GetXY(Index: Integer): TFPoint; override;
    function GetEntType: TsgCADEntities; override;
    function GetPointsSignleList: TsgSingleList; override;
    function GetPointsClass: TClass; override;
    procedure SetXY(Index: Integer; const Value: TFPoint); override;
  public
    function PCount: Integer; override;
  end;

  TsgSVGInsert = class(TsgDXFInsert)
  private
    FPrevMatrix: PFMatrix;
  protected
    procedure FreeReferences; override;
    procedure InitializeMatrix; override;
  public
    procedure AssignEntity(Source: TsgDXFEntity); override;
    function GetInitMatrix: TFMatrix;
    procedure SetInitMatrix(const AMatrix: TFMatrix);
  end;

  TsgSVGMText = class(TsgSVGInsert)
  protected
    procedure CopyItems(const ASource: TsgDXFEntity); override;
    procedure DoDelayedLoad(AConverter: TsgDXFConverter); override;
    procedure ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord); override;
  public
    constructor Create; override;
  end;

{$IFDEF SG_BTI}
  TsgCADPolyPolyline2D = class(TsgDXFObjectEntityLineType)
  private
    FBox: PFRect;
    FDotSingPts: TFPointList;
    FCurves: TList;
    FBoundaries: TsgObjectList;
    FLineWeight: Double;
    FOwner: TsgDXFEntity;
    FCurvesVisibleCount: Integer;
  protected
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    function CanDraw: Boolean; override;
    function GetBox: TFRect; override;
    function GetDotSingPts: TFPointList; virtual;
    function GetCurveFlags(const AIndex: Integer): TsgCurveProperties;
    function GetEntType: TsgCADEntities; override;
    function GetArc(const AIndex: Integer): TsgArcR;
    function GetLine(const AIndex: Integer): TsgLine;
    function GetCurvesCount: Integer;
    function GetCurveJoin(const AIndex: Integer): Boolean;
    function GetCurvesVisible(const AIndex: Integer): Boolean;
    function GetLineWeight: Double; override;
    function GetOwner: TsgDXFEntity; override;
    function GroupExists: Boolean; override;
    function GroupFill(AConverter: TsgDXFConverter = nil): Boolean; override;
    function GroupHasAddedEntities: Boolean; override;
    function IsLoaded: Boolean;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure LoadBoundary(AConverter: TsgDXFConverter);
    procedure LoadHatch(const AHatch: TsgCADCurvePolygon;
      const AUseBoundaries: Boolean = False);
    procedure SetCurveFlags(const AIndex: Integer; const Value: TsgCurveProperties);
    procedure SetArc(const AIndex: Integer; const Value: TsgArcR);
    procedure SetLines(const AIndex: Integer; const Value: TsgLine);
    procedure SetCurveJoin(const AIndex: Integer; const Value: Boolean);
    procedure SetLineVisible(const AIndex: Integer; const Value: Boolean);
    procedure SetLineWeight(Value: Double); override;
    procedure SetHandle(const Value: UInt64); override;
    procedure SetOwner(const Value: TsgDXFEntity); override;
    procedure ClearBox;
    procedure ClearBoundary;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure AddCoords(const X1, Y1, X2, Y2: Double; const AFlags: TsgCurveProperties);
    procedure AddPoints(const AP1, AP2: TFPoint; const AFlags: TsgCurveProperties);
    procedure AddLine(const Value: TsgLine; const AFlags: TsgCurveProperties);
    procedure AddArc(const Arc: TsgArcR; const AFlags: TsgCurveProperties);
    procedure AddArcCoords(const X, Y, R, A1, A2: Double; const AFlags: TsgCurveProperties);
    procedure AddArcPoints(const AP: TFPoint; const R, A1, A2: Double; const AFlags: TsgCurveProperties);
    procedure Clear(const ADoFree: Boolean = True); override;
    procedure DeleteCurve(const AIndex: Integer);
    procedure GetBoundary(const AList: TList);
    function GetPointsOfArc(const AIndex: Integer;
      const A3DPointsList: TFPointList; const AContext: TsgProxyBase2D;
      NumberPart: Integer): Integer;
    function IsCurveArc(const AIndex: Integer): Boolean;
    property Boundaries: TsgObjectList read FBoundaries;
    property DotSingPts: TFPointList read GetDotSingPts;
    property LineType: TsgDXFLineType read GetLineType write SetLineType;
    property Arcs[const AIndex: Integer]: TsgArcR read GetArc write SetArc;
    property Lines[const AIndex: Integer]: TsgLine read GetLine write SetLines;
    property Flags[const AIndex: Integer]: TsgCurveProperties read GetCurveFlags write SetCurveFlags;
    property CurveJoin[const AIndex: Integer]: Boolean read GetCurveJoin write SetCurveJoin;
    property CurveVisible[const AIndex: Integer]: Boolean read GetCurvesVisible write SetLineVisible;
    property CurvesCount: Integer read GetCurvesCount;
    property CurvesVisibleCount: Integer read FCurvesVisibleCount;
  end;

  TsgAttributeData = class
  private
    FValues: TStringList;
    FFlags: Integer;
    function GetFlagsInt: Integer;
    function GetDeletable: Boolean;
    function GetRequiredField: Boolean;
    function GetReadOnly: Boolean;
    function GetVisible: Boolean;
    procedure SetFlagsInt(const AValue: Integer);
    procedure SetDeletable(const AValue: Boolean);
    procedure SetRequiredField(const AValue: Boolean);
    procedure SetReadOnly(const AValue: Boolean);
    procedure SetVisible(const AValue: Boolean);
  protected
    property Flags: Integer read GetFlagsInt write SetFlagsInt;
  public
    AttribType: TsgAttribType;
    Name: string;
    Value: string;
    Point: TFPoint;
    constructor Create;
    destructor Destroy; override;
    procedure Assign(const AData: TsgAttributeData);
    procedure FromNode(const ANode: TsgNode);
    procedure ToNode(const ANode: TsgNode);
    class function GetFlags(const ADeletable, ARequiredField, AReadOnly: Boolean): Integer;
    function CreateValues: TStringList;
    property RequiredField: Boolean read GetRequiredField write SetRequiredField;
    property IsReadOnly: Boolean read GetReadOnly write SetReadOnly;
    property Deletable: Boolean read GetDeletable write SetDeletable;
    property Visible: Boolean read GetVisible write SetVisible;
    property Values: TStringList read FValues;
  end;

  TsgAttrib = class(TsgDXFAttrib)
  private
    FIdValue: string;
    FClassifierName: string;
    FBTIFlags: Cardinal;
    FVertexData: sgConsts.PsgAttribVertex;
    FOwnerInsert: TsgDXFInsert;
    procedure VertexDataFree;
    procedure SetClassifierName(const AName: string);
  protected
    class function CreateVertexData: sgConsts.PsgAttribVertex;
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure EndExtData(const AData: TsgCADExtendedData); override;
    function GetAttribIndex: Integer;
    function GetExBlockData: TsgExtendedBlockData;
    function GetIndexValue: Integer;
    function GetValues: TStringList;
    function GetDeletable: Boolean; override;
    function GetReadOnly: Boolean; override;
    function GetRequiredField: Boolean; override;
    function GetIdValueIndex: Integer; override;
    function GetLinkVertex: TObject;
    function GetLinkIndex: Integer;
    function GetLinkState: Integer;
    function GetOwnerInsert: TsgDXFInsert; override;

    procedure SetValueInsp(const AValue: string);
    procedure SetIdValueByIndex(const AIndexInValues: Integer); override;
    procedure SetIdValue(const AID: string);
    procedure SetIndexValue(const AIndex: Integer);
    procedure SetValueInternal(const AValue: string);
    procedure SetDeletable(const AValue: Boolean);
    procedure SetReadOnly(const AValue: Boolean);
    procedure SetRequiredField(const AValue: Boolean);
    procedure SetLinkVertex(const AValue: TObject);
    procedure SetLinkIndex(const AValue: Integer);
    procedure SetLinkState(const AValue: Integer);
    procedure SetTypeValue(const AValue: TsgAttribType); override;
    procedure SetOwnerInsert(const AValue: TsgDXFInsert); override;

    property AttribIndex: Integer read GetAttribIndex;
    property ExBlockData: TsgExtendedBlockData read GetExBlockData;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure FromData(const AData: TsgAttributeData);
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
    function IsValueLinkOfFile: Boolean;
    property Values: TStringList read GetValues;
    property IndexValue: Integer read GetIndexValue write SetIndexValue;
    property IdValue: string read FIdValue write SetIdValue;
    property ClassifierName: string read FClassifierName write SetClassifierName;
    property IsReadOnly: Boolean read GetReadOnly write SetReadOnly;
    property Deletable: Boolean read GetDeletable write SetDeletable;
    property RequiredField: Boolean read GetRequiredField write SetRequiredField;
    property LinkVertex: TObject read GetLinkVertex write SetLinkVertex;
    property LinkIndex: Integer read GetLinkIndex write SetLinkIndex;
    property LinkState: Integer read GetLinkState write SetLinkState;
  end;

  TsgGroup = class(TsgDXFInsert)
  protected
    function AddBlock(const AConverter: TsgDXFConverter): Boolean;
    procedure AddBlockInConverter(const AConverter: TsgDXFConverter); virtual;
    function CanFreeBlock(AConverter: TsgDXFConverter): Boolean;
    function CanLoading(AConverter: TsgDXFConverter): Boolean;
    procedure CreateBlock;
    procedure ClearBlock; virtual;
    function FreeBlock: Boolean;
    function GetClassOfBlock: TsgDXFEntityClass; virtual;
    function ReMoveBlock(const AConverter: TsgDXFConverter): Boolean;
    procedure ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord); override;
    function ShortName: string; virtual;
  public
    constructor Create; override;
    destructor Destroy; override;
  end;

  TsgBlockOfLabel = class(TsgDXFBlock)
  end;

  TsgLabel = class(TsgGroup)
  private
    FConvWithBlockAdded: TsgDXFConverter;
    FFlags: Byte;
    FHeight: TsgFloat;
    FTextStyleItem: TsgTableItem;
    FTextLeft: string;
    FTextRight: string;
    FTextTop: string;
    FTextBottom: string;
    FTextOffset: TsgFloat;
    FEntOwner: TsgDXFEntity;
    function GenerateLabel(const AConverter: TsgDXFConverter): Boolean;
    function CreateText(const AText: string; const AConverter: TsgDXFConverter;
      const AMText: Boolean = False): TsgDXFCustomVertex;
  protected
    procedure AddBlockInConverter(const AConverter: TsgDXFConverter); override;
    function BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure EndExtData(const AData: TsgCADExtendedData); override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
{$IFDEF DEBUG}
    function DoSetBlockAfter(const ASetBlock: TsgDXFBlock): Integer; override;
    function DoSetBlockBefore(const ASetBlock: TsgDXFBlock): Integer; override;
    procedure SetConverter(const AConverter: TsgDXFConverter); override;
{$ENDIF}
    procedure SetMTextPropsFromOwner(const AMText: TsgDXFMText); virtual;
    function GetAlign: Byte;
    function GetActualBlockRecord: TsgDXFBlockRecord; override;
    function GetEntType: TsgCADEntities; override;
    function GetEntTypeEx: Integer; override;
    function GetHeight: TsgFloat;
    function GetTextLeft: string;
    function GetTextRight: string;
    function GetTextTop: string;
    function GetTextBottom: string;
    function GetTextLeftShow: string; virtual;
    function GetTextRightShow: string; virtual;
    function GetTextTopShow: string; virtual;
    function GetTextBottomShow: string; virtual;
    function GetShowSplitter: Boolean;
    function GetShowFrame: Boolean;
    function GetStyle: TsgDXFStyle;
    function GetTextOffset: TsgFloat;
    function GetEntClassEx: TsgEntClass; override;
    function GetClassOfBlock: TsgDXFEntityClass; override;
    function IsMText: Boolean; virtual;
    procedure SetAlign(const Value: Byte);
    procedure SetHeight(const Value: TsgFloat);
    procedure SetHeightExternal(const AValue: Double);
    procedure SetTextLeft(const Value: string);
    procedure SetTextRight(const Value: string);
    procedure SetTextTop(const Value: string);
    procedure SetTextBottom(const Value: string);
    procedure SetShowSplitter(const Value: Boolean);
    procedure SetShowFrame(const Value: Boolean);
    procedure SetStyle(const Value: TsgDXFStyle);
    procedure SetTextOffset(const Value: TsgFloat);
    procedure SetEntiyPropsFromOwner(const AEntity: TsgDXFEntity);
    function ShortName: string; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure Link(AConverter: TsgDXFConverter); override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure CopyFrom(Source: TsgLabel);
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; override;
    procedure SetExtData(const AData: TsgCADExtendedData); override;
    function ImportParamsFromBlockPattern(const APattern: TsgDXFBlock;
      const AScale: Double = 1): Boolean; virtual;
    function ExportParamsToBlockPattern(const APattern: TsgDXFBlock): Boolean; virtual;
    function EntName: string; override;
    property Align: Byte read GetAlign write SetAlign;
    property Height: TsgFloat read GetHeight write SetHeight;
    property EntOwner: TsgDXFEntity read FEntOwner write FEntOwner;
    property TextLeft: string read GetTextLeft write SetTextLeft;
    property TextRight: string read GetTextRight write SetTextRight;
    property TextTop: string read GetTextTop write SetTextTop;
    property TextBottom: string read GetTextBottom write SetTextBottom;
    property TextLeftShow: string read GetTextLeftShow;
    property TextRightShow: string read GetTextRightShow;
    property TextTopShow: string read GetTextTopShow;
    property TextBottomShow: string read GetTextBottomShow;
    property ShowFrame: Boolean read GetShowFrame write SetShowFrame;
    property ShowSplitter: Boolean read GetShowSplitter write SetShowSplitter;
    property Style: TsgDXFStyle read GetStyle write SetStyle;
    property TextOffset: TsgFloat read GetTextOffset write SetTextOffset;
  end;

  TsgAreaFigure = class
  private
    function GetArea: Double;
    function GetSign: Integer;
    procedure SetSign(const Value: Integer);
    function GetName: string;
    function GetPerimeter: Double;
    procedure SetKoef(const Value: Double);
    procedure SetEpsilon(const Value: Double);
  protected
    FFlags: Byte;
    FKoef: Double;
    FName: string;
    FParams: array [0..3] of Double;
    FType: TsgFigureType;
    FEpsilon: Double;
    function GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean; virtual;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Assign(const AObj: TObject);

    function ToXML(const AParentNode: TsgNode;
      const AMode: TsgXMLModes = cnstDefaultXMLMode): TsgNode;
    function ToXMLWithParams(const AParentNode: TsgNode;
      const AParams: TsgXMLParams): TsgNode;
    function FromXML(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer;

    function GetAreaStr(const APrecition: Integer;
      const ASeparator: Char = ','): string;
    function GetFormula(const APrecition: Integer;
      const ASeparator: Char = ','): string;
    function GetInfo(const APrecition: Integer;
      const ASeparator: Char = ','): string;
    property Area: Double read GetArea;
    property FigureType: TsgFigureType read FType write FType;
    property Koef: Double read FKoef write SetKoef;
    property Epsilon: Double read FEpsilon write SetEpsilon;
    property Name: string read GetName write FName;
    property Perimeter: Double read GetPerimeter;
    property Sign: Integer read GetSign write SetSign;
    property A: Double read FParams[0] write FParams[0];
    property B: Double read FParams[1] write FParams[1];
    property C: Double read FParams[2] write FParams[2];
    property D: Double read FParams[3] write FParams[3];
    property H: Double read FParams[2] write FParams[2];
    property L: Double read FParams[1] write FParams[1];
    property R: Double read FParams[1] write FParams[1];
    property S: Double read FParams[0] write FParams[0];
    property P: Double read FParams[1] write FParams[1];
  end;

  TsgExtendedBlockData = class
  private
    FFlags: Byte;
    FLineTypeItem: TsgTableItem;
    //fields not use parent
    FEditorFlags: Integer;
    FSegmentsMode: Byte;
    FSegmentsLength: Double;
    FSegmentBegin: Double;
    FSegmentEnd: Double;
    FSegmentGap: Double;
    FGapAngle: Double;
    FFlightOfSteps: TsgFlightOfSteps;
    FAreaFlags: Integer;
    FElementFlags: Integer;
    FComplexFlags: Integer;
    FCategory: Byte;
    function GetAlignment: Boolean;
    function GetArea: Boolean;
    function GetAttribute(AIndex: Integer): TsgAttributeData;
    function GetAttributesCount: Integer;
    function GetBlockPatternName: string;
    function GetBroad: Boolean;
    function GetBoundaryVisible: Boolean;
    function GetCarvingMode: Byte;
    function GetCircular: Boolean;
    function GetComplex: Boolean;
    function GetContour: Boolean;
    function GetDiffWidths: Boolean;
    function GetFillColor: TColor;
    function GetFillColorCAD: TsgColorCAD;
    function GetFlightOfSteps: TsgFlightOfSteps;
    function GetGapAngle: Double;
    function GetInsUnits: TsgInsUnits;
    function GetLayer: string;
    function GetLength: Double;
    function GetLineType: TsgDXFLineType;
    function GetValueMask: string;
    function GetLabelFlags: Integer;
    function GetLabelText(const AIndex: Integer): string;
    function GetSegmentsCount: Integer;
    function GetSegmentsLength: Double;
    function GetSegmentBegin: Double;
    function GetSegmentEnd: Double;
    function GetSegmentGap: Double;
    function GetSegmentsByLength: Boolean;
    function GetSegmentWidths: TF2DRect;
    function GetSign: Integer;
    function GetSize: TF2DPoint;
    function GetStairs: Boolean;
    function GetStaggeredView: Integer;
    function GetTypeSnapEntities: Integer;
    function GetWidth: Double;
    function GetWidthOwner: Boolean;
    function GetDeletable: Boolean;
    function GetEditable: Boolean;
    function GetVertexMode: Byte;
    function GetCategory: Byte;
    procedure SetAlignment(const Value: Boolean);
    procedure SetBlockPatternName(const Value: string);
    procedure SetBoundaryVisible(const AValue: Boolean);
    procedure SetCarvingMode(const Value: Byte);
    procedure SetCircular(const Value: Boolean);
    procedure SetContour(const Value: Boolean);
    procedure SetDiffWidths(const Value: Boolean);
    procedure SetFillColor(const Value: TColor);
    procedure SetFillColorCAD(const Value: TsgColorCAD);
    procedure SetFlightOfSteps(const Value: TsgFlightOfSteps);
    procedure SetGapAngle(const Value: Double);
    procedure SetInsUnits(const Value: TsgInsUnits);
    procedure SetLayer(const Value: string);
    procedure SetLength(const Value: Double);
    procedure SetLineType(const Value: TsgDXFLineType);
    procedure SetValueMask(const Value: string);
    procedure SetLabelFlags(const Value: Integer);
    procedure SetLabelText(const AIndex: Integer; const Value: string);
    procedure SetSegmentsCount(const Value: Integer);
    procedure SetSegmentsLength(const Value: Double);
    procedure SetSegmentBegin(const Value: Double);
    procedure SetSegmentEnd(const Value: Double);
    procedure SetSegmentGap(const Value: Double);
    procedure SetSegmentsByLength(const Value: Boolean);
    procedure SetSegmentWidths(const Value: TF2DRect);
    procedure SetStairs(const Value: Boolean);
    procedure SetTypeSnapEntities(const Value: Integer);
    procedure SetWidth(const Value: Double);
    procedure SetWidthOwner(const AValue: Boolean);
    procedure SetSign(const AValue: Integer);
    procedure SetSize(const Value: TF2DPoint);
    procedure SetStaggeredView(const AValue: Integer);
    procedure SetParent(const AValue: TsgDXFBlock);
    procedure SetParentName(const AValue: string);
    procedure SetDeletable(const AValue: Boolean);
    procedure SetEditable(const AValue: Boolean);
    procedure SetVertexMode(const AValue: Byte);
    procedure SetCategory(const AValue: Byte);
  protected
    FAlignment: PBoolean;
    FAttribs: TList;
    FCarvingMode: PByte;
    FBoundaryVisible: PBoolean;
    FFillColor: PsgColorCAD;
    FIsCircular: PBoolean;
    FInsUnits: PByte;
    FLength: PDouble;
    FSegmentsCount: PInteger;
    FSegmentWidths: PF2DRect;
    FTypeSnapEntities: PInteger;
    FWidth: PDouble;
    FParent: TsgDXFBlock;
    FParentName: string;
    FValueMask: string;
    FLabelFlags: Integer;
    FLabelText: array [0..3] of string;
    FSign: Byte;
    FName: string;
    FLayer: string;
  public
    constructor Create;
    destructor Destroy; override;
    procedure ClearAttribs;
    procedure DeleteAttribute(AIndex: Integer;
      const ADoFree: Boolean = True);
    function AddAttribute(const AName, AValue: string; const AFlags: Integer;
      AType: TsgAttribType; ValuesList: TStringList = nil;
      const ASort: Boolean = False): TsgAttributeData; overload;
    function AddAttribute(const ANode: TsgNodeSample;
      const ASort: Boolean = False): TsgAttributeData; overload;
    function AddAttributeWithCorrecting(const AName, AValue: string; const AFlags: Integer;
      const AType: TsgAttribType; const AVisible: PBoolean;
      const APoint: PFPoint; const AClassifierData: TStringList = nil): TsgAttributeData;
    procedure Assign(const Source: TsgExtendedBlockData;
      const AMode: Integer = 0);
    function CopyProps(const Source: TsgExtendedBlockData;
      const AConverter: TsgDXFConverter): Boolean;
    function GetXML(const ADescriptions: string;
      const AEntDescription: string): string;
    function SetXML(const AXML: string; AConv: TsgDXFConverter;
      var ADescriptions: string; var AEntDescription: string;
      const AVersion: PsgVersion): Boolean;
    function IndexOfAttribName(const AName:string): Integer;
    //function HasSegmentWidths: Boolean;
    property Alignment: Boolean read GetAlignment write SetAlignment;
    property Attributes[AIndex: Integer]: TsgAttributeData read GetAttribute;
    property AttributesCount: Integer read GetAttributesCount;
    property CarvingMode: Byte read GetCarvingMode write SetCarvingMode;
    property DiffWidths: Boolean read GetDiffWidths write SetDiffWidths;
    property FillColor: TColor read GetFillColor write SetFillColor;
    property FillColorCAD: TsgColorCAD read GetFillColorCAD write SetFillColorCAD;
    property Flags: Byte read FFlags write FFlags;
    property InsUnits: TsgInsUnits read GetInsUnits write SetInsUnits;
    property IsArea: Boolean read GetArea;
    property IsBroad: Boolean read GetBroad;
    property IsCircular: Boolean read GetCircular write SetCircular;
    property IsComplex: Boolean read GetComplex;
    property IsContour: Boolean read GetContour write SetContour;
    property IsStairs: Boolean read GetStairs write SetStairs;
    property Layer: string read GetLayer write SetLayer;
    property Length: Double read GetLength write SetLength;
    property LineType: TsgDXFLineType read GetLineType write SetLineType;
    property SegmentsCount: Integer read GetSegmentsCount write SetSegmentsCount;
    property SegmentsLength: Double read GetSegmentsLength write SetSegmentsLength;
    property SegmentsByLength: Boolean read GetSegmentsByLength write SetSegmentsByLength;
    property SegmentWidths: TF2DRect read GetSegmentWidths write SetSegmentWidths;
    property SegmentBegin: Double read GetSegmentBegin write SetSegmentBegin;
    property SegmentEnd: Double read GetSegmentEnd write SetSegmentEnd;
    property SegmentGap: Double read GetSegmentGap write SetSegmentGap;
    property Size: TF2DPoint read GetSize write SetSize;
    property TypeSnapEntities: Integer read GetTypeSnapEntities write SetTypeSnapEntities;
    property Parent: TsgDXFBlock read FParent write SetParent;
    property ParentName: string read FParentName write SetParentName;//by import
    property Width: Double read GetWidth write SetWidth;
    property BoundaryVisible: Boolean read GetBoundaryVisible write SetBoundaryVisible;
    property FlightOfSteps: TsgFlightOfSteps read GetFlightOfSteps write SetFlightOfSteps;
    property GapAngle: Double read GetGapAngle write SetGapAngle;
    property WidthOwner: Boolean read GetWidthOwner write SetWidthOwner;
    property Sign: Integer read GetSign write SetSign;
    property StaggeredView: Integer read GetStaggeredView write SetStaggeredView;
    property BlockPatternName: string read GetBlockPatternName write SetBlockPatternName;
    property VertexMode: Byte read GetVertexMode write SetVertexMode;//4 bits
    property Category: Byte read GetCategory write SetCategory;
    //property by label
    property ValueMask: string read GetValueMask write SetValueMask;
    property LabelFlags: Integer read GetLabelFlags write SetLabelFlags;
    property LabelText[const AIndex: Integer]: string read GetLabelText write SetLabelText;
    //property by editor
    property EditorFlags: Integer read FEditorFlags write FEditorFlags;
    property Deletable: Boolean read GetDeletable write SetDeletable;
    property Editable: Boolean read GetEditable write SetEditable;
  end;
{$ENDIF}

  TsgBrepModSupport = class
  public
    class procedure ExtractShape(AShape: TsgModTopoShape;
      var AParams: TsgBrepModIterateParams;  const AProc: TsgModBrepIterateProc);
    class procedure ExtractPartCompound(ACompound: TsgModPartCompound;
      var AParams: TsgBrepModIterateParams; const AProc: TsgModBrepIterateProc);
    class function GetBox(const AEntity: TsgModEntity): TFRect;
  end;

  TsgBrepModEntity = class(TsgDXFPenLine)
  private
    FIsGenerateGroup: Boolean;
    FIsGenerate3DFaceByGroup: Boolean;
    FCompound: TsgModPartCompound;
    procedure SetMeshLinPrecision(const Value: Double);
  protected
    function GetBox: TFRect; override;
    function Is3dObject: Integer; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
    procedure LoadTriangle(const AFace: TsgModTopoFace; const AParams: TsgBrepModIterateParams);
    procedure LoadModPolyline(const APoly: TsgModMeshPolyline; const AParams: TsgBrepModIterateParams);
    procedure LoadIsoLines(const AFace: TsgModTopoFace; const AParams: TsgBrepModIterateParams);
    procedure LoadModEntity(const AEnt: TsgModEntity;  var AParams: TsgBrepModIterateParams);
    // For CADDll
    function GroupExists: Boolean; override;
    function GroupFill(AConverter: TsgDXFConverter): Boolean; override;
    function GroupHasAddedEntities: Boolean; override;
    function  ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    function FromXMLNode(const AType: TsgXMLType;
      const ANode: TsgNodeSample; const AIsChild: Boolean;
      const AResult: IsgResultNode = nil): Integer; override;
    procedure ToXMLSubEntities(const AParentNode: TsgNode;
      const AParams: TsgXMLParams); override;
    function GetSubEntitiesNode(const AParentNode: TsgNode;
      var AParams: TsgXMLParams; const AHasSubEntities: Boolean = False): TsgNode; override;
{$IFNDEF SG_NO_USE_KERNEL3D}
  function BuildTriangle(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
  function BuildRectangle(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
  function BuildDisc(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
  function BuildCylinder(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
  function BuildCone(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
  function BuildSphere(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
  function BuildTorus(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
  function BuildBox(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
{$ENDIF}
    property IsGenerateGroup: Boolean read FIsGenerateGroup write FIsGenerateGroup;
    property IsGenerate3DFaceByGroup: Boolean read FIsGenerate3DFaceByGroup write FIsGenerate3DFaceByGroup;
  public
    constructor Create; override;
    destructor Destroy; override;
{$IFNDEF SG_NO_USE_KERNEL3D}
    function FromXML(const ANode: TsgNodeSample;
      const AResult: IsgResultNode = nil): Integer; override;
{$ENDIF}
    procedure AssignEntity(Source: TsgDXFEntity); override;
    class function FindColor(const AColorAttrib: TsgModAttribColorBase): TColor; overload;
    class function FindColor(const AParams: TsgBrepModIterateParams; const AColorAttrib: TsgModAttribColorBase): TColor; overload;
    procedure DrawIterateCompound(const AProc: TsgModBrepIterateProc;
      var AParams: TsgBrepModIterateParams);

    procedure SetCompound(ACompound: TsgModPartCompound);
    property Compound: TsgModPartCompound read FCompound;
    property MeshLinPrecision: Double write SetMeshLinPrecision;
  end;

  TsgBrepModAcis = class(TsgBrepModEntity)
  private
    FAcisStream: TMemoryStream;
  protected
    procedure ClearReferences; override;
    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Clear(const ADoFree: Boolean = True); override;
    procedure LoadFromStream(const AStream: TStream);
    function QueryAcisStream: TMemoryStream;
  end;

//  TsgBrepGroup = class(TsgBrepModEntity)
//  private
//    FName: string;
//  protected
//    procedure LoadedInternal(AConverter: TsgDXFConverter); override;
//  public
//    constructor Create; override;
//    destructor Destroy; override;
//    procedure AssignEntity(Source: TsgDXFEntity); override;
//    property FileName: string read FName write FName;
//  end;

  TsgBrepIges = class(TsgBrepModEntity)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  TsgBrepStep = class(TsgBrepModEntity)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  TsgBrepBrep = class(TsgBrepModEntity)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  TsgBrepParasolid = class(TsgBrepModEntity)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  TsgBrepInventor = class(TsgBrepModEntity)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  TsgDXFRegion = class(TsgBrepModAcis)
  protected
    function GetEntType: TsgCADEntities; override;
{$IFNDEF SG_VM_PLUGIN}
  public
    procedure GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList;
      AProgID: TsgProgID); override;
{$ENDIF}
  end;

  TsgDXFSurface = class(TsgBrepModAcis)
  protected
    FIsoCountU,
    FIsoCountV: Integer;
    function GetEntType: TsgCADEntities; override;
    procedure SetIsoCountU(const AValue: Integer);
    procedure SetIsoCountV(const AValue: Integer);
  public
    constructor Create; override;
    property IsoCountU: Integer read FIsoCountU write SetIsoCountU;
    property IsoCountV: Integer read FIsoCountV write SetIsoCountV;
  end;

  TsgDXF3dSolid = class(TsgBrepModAcis)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  TsgDXFBody = class(TsgBrepModAcis)
  protected
    function GetEntType: TsgCADEntities; override;
  end;

  PsgTexVertex4f = ^TsgTexVertex4f;
  TsgTexVertex4f = record
    case Integer of
      0: (X, Y, Z, W: Single);
      1: (V: array[0 .. 3] of Single)
  end;

  PsgTexMatrix4f = ^TsgTexMatrix4f;
  TsgTexMatrix4f = record
    case Integer of
      0: (V1, V2, V3, V4: TsgTexVertex4f);
      1: (M: array[0 .. 3, 0 .. 3] of Single);
      2: (V: array[0 .. 3] of TsgTexVertex4f)
  end;

  TsgCustomMaterialColor = class(TPersistent)
  protected
    function GetColor: TsgColorCAD; virtual;
    function GetFactor: Double; virtual;
    procedure SetColor(const Value: TsgColorCAD); virtual;
    procedure SetFactor(const Value: Double); virtual;
    function GetMethod: Integer; virtual;
    procedure SetMethod(const Value: Integer); virtual;
  public
    constructor Create; virtual;
    property Color: TsgColorCAD read GetColor write SetColor;
    property Factor: Double read GetFactor write SetFactor;
    property Method: Integer read GetMethod write SetMethod;
  end;

  TsgMaterialColor = class(TsgCustomMaterialColor)
  private
    FColor: TsgColorCAD;
    FFactor: Double;
    FMethod: Integer; // 0..1
  protected
    function GetColor: TsgColorCAD; override;
    function GetFactor: Double; override;
    procedure SetColor(const Value: TsgColorCAD); override;
    procedure SetFactor(const Value: Double); override;
    function GetMethod: Integer; override;
    procedure SetMethod(const Value: Integer); override;
  public
    constructor Create; override;
    procedure Assign(Source: TPersistent); override;
  end;

  TsgMaterialMapper = class(TPersistent)
  private
    FTransform: TsgTexMatrix4f;
    FAutoTransform: Byte;
    FProjection: Byte;
    FTiling: Byte;
    function GetMatrix(I, J: Integer): Single;
    procedure SetTransform(const Value: TsgTexMatrix4f);
    procedure SetAutoTransform(const Value: Byte);
    procedure SetProjection(const Value: Byte);
    procedure SetTiling(const Value: Byte);
    procedure SetMatrix(I, J: Integer; const Value: Single);
    function GetAsAddress: PSingle;
  public
    constructor Create; virtual;
    procedure Assign(Source: TPersistent); override;
    property AutoTransform: Byte read FAutoTransform write SetAutoTransform;
    property Projection: Byte read FProjection write SetProjection;
    property Tiling: Byte read FTiling write SetTiling;
    property Transform: TsgTexMatrix4f read FTransform write SetTransform;
    property Matrix[I, J: Integer]: Single read GetMatrix write SetMatrix; default;
    property AsAddress: PSingle read GetAsAddress;
  end;

  TsgMaterialMap = class(TPersistent)
  private
    FBlend: Double;
    FFileName: string;
    FMapper: TsgMaterialMapper;
    FMapSource: Integer;
    FMaterialColor: TsgCustomMaterialColor;
    FXrecordItem: TsgTableItem;
    function GetXrecord: TsgDXFXRecord;
    procedure SetBlend(const Value: Double);
    procedure SetFileName(const Value: string);
    procedure SetMapper(const Value: TsgMaterialMapper);
    procedure SetMapSource(const Value: Integer);
    procedure SetMaterialColor(const Value: TsgCustomMaterialColor);
    procedure SetXrecord(const Value: TsgDXFXRecord);
  protected
    function CreateMaterialColor: TsgCustomMaterialColor; virtual;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property Blend: Double read FBlend write SetBlend;
    property MaterialColor: TsgCustomMaterialColor read FMaterialColor
      write SetMaterialColor;
    property FileName: string read FFileName write SetFileName;
    property Mapper: TsgMaterialMapper read FMapper write SetMapper;
    property MapSource: Integer read FMapSource write SetMapSource;
    property Xrecord: TsgDXFXRecord read GetXrecord write SetXrecord;
  end;

  TsgColoredMaterialMap = class(TsgMaterialMap)
  protected
    function CreateMaterialColor: TsgCustomMaterialColor; override;
  end;

  TsgAmbientMaterialMap = class(TsgColoredMaterialMap);

  TsgDiffuseMaterialMap = class(TsgColoredMaterialMap)
  private
    FBleed: TsgCustomMaterialColor;
    FIndirectDump: TsgCustomMaterialColor;
    FNormal1: TsgCustomMaterialColor;
    FNormal2: TsgCustomMaterialColor;
    FReflectanceScale: Double;
    FLuminance: Double;
    FTransmittanceScale: Double;
    procedure SetBleed(const Value: TsgCustomMaterialColor);
    procedure SetIndirectDump(const Value: TsgCustomMaterialColor);
    procedure SetLuminance(const Value: Double);
    procedure SetReflectanceScale(const Value: Double);
    procedure SetTransmittanceScale(const Value: Double);
    procedure SetNormal1(const Value: TsgCustomMaterialColor);
    procedure SetNormal2(const Value: TsgCustomMaterialColor);
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property Bleed: TsgCustomMaterialColor read FBleed write SetBleed;
    property IndirectDump: TsgCustomMaterialColor read FIndirectDump write SetIndirectDump;
    property Normal1: TsgCustomMaterialColor read FNormal1 write SetNormal1;
    property Normal2: TsgCustomMaterialColor read FNormal2 write SetNormal2;
    property ReflectanceScale: Double read FReflectanceScale write SetReflectanceScale;
    property TransmittanceScale: Double read FTransmittanceScale write SetTransmittanceScale;
    property Luminance: Double read FLuminance write SetLuminance;
  end;

  TsgSpecularMaterialMap = class(TsgColoredMaterialMap)
  private
    FGloss: Double;
    procedure SetGloss(const Value: Double);
  public
    constructor Create; override;
    procedure Assign(Source: TPersistent); override;
    property Gloss: Double read FGloss write SetGloss;
  end;

  TsgReflectionMaterialMap = class(TsgMaterialMap);

  TsgOpacityMaterialMap = class(TsgMaterialMap)
  private
    FPercent: Double;
    procedure SetPercent(const Value: Double);
  public
    constructor Create; override;
    procedure Assign(Source: TPersistent); override;
    property Percent: Double read FPercent write SetPercent;
  end;

  TsgBumpMaterialMap = class(TsgMaterialMap);

  TsgRefractionMaterialMap = class(TsgMaterialMap)
  private
    FIndex: Double;
    procedure SetIndex(const Value: Double);
  public
    procedure Assign(Source: TPersistent); override;
    property Index: Double read FIndex write SetIndex;
  end;

  TsgDXFMaterial = class(TsgDXFOwneredItem)
  private
    FAmbient: TsgAmbientMaterialMap;
    FDiffuse: TsgDiffuseMaterialMap;
    FSpecular: TsgSpecularMaterialMap;
    FReflection: TsgReflectionMaterialMap;
    FOpacity: TsgOpacityMaterialMap;
    FBump: TsgBumpMaterialMap;
    FRefraction: TsgRefractionMaterialMap;
    procedure SetAmbient(const Value: TsgAmbientMaterialMap);
    procedure SetDiffuse(const Value: TsgDiffuseMaterialMap);
    procedure SetSpecular(const Value: TsgSpecularMaterialMap);
    procedure SetReflection(const Value: TsgReflectionMaterialMap);
    procedure SetOpacity(const Value: TsgOpacityMaterialMap);
    procedure SetBump(const Value: TsgBumpMaterialMap);
    procedure SetRefraction(const Value: TsgRefractionMaterialMap);
  protected
    procedure FreeReferences; override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    property Ambient: TsgAmbientMaterialMap read FAmbient write SetAmbient;
    property Bump: TsgBumpMaterialMap read FBump write SetBump;
    property Diffuse: TsgDiffuseMaterialMap read FDiffuse write SetDiffuse;
    property Opacity: TsgOpacityMaterialMap read FOpacity write SetOpacity;
    property Reflection: TsgReflectionMaterialMap read FReflection write SetReflection;
    property Refraction: TsgRefractionMaterialMap read FRefraction write SetRefraction;
    property Specular: TsgSpecularMaterialMap read FSpecular write SetSpecular;
  end;

  TsgCADGroup = class(TsgDXFOwneredItem)
  private
    FItems: TsgEntitiesList;
    FUnnamed: Boolean;
    FSelectable: Boolean;
  protected
    procedure FreeReferences; override;
    function GetCount: Integer; override;
    function GetEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity); override;
    function GetLinkClass: TsgOwneredItemClass; override;
    function FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample;
      const AIsChild: Boolean; const AResult: IsgResultNode = nil): Integer;override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    procedure ToXMLSubEntities(const AParentNode: TsgNode; const AParams: TsgXMLParams); override;
  public
    constructor Create; override;
    procedure AssignEntity(Source: TsgDXFEntity); override;
    procedure Clear(const ADoFree: Boolean = True); override;
    function DeleteEntity(const AIndex: Integer): TsgDXFEntity; override;
    procedure ExchangeEntity(AIndex1, AIndex2: Integer); override;
    function IndexOfEntity(const AEntity: TsgDXFEntity): Integer; override;
    function InsertEntity(const AIndex: Integer; const AEntity: TsgDXFEntity): Boolean; override;
    property Unnamed: Boolean read FUnnamed write FUnnamed;
    property Selectable: Boolean read FSelectable write FSelectable;
  end;

  TsgCADProxyObject = class(TsgDXFOwneredItem)
  end;

  TsgIrdFieldData = record
    DataType: TsgDataType;
    case TsgDataType of
      dtUndefined: (VRaw: array[0 .. SizeOf(Double) - 1] of Byte);
      dtInteger: (VInt32: Integer);
      dtInt64: (VInt64: Int64);
      dtTFPoint: (VFPoint: PFPoint);//GetMem
      dtString: (VStr: Pointer);//sgUnicodeStr
      dtDouble: (VDouble: Double);
  end;

  TsgCADCustomIrdRecord = class(TsgCADProxyObject)
  private
    FTableFlags: Integer;
  protected
    procedure FreeReferences; override;
    procedure ClearValues; virtual;
    function GetLinkClass: TsgOwneredItemClass; override;
    class function ReadString(var P: PWideChar; out S: sgUnicodeStr): Integer;
    class function GetDataType(const AIrdClassName: string; out ADataType: TsgDataType): Boolean;
    class procedure FinalizeIdrData(var AIdrData: TsgIrdFieldData);
    function AddAttributes(ANode: TsgNode; const AParams: TsgXMLParams): Integer; virtual;
  public
    procedure Clear(const ADoFree: Boolean = True); override;
    property TableFlags: Integer read FTableFlags write FTableFlags;
  end;

  PsgIrdFieldInfo = ^TsgIrdField;
  TsgIrdField = record
    Data: TsgIrdFieldData;
    Name: sgUnicodeStr;
    Description: sgUnicodeStr;
  end;

  TsgCADIrdDscRecord = class(TsgCADCustomIrdRecord)
  private
    FTableName: string;
  protected
    FFieldDefs: array of TsgIrdField;
    function AddAttributes(ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    procedure ClearValues; override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    property TableName: string read FTableName write FTableName;
  end;

  TsgCADIrdObjRecord = class(TsgCADCustomIrdRecord)
  private
    FIrdDscRecordItem: TsgTableItem;
    function GetIrdDscRecord: TsgCADIrdDscRecord;
    procedure SetIrdDscRecord(const Value: TsgCADIrdDscRecord);
//    procedure IrdDscRecordDestroyed(Sender: TObject);
  protected
    FValues: array of TsgIrdFieldData;
    function AddAttributes(ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
    procedure ClearReferences; override;
    procedure FreeReferences; override;
    procedure ClearValues; override;
    procedure Link(AConverter: TsgDXFConverter); override;
    function ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer; override;
  public
    constructor Create; override;
    property IrdDscRecord: TsgCADIrdDscRecord read GetIrdDscRecord write SetIrdDscRecord;
  end;

  TBufferedStream = class(TStream)
  private
    FStream: TStream;
//    FOffset: Int64;
    FBuffer: PAnsiChar;
    FBufPtr: PAnsiChar;
    FBufEnd: PAnsiChar;
    FBufSize: Integer;
    function Overflow: Boolean;
    function Underflow: Boolean;
    function GetByte(var Buffer): Boolean;
    function PutByte(const Buffer): Boolean;
  public
    constructor Create(AStream: TStream; ABufSize: Integer);
    destructor Destroy; override;
    function Read(var Buffer; Count: Longint): Longint; override;
    function Write(const Buffer; Count: Longint): Longint; override;
{$IFNDEF SGDEL_6}
    function Seek(Offset: Longint; Origin: Word): Longint; override;
{$ELSE}
    function Seek(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
{$ENDIF}
  end;

  TCustomAlignedDataReader = class(TInterfacedObject, IProxyReader)
  private
    FVersion: TsgDWGVersion;
    procedure ReadRaw(const ALen: Integer; var AStr: sgRawByteString);
    procedure ReadWideRaw(const ALen: Integer; var AStr: WideString);
  protected
    FPos: Pointer;
    FStack: Pointer;
    function ReadDouble: Double; virtual;
    function ReadInteger: Integer; virtual;
    function ReadSmallInt: SmallInt; virtual;
    function ReadWord: Word; virtual;
    function ReadByte: Byte; virtual;
    procedure PushPosition; virtual;
    procedure PopPosition; virtual;
    procedure Seek(ASize: Integer); virtual;
    function ReadAnsiPadding: AnsiString; virtual;
    function ReadWidePadding: WideString; virtual;
    function ReadString: string; virtual;
    function ReadHandle: UInt64; virtual;
    procedure ReadBytes(var Dest; const ACount: UInt64); virtual;
    function Position: Pointer; virtual;
    function GetVersion: Integer; virtual;
    function PositionAsInt64: TsgInt64; virtual;
    procedure UpdatePosition(ANewPos: Pointer); virtual;
    property Version: TsgDWGVersion read FVersion write FVersion;
  public
    constructor Create(APos: Pointer; AVersion: TsgDWGVersion); virtual;
  end;

  // Not documented, only for internal using (!)

  TsgProxyClipItem = record
    Dict: TsgDXFDictionary;
    Ent: TsgDXFEntity;
  end;

  TsgProxyReaderImpl = class
  private
    FProxyEntityProps: TsgObjectCollection;
    FReader: IProxyReader;
    FConv: TsgDXFConverter;
    FStylesByFont: TStringList;
    FCount: Integer;
    FProxyClips: array of TsgProxyClipItem;
    procedure Grow;
    function GetProxyClipItem(Index: Integer): TsgProxyClipItem;
  protected
    procedure UpdateStyleByFont(AStyles: TsgDXFEntity); virtual;
    property ProxyEntityProps: TsgObjectCollection read FProxyEntityProps;
  public
    constructor Create(const AConv: TsgDXFConverter; AReader: IProxyReader);
    destructor Destroy; override;
    procedure Read(AProxy: TsgDXFEntity); virtual;
    procedure Apply(AProxy: TsgDXFEntity); virtual;
    procedure UpdateHandles; virtual;
    procedure AddToDataBase; virtual;
    property Reader: IProxyReader read FReader;
    property ProxyClipsCount: Integer read FCount;
    property ProxyClipItem[Index: Integer]: TsgProxyClipItem read GetProxyClipItem;
  end;

  TsgTextLinesCollection = class(TsgCustomPolyItemsCollection)
  protected
    function DoAddPtDirrect(const P): Integer; override;
    function DoAddPt(const P): Integer; override;
  end;

  TsgTextCurvesFPointListCollection = class(TsgCustomPolyItemsCollection)
  protected
    function DoAddPtDirrect(const P): Integer; override;
  public
    function NewCollection: TAddPt; override;
    procedure ChangeItemsCount(ADelta: Integer); override;
  end;

function UnitRect: TFRect;
function SGArcCos(const X: Double): Double;
function GetVertex(AList: TList; Index: Integer; const ASy: Double): PsgSHXVertex;
function GetExportImageIndex(AImage: TsgDXFImageEnt; AIndex: Integer;
  ConverImageToOLE: Boolean): Integer;

function EntArc(E: TsgDXFArc; P: TsgCADIterate): TsgArc;
function EntColor(E: TsgDXFEntity; Ins: TsgDXFInsert): TColor;
function GetEntColorCAD(E: TsgDXFEntity; Ins: TsgDXFInsert;
 const AColorCAD: PsgColorCAD): Integer;
function EntLayer(E: TsgDXFEntity; Ins: TsgDXFInsert;
 const ANeedContainerLayer: Boolean = True): TsgDXFLayer;
function EntLines(E: TsgDXFEntity; const P: TsgCADIterate; var ALayerLines: TsgLines): TsgLines;
function EntLineWeight(E: TsgDXFEntity; Ins: TsgDXFInsert): Double;
function EntStyle(E: TsgDXFEntity): TPenStyle;
function EntXrefBlock(E: TsgDXFEntity; Converter: TsgDXFConverter): TsgDXFBlockRecord;
// result - not Material!!! result is entity with actual property "Material"
// query result.Material to get real material object
function MaterialEnt(E: TsgDXFEntity; EntNode: TsgDXFInsert; Group: TsgDXFEntity;
  GroupNode: TsgDXFInsert): TsgDXFEntity;
function BSwap(Value: Integer): Integer;
//function StrPos(Str1, Str2, Limit: PChar): PChar;
function StrIndex(const S: string; const Map: array of string): Integer;//{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure SubStr(var S: AnsiString; var P: PAnsiChar; Limit: PAnsiChar);
procedure SetPolyPolylineOwner(const AEnt, AOwner: TsgDXFEntity);
procedure ApplyBulge(const P1,P2: TFPoint; const Bulge: Double;
  const AList: TList; const ANumberOfCircleParts: Integer;
  const AGetPointProc: TsgCreatePPoint; var AResultArc: TsgArcR);
function BulgeByArc(AArc: TsgArcR; AVertexPoint: TFPoint;
  const Epsilon: Double = fDoubleResolution): Double;
function GetArcROfVertexes(const AVertex1, AVertex2: TsgDXFVertex; var AArc: TsgArcR): Boolean;
procedure ReCalcBulgeParams(const APrev, ACur, ANext: TsgDXFVertex);
procedure GenerateLineTypes(AConverter: TsgDXFConverter; const AComplex: Boolean);
procedure GenerateLineTypesEx(const AConverter: TsgDXFConverter;
 const APrefix: string; const AComplex: Boolean; AUniform: Integer);
procedure GenerateArrow(const AConverter: TsgDXFConverter;
  const ABlock: TsgDXFEntity; const ArrowType: TsgDimArrowType);
procedure GetSinglePts(APts: array of TFPoint; AList: TList);
function GetTextAlignedRotation(const ATextAlign: Integer;
   const ARotation: Double): Double;
procedure OffsetFRect(var R: TFRect; DX, DY, DZ: Extended);
procedure DoScale2D(var P: TsgCADIterate);
procedure TextParms(var P: TsgCADIterate);// is equal DoScale2D
function ConvertDoubleToSingle(const ADouble: Double): Single;

function CircleFromThreePoints(APoly: TsgDXFPolyline; const P1, P2, P3: TFPoint;
  const APartsNumber: Integer; const AIsCircle: Boolean): Boolean;
function ArcFromTwoVectors(APoly: TsgDXFPolyline; const ARadius, ASweepAngle: Double;
  const ACenter, ANormalVector, AStartVector: TFPoint; APartsNumber: Integer): Boolean;

function IsFileOnWeb(const AFileName: string): Boolean;
function IsFileExistsOrOnWeb(const AFileName: string): Boolean;
function LoadPictureFromDisk(const APicture: TPicture; const AFileName: string): Boolean;
function LoadPictureFromWEB(const APicture: TPicture; const AFileName: string): Boolean;
function LoadStreamFromWEB(const AFileName: string; const AStream: TStream;
  var AFile, AErrors: string): Boolean;

function CreateInsert(const ABlock: TsgDXFBlock; const APos,AScale: TFPoint;
  const ARotation: Double): TsgDXFInsert;

function CreateRegEntity(const AGroup: string; const ID: Integer; const AConv: TsgDXFConverter; var AExtData: TsgCADExtendedData): TsgDXFEntity;
procedure RegisterEntityClass(const AGroup: string; const ID: Integer; const AClass: TClass);
procedure UnRegisterEntityClass(const AGroup: string; const ID: Integer);

procedure CopyEntitiesLnk(const ADest, ASource: TsgDXFEntity); overload;
procedure CopyEntitiesLnk(const ADest: TsgObjectList; const ASource: TsgDXFEntity); overload;
procedure CopyEntitiesLnk(const ADest: TsgDXFEntity; const ASource: TsgObjectList); overload;

function IsCADGradient(const AEntity: TsgDXFEntity): Boolean;
function IsEntity(const AEntity: TObject): Boolean; overload;
function IsEntity(const AEntity: TObject;const AClasses: array of TClass): Boolean; overload;
function IsIncludeBlock(const Value1, Value2: Pointer): Boolean;
function IsIncludeStyle(const Value1, Value2: Pointer): Boolean;
function IsIncludeDimStyle(const Value1, Value2: Pointer): Boolean;
function IsIncludeAllDimesionStyle(const Value1, Value2: Pointer): Boolean;
function ReLoadEntities(const AImage: Pointer; const AChanged: TsgDXFEntity;
  const AProc: TsgProcEqual; const AReload: PInteger = nil): TFRect;

procedure LinkDataBase(AConv: TsgDXFConverter);
procedure LoadDataBase(AConv: TsgDXFConverter);
procedure ForceStdDictionaries(AConv: TsgDXFConverter; ANamedObjects: UInt64);

procedure AddVertexList(const AList: TsgObjectList; const APoint: TFPoint);
function AddVertexInList(const AList: TsgObjectList; const APoint: TFPoint;
  const ABulge: Double = 0): TsgDXFVertex;
function AddVertexInPolyline(const APoly: TsgDXFPolyline; const APoint: TFPoint;
  const ABulge: Double = 0): TsgDXFVertex;
function AddVertexCopyInPolyline(const APoly: TsgDXFPolyline;
  const AVertex: TsgDXFVertex): TsgDXFVertex;
procedure AddVertesesInPolyline(const APoly: TsgDXFPolyline; const APoints: TList;
  const ARevers: Boolean = False); overload;
procedure AddVertexesInPolyline(const APoly: TsgDXFPolyline; const APoints: array of TFPoint;
  const ARevers: Boolean = False); overload;
procedure AddVertexesInPolyline(const APoly: TsgDXFPolyline; const APoints: IsgArrayFPoint;
  const ARevers: Boolean = False); overload;
function InsertVertexInPolyline(const APoly: TsgDXFPolyline; const AIndex: Integer;
  const APoint: TFPoint; const ABulge: Double = 0): TsgDXFVertex;
function CreateCADEllipticArc(const APoint, ARatPt1, ARatPt2: TFPoint;
  const APStart, APEnd: PFPoint): TsgDXFEllipse;

function FindByHandle(const AOwner: TsgDXFEntity; const AHandle: UInt64;
  var AIndex: Integer): Boolean; overload;
function FindByHandle(const AList: TList; const AHandle: UInt64;
  var AIndex: Integer): Boolean; overload;
function FindChildByEntName(const AOwner: TsgDXFEntity; const AName: string;
  const ACaseSensitive: Boolean; var AIndex: Integer): Boolean;

function GetOleExtents(AOleObject: {$IFDEF SG_HAS_ACTIVEX}IOleObject{$ELSE}IUnknown{$ENDIF};
  ADrawAspect: Integer; out ASize: TPoint; AOLEBitmap: TBitmap = nil): Boolean;

function GetTransClipRect(const ALayout: TsgDXFLayout;
  const ADrawMatrix: TFMatrix; const AClipRectangle: PFRect): TFRect;
procedure SetArcParams(const Arc: TsgDXFArc; const AP1, AP2: TFPoint;
 const ABulge: Double);

function GetClassXDataProcs: TsgClassXDataProcs;
procedure SetClassXDataProcs(const AXDataProcs: TsgClassXDataProcs);

procedure DimStylePropsToHeadVarStruct(const ADimStyle: TsgDXFDimensionStyle;
  const AConv: TsgDXFConverter);

function CheckStandartNames(var AName: string): TsgStandardLineTypeName;
procedure SetProcFindFont(const P: TsgCADFindFont);

procedure FillSubDMesh(AMesh: TsgDXFEntity; AVerteces: TFPointList;
  AIndexes: TsgIntegerList);
procedure RegisterProxyObjectReader(ProxyType: Integer; ProxyObjReader: TCustomProxyObjReader);
procedure UnRegisterProxyObjectReader(ProxyObjReader: TCustomProxyObjReader);
function GetProxyObjectReader(ProxyType: Integer; out ProxyObjReader: TCustomProxyObjReader): Boolean;

function HasSpatialFilter(ADictionary: TsgDXFEntity; var AFilter: TsgDXFEntity): Boolean;
function GetSpatialFilter(AInsert: TsgDXFInsert; var AFilter: TsgDXFEntity): Boolean;

procedure DoPolylineArrow(const AEnt: TsgDXFEntity; const ALines: TsgLines;
  const AMatrix: PFMatrix; const ANeedRegen: Boolean = False);
procedure CalcDottedSingPts(AEntity: TsgDXFEntity; AEntityLines: TsgLines;
  ConvertMatrixCurrentInsertToWCS: TFMatrix; ADottedPoints: TFPointList;
  AIsAutocadLType, AIsNotScaledLType: Boolean);

function GetTopInsert(const AInsert: TsgDXFInsert): TsgDXFInsert;
procedure NormFRect(var R: TFRect);

function CheckStyleInUse(const AConv: TsgDXFConverter; const AStyle: TsgDXFStyle;
  const ACurrentLayout:TsgDXFLayout = nil): Boolean;

function GetPolyPoints(const AEntity: TsgDXFEntity;
  const APoly: TFPointList): Boolean;//for internal using
function GetBoundariesPolylines(const ABoundaries, APolygons: TsgObjectList;
  AConverter: TsgDXFConverter; AProgress: IsgProgress;
  const ACheck: Boolean = True): Boolean;//for internal using

function GetDefaultImageDefResolverProc: TsgCADImageDefResolver;
function GetDefaultXRefResolverProc: TsgCADXRefResolver;
function GetDefaultSHXResolverProc: TsgCADSHXResolver;
function GetDefaultModellerMsg: TsgCADNotifyMessage;
function GetDefaultAcisNumberProc: TsgCADNotifyMessage;
procedure GetDefaultAcisNumberProcEx(var AProc: TsgCADNotifyMessage);
function IsAnnotative(const S: String): Boolean;
procedure SetDefaultImageDefResolverProc(const AProc: TsgCADImageDefResolver);
procedure SetDefaultXRefResolverProc(const AProc: TsgCADXRefResolver);
procedure SetDefaultSHXResolverProc(const AProc: TsgCADSHXResolver);
procedure SetDefaultModellerMsgProc(const AProc: TsgCADNotifyMessage);
procedure SetDefaultAcisNumberProc(const AProc: TsgCADNotifyMessage);

procedure GetResolveProcs(var AImage: TsgCADImageDefResolver;
  var AXRef: TsgCADXRefResolver; var AShx: TsgCADSHXResolver;
  var AModelerMsg: TsgCADNotifyMessage; var AAcisNumber: TsgCADNotifyMessage);
procedure SetResolveProcs(const AImage: TsgCADImageDefResolver;
  const AXRef: TsgCADXRefResolver; const AShx: TsgCADSHXResolver;
  const AModelerMsg: TsgCADNotifyMessage; const AAcisNumber: TsgCADNotifyMessage);


{$IFDEF SG_CLIENTSVG}
function HasPolylineText(const APoly: TsgDXFEntity): Boolean;
function GetPolylineText(const APoly: TsgDXFEntity; var AText: string): Boolean;
function SetPolylineText(const APoly: TsgDXFEntity; const AText: string): Boolean;
{$ENDIF}

var
  MacroStrings: TStringList;
  LoadEntityProc: TsgCADLoadEntitiy;
  GlobalCheckNameLayer: Boolean;
  GlobalAutoCorrectSymbolTableRecordNames: Boolean;
{$IFDEF SG_INTERNAL_TEST_AB3DKERNEL}
  GlobalBrepParser: TList;
{$ENDIF}
{$IFDEF SG_READER_DEBUG}
  GlobalEntityDestroyNotification: TNotifyEvent;
{$ENDIF}

implementation

uses
  {$IFNDEF SG_NON_WIN_PLATFORM}
  ComObj,
  {$ENDIF}
  CADImage,
  sgSelection,
  sgBitmap,
  sgHatch,
  sgUnicode,
  TTF
{$IFDEF SGABVIewer}
 , RasterFunctions
{$ENDIF}
(*{$IFDEF DEMO}
 , Forms
{$ELSE}
{$IFDEF FRDEMO}
 , Forms
{$ENDIF}
{$ENDIF}*)
  , sgMLeaderGenerator, sgEncoding, sgEncMgr;

const
  DefaultImageDefResolver: TsgCADImageDefResolver = nil;
  DefaultXRefResolver: TsgCADXRefResolver = nil;
  DefaultSHXResolver: TsgCADSHXResolver = nil;
  DefaultModellerMsg: TsgCADNotifyMessage = nil;
  DefaultAcisNumberMsg: TsgCADNotifyMessage = nil;
  cnstProxyEntityDefaultColorID = cmcByBlock shl 24 or clDXFByBlock;
  cnstDestroyNotification = PChar(Word(400));
  cnstAcAuthEnviron = 'ACAUTHENVIRON';

{$IFDEF SG_CLIENTSVG}
const
  cnstAppIdClientSVG = 'AFM10';
{$ENDIF}

type
  TsgSHXFontAccess = class(TsgSHXFont);
  TsgDXFTextAccess = class(TsgDXFText);
  TsgDXFStyleAccess = class(TsgDXFStyle);
  TsgNodeAccess = class(TsgNode);

  TsgBlockrecordsItem = class(TsgSortedItem)
  protected
    FBlocks: TsgOwneredItem;
    function AddItem(const AItem: TObject): Integer; override;
    function RemoveItem(const AItem: TObject): Integer; override;
  end;

  TsgBlockItem = class(TsgOwneredItem)
  protected
    FBlockRecordLinkID: TsgOwneredItem;
    function GetAncestor: TsgDXFEntity; override;
    function GetName: string; override;
    procedure SetName(const AName: string); override;
    function GetDescription: string; override;
    procedure SetDescription(const AValue: string); override;
  end;

  TAcadMLAttData = record
    Flag: Integer;
    Locked: Boolean;
    SecondaryAtt: array of UInt64;
    InsertionPoint: TFPoint;
    AnnotationScale: Double;
    Tag: string;
    NominalTextHeight: Double;
    ReferenceRectangleWidth: Double;
    DefinedAnnotationHeight: Double;
    Align: Integer;
    DrawingDirection: Integer;
    Text: string;
    LinespacingStyle: Integer;
    LinespacingFactor: Double;
    Style: string;
  end;

var
{$IFDEF SG_BTI}
  XDataProc__: TsgClassXDataProcs = nil;
{$ENDIF}
   GlobalFindFont: TsgCADFindFont = nil;
   XRefFileClasses: TStringList = nil;
   GlobalLoadingXRefsStack: TList = nil;
   DWGLWPLineObjReader: TCustomProxyObjReader = nil;
{$IFDEF SG_CLIENTSVG}
   PolylinesNoCopyExtData: Boolean = False;
{$ENDIF}

const
  cnstMLeaderXmlId: array[TsgDXFMLeaderProp] of TsgXMLId =
    (xmlLeaderLineType, xmlLineColor, xmlLineTypeName,
     xmlLineWeight, xmlLanding, xmlLandingGap, xmlDogLeg,
     xmlDogLegLen, xmlArrowType, xmlArrowSize, xmlContentType, xmlTextStyle,
     xmlLeftAttachment, xmlTextAngleType, xmlTextAlignment,
     xmlTextColor, xmlTextHeight, xmlTextFrame, xmlUseDefMText,
     xmlBlockName, xmlBlockColor, xmlBlockScale, xmlBlockRotation,
     xmlBlockConnectionType, xmlFPointScale, xmlRightAttachment,
     xmlTextSwitchAlignment, xmlTextAttachmentDirection,
     xmlTopAttachment, xmlBottomAttachment);

function VarCastToObj(const V: Variant; out obj): Boolean;
{$IFNDEF HAS_OBJECT_CAST_FROM_INTERFACE}
var
  vInstancePersist: IInstancePersist;
{$ENDIF}
begin
  Result := False;
  Pointer(obj) := nil;
  if VarType(V) = varUnknown then
  begin
{$IFNDEF HAS_OBJECT_CAST_FROM_INTERFACE}
    Result := IInterface(TVarData(V).VUnknown).QueryInterface(IInstancePersist, vInstancePersist) = S_OK;
    if Result then
      TObject(obj) := vInstancePersist.GetInstance;
{$ELSE}
    Result := IInterface(TVarData(V).VUnknown) is TObject;
    if Result then
      TObject(obj) := IInterface(TVarData(V).VUnknown) as TObject;
{$ENDIF}
  end;
end;

procedure GetMiddlePoly(const AInPoly,AOutPoly: TFPointList;
  const AP1,AP2: TFPoint);
var
  I: Integer;
  vP1,vP2: PFPoint;
  vSegment: TsgLine;
  vIsStartAdd: Boolean;
begin
  if AInPoly.Count < 2 then
    Exit;
  vIsStartAdd := False;
  AOutPoly.Clear;
  for I := 0 to AInPoly.Count - 2 do
  begin
    vP1 := nil;
    vP2 := nil;
    vSegment := MakeLine(AInPoly[I], AInPoly[I + 1]);
    if IsPointOnSegment(vSegment, AP1) then
      vP1 := @AP1;
    if IsPointOnSegment(vSegment, AP2) then
      vP2 := @AP2;
    if Assigned(vP1) and Assigned(vP2) then
    begin
      AOutPoly.Add(vP1^);
      AOutPoly.Add(vP2^);
      Break;
    end
    else
    begin
      if Assigned(vP1) or Assigned(vP2) then
      begin
        if Assigned(vP1) then
          AOutPoly.Add(vP1^);
        if Assigned(vP2) then
          AOutPoly.Add(vP2^);
        if vIsStartAdd then
          Break
        else
          vIsStartAdd := True;
      end
      else
        if vIsStartAdd then
          AOutPoly.Add(vSegment.Point1);
    end;
  end;
end;

procedure SplitPoly(const AInPoly,AOutPoly1,AOutPoly2: TFPointList;
  const AP: TFPoint);
var
  I,vCount: Integer;
  vIsDivided: Boolean;
  vP1,vP2: TFPoint;
begin
  if AInPoly.Count < 2 then
    Exit;
  vIsDivided := IsEqualFPoints(AInPoly.First, AP);
  vCount := AInPoly.Count - 1;
  AOutPoly1.Clear;
  AOutPoly2.Clear;
  for I := 0 to vCount do
  begin
    if vIsDivided then
      AOutPoly2.Add(AInPoly[I])
    else
    begin
      AOutPoly1.Add(AInPoly[I]);
      if I < vCount then
      begin
        vP1 := AInPoly[I];
        vP2 := AInPoly[I + 1];
        if IsPointOnSegmentPts(vP1, vP2, AP) then
        begin
          if not IsEqualFPoints(vP1, AP) then
            AOutPoly1.Add(AP);
          if not IsEqualFPoints(vP2, AP) then
            AOutPoly2.Add(AP);
          vIsDivided := True;
        end;
      end;
    end;
  end;
end;

function GetPolyPoints(const AEntity: TsgDXFEntity;
  const APoly: TFPointList): Boolean;
var
  vPolyline: TsgCADBasePolyline absolute AEntity;
  vLine: TsgDXFLine absolute AEntity;
{$IFDEF SG_BTI}
  vInsert: TsgDXFInsert absolute AEntity;
  vPts: TsgPoints4;
{$ENDIF}
begin
  Result := False;
  APoly.Clear;
  case AEntity.EntType of
    ceLine:
      begin
        Result := True;
        APoly.Add(vLine.Point);
        APoly.Add(vLine.Point1);
      end;
    cePolyline, ceLWPolyline:
      begin
        Result := True;
        APoly.AppendArray(vPolyline.PolyPoints);
        if vPolyline.Closed then
          APoly.Add(vPolyline.PolyPoints.First);
      end;
{$IFDEF SG_BTI}
    ceInsert:
      if (AEntity.GetEntTypeEx = cnstComplexBroad) and not vInsert.IsRealCircular then
      begin
        Result := True;
        vInsert.GetPts(vPts);
        APoly.Add(MiddleFPoint(vPts[1], vPts[2]));
        APoly.Add(MiddleFPoint(vPts[3], vPts[0]));
      end;
{$ENDIF}
  end;
end;

function GetCrossEntities(const AEntities: TsgObjectList; const APolyPoints: TFPointList;
  AFound: TsgObjectList; ACrossPoints: TFPointList;
  const AIsOnlyCheck: Boolean): Integer;
var
  I: Integer;
  vCurPolyPts,vCurCrossPts: TFPointList;
  vEntity: TsgDXFEntity;
begin
  if (APolyPoints.Count = 0) or (AEntities.Count = 0) then
  begin
    Result := 0;
    Exit;
  end;
  Result := 1;
  vCurPolyPts := nil;
  vCurCrossPts := nil;
  try
    vCurPolyPts := TFPointList.Create;
    vCurCrossPts := TFPointList.Create;
    for I := 0 to AEntities.Count - 1 do
    begin
      vCurCrossPts.Clear;
      vEntity := TsgDXFEntity(AEntities[I]);
      if AFound.IndexOf(vEntity) < 0 then
      begin
        if GetPolyPoints(vEntity, vCurPolyPts) then
        begin
          if IsCrossPolylines(vCurPolyPts, False, APolyPoints, False, vCurCrossPts, 0) > 0 then
          begin
            if AIsOnlyCheck then
            begin
              Result := 3;
              Break;
            end
            else
              case vCurCrossPts.Count of
                1:
                  if AEntities.Count > 2 then
                  begin
                    AFound.Add(vEntity);
                    ACrossPoints.Add(vCurCrossPts.First);
                  end
                  else
                    Result := 0;
                2:
                  if AEntities.Count = 2 then
                  begin
                    ACrossPoints.First := vCurCrossPts.First;
                    ACrossPoints.Add(vCurCrossPts.Last);
                    Result := 2;
                  end
                  else
                    Result := 0;
              else
                Result := 0;
              end;
          end;
        end
        else
          Result := 0;
      end;
      if Result = 0 then
        Break;
    end;
  finally
    FreeAndNil(vCurPolyPts);
    FreeAndNil(vCurCrossPts);
  end;
end;

procedure UpdatePoly(APoly: TsgDXFPolyline; const APolyPoints: TFPointList;
  const AConverter: TsgDXFConverter);
begin
  APoly.Clear;
  AddVertexesInPolyline(APoly, APolyPoints);
  AConverter.Loads(APoly);
end;

procedure ResetToMiddlePoly(APoly: TsgDXFPolyline; const AP1,AP2: TFPoint;
  const AConverter: TsgDXFConverter);
var
  vPolyPoints1,vPolyPoints2: TFPointList;
begin
  vPolyPoints1 := nil;
  vPolyPoints2 := nil;
  try
    vPolyPoints1 := TFPointList.Create;
    vPolyPoints2 := TFPointList.Create;
    GetPolyPoints(APoly, vPolyPoints1);
    GetMiddlePoly(vPolyPoints1, vPolyPoints2, AP1, AP2);
    UpdatePoly(APoly, vPolyPoints2, AConverter);
  finally
    FreeAndNil(vPolyPoints1);
    FreeAndNil(vPolyPoints2);
  end;
end;

procedure ResetToEndPoly(APoly: TsgDXFPolyline;
  const AEntities: TsgObjectList; AExcludeEnts: array of Pointer;
  const AP: TFPoint; const AConverter: TsgDXFConverter);
var
  vPolyPoints,vPolyPoints1,vPolyPoints2: TFPointList;
  vExcludeEnts: TsgObjectList;
begin
  vPolyPoints := nil;
  vPolyPoints1 := nil;
  vPolyPoints2 := nil;
  vExcludeEnts := nil;
  try
    vPolyPoints := TFPointList.Create;
    vPolyPoints1 := TFPointList.Create;
    vPolyPoints2 := TFPointList.Create;
    vExcludeEnts := TsgObjectList.Create;
    vExcludeEnts.Count := Length(AExcludeEnts);
    CopyMemory(vExcludeEnts.List, @AExcludeEnts[0], vExcludeEnts.Capacity*SizeOf(Pointer));
    GetPolyPoints(APoly, vPolyPoints);
    SplitPoly(vPolyPoints, vPolyPoints1, vPolyPoints2, AP);
    if GetCrossEntities(AEntities, vPolyPoints1, vExcludeEnts, nil, True) = 3 then
      UpdatePoly(APoly, vPolyPoints1, AConverter);
    if GetCrossEntities(AEntities, vPolyPoints2, vExcludeEnts, nil, True) = 3 then
      UpdatePoly(APoly, vPolyPoints2, AConverter);
  finally
    FreeAndNil(vPolyPoints);
    FreeAndNil(vPolyPoints1);
    FreeAndNil(vPolyPoints2);
    FreeAndNil(vExcludeEnts);
  end;
end;

function TranslateToValidBoundary(const AInEntities,AOutEntities: TsgObjectList;
  AConverter: TsgDXFConverter): Boolean;
var
  I,J: Integer;
  vTempList,vCrossPolies: TsgObjectList;
  vPoly: TsgDXFLWPolyline;
  vPolyPoints,vCrossPts: TFPointList;
begin
  Result := True;
  vTempList := nil;
  vCrossPolies := nil;
  vPolyPoints := nil;
  vCrossPts := nil;
  try
    vTempList := TsgObjectList.Create;
    vCrossPolies := TsgObjectList.Create;
    vPolyPoints := TFPointList.Create;
    vCrossPts := TFPointList.Create;
    for I := 0 to AInEntities.Count - 1 do
    begin
      if GetPolyPoints(TsgDXFEntity(AInEntities[I]), vPolyPoints) then
      begin
        vPoly := TsgDXFLWPolyline.Create;
        UpdatePoly(vPoly, vPolyPoints, AConverter);
        vTempList.Add(vPoly);
      end
      else
        Result := False;
    end;
    if Result then
      for I := 0 to vTempList.Count - 1 do
      begin
        vCrossPolies.Clear;
        vCrossPts.Clear;
        vPoly := TsgDXFLWPolyline(vTempList[I]);
        if GetPolyPoints(vPoly, vPolyPoints) then
        begin
          vCrossPts.Add(cnstBadPoint);
          vCrossPolies.Add(vPoly);
          case GetCrossEntities(vTempList, vPolyPoints, vCrossPolies, vCrossPts, False) of
            1:
              if vCrossPts.Count = 3 then
              begin
                for J := 1 to vCrossPolies.Count - 1 do
                  ResetToEndPoly(TsgDXFPolyline(vCrossPolies[J]), vTempList, [vCrossPolies[0], vCrossPolies[J]], vCrossPts[J], AConverter);
                ResetToMiddlePoly(TsgDXFPolyline(vCrossPolies[0]), vCrossPts[1], vCrossPts[2], AConverter);
              end
              else
                Result := False;
            2:
              begin
                ResetToMiddlePoly(TsgDXFPolyline(vCrossPolies[0]), vCrossPts[0], vCrossPts[1], AConverter);
                ResetToMiddlePoly(TsgDXFPolyline(vCrossPolies[1]), vCrossPts[0], vCrossPts[1], AConverter);
              end;
          else
            Result := False;
          end;
        end
        else
          Result := False;
      end;
    AOutEntities.AppendDynArray(vTempList);  
    vTempList.Count := 0;
  finally
    FreeAndNil(vTempList);
    FreeAndNil(vCrossPolies);
    FreeAndNil(vPolyPoints);
    FreeAndNil(vCrossPts);
  end;
end;

function GetBoundariesPolylines(const ABoundaries, APolygons: TsgObjectList;
  AConverter: TsgDXFConverter; AProgress: IsgProgress;
  const ACheck: Boolean = True): Boolean;
var
  vHatch: TsgCADCurvePolygon;
  vPoly, vSrcPoly: TF2DPointList;
  I, J: Integer;
  p1, p2: TF2DPoint;
  vValidBoundaries: TsgObjectList;
begin
  vHatch := TsgCADCurvePolygon.Create;
  try
    vValidBoundaries := TsgObjectList.Create;
    try
      if TranslateToValidBoundary(ABoundaries, vValidBoundaries, AConverter) then
        vHatch.GenerateListOfBoundaries(vValidBoundaries, True)
      else
        vHatch.GenerateListOfBoundaries(ABoundaries, True);
    finally
      TsgObjectList.FreeList(vValidBoundaries);
    end;
    if Assigned(AProgress) then
      vHatch.MakeBorderPolylinesWithProgress(AConverter, AProgress)
    else
      AConverter.Loads(vHatch);
    Result := True;
    for I := 0 to vHatch.Boundaries.Count - 1 do
    begin
      vSrcPoly := TF2DPointList(vHatch.Boundaries[I]);
      vPoly := TF2DPointList.Create;
      p1 := vSrcPoly[0];
      vPoly.Add(p1);
      for J := 1 to vSrcPoly.Count - 1 do
      begin
        p2 := vSrcPoly[J];
        if not IsEqualF2DPoints(p1, p2) then
        begin
          vPoly.Add(p2);
          p1 := p2;
        end;
      end;
      if ACheck then
      begin
        if (vPoly.Count > 2) then
        begin
          APolygons.Add(vPoly);
          if IsSelfIntersectingPolyline(vPoly) then
            Result := False;
        end
        else
        begin
          Result := False;
          vPoly.Free;
        end;
      end
      else
      begin
        APolygons.Add(vPoly);
      end;
    end;
  finally
    vHatch.Free;
  end;
end;

function GetDefaultImageDefResolverProc: TsgCADImageDefResolver;
begin
  Result := DefaultImageDefResolver;
end;

function GetDefaultXRefResolverProc: TsgCADXRefResolver;
begin
  Result := DefaultXRefResolver;
end;

function GetDefaultSHXResolverProc: TsgCADSHXResolver;
begin
  Result := DefaultSHXResolver;
end;

function GetDefaultModellerMsg: TsgCADNotifyMessage;
begin
  Result := DefaultModellerMsg;
end;

function GetDefaultAcisNumberProc: TsgCADNotifyMessage;
begin
  Result := DefaultAcisNumberMsg;
end;

procedure GetDefaultAcisNumberProcEx(var AProc: TsgCADNotifyMessage);
begin
  AProc := DefaultAcisNumberMsg;
end;

function IsAnnotative(const S: String): Boolean;
begin
  Result := sgSameText(Copy(S,1,14), cnstAcadAnnotative) or sgSameText(S, cnstAnnotativeData);
end;

procedure SetDefaultImageDefResolverProc(const AProc: TsgCADImageDefResolver);
begin
  DefaultImageDefResolver := AProc;
end;

procedure SetDefaultXRefResolverProc(const AProc: TsgCADXRefResolver);
begin
  DefaultXRefResolver := AProc;
end;

procedure SetDefaultSHXResolverProc(const AProc: TsgCADSHXResolver);
begin
  DefaultSHXResolver := AProc;
end;

procedure SetDefaultModellerMsgProc(const AProc: TsgCADNotifyMessage);
begin
  DefaultModellerMsg := AProc;
end;

procedure SetDefaultAcisNumberProc(const AProc: TsgCADNotifyMessage);
begin
  DefaultAcisNumberMsg := AProc;
end;

procedure SetProcFindFont(const P: TsgCADFindFont);
begin
  GlobalFindFont := P;
end;

procedure GetResolveProcs(var AImage: TsgCADImageDefResolver;
  var AXRef: TsgCADXRefResolver; var AShx: TsgCADSHXResolver;
  var AModelerMsg: TsgCADNotifyMessage; var AAcisNumber: TsgCADNotifyMessage);
begin
  AImage := DefaultImageDefResolver;
  AXRef := DefaultXRefResolver;
  AShx := DefaultSHXResolver;
  AModelerMsg := DefaultModellerMsg;
  AAcisNumber := DefaultAcisNumberMsg;
end;

procedure SetResolveProcs(const AImage: TsgCADImageDefResolver;
  const AXRef: TsgCADXRefResolver; const AShx: TsgCADSHXResolver;
  const AModelerMsg: TsgCADNotifyMessage; const AAcisNumber: TsgCADNotifyMessage);
begin
  SetDefaultImageDefResolverProc(AImage);
  SetDefaultXRefResolverProc(AXRef);
  SetDefaultSHXResolverProc(AShx);
  SetDefaultModellerMsgProc(AModelerMsg);
  SetDefaultAcisNumberProc(AAcisNumber);
end;

{$IFDEF SG_CLIENTSVG}
function GetEntityExtData(const AEntity: TsgDXFEntity; var AAppId: Int64;
  AConverter: TsgDXFConverter = nil; const Add: Boolean = False): TsgCADExtendedData;
var
  vAFMId: TsgDXFEntity;
begin
  Result := nil;
  AAppId := cnstBadHandle;
  if Assigned(AEntity) then
  begin
    if not Assigned(AConverter) then
      AConverter := AEntity.Converter;
    if Assigned(AConverter) then
    begin
      vAFMId := AConverter.Sections[csAppID].FindEntByName(cnstAppIdClientSVG);
      if Assigned(vAFMId) then
      begin
        AAppId := vAFMId.Handle;
        Result := AEntity.EED[vAFMId.Handle];
      end;
      if Add and (not Assigned(Result)) then
      begin
        if not Assigned(vAFMId) then
        begin
          vAFMId := TsgDXFAppID.Create;
          TsgDXFAppID(vAFMId).Name := cnstAppIdClientSVG;
          AConverter.Loads(vAFMId);
          AAppId := vAFMId.Handle;
          AConverter.Sections[csAppID].AddEntity(vAFMId);
        end;
        Result := TsgCADExtendedData.Create(AConverter.Version);
        if AEntity.Handle = cnstBadHandle then
          AConverter.SetHandle(AEntity);
        AEntity.SetEED(vAFMId.Handle, Result);
      end;
    end;
  end;
end;

function HasPolylineText(const APoly: TsgDXFEntity): Boolean;
var
  vAppId: Int64;
begin
  Result := False;
  if Assigned(GetEntityExtData(APoly, vAppId)) then
    Result := True;
end;

function GetPolylineText(const APoly: TsgDXFEntity; var AText: string): Boolean;
var
  vExtData: TsgCADExtendedData;
  I, vIds: Integer;
  vValue: string;
  vValueByte: Byte;
  vAppId: Int64;
  vValues: TStringList;
begin
  Result := False;
  AText := '';
  vExtData := GetEntityExtData(APoly, vAppId);
  if Assigned(vExtData) then
  begin
    Result := True;
    vValues := TStringList.Create;
    try
      vIds := 0;
      I := 1;
      while I < vExtData.DataCount do
      begin
        case vExtData.DataCode[I] of
          String_1002:
            begin
              case vExtData.DataType[I] of
                edtString:
                  begin
                    vValue := vExtData.DataString[I];
                    if (vValue = '') or (vValue = '{') or (vValue = '}') then
                      Inc(vIds);
                  end;
                edtByte:
                  begin
                    vValueByte := vExtData.DataByte[I];
                    if (vValueByte = 0) or (vValueByte = 1) then
                      Inc(vIds);
                  end;
              else
                Break;
              end;
              if vIds >= 2 then
                Break;
            end;
          String_1000:
             begin
               if vIds = 1 then
                 vValues.Add(vExtData.DataString[I]);
             end;
        end;
        Inc(I);
      end;
      for I := vValues.Count - 1 downto 0 do
      begin
        if Length(vValues[I]) < 1 then
          vValues.Delete(I)
        else
          Break;
      end;
      for I := 0 to vValues.Count - 1 do
      begin
        if I > 0 then
          AText := AText + ';';
        AText := AText + vValues[I];
      end;
    finally
      vValues.Free;
    end;
  end;
end;

function SetPolylineText(const APoly: TsgDXFEntity; const AText: string): Boolean;
var
  vExtData: TsgCADExtendedData;
  vIndex, vIndexAfm, I: Integer;
  vStr: string;
  vStrings: TStringList;
  vAppId: Int64;
begin
  Result := False;
  vStrings := TStringList.Create;
  try
    vStrings.LineBreak := ';';
    vStrings.Text := AText;
    while vStrings.Count < 3 do
      vStrings.Add('');
    while vStrings.Count > 3 do
      vStrings.Delete(vStrings.Count - 1);
    vExtData := GetEntityExtData(APoly, vAppId, nil, True);
    if Assigned(vExtData) then
    begin
      Result := True;
      if vExtData.DataCount = 0 then//created
      begin
        vExtData.AddInt64(String_1001, vAppId);//AddString(String_1001, cnstAppIdClientSVG);
        vExtData.AddInt16(Integer_1070, 3);
        vExtData.AddString(String_1000, 'SG');
        vExtData.AddByte(String_1002, Byte(0));//as dwg code value
        for I := 0 to vStrings.Count - 1 do
          vExtData.AddString(String_1000, vStrings[I]);
        vExtData.AddByte(String_1002, Byte(1));
      end
      else
      begin
        vIndexAfm := -1;
        for I := 0 to vExtData.DataCount - 1 do
        begin
          if (vExtData.Data[I].ECode = String_1001)then
          begin
            case vExtData.Data[I].EType of
              edtString:
                begin
                  vStr := vExtData.DataString[I];
                  if (Length(vStr) = 0) or (SameText(vStr, cnstAppIdClientSVG)) then
                  begin
                    vIndexAfm := I;
                    Break;
                  end;
                end;
              edtInt64:
                begin
                  if vExtData.DataInt64[I] = vAppId then
                  begin
                    vIndexAfm := I;
                    Break;
                  end;
                end;
            else
              Break;
            end;
          end;
        end;
        if vIndexAfm > -1 then
        begin
          vIndex := -1;
          for I := vIndexAfm + 1 to vExtData.DataCount - 1 do
          begin
            if (vExtData.Data[I].ECode = String_1002) then
            begin
              case vExtData.Data[I].EType of
                edtString:
                  begin
                    if vExtData.DataString[I] = '{' then
                    begin
                      vIndex := I;
                      Break;
                    end;
                  end;
                edtByte:
                  begin
                    if vExtData.DataByte[I] = 0 then
                    begin
                      vIndex := I;
                      Break;
                    end;
                  end;
              else
                Break;
              end;
            end;
          end;
          if vIndex > -1 then
          begin
            for I := 0 to vStrings.Count - 1 do
            begin
              Inc(vIndex);
              if vExtData.Data[vIndex].ECode = String_1000 then
                vExtData.DataString[vIndex] := vStrings[I]
              else
                Break;
            end;
          end;
        end;
      end;
    end;
  finally
    vStrings.Free;
  end;
end;
{$ENDIF}

function AdsorbAccentSpaces(const AText: string): string;
const
  cnstAccentSpace = '^ ';
var
  I: Integer;
begin
  Result := AText;
  if Length(Result) > 0 then
  begin
    I := AnsiPos(cnstAccentSpace, Result);
    while I > 0 do
    begin
      Delete(Result, I + 1, 1);
      I := AnsiPos(cnstAccentSpace, Result);
    end;
  end;
end;

const
  cnstSectionsByFindObject : array[0..13] of TConvSection = (
    csLayouts, csBlocks, csLTypes, csLayers, csStyles, csDimStyles,
    csBlockRecords, csVPorts, csMLineStyles, csTableStyles, csImageDefs,
    csObjects, csTables, csAppID);

  wcDiametr: WCHAR = WCHAR($00D8);
  wcDiameterUni: WCHAR = WCHAR($2205);

  cnstDiameterUni = '\U+00D8';
  cnstDiameterArialUni = '\U+2205';
  cnstTextParseZero: TsgTextParse = ();
  cnstCoords = 3;// X, Y and Z - points dimension (for SPLINE)

type
  TsgSectionInfo = record
    Name: string;
    ClassType: TsgDXFEntityClass;
  end;

const
  cnstSectionNames: array[TConvSection] of TsgSectionInfo = (
    (Name: cnstSectionTABLES; ClassType: TsgDXFSectionTables),
    (Name: cnstSectionBLOCKS; ClassType: TsgDXFSectionBlocks),
    (Name: cnstSectionENTITIES; ClassType: TsgDXFBlock),
    (Name: cnstTableAPPID; ClassType: TsgDXFTable),
    (Name: cnstTableLTYPE; ClassType: TsgDXFTable),
    (Name: cnstTableLAYER; ClassType: TsgDXFTable),
    (Name: cnstTableSTYLE; ClassType: TsgDXFTable),
    (Name: cnstTableDIMSTYLE; ClassType: TsgDXFTable),
    (Name: cnstTableBLOCK_RECORD; ClassType: TsgDXFBlockRecords),
    (Name: cnstTableVPORT; ClassType: TsgDXFTable),
    (Name: cnstObjectsMLINESTYLES; ClassType: TsgDXFDictionary),
    (Name: cnstObjectsIMAGEDEFS; ClassType: TsgDXFDictionary),
    (Name: cnstObjectsLAYOUTS; ClassType: TsgDXFDictionary),
    (Name: cnstObjectsTABLESTYLES; ClassType: TsgDXFDictionary),
    (Name: cnstSectionOBJECTS; ClassType: TsgDXFSectionObjects),
    (Name: cnstSectionCLASSES; ClassType: TsgDXFSection));

  cnstAcExpr = 'AcExpr';
  cnstFormat2Digits = '\f';

  cnstAnsiChar = -2;
  cnstWideChar = -1;
  cnstExtWideChar = 0;

type
  PsgRegClass = ^TsgRegClass;
  TsgRegClass = record
    RID: Integer;
    RClass: TClass;
  end;

  TsgCADImageAccess = class(TsgCADImage);
  TsgBitmapAccess = class(TsgBitmap);
  TsgCADExtendedDataAccess = class(TsgCADExtendedData);

  TsgCreatorSegments = class
  private
    FArrows: TFPointList;
    FCounts: TsgIntegerList;
    FDottedSingPts: TFPointList;
    FPoints: TFPointList;
    FPolyLine: TsgDXFLWPolyline;
    FPolyPoints: TFPointList;
    FPolyCounts: TsgIntegerList;
    FPolyExtrusion: PFPoint;
    FPointsIndex: Integer;
    FPointsCount: Integer;
    FIsPolylineClosed: Boolean;
    FIsPolyLineSolid: Boolean;
    FMakeCrossSegments: Boolean;
    FIsManyDottedPoints: Boolean;
    FStartWidth: Double;
    FSegmentSinCos: TFPoint;
    FSegmentLength: Double;
    FEndWidth: Double;
    FSegmentFirst: TsgIndexes4;
    FSegmentFirstLinear: Boolean;
    FSegmentLast: TsgIndexes4;
    FSegmentLastLinear: Boolean;
    FVertexCount: Integer;
    FVertexFirst: Integer;
    FMatrix: PFMatrix;
    procedure AddPFPoint(const APoint: PFPoint);
    procedure ClearPFPoints;
    function DistanceIndexes(const I1, I2: Integer): Double;
    function DistanceIndexesSqr(const I1, I2: Integer): Extended;
    function AddSegment(const APC, AP1, AP2: PFPoint; const AW1, AW2: Double): TsgIndexes4;
    function GetCenterIndexes(const AIndexes: TsgIndexes4): TsgLine;
    function GetPolyPoint(AIndex: Integer): TFPoint;
    function GetSegment(const AP1, AP2, AD1, AD2: TFPoint): TsgPoints4;
    function GetSegmentLinear(const AP1, AP2: TFPoint; const AW1, AW2: Double): TsgPoints4;
    function GetSegmentCircular(const APC, AP1, AP2: TFPoint; const AW1, AW2: Double): TsgPoints4;
    function GetVertex(const AIndex: Integer): TsgDXFVertex;
    function GetVertexesCount: Integer;
    function GetVertexFirst: Integer;
    function IsCrossIndexes(const I11, I12, I21, I22: Integer;
      const ACross: PFPoint): Boolean;
    function IsCorrectExtendedAngle(const APB, AP1, AP2: TFPoint): Boolean;
    function IsCorrectJoinAngle(const APB, AP1, AP2: TFPoint): Boolean;
    procedure SetActiveEdges(const AIsFirst: Boolean; const APts: TsgIndexes4;
      var AActPts: TsgIndexes4);
    procedure SetPFPoint2DValue(const AIndex: Integer; const AValue: TFPoint);
    function UseAsSolid: Boolean;
  protected
    procedure MakeSegments(const APoints: TFPointList; const ACenter: PFPoint);
    procedure LoadPointsAndCalcParams;
    procedure LoadPoinstBySegment(const AClosed: Boolean;
      const ACenter: PFPoint);
    procedure CheckGlobalWidth;
    procedure CrossingSegments(const AIsLinear1, AIsLinear2: Boolean;
      const APts1, APts2: TsgIndexes4);
    function GetPFPoint(const APoints: TFPointList; var AIndex: Integer): PFPoint;
    function GetStartAndEndWidths(const AVertex: TsgDXFVertex;
      var AStartWidth, AEndWidth: Double): Boolean;
    function IsNillWidth(const AVertex: TsgDXFVertex): Boolean;
    procedure ExtendSegments(const AIsFirstLine: Boolean;
      const APtsLine, APtsCircle: TsgIndexes4);
    procedure JoinSegments(const APts1, APts2: TsgIndexes4);
    property PolyPoints[AIndex: Integer]: TFPoint read GetPolyPoint;
    property Vertexes[const AIndex: Integer]: TsgDXFVertex read GetVertex;
    property VertexFirst: Integer read GetVertexFirst;
    property VertexesCount: Integer read GetVertexesCount;
  public
    constructor Create(const APolyline: TsgDXFLWPolyline;
      const ALines: TsgLines;
      const AMatrix: PFMatrix = nil);
    procedure LoadSegments(const AsSolid: Boolean = False);
    destructor Destroy; override;
  end;

{$IFDEF UNICODE}
{$DEFINE SG_DWORD_TOKEN}
{$ENDIF}
{$IFDEF SG_LINUX_FPC}
{$DEFINE SG_DWORD_TOKEN}
{$ENDIF}

  PToken = ^TToken;
  TToken = {$IFDEF SG_DWORD_TOKEN}Word{$ELSE}Byte{$ENDIF};
  PToken2 = ^TToken2;
  TToken2 = {$IFDEF SG_DWORD_TOKEN}Cardinal{$ELSE}Word{$ENDIF};

  TsgWordsArray = array of string;

  TsgMTextWords = class
  private
    FCount: Integer;
    FWords: array of Integer;
    FListCount: Integer;
    FList: TsgWordsArray;
    function GetWords(Index: Integer): string;
    function ListAddWord(const AWord: string): Integer;
    function GetText: string;
    procedure SetText(const Value: string);
    function GetWordID(Index: Integer): Integer;
  protected
    property WordID[Index: Integer]: Integer read GetWordID;
  public
    function AddWord(const AWord: string): Integer;
    procedure Clear;
    function ExpandText(AFrom, ATo: Integer): string;
    property Text: string read GetText write SetText;
    property Count: Integer read FCount;
    property Words[Index: Integer]: string read GetWords; default;
  end;

  TsgMTextParser = class
  private
    FAlign: Byte;
    FConverter: TsgDXFConverter;
    FDest: TsgDXFEntity;
    FDestWidth: Double;
    FFontParams: TsgFontParams;
    FHasLine: Boolean;
    FIndex: Integer;
    FLenByRow: Double;
    FLength: Integer;
    FLevels: TsgIntegerList;
    FNeedSetupOptions: Boolean;
    FPos: TF2DPoint;
    FSource: TsgDXFMText;
    FString: {$IFDEF SG_DWORD_TOKEN}UnicodeString{$ELSE}string{$ENDIF};
    FTextParse: TsgTextParse;
    FSourceAlign: Byte;
    FHorzAlignDropped: Boolean;
    FListCarry: TsgEntitiesList;
    FSourceRectWidth: Double;
    FDestNotify: TsgObjectListNotify;
    FPrevText: TsgDXFText;
    procedure ConvertUnicode(const AText:  TsgDXFText);
    function IsTextEmpty(const AText: TsgDXFText): Boolean;
    function IsFirstText(const AText: Pointer): Boolean;
    function GetDestWidth: Double;
    function GetTextHeight(const AText: TsgDXFText): Double;
    function GetTextTab(const AText: TsgDXFText): Double;
    function GetTextWidth(const AText: Pointer): Double;
    procedure SetIsFirstTextAndLoad(const AText: TsgDXFText);
    procedure SeekChars(const AChars: TSysCharSet);
    function GetToken: TToken;{$IFDEF USE_INLINE} inline;{$ENDIF}
    function GetToken2: TToken2;{$IFDEF USE_INLINE} inline;{$ENDIF}
    function GetPTken(Index: Integer): PToken;{$IFDEF USE_INLINE} inline;{$ENDIF}
    procedure ResetCaret(AText: TsgDXFText);
    procedure CarryString(const AText: TsgDXFText);
    procedure DoClearListCarry;
    procedure DestNotify(const Obj: TObject; Action: TListNotification);
  protected
    FCells: TsgEntitiesList;
    FCellColor: TsgColorCAD;
    FCellSize: Double;
    procedure CorrectTextByDivision;
    procedure CorrectTextByHyphenation;
    procedure CorrectTextByTolerance;
    procedure AdjustChildren;
    function CreateDefaultText: TsgDXFText;
    procedure CopyTextOptions(const ATextBase, AText: TsgDXFText);
    procedure DivisionString;
    procedure DivisionStringWithHyphenation;
    procedure LevelingString;
    function MakeFraction(const AText: TsgDXFText): Integer;
    procedure ReadParams(var AText: TsgDXFText);
    procedure SpliteTextbySpace(const AEntities: TsgDXFEntity; AStart: Integer);
    function GetSourceAlign(Index: Integer = -1): Byte;
    function GetBoxWidth(const AText: TsgDXFText): Double;
    function GetString(P: PToken): string;{$IFDEF USE_INLINE} inline;{$ENDIF}
    property PTken[Index: Integer]: PToken read GetPTken;
    property Token: TToken read GetToken;
    property Token2: TToken2 read GetToken2;
  public
    constructor Create(const AConv: TsgDXFConverter);
    destructor Destroy; override;
    function Parse(const Source, Dest: TsgDXFEntity): Boolean;
  end;


  TsgUnicodeParser = class
  private
    FText: {$IFDEF SGFPC}WideString{$ELSE}string{$ENDIF};
    FBigFont: TsgSHXFontAccess;
    FFont: TsgSHXFontAccess;
    FBigFontCodePage: Integer;
    FBigFontInternal: Boolean;
    FCodePage: Integer;
    FUnicode: WideString;
    FSHXMap: TsgSymbolsMap;
    FLastUnicode: Boolean;
    FIndices: array of Word;
    FCodepagesList: TsgIntegerList;
    FDefaultIndex: Integer;
    FHasUndefinedUnicodeSymbol: Boolean;
    FTestUndefinedUnicodeSymbol: Boolean;
    function TryAddCodepage(ACodepage: Integer): Integer;
  protected
    procedure AddUnicodeSymbol(ASymbol: Integer; const ACodePage: Integer = CP_ACP;
      const ACheckCodePage: Boolean = False);
    class function ReadPercent(const AStr: string;
      const AIndex: Integer; var AUnicode: string): Integer;
    class function ReadUnicode(const AStr: string;
      const AIndex: Integer; var AUnicode: string): Integer;
  public
    constructor Create(const AText: string; const ACodePage: Integer;
      const AFont, ABigFont: TsgSHXFont);
    destructor Destroy; override;
    procedure Execute(const AParsePercentSymbols: Boolean = True);
    property Unicode: WideString read FUnicode;
    property SHXMap: AnsiString read FSHXMap;
  end;

  PCellBorderLineData = ^TCellBorderLineData;
  TCellBorderLineData = record
    ID: Integer;
    Cell: TsgAcadTableCell;
    Border: Integer;
    Span: Integer;
  end;

  TsgAcadTableGenerator = class
  private
    FAcadTable: TsgDXFAcadTable;
    FConv: TsgDXFConverter;
    FData: TList;
    FIndex: array[Boolean] of Integer;
    FRange: TRange;
    FSgn: array[Boolean] of Integer;
    function AddLineData(const AHorz: Boolean; const ACell: TsgAcadTableCell;
      const ABorder: Integer;const ASpan: Integer): PCellBorderLineData;
    function CreateMText(const ACell: TsgAcadTableCell; const ADoCreate, ALoad: Boolean): TsgDXFMText;
    procedure GenerateLines(const ALines: TsgObjectList; const AHoresontal: Boolean);
    function GetCell(AHorz: Boolean; ADec: Integer): TsgAcadTableCell;
    function GetSizes(AHorz: Boolean): Double;
    function GetActiveCellBorderLineData(AHorz: Boolean): PCellBorderLineData;
  protected
    property Cell[AHorz: Boolean; ADec: Integer]: TsgAcadTableCell read GetCell;
    property Sizes[AHorz: Boolean]: Double read GetSizes;
    property ActiveCellBorderLineData[AHorz: Boolean]: PCellBorderLineData read
      GetActiveCellBorderLineData;
  public
    constructor Create(const AConv: TsgDXFConverter;
      const AAcadTable: TsgDXFAcadTable);
    constructor CreateRanged(const AConv: TsgDXFConverter;
      const AAcadTable: TsgDXFAcadTable; const ARange: TRect);
    destructor Destroy; override;
    function GenerateBlock: TsgDXFBlock;
    property Range: TRange read FRange;
  end;

  TListNotifyClearWrapper = class
  private
    FList: TsgObjectList;
    FNotify: TsgObjectListNotify;
    FDoFree: Boolean;
  protected
    procedure DoNotify(const Obj: TObject; Action: TListNotification); dynamic;
    procedure ClearListNotify(const Obj: TObject; Action: TListNotification); virtual;
  public
    constructor Create(const AList: TsgObjectList; const ADoFree: Boolean);
    destructor Destroy; override;
    procedure Clear;
  end;
//
  TListNotifyClearWrapperGroup = class(TListNotifyClearWrapper)
  protected
    procedure ClearListNotify(const Obj: TObject; Action: TListNotification); override;
  end;

  TsgImageDefPicture = class(TPicture)
  private
    FImageDef: TsgDXFImageDef;
  public
    constructor Create(AImageDef: TsgDXFImageDef); virtual;
    destructor Destroy; override;
    property ImageDef: TsgDXFImageDef read FImageDef;
  end;

  TsgStyleItem = class(TsgTableItem)
  private
    FNotifyChange: TNotifyEvent;
  protected
    procedure SetItemObj(const Value: TsgOwneredItem); override;
  public
    property NotifyChange: TNotifyEvent read FNotifyChange write FNotifyChange;
  end;

var
  ExternalEntities: TsgStringList = nil;
  StdLines: TsgLines;
//  GlobalConvertersByOpenFromPicture: IsgCollectionPointer = nil;

function CreateCollection: TsgCollection;
begin
  Result := TsgCollection.Create;
  Result.Sorted := True;
  Result.Duplicates := dupIgnore;
end;

function CreateObjectCollection: TsgObjectCollection;
begin
  Result := TsgObjectCollection.Create;
  Result.Sorted := True;
  Result.Duplicates := dupIgnore;
end;

function CorrectScale(AScale,AOldScale: Double;
  AIsPositive: Boolean = False): Double;
begin
  Result := Abs(AScale);
  if AIsPositive and IsZero(Result) then
    Result := AOldScale;
end;

function NumberOfCirclePartsByRadius(AConverter: TsgDXFConverter;
  const ARadius: Double): Integer;
begin
  if Assigned(AConverter) then
    Result := AConverter.GetNumberOfCirclePartsByRadius(ARadius)
  else
    Result := GetNumberOfCircleParts;
end;

function NumberOfCirclePartsByBulge(AConverter: TsgDXFConverter;
  const P1,P2: TFPoint; const ABulge: Double): Integer;
begin
  if Assigned(AConverter) then
    Result := AConverter.GetNumberOfCirclePartsByBulge(P1, P2, ABulge)
  else
    Result := GetNumberOfCircleParts;
end;

function SetHandleFromBase(const ASource, ABase: TsgDXFEntity;
  const ALevel: Integer = MAXWORD): Boolean;
var
  I, vLevel: Integer;
  vEntSource, vEntBase: TsgDXFEntity;
begin
  Result := True;
  ASource.Handle := ABase.Handle;
  if (ALevel > 0) and (ASource.Count > 0) then
  begin
    if ASource.Count = ABase.Count then
    begin
      vLevel := ALevel - 1;
      for I := 0 to ASource.Count - 1 do
      begin
        vEntSource := ASource.Entities[I];
        vEntBase := ABase.Entities[I];
        if not (IsEqualEntClass(vEntSource.EntClass, vEntBase.EntClass) and
         SetHandleFromBase(vEntSource, vEntBase, vLevel)) then
        begin
          Result := False;
          Break;
        end;
      end;
    end
    else
      Result := False;
  end;
end;

procedure ClearEntCollection(AList: TsgObjectList; ADoFree: Boolean);
var
  ListNotifyClearWrapper: TListNotifyClearWrapper;
begin
  ListNotifyClearWrapper := TListNotifyClearWrapper.Create(AList, ADoFree);
  try
    ListNotifyClearWrapper.Clear;
  finally
    ListNotifyClearWrapper.Free;
  end;
end;

procedure ClearItemsCollection(AList: TsgObjectList; ADoFree: Boolean);
var
  ListNotifyClearWrapper: TListNotifyClearWrapperGroup;
begin
  ListNotifyClearWrapper := TListNotifyClearWrapperGroup.Create(AList, ADoFree);
  try
    ListNotifyClearWrapper.Clear;
  finally
    ListNotifyClearWrapper.Free;
  end;
end;

procedure SwapEntitiesHandle(const AEntity1, AEntity2: TsgDXFEntity);
var
  vTmp: UInt64;
begin
  vTmp := AEntity1.Handle;
  AEntity1.Handle := AEntity2.Handle;
  AEntity2.Handle := vTmp;
end;

procedure AddListPointsPolyline(const AList: TList;
  const APoly: TsgCADBasePolyline;
  const AClosing: Boolean;
  const AReversed: Boolean);
var
  I: Integer;
  vPoints: TList;
begin
  if APoly.PointCount > 0 then
  begin
    vPoints := TList.Create;
    AList.Add(vPoints);
    vPoints.Capacity := APoly.PointCount + 1;
    if AReversed then
      for I := APoly.PointCount - 1 downto 0 do
         AddFPointInList(vPoints, APoly.Points[I])
    else
      for I := 0 to APoly.PointCount - 1 do
        AddFPointInList(vPoints, APoly.Points[I]);
    if AClosing then
       AddFPointInList(vPoints, PFPoint(vPoints[0])^);
  end;
end;

function CheckEntTypeByRealod(const AEnt: TsgDXFEntity; const AType: Integer): Boolean;
begin
  Result := (AEnt is TsgCADCurvePolygon);
  if not Result then
  begin
    if AType and 1 <> 0 then
      Result := AEnt is TsgCADBasePolyline;
    if AType and 2 <> 0 then
      Result := Result or (AEnt is TsgDXFSpline);
  end;
end;

function GetDimensionType(const AFlags: Integer): TsgDimensionType;
begin
  case AFlags and 7 of
    0:  Result := dmtRotHorVert;
    1:  Result := dmtAligned;
    2:  Result := dmtAngular;
    3:  Result := dmtDiameter;
    4:  Result := dmtRadius;
    5:  Result := dmtAngular3Point;
    6:  Result := dmtOrdinate;
  else
    Result := dmtUndefined;
  end;
end;

{ CircleFromThreePoints
  Parameters:
  P1, P2, P3 - the circle points that form the triangle ABC
     (AB = [P1 P2], BC = [P2 P3], AC = [P3 P1]).          }
function CircleFromThreePoints(APoly: TsgDXFPolyline; const P1, P2, P3: TFPoint;
  const APartsNumber: Integer; const AIsCircle: Boolean): Boolean;
const
  cnstZero = 1E-15;
var
  vDet: array[0..2] of Double;
  vRadius, vSweepAngle, Tau, Phi, Delta: Double;
  vCenter, N, Nx, Ny, vOrtAB, vCenterAB, vCenterBC, vCenterAC, vP1, vP3: TFPoint;
  vVertex: TsgDXFVertex;
  I: Integer;
begin
  Result := False;
  try
    vOrtAB := Ort(MakeFPoint(P2.X-P1.X, P2.Y-P1.Y, P2.Z-P1.Z));
    // Normal to the plane of a circle: N = [AB x AC]
    N := Ort(sgFunction.Vector(vOrtAB, MakeFPoint(P3.X-P1.X, P3.Y-P1.Y, P3.Z-P1.Z)));
    // Perpendicular to AB side: Nx = [AB x N]
    Nx := Ort(sgFunction.Vector(vOrtAB, N));
    // Perpendicular to AC side: Ny = [AC x N]
    Ny := Ort(sgFunction.Vector(MakeFPoint(P3.X-P1.X, P3.Y-P1.Y, P3.Z-P1.Z), N));
    vCenterAB := MakeFPoint(0.5*(P2.X+P1.X), 0.5*(P2.Y+P1.Y), 0.5*(P2.Z+P1.Z));
    vCenterBC := MakeFPoint(0.5*(P3.X+P2.X), 0.5*(P3.Y+P2.Y), 0.5*(P3.Z+P2.Z));
    vCenterAC := MakeFPoint(0.5*(P3.X+P1.X), 0.5*(P3.Y+P1.Y), 0.5*(P3.Z+P1.Z));
    vDet[0] := Nx.Y*Ny.X - Nx.X*Ny.Y;
    vDet[1] := Nx.Z*Ny.X - Nx.X*Ny.Z;
    vDet[2] := Nx.Z*Ny.Y - Nx.Y*Ny.Z;
    if not IsRange(vDet[0],cnstZero) then
      Tau := (Ny.X*(vCenterAC.Y - vCenterAB.Y) - Ny.Y*(vCenterAC.X - vCenterAB.X))/vDet[0] //Tau1 :=  (Nx.X*(vCenterAC.Y - vCenterAB.Y) - Nx.Y*(vCenterAC.X - vCenterAB.X))/vDet[0];
    else
      if not IsRange(vDet[1], cnstZero) then
        Tau := (Ny.X*(vCenterAC.Z - vCenterAB.Z) - Ny.Z*(vCenterAC.X - vCenterAB.X))/vDet[1]
      else
        if not IsRange(vDet[2], cnstZero) then
          Tau := (Ny.Y*(vCenterAC.Z - vCenterAB.Z) - Ny.Z*(vCenterAC.Y - vCenterAB.Y))/vDet[2]
        else
          Exit;// undefined Error
    vCenter := MakeFPoint(Nx.X*Tau + vCenterAB.X, Nx.Y*Tau + vCenterAB.Y, Nx.Z*Tau + vCenterAB.Z);
    vRadius := Sqrt(Sqr(P1.X-vCenter.X) + Sqr(P1.Y-vCenter.Y) + Sqr(P1.Z-vCenter.Z));
    if AIsCircle then
      vSweepAngle := 2*Pi
    else
    begin
      Nx := Ort(MakeFPoint(P1.X-vCenter.X, P1.Y-vCenter.Y,P1.Z- vCenter.Z));
      vOrtAB := Ort(sgFunction.Vector(N, Nx));
      vP1 := Ort(MakeFPoint(P1.X- vCenter.X, P1.Y- vCenter.Y, P1.Z- vCenter.Z));
      vP3 := Ort(MakeFPoint(P3.X- vCenter.X, P3.Y- vCenter.Y, P3.Z- vCenter.Z));
      vSweepAngle := SGArcCos(vP1.X*vP3.X + vP1.Y*vP3.Y + vP1.Z*vP3.Z);
    end;
    Phi := 0;
    Delta := vSweepAngle / APartsNumber;
    for I := 0 to APartsNumber do
    begin
      vVertex := TsgDXFVertex.Create;
      vVertex.Point := MakeFPoint(
        vCenter.X + vRadius*(Nx.X*Cos(Phi)+ vOrtAB.X*Sin(Phi)),
        vCenter.Y + vRadius*(Nx.Y*Cos(Phi)+ vOrtAB.Y*Sin(Phi)),
        vCenter.Z + vRadius*(Nx.Z*Cos(Phi)+ vOrtAB.Z*Sin(Phi)));
      APoly.AddEntity(vVertex);
      Phi := Phi + Delta;
    end;
  except
    Exit;
  end;
  Result := True;
end;

function ArcFromTwoVectors(APoly: TsgDXFPolyline; const ARadius, ASweepAngle: Double;
  const ACenter, ANormalVector, AStartVector: TFPoint; APartsNumber: Integer): Boolean;
var
  Phi, Delta: Double;
  vVertex: TsgDXFVertex;
  Ny: TFPoint;
  I: Integer;
begin
  Result := False;
  try
    Ny := Ort(sgFunction.Vector(ANormalVector, AStartVector));
    Phi := 0;
    Delta := ASweepAngle / APartsNumber;
    for I := 0 to APartsNumber do
    begin
      vVertex := TsgDXFVertex.Create;
      vVertex.Point := MakeFPoint(
        ACenter.X + ARadius*(AStartVector.X*Cos(Phi)+ Ny.X*Sin(Phi)),
        ACenter.Y + ARadius*(AStartVector.Y*Cos(Phi)+ Ny.Y*Sin(Phi)),
        ACenter.Z + ARadius*(AStartVector.Z*Cos(Phi)+ Ny.Z*Sin(Phi)));
      APoly.AddEntity(vVertex);
      Phi := Phi + Delta;
    end;
  except
    Exit;
  end;
  Result := True;
end;

function EnumBoxPoints(const ABox: TFRect; Proc: TFPointProc; Full: Boolean): Boolean;//{$IFDEF USE_INLINE} inline;{$ENDIF}
begin
  Result := False;
  if IsBadRect(ABox) then
    Exit;
  Proc(ABox.TopLeft);
  Proc(ABox.BottomRight);
  if not Full then
    Exit;
  Proc(MakeFPoint(ABox.Left, ABox.Top, ABox.Z2));
  Proc(MakeFPoint(ABox.Left, ABox.Bottom, ABox.Z1));
  Proc(MakeFPoint(ABox.Left, ABox.Bottom, ABox.Z2));
  Proc(MakeFPoint(ABox.Right, ABox.Top, ABox.Z1));
  Proc(MakeFPoint(ABox.Right, ABox.Top, ABox.Z2));
  Proc(MakeFPoint(ABox.Right, ABox.Bottom, ABox.Z1));
end;

function IsFileOnWeb(const AFileName: string): Boolean;
const
  cHTTPSprefx = 'https://';
  cHTTPprefx = 'http://';
  cWWWprefx = 'www.';
var
  vFileName: string;
begin
  vFileName := AnsiLowerCase(AFileName);
  Result := (Pos(cHTTPprefx, vFileName) = 1) or
   (Pos(cWWWprefx, vFileName) = 1) or (Pos(cHTTPSprefx, vFileName) = 1);
end;

function IsFileExistsOrOnWeb(const AFileName: string): Boolean;
begin
  Result := FileExists(AFileName) or IsFileOnWeb(AFileName);
end;

function GetDimArrowTypeByDimSah(const DIMSAH: Boolean; const DIMBLK, DIMBLKx: TsgDimArrowType): TsgDimArrowType; overload;
begin
  if DIMSAH then
    Result := DIMBLKx
  else
    Result := DIMBLK;
end;

function GetDimArrowTypeByDimSah(const DIMSAH: Boolean; const InitDimBlk, InitDimBlkx: Boolean;
  const DIMBLK, DIMBLKx, DIMBLKSTYLE: TsgDimArrowType): TsgDimArrowType; overload;
var
  vDimBlkx:  TsgDimArrowType;
begin
  vDimBlkx := DIMBLKSTYLE;
  if InitDimBlkx then
  begin
    vDimBlkx := DIMBLKx;
    if (vDimBlkx = datClosedfilled) then
    begin
      if InitDimBlk then
        vDimBlkx := DIMBLK
      else
        vDimBlkx := DIMBLKSTYLE;
    end;
  end;
  Result := GetDimArrowTypeByDimSah(DIMSAH, DIMBLK, vDimBlkx);
end;

procedure SetDimArrowType1BySah(const Value: TsgDimArrowType; var ADim: TsgDimStyle);
begin
  if ADim.Sah then
  begin
    ADim.Arrows.Blk1 := Value;
    if ADim.Arrows.Blk1 = ADim.Arrows.Blk2 then
    begin
      ADim.Sah := False;
      ADim.Arrows.Blk := ADim.Arrows.Blk1;
    end;
  end
  else
  begin
    ADim.Arrows.Blk := Value;
    ADim.Arrows.Blk1 := Value;
    ADim.Arrows.Blk2 := Value;
  end;
end;

procedure SetDimArrowType2BySah(const Value: TsgDimArrowType; var ADim: TsgDimStyle);
begin
  if not ADim.Sah then
  begin
    ADim.Sah := True;
     ADim.Arrows.Blk1 := ADim.Arrows.Blk;
  end;
  ADim.Arrows.Blk2 := Value;
  if  ADim.Arrows.Blk1 = ADim.Arrows.Blk2 then
  begin
    ADim.Sah := False;
    ADim.Arrows.Blk :=  ADim.Arrows.Blk1;
  end;
end;

function LoadPictureFromDisk(const APicture: TPicture; const AFileName: string): Boolean;
var
  vFileName: string;
begin
  vFileName := AFileName;
  if not FileExists(vFileName) then
    vFileName := ExtractFileName(AFileName);
  if FileExists(vFileName) then
    try
      APicture.LoadFromFile(vFileName)
    except
    end;
  Result := APicture.Graphic <> nil;
end;

function LoadStreamFromWEB(const AFileName: string; const AStream: TStream;
  var AFile, AErrors: string): Boolean;

var
  vProxyInfo: TsgHTTPProxyInfo;

  procedure InitProxyInfo;
  begin
    if cnstUseProxy then
      vProxyInfo := cnstProxyInfo
    else
    begin
      vProxyInfo.ProxyHost := '';
      vProxyInfo.ProxyPort := 0;
      vProxyInfo.ProxyNeedPass := False;
      vProxyInfo.ProxyUser := '';
      vProxyInfo.ProxyPass := '';
    end;
  end;

begin
  Result := False;
  AFile := '';
  AErrors := '';
  try
    InitProxyInfo;
    if GetDataFromHttp(AFileName, AStream, cnstHttpTimeOut, AFile, AErrors,
      cnstProxyInfo, cnstUseProxy) then
      Result := True;
  except
  end;
end;

function LoadPictureFromWEB(const APicture: TPicture; const AFileName: string): Boolean;
var
  vStream: TMemoryStream;
  vFileName, vTempDir, vTestFileName, vErrorMes: string;
  vReadFromWeb: Boolean;
  I: Integer;
begin
  Result := False;
  vStream := TMemoryStream.Create;
  try
    vReadFromWeb := LoadStreamFromWEB(AFileName, vStream, vFileName, vErrorMes);
    if vReadFromWeb then
    begin
      try
        I := 0;
        vTempDir := GetTempDir;
        repeat
          Inc(I);
          vTestFileName := vTempDir + sTempFileName + IntToStr(I) + '.' + vFileName;
        until not FileExists(vTestFileName);
        vFileName := vTestFileName;
        vStream.SaveToFile(vFileName);
        try
          Result := LoadPictureFromDisk(APicture, vFileName);
        finally
          DeleteFile(vFileName);
        end;
      except
        APicture.Graphic := nil;
      end;
    end;
  finally
    FreeAndNil(vStream);
  end;
end;

// Checks Converter1 > Converter2 [> ...] > Converter1
function CheckConverters(AGlobalConverters: IsgCollectionPointer;
  const AXrefPath: string): Boolean;
var
  I: Integer;
begin
  Result := True;
  if not ((AGlobalConverters = nil) or (AGlobalConverters.Count = 0)) then
  begin
    I := AGlobalConverters.Count - 1;
    while (I >= 0) and Result do
      if TsgDXFConverter(AGlobalConverters[I]).Filename = ExtractFileName(AXrefPath) then
        Result := False
      else
        Dec(I);
  end;
end;

function CompareHandles(const AH1, AH2: UInt64): Integer;
begin
//  Result := AH1 - AH2;
  if AH1 = AH2 then
    Result := 0
  else
    if AH1 > AH2 then
      Result := 1
    else
      Result := -1;
end;

function CompareHandleEntities(const Ent1, Ent2: Pointer): Integer;
begin
//  Result := TsgDXFEntity(Ent1).Handle - TsgDXFEntity(Ent2).Handle;
  Result := CompareHandles(TsgDXFEntity(Ent1).Handle, TsgDXFEntity(Ent2).Handle);
end;

function CompareZDepthEntities(const Ent1, Ent2: Pointer): Integer;
var
  vInd: TsgFloat;
  vBox1, vBox2: TFRect;
begin
  vBox1 := TsgDXFEntity(Ent1).Box;
  vBox2 := TsgDXFEntity(Ent2).Box;
  vInd := (vBox1.Z1 + vBox1.Z2) - (vBox2.Z1 + vBox2.Z2);
  if vInd > fAccuracy then
    Result := 1
  else
    if vInd < -fAccuracy then
      Result := -1
    else
      Result := 0;
end;

function ComparePoint(AP1, AP2: PFPoint): Boolean;
begin
  Result :=(not IsRange(AP1^.X - AP2^.X, fAccuracy)) or
    (not IsRange(AP1^.Y - AP2^.Y, fAccuracy)) or
    (not IsRange(AP1^.Z - AP2^.Z,fAccuracy)); // Return true if AP1 <> AP2;
end;

function ConvertDoubleToSingle(const ADouble: Double): Single;
begin
  if IsRange(ADouble,MaxSingle) then
    Result := ADouble
  else
    Result := (ADouble/Abs(ADouble)) * MaxSingle;
end;

procedure CreatesgBitMapBy1pxlDiv4(const BitMap: TsgBitMap; var BMP: TsgBitMap);
{$IFDEF SGABVIewer}
begin
   RasterFunctions.CreatesgBitMapLittle(TGraphic(BitMap), BMP, 4);
{$ELSE}
var
  vBitmap: TBitmap;
  vMax, vW, vH: Integer;
begin
  vW := BitMap.Width div 4;
  vH := BitMap.Height div 4;
  vBitmap := TBitmap.Create;
  try
    Inc(vW, Integer(vW = 0));
    Inc(vH, Integer(vH = 0));
    vBitmap.PixelFormat := BitMap.PixelFormat;
    vMax := MaxI(vW, vH);
    if vMax > cnstMaxImgSize then
    begin
      vW := cnstMaxImgSize * vW div vMax;
      vH := cnstMaxImgSize * vH div vMax;
    end;
    SetSizeBmp(vBitmap, vW, vH);
{$IFNDEF SG_FIREMONKEY}
    SetStretchBltMode(vBitmap.Canvas.Handle, HALFTONE);
{$ENDIF}
    vBitmap.Canvas.StretchDraw(Rect(0, 0,  vBitmap.Width,  vBitmap.Height), BitMap);
    BMP := TsgBitmap.Create;
    BMP.Assign(vBitmap);
  finally
    vBitmap.Free;
  end;
{$ENDIF}
end;

procedure CreatesgBitMapBy1pxlDiv8(const BitMap: TsgBitMap; var BMP: TsgBitMap);
{$IFDEF SGABVIewer}
begin
   RasterFunctions.CreatesgBitMapLittle(TGraphic(BitMap), BMP, 8);
{$ELSE}
var
  vBitmap: TBitmap;
  vMax, vW, vH: Integer;
begin
  vW := BitMap.Width div 8;
  vH := BitMap.Height div 8;
  vBitmap := TBitmap.Create;
  try
    Inc(vW, Integer(vW = 0));
    Inc(vH, Integer(vH = 0));
    vBitmap.PixelFormat := BitMap.PixelFormat;
    vMax := MaxI(vW, vH);
    if vMax > cnstMaxImgSize then
    begin
      vW := cnstMaxImgSize * vW div vMax;
      vH := cnstMaxImgSize * vH div vMax;
    end;
    SetSizeBmp(vBitmap, vW, vH);
{$IFNDEF SG_FIREMONKEY}
    SetStretchBltMode(vBitmap.Canvas.Handle, HALFTONE);
{$ENDIF}
    vBitmap.Canvas.StretchDraw(Rect(0, 0,  vBitmap.Width,  vBitmap.Height), BitMap);
    BMP := TsgBitmap.Create;
    BMP.Assign(vBitmap);
  finally
    vBitmap.Free;
  end;
{$ENDIF}
end;

procedure DoPolylineArrow(const AEnt: TsgDXFEntity; const ALines: TsgLines;
  const AMatrix: PFMatrix; const ANeedRegen: Boolean = False);
var
  PL: TsgDXFPolyline absolute AEnt;
begin
  if (AEnt is TsgDXFPolyline) and (ANeedRegen or (PL.ArrowsLines <> ALines)) and PL.HasWidth then
    PL.DoArrows(ALines, AMatrix);
end;

procedure CalcDottedSingPts(AEntity: TsgDXFEntity;
      AEntityLines: sgLines.TsgLines;
      ConvertMatrixCurrentInsertToWCS: TFMatrix;
      ADottedPoints: TFPointList; AIsAutocadLType, AIsNotScaledLType: Boolean);
var
  vPoint1, vPoint2, vScale: TFPoint;
  vIsNotScaledLType: Boolean;

  vPLine: TsgCADBasePolyLine;
  PL: TsgDXFPolyLine;

  vPLineGen, vOldAutocadMetod: Boolean;
  vOldUniform: Integer;

  function GetPlaneScale(const AMatrix: TFMatrix): TFPoint;
  begin
    Result := MakeFPoint(GetLengthVector(AMatrix.EX, fMaxResolution),
        GetLengthVector(AMatrix.EY, fMaxResolution),
        GetLengthVector(AMatrix.EZ, fMaxResolution));
  end;

  procedure BeforeBreakdown(ALine: TsgCADBasePolyLine;
    APLineGen: Boolean; var AScale: TFPoint; AOnlyScale: Boolean = True);
  begin
    if ALine.Closed and AIsAutocadLType and APLineGen and (not AOnlyScale) then
    begin
      ALine.PolyPoints.CyclicShiftRight(Integer(TsgDXFPolyLine(ALine).PointsCounts[0]));
      ALine.PolyPoints.Add(ALine.PolyPoints.First);
    end;
    if vIsNotScaledLType then
    begin
      AScale := GetPlaneScale(ConvertMatrixCurrentInsertToWCS);
      ScaleList(ALine.PolyPoints, AScale);
    end;
  end;

  procedure AfterBreakdown(ALine: TsgCADBasePolyLine; APLineGen: Boolean;
    AScale: TFPoint; ArrowDraw: Boolean = False; AOnlyScale: Boolean = True);
  begin
    if vIsNotScaledLType then
    begin
      AScale := ReverseScale(AScale);
      if Assigned(ADottedPoints) then
        ScaleList(ADottedPoints, AScale);
      ScaleList(ALine.PolyPoints, AScale);
      if ArrowDraw then
        DoPolylineArrow(vPLine, AEntityLines, @ConvertMatrixCurrentInsertToWCS, True);
    end
    else
      if ArrowDraw then
        DoPolylineArrow(ALine, AEntityLines, nil);

    if ALine.Closed and AIsAutocadLType and APLineGen and (not AOnlyScale)then
    begin
      ALine.PolyPoints.Count := ALine.PolyPoints.Count -1;
      ALine.PolyPoints.CyclicShiftLeft(Integer(TsgDXFPolyLine(ALine).PointsCounts[0]));
    end;
  end;

begin
  vIsNotScaledLType := AIsNotScaledLType;
  if AEntity.EntType in [ceLine, ceXline, ceRay] then
  begin
    vPoint1 := TsgDXFLine(AEntity).Point;
    vPoint2 := TsgDXFLine(AEntity).Point1;
    if vIsNotScaledLType then
    begin
      vScale := GetPlaneScale(ConvertMatrixCurrentInsertToWCS);
      vPoint1 := MultiplyFPoint(vPoint1, vScale);
      vPoint2 := MultiplyFPoint(vPoint2, vScale);
    end;
    AEntityLines.Line(vPoint1, vPoint2, ADottedPoints);
    if vIsNotScaledLType then
    begin
      vScale := ReverseScale(vScale);
      ScaleList(ADottedPoints, vScale);
    end;
  end
  else
  begin
    vPLine := TsgCADBasePolyLine(AEntity);
    if not (AEntity is TsgDXFPolyLine) then
      PL := nil
    else
      PL := TsgDXFPolyLine(AEntity);

    vOldUniform := AEntityLines.Uniform;
    vOldAutocadMetod := AEntityLines.IsAutocadMetod;
    try
      vPLineGen := vPLine.IsPLinegen and (AIsAutocadLType) and
        (not TsgDXFPolyline(vPLine).HasWidth);//change in future version
      if vPLineGen then
      begin
        AEntityLines.Uniform := 1;
        if AIsAutocadLType then
          AEntityLines.IsAutocadMetod := True;
        AEntityLines.Loaded(vPLine.Converter);
      end;

      case vPLine.EntType of
        cePolyline, ceLWPolyline:
        begin
          BeforeBreakdown(vPLine, vPLineGen, vScale, False);
          if Assigned(ADottedPoints) then
            AEntityLines.Vertexes(vPLine.PolyPoints, PL.PointsCounts, ADottedPoints, vPLine.Closed);
          AfterBreakdown(vPLine, vPLineGen, vScale, True, False);
        end;
        ceWipeOut, ceImageEnt:
          begin
            BeforeBreakdown(vPLine, vPLineGen, vScale);
            AEntityLines.Poly(vPLine.PolyPoints, ADottedPoints, vPLine.Closed);
            AfterBreakdown(vPLine, vPLineGen, vScale);
          end
          else // for circles, arcs, splines, etc.
          begin
            BeforeBreakdown(vPLine, vPLineGen, vScale);
            if vPLine.EntType = ceCircle then
              AEntityLines.Curve(vPLine.PolyPoints, ADottedPoints, vPLine.Closed)
            else
            begin
              AEntityLines.Curve(vPLine.PolyPoints, ADottedPoints, False);
            end;
            AfterBreakdown(vPLine, vPLineGen, vScale);
          end;
        end;
    finally
      AEntityLines.Uniform := vOldUniform;
      AEntityLines.IsAutocadMetod := vOldAutocadMetod;
    end;
  end;
end;

procedure GenerateArrow(const AConverter: TsgDXFConverter;
  const ABlock: TsgDXFEntity; const ArrowType: TsgDimArrowType);

  procedure ApplyEntity(AEntity: TsgDXFEntity);
  begin
    AConverter.DoCreate(AEntity);
    ABlock.AddEntity(AEntity);
    AEntity.ColorCAD := cnstColorCADByBlock;
    AEntity.LineWeight := fLineWeightByBlock;
    AEntity.Loaded(AConverter);
  end;

  procedure AddArc(const CX,CY,ARadius, AStart,AEnd: Double);
  var
    vArc: TsgDXFArc;
  begin
    vArc := TsgDXFArc.Create;
    vArc.Point := MakeFPoint(CX, CY, 0);
    vArc.Radius := ARadius;
    vArc.StartAngle := AStart;
    vArc.EndAngle := AEnd;
    ApplyEntity(vArc);
  end;

  procedure AddCircle(const CX,CY,ARadius: Double);
  var
    vCircle: TsgDXFCircle;
  begin
    vCircle := TsgDXFCircle.Create;
    vCircle.Point := MakeFPoint(CX, CY, 0);
    vCircle.Radius := ARadius;
    ApplyEntity(vCircle);
  end;

  procedure AddLine(const X1,Y1, X2,Y2: Double);
  var
    vLine: TsgDXFLine;
  begin
    vLine := TsgDXFLine.Create;
    vLine.Point := MakeFPoint(X1, Y1, 0);
    vLine.Point1 := MakeFPoint(X2, Y2, 0);
    ApplyEntity(vLine);
  end;

  procedure AddLWPolyLine(const X1,Y1,B1, X2,Y2,B2, AGlobalW: Double);
  var
    vLWPolyline: TsgDXFLWPolyline;
    procedure Add2DVertex(const X,Y, ABulge: Double);
    var
      vVertex: TsgDXFVertex;
    begin
      vVertex := TsgDXFVertex.Create;
      vVertex.Point := MakeFPoint(X, Y, 0);
      vVertex.Bulge := ABulge;
      vLWPolyline.AddEntity(vVertex);
    end;
  begin
    vLWPolyline := TsgDXFLWPolyline.Create;
    vLWPolyline.Closed := True;
    vLWPolyline.GlobalWidth := AGlobalW;
    Add2DVertex(X1, Y1, B1);
    Add2DVertex(X2, Y2, B2);
    ApplyEntity(vLWPolyline);
  end;

  procedure AddSolid(const X1,Y1, X2,Y2, X3,Y3, X4,Y4: Double);
  var
    vSolid: TsgDXFSolid;
  begin
    vSolid := TsgDXFSolid.Create;
    vSolid.Point := MakeFPoint(X1, Y1, 0);
    vSolid.Point1 := MakeFPoint(X2, Y2, 0);
    vSolid.Point2 := MakeFPoint(X3, Y3, 0);
    vSolid.Point3 := MakeFPoint(X4, Y4, 0);
    ApplyEntity(vSolid);
  end;

begin
  case ArrowType of
    datClosedblank, datClosed:   // '_CLOSEDBLANK', '_CLOSED'
      begin
        AddLine(-1,1/6, 0,0);
        AddLine(0,0, -1,-1/6);
        AddLine(-1,1/6, -1,-1/6);
        if ArrowType = datClosed then // '_CLOSED'
          AddLine(0,0, -1,0);
      end;
    datDot:     // '_DOT'
      begin
        AddLWPolyLine(-0.25,0,1, 0.25,0,1, 0.5);
        AddLine(-0.5,0, -1,0);
      end;
    datArchtick:     // '_ARCHTICK'
      AddLWPolyLine(-0.5,-0.5,0, 0.5,0.5,0, 0.15);
    datOblique:     // '_OBLIQUE'
      AddLine(-0.5,-0.5, 0.5,0.5);
    datOpen:     // '_OPEN'
      begin
        AddLine(-1,1/6, 0,0);
        AddLine(0,0, -1,-1/6);
        AddLine(0,0, -1,0);
      end;
    datOrigin, datOrigin2, datDotblank:  // '_ORIGIN', '_ORIGIN2', '_DOTBLANK'
      begin
        AddCircle(0,0, 0.5);
        if ArrowType = datOrigin2 then
          AddCircle(0,0, 0.25);
        if ArrowType = datOrigin then
          AddLine(0,0, -1,0)
        else
          AddLine(-0.5,0, -1,0);
      end;
    datOpen90:     // '_OPEN90'
      begin
        AddLine(-0.5,0.5, 0,0);
        AddLine(0,0, -0.5,-0.5);
        AddLine(0,0, -1,0);
      end;
    datOpen30:    // '_OPEN30'
      begin
        AddLine(-1,0.26794919, 0,0);
        AddLine(0,0, -1,-0.26794919);
        AddLine(0,0, -1,0);
      end;
    datDotsmall:    // '_DOTSMALL'
      AddLWPolyLine(-0.0625,0,1, 0.0625,0,1, 0.5);
    datDotsmallbank:    // '_DOTSMALLBLANK'
      AddCircle(0,0, 0.25);
    datBoxblank:    // '_BOXBLANK'
      begin
        AddLine(-0.5,-0.5,  0.5,-0.5);
        AddLine( 0.5,-0.5,  0.5, 0.5);
        AddLine( 0.5, 0.5, -0.5, 0.5);
        AddLine(-0.5, 0.5, -0.5,-0.5);
        AddLine(-0.5,0, -1,0);
      end;
    datBoxfilled:    // '_BOXFILLED'
      begin
        AddSolid(-0.5,0.5, 0.5,0.5, -0.5,-0.5, 0.5,-0.5);
        AddLine(-0.5,0, -1,0);
      end;
    datDatumblank:    // '_DATUMBLANK'
      begin
        AddLine(0,0.57735027, -1,0);
        AddLine(-1,0, 0,-0.57735027);
        AddLine(0,-0.57735027, 0,0.57735027);
      end;
    datDatumfilled:    // '_DATUMFILLED'
      AddSolid(0,0.57735027, -1,0, 0,-0.57735027, 0,-0.57735027);
    datIntegral:    // '_INTEGRAL'
      begin
        AddArc(0.44488802,-0.09133463, 0.45416667, 102,168);
        AddArc(-0.44488802,0.09133463, 0.45416667, 282,348);
      end;
    datNone:    // '_NONE'
      begin
        { empty }
      end;
  else     // _CLOSEDFILLED as default
    AddSolid(-1,1/6, 0,0, -1,1/6, -1,-1/6);
    AddLine(-1,0, -2,0);
  end;
end;


function GetOleExtents(AOleObject: {$IFDEF SG_HAS_ACTIVEX}IOleObject{$ELSE}IUnknown{$ENDIF};
  ADrawAspect: Integer; out ASize: TPoint; AOLEBitmap: TBitmap = nil): Boolean;
var
  LogPixelsPerInch: TPoint;
begin
  Result := False;
{$IFDEF SG_HAS_ACTIVEX}
{$IFDEF MSWINDOWS}
  if AOleObject <> nil then
    Result := AOleObject.GetExtent(ADrawAspect, ASize) = S_OK;
{$ENDIF}
{$ENDIF}
  if AOLEBitmap <> nil then
  begin
    ASize.X := AOLEBitmap.Width;
    ASize.Y := AOLEBitmap.Height;
    Result := True;
  end;
  if Result then
  begin
    LogPixelsPerInch := GetLogPixelsPerInch;
    ASize.X := sgMulDiv(ASize.X, LogPixelsPerInch.X, 2540);
    ASize.Y := sgMulDiv(ASize.Y, LogPixelsPerInch.Y, 2540);
  end
end;

function GetTransClipRect(const ALayout: TsgDXFLayout;
  const ADrawMatrix: TFMatrix; const AClipRectangle: PFRect): TFRect;
var
  vPictureRect: TFRect;
  vViewBox: TFRect;
begin
  FillChar(Result, SizeOf(Result), 0);
  vPictureRect := ALayout.Box;
  if Assigned(AClipRectangle) then
    vViewBox := AClipRectangle^
  else
    vViewBox := ALayout.Box;
  TransRectCorners(vPictureRect, ADrawMatrix);
  SwapDoubles(vPictureRect.Top, vPictureRect.Bottom);
  TransRectCorners(vViewBox, ADrawMatrix);
  SwapDoubles(vViewBox.Top, vViewBox.Bottom);
  Result.Left := (vViewBox.Left - vPictureRect.Left);
  Result.Top := vViewBox.Top - vPictureRect.Top;
  Result.Right := Result.Left + (vViewBox.Right - vViewBox.Left);
  Result.Bottom := Result.Top + (vViewBox.Bottom - vViewBox.Top);
end;

function GetVertex(AList: TList; Index: Integer; const ASy: Double): PsgSHXVertex;
begin
  Result := nil;
  if Index < 0 then Exit;
  if Index >= AList.Count then Exit;
  Result := PsgSHXVertex(AList[Index]);
  Result^.X := Result^.X * ASy;
  Result^.Y := Result^.Y * ASy;
end;

function GetExportImageIndex(AImage: TsgDXFImageEnt; AIndex: Integer;
  ConverImageToOLE: Boolean): Integer;
begin
  if AImage.ImageDef <> nil then
    Result := cntImageExportAsImage
  else
  begin
    if AIndex = -1 then
      Result := cntImageExportAsOLE2Frame
    else
    begin
      if AImage.ClipPointsCount > 0 then
        Result := cntImageExportAsFile
      else
      begin
        if (sgModAapproxim(GetAngleByPoints(AImage.Point, AImage.Point1, False,
              fDoubleResolution ,1, 1), 90, 1) = 0) and
          (sgModAapproxim(GetAngleByPoints(AImage.Point, AImage.Point2, False,
              fDoubleResolution ,1, 1), 90, 1) = 0) and
          ConverImageToOLE then
          // no rotate image -> save to ole
          Result := cntImageExportAsOLE2Frame
        else
          Result := cntImageExportAsFile;
      end;
    end;
  end;
end;

function SGArcCos(const X: Double): Double;
begin
  Result := ArcTan2(Sqrt(Abs(1 - X * X)), X);
end;

function UnitRect: TFRect;
begin
  Result := MakeFRect(0, 1, 0, 1, 0, 0);
end;

function EntArc(E: TsgDXFArc; P: TsgCADIterate): TsgArc;
var
  R: TFRect;
  vP: TFPoint;
  C: TFPoint;

  procedure XP(X,Y: Extended);
  var
    Pt: TFPoint;
  begin
    Pt.X := C.X + X;
    Pt.Y := C.Y + Y;
    Pt.Z := C.Z;
    DoExtrusion(Pt, E.Extrusion);
    vP := FPointXMat(Pt, P.Matrix);
    ExpandFRect(R, TFPoint(vP));
    Pt.X := C.X - X;
    Pt.Y := C.Y - Y;
    Pt.Z := C.Z;
    DoExtrusion(Pt, E.Extrusion);
    vP := FPointXMat(Pt, P.Matrix);
    ExpandFRect(R, TFPoint(vP));
  end;

  function Angle(const Pt: TFPoint): Extended;
  begin
    Result := ArcTan2(Pt.Y - C.Y, Pt.X - C.X);
    if Result < 0 then Result := Result + Pi;
    if Pt.Y < C.Y then Result := Result + Pi;
  end;

begin
  Result.Valid := False;
  if (E.Extrusion.X <> 0) or (E.Extrusion.Y <> 0)
    or (E.Extrusion.Z <> 1.0) then
      Exit;
  R := BadRect;
  C := E.Point;
  if E is TsgDXFEllipse then
  begin
    if (E.EndPoint.X <> 0) and (E.EndPoint.Y <> 0) then
      Exit;
    XP(E.EndPoint.X, E.EndPoint.Y);
    XP(TsgDXFEllipse(E).Ratio * E.EndPoint.Y, TsgDXFEllipse(E).Ratio * E.EndPoint.X);
  end
  else
  begin
    XP(E.Radius, 0);
    XP(0, E.Radius);
  end;
  Result.Rect.TopLeft := R.TopLeft;
  Result.Rect.BottomRight := R.BottomRight;
  Result.Point1 := FPointXMat(E.PolyPoints[E.PolyPoints.Count-1], P.Matrix);
  Result.Point2 := FPointXMat(E.PolyPoints[0], P.Matrix);
  DoScale2D(P);
  if P.XScale = 0 then// Polyline
    Exit;
  if (P.XScale < 0) xor (E.Extrusion.Z < 0) then
  begin
    vP := Result.Point2;
    Result.Point2 := Result.Point1;
    Result.Point1 := vP;
  end;

  Result.Center := FPointXMat(E.Point, P.Matrix);
  Result.Rx := Abs(Result.Rect.Right - Result.Rect.Left) / 2;
  Result.Ry := Abs(Result.Rect.Bottom - Result.Rect.Top) / 2;
  C := Result.Center;
  Result.Ang1 := Angle(Result.Point2);            // End angle
  Result.Ang2 := Angle(Result.Point1);          // Start angle
  Result.Valid := True;
end;

procedure RegisterProxyObjectReader(ProxyType: Integer; ProxyObjReader: TCustomProxyObjReader);
begin
  if ProxyType = cnstProxyTypeLWPLine then
    DWGLWPLineObjReader := ProxyObjReader;
end;

procedure UnRegisterProxyObjectReader(ProxyObjReader: TCustomProxyObjReader);
begin
  if ProxyObjReader = DWGLWPLineObjReader then
    DWGLWPLineObjReader := nil;
end;

function GetProxyObjectReader(ProxyType: Integer; out ProxyObjReader: TCustomProxyObjReader): Boolean;
begin
  ProxyObjReader := nil;
  if (ProxyType = cnstProxyTypeLWPLine) then
    ProxyObjReader := DWGLWPLineObjReader;
  Result := Assigned(ProxyObjReader);
end;

{ TsgProxyReaderImpl }

type
  TsgProxyEntProp = record
    Ent: TsgDXFEntity;
    Props: TsgSubProxyProps;
  end;

  TsgProxyEntPropArray = array of TsgProxyEntProp;

  TsgProxyEntPropList = class
  private
    FCount: Integer;
    FList: TsgProxyEntPropArray;
    function GetItem(Index: Integer): TsgProxyEntProp;{$IFDEF SG_INLINE} inline;{$ENDIF}
  protected
    property List: TsgProxyEntPropArray read FList;
  public
    function Add(Ent: TsgDXFEntity; const Props: TsgSubProxyProps): Integer;
    property Count: Integer read FCount;
    property Item[Index: Integer]: TsgProxyEntProp read GetItem; default;
  end;

{ TsgProxyEntPropList }

function TsgProxyEntPropList.Add(Ent: TsgDXFEntity; const Props: TsgSubProxyProps): Integer;
begin
  Result := FCount;
  if FCount = Length(FList) then
    SetLength(FList, ListGrow(Length(FList)));
  FList[Result].Ent := Ent;
  FList[Result].Props := Props;
  Inc(FCount);
end;

function TsgProxyEntPropList.GetItem(Index: Integer): TsgProxyEntProp;
begin
  Result := FList[Index];
end;

procedure TsgProxyReaderImpl.AddToDataBase;
var
  I, J, vID: Integer;
  S: string;
  vBlocks: TsgDXFEntity;
  vInsert: TsgDXFInsert;
  vItem: TsgTableItem;
begin
  vBlocks := FConv.Sections[csBlocks];
  vID := vBlocks.Count;
  for I := Low(FProxyClips) to FCount - 1 do
  begin
    vInsert := TsgDXFInsert(FProxyClips[I].Ent);
    vItem := TsgTableItem.Create;
    vItem.ItemObj := TsgOwneredItem(FProxyClips[I].Dict.GetNamedItem);
    J := FConv.EntityDictionaries.Add(vInsert.Handle, nil);
    TObject(FConv.EntityDictionaries.List^[J].Data) := vItem;
    FConv.Sections[csObjects].AddEntity(FProxyClips[I].Dict);
    repeat
      S := 'SG_PROXY_CLIP' + IntToStr(vID);
      Inc(vID);
    until vBlocks.FindEntByName(S) = nil;
    vInsert.BlockRecord.Name := S;
    vBlocks.AddEntity(vInsert.BlockRecord.Block);
  end;
end;

procedure TsgProxyReaderImpl.Apply(AProxy: TsgDXFEntity);
var
  I, K, J: Integer;
  vCurrentGroup: TsgDXFEntity;
  vE: TsgDXFEntity;
  vT: TsgDXFText absolute vE;
  vFontName: string;
  vStyle: TsgDXFStyle;
  vProps: TsgProxyEntPropList;
  vHasAnyEntityVisible: Boolean;
begin
  J := FProxyEntityProps.IndexOf(UInt64(AProxy));
  if J >= 0 then
  begin
    vHasAnyEntityVisible := False;
    vProps := TsgProxyEntPropList(FProxyEntityProps[J].Data);
    try
      vCurrentGroup := AProxy;
      I := 0;
      while (I < vProps.Count) and Assigned(vProps[I].Ent) do
      begin
        vE := vProps[I].Ent;
        vHasAnyEntityVisible := vHasAnyEntityVisible or vE.Visibility;
        if vE.EntType <> ceInsert then
        begin
          vE.Visibility := AProxy.Visibility;
          vE.LineTypeScale := AProxy.LineTypeScale;
          if vProps[I].Props.ColorID = cnstProxyEntityDefaultColorID then
            vE.ColorCAD := vCurrentGroup.ColorCAD
          else
            vE.ColorCAD := CmEntityColorToColorCAD(vProps[I].Props.ColorID);
          if vProps[I].Props.LayerIndex < 0 then
            vE.Layer := AProxy.Layer
          else
            if vProps[I].Props.LayerIndex >= FConv.Counts[csLayers] then
              vE.Layer := AProxy.Layer
            else
              vE.Layer := FConv.Layers[vProps[I].Props.LayerIndex];
          vE.LineType := FConv.LTypes[(vProps[I].Props.LTypeIndex + 2) mod FConv.Counts[csLTypes]];
          vE.SetLWeight(vProps[I].Props.LWeight);
          case vE.EntType of
            ceText, ceAttrib, ceAttdef:
              begin
                vFontName := vT.SHXFont;
                if vT.WinFont then
                  vFontName := vT.FontName;
                K := FStylesByFont.IndexOf(vFontName);
                if K >= 0 then
                  vStyle := TsgDXFStyle(FStylesByFont.Objects[K])
                else
                begin
                  vFontName := ChangeFileExt(vFontName, '');
                  K := FStylesByFont.IndexOf(vFontName);
                  if K >= 0 then
                    vStyle := TsgDXFStyle(FStylesByFont.Objects[K])
                  else
                    vStyle := FConv.StyleByName(cnstStandard);
                end;
                vT.StyleRef := vStyle;
                vT.Properties.BigFont := vStyle.BigFont;
              end;
          end;
          vCurrentGroup.AddEntity(vE);
        end
        else
          if vCurrentGroup = AProxy then
            vCurrentGroup := TsgDXFInsert(vE).BlockRecord.Block
          else
          begin
            AProxy.AddEntity(vE);
            vCurrentGroup := AProxy;
          end;
        Inc(I);
      end;
      if AProxy.Visibility then
        AProxy.Visibility := vHasAnyEntityVisible;
    finally
      FProxyEntityProps.Delete(J);
      vProps.Free;
    end;
  end;
end;

constructor TsgProxyReaderImpl.Create(const AConv: TsgDXFConverter;
  AReader: IProxyReader);
begin
  FConv := AConv;
  FReader := AReader;
  FProxyEntityProps := TsgObjectCollection.Create;
  FProxyEntityProps.Duplicates := dupIgnore;
  FStylesByFont := TStringList.Create;
  FStylesByFont.Sorted := True;
end;

destructor TsgProxyReaderImpl.Destroy;
begin
  FProxyEntityProps.Free;
  FStylesByFont.Free;
  inherited Destroy;
end;

function TsgProxyReaderImpl.GetProxyClipItem(Index: Integer): TsgProxyClipItem;
begin
  Result := FProxyClips[Index];
end;

procedure TsgProxyReaderImpl.Grow;
begin
  SetLength(FProxyClips, ListGrow(Length(FProxyClips)));
end;

procedure TsgProxyReaderImpl.Read(AProxy: TsgDXFEntity);
const
  cnstSubProxyProps: TsgSubProxyProps = (
    LayerIndex: -1;
    LTypeIndex: -1;
    ColorID: cnstProxyEntityDefaultColorID;
    LWeight: -2;//fLineWeightByBlock??
    Marker: 0;
    LTScale: 1.0;
    ProxyType: 0;
    PlotStyleIndex: 0
  );
//  cnstSubEntNames: array[0 .. 38] of string = (
//    'UNKNOWN', 'Extents', 'CIRCLE', 'CIRCLE3PT', 'CIRCULARARC', 'CIRCULARARC3PT',
//    'POLYLINE', 'POLYGON', 'MESH', 'SHELL', 'TEXT', 'TEXT2', 'XLINE', 'RAY',
//    'SUBENT_COLOR', 'SUBENT_UNKNOWN_15', 'SUBENT_LAYER', 'SUBENT_UNKNOWN_17',
//    'SUBENT_LINETYPE', 'SUBENT_MARKER', 'SUBENT_FILLON', 'SUBENT_UNKNOWN_21',
//    'SUBENT_TRUECOLOR', 'SUBENT_LNWEIGHT', 'SUBENT_ LTSCALE', 'SUBENT_ THICKNESS',
//    'SUBENT_ PLSTNAME', 'PUSH_CLIP', 'POP_CLIP', 'PUSH_MODELXFORM', 'PUSH_MODELXFORM2',
//    'POP_MODELXFORM', 'ACAD_TABLE_LINE', 'SUBENT_UNKNOWN_33', 'SUBENT_UNKNOWN_34',
//    'SUBENT_UNKNOWN_35', 'AEC_UNKNOWN_TEXT', 'SUBENT_UNKNOWN_37','ACAD_TABLE_TEXT');
type
  TIntegerArray = array of Integer;
var
  I, J, K, L, M, Count, vDataSize, vSubEntityType, vSubEntCount, vRowsNumber,
    vColumnsNumber, vEntriesNumber: Integer;
  vRadius, vSweepAngle: Double;
  vPTransform: PsgCADIterate;
  pt1, pt2, pt3: TFPoint;
  vFill: Boolean;
  vStr, vTrueFace, vFontName, vBigFontName: string;
  vAStr: AnsiString;
  vTransforms: TList;
  vPolygon: TsgCADPolyPolygon;
  vPolyline: TsgDXFPolyLine;
  vVertex: TsgDXFVertex;
  vText: TsgDXFText;
  vEntity: TsgDXFEntity;
  vLWPLineReader: TCustomProxyObjReader;
{  vEntries: TsgIntegerList;
  vAng1, vAng2, vAng3, vAng4: Double;
  vEntriesNumber, eLayerID, fLayerID, meshEdgesNumber, meshFacesNumber, vertNumber, rrr, epf, fpf, vpf: Integer;
  vPt: PFPoint;
  pp: TList;   }
  vSpatial: TsgCADSpatialFilter;
  vProps: TsgProxyEntPropList;
  vSubEntProp: TsgSubProxyProps;
  vEntriesCount, vVertexCount: Integer;
  vEntries: array of TIntegerArray;

  function IsPointIncludeNotBadProxyCoordValue(const APoint: TFPoint): Boolean;
  const
    cnstBadProxyCoordValue = 1E20;
  begin
    Result := (APoint.X <> cnstBadProxyCoordValue) or (APoint.Y <> cnstBadProxyCoordValue) or
      (Abs(APoint.Z) <> cnstBadProxyCoordValue);
  end;

  function HasNormalPolyPoint(APoints: PFPointArray; ACount: Integer): Boolean;
  var
    T: Integer;
  begin
    Result := False;
    T := 0;
    while (T < ACount) and not Result do
      if IsPointIncludeNotBadProxyCoordValue(APoints^[T]) then
        Inc(Result)
      else
        Inc(T);
  end;

  function Read3RD: TFPoint;
  begin
    Result.X := FReader.ReadDouble;
    Result.Y := FReader.ReadDouble;
    Result.Z := FReader.ReadDouble;
  end;

  function Read2RD: TFPoint;
  begin
    Result.X := FReader.ReadDouble;
    Result.Y := FReader.ReadDouble;
    Result.Z := 0;
  end;

  function GetTextString: string;
{$IFNDEF SGDEL_2009}
  var
    K: Integer;
    S: WideString;
{$ENDIF}
  begin
{$IFDEF SGDEL_2009}
    Result := string(FReader.ReadWidePadding);
{$ELSE}
    Result := '';
    S := FReader.ReadWidePadding;
    for K := 1 to Length(S) do
      if Ord(S[K]) <= 127 then
        Result := Result + AnsiChar(S[K])
      else
        Result := Result + cnstTypeU + IntToHex(Ord(S[K]), 4);
{$ENDIF}
  end;

  function GetTransformPoint(const APoint: TFPoint): TFPoint;
  begin
    if vTransforms = nil then
      Result := APoint
    else
      Result := FPointXMat(APoint, PsgCADIterate(vTransforms.Last)^.Matrix);
  end;

  function GetTransformSize(const ASize: Double): Double;
  begin
    if vTransforms = nil then
      Result := ASize
    else
      Result := ASize*PsgCADIterate(vTransforms.Last)^.YScale;
  end;

  function CreateVertex(const APoint: TFPoint): TsgDXFVertex;
  begin
    Result := TsgDXFVertex.Create;
    Result.Point := APoint;
  end;

  function CustomReadVertexTransformed: TsgDXFVertex;
  begin
    Result := CreateVertex(GetTransformPoint(Read3RD));
  end;

  procedure FillPolygon(APoly: TsgDXFPolyline; const AIndices: array of Integer;
    APolyPolygon: TsgCADPolyPolygon);
  var
    M: Integer;
    Boundaries: TF2DPointList;
  begin
    Boundaries := TF2DPointList.Create;
    APolyPolygon.Boundaries.Add(Boundaries);
    for M := Low(AIndices) to High(AIndices) do
      Boundaries.Add(APoly.Vertexes[AIndices[M]].Point.Point2D);
  end;

  function CreatePolygon(APoly: TsgDXFPolyline; ACount: Integer = -1): TsgCADPolyPolygon;
  var
    M: Integer;
  begin
    Result := TsgCADPolyPolygon.Create;
    Result.Boundaries.Add(TF2DPointList.Create);
    if ACount = -1 then ACount := APoly.Count;
    for M := 0 to ACount - 1 do
      TF2DPointList(Result.Boundaries[0]).Add(APoly.Vertexes[M].Point.Point2D);
  end;

  procedure AddPolyToProxy(APoly: TsgDXFPolyline; AFill: Boolean; ACount: Integer = -1);
  begin
    if AFill then
      vProps.Add(CreatePolygon(APoly), vSubEntProp);
    vProps.Add(APoly, vSubEntProp);
  end;

  function GetAngle(p, a: TFPoint): Single;
  var
    hip, leg: Double;
  begin
    Result := 0;
    if ((a.X > p.X) and (a.Y > p.Y)) then // quadrant 1
    begin
      hip := Sqrt(Sqr(a.X - p.X) + Sqr(a.Y - p.Y));
      leg := a.X - p.X;
      Result := (ArcCos(leg / hip) * f180DividedByPi);
      Exit;
    end
    else if ((a.X < p.X) and (a.Y > p.Y)) then// quadrant 2
    begin
      hip := Sqrt(Sqr(p.X - a.X) + Sqr(a.Y - p.Y));
      leg := p.X - a.X;
      Result := (180 - ArcCos(leg / hip) * f180DividedByPi);
      Exit;
    end
    else if ((a.X < p.X) and (a.Y < p.Y)) then// quadrant 3
    begin
      hip := Sqrt(Sqr(p.X - a.X) + Sqr(p.Y - a.Y));
      leg := p.X - a.X;
      Result := (180 + ArcCos(leg / hip) * f180DividedByPi);
      Exit;
    end
    else if ((a.X > p.X) and (a.Y < p.Y)) then// quadrant 4
    begin
      hip := Sqrt(Sqr(a.X - p.X) + Sqr(p.Y - a.Y));
      leg := a.X - p.X;
      Result := (360 - ArcCos(leg / hip) * f180DividedByPi);
      Exit;
    end
    else if((a.Y = p.Y) and (a.X > p.X)) then
      Exit// Result := 0;
    else if ((a.Y > p.Y) and (a.X = p.X)) then
    begin
      Result := 90;
      Exit;
    end
    else if((a.Y = p.Y) and (a.X < p.X)) then
    begin
      Result := 180;
      Exit;
    end
    else// if((a.Y < p.Y) and (a.X = p.X)) then
    begin
      Result := 270;
      Exit;
    end;
  end;

  function DoPolyline(ACount: Integer; const AClosed: Boolean; const AIs3D: Boolean): TsgDXFEntity;
  var
    N: Integer;
    vPoints: PFPointArray;
  begin
    GetMem(vPoints, ACount * SizeOf(TFPoint));
    try
      FReader.ReadBytes(vPoints^, ACount * SizeOf(TFPoint));
      if ACount = 2 then
      begin
        Result := TsgDXFLine.Create;
        TsgDXFLine(Result).Point := GetTransformPoint(vPoints^[0]);
        TsgDXFLine(Result).Point1 := GetTransformPoint(vPoints^[1]);
      end
      else
      begin
        Result := TsgDXFPolyLine.Create;
        TsgDXFPolyLine(Result).Polyline3D := AIs3D; //3d Polyline
        for N := 0 to ACount - 1 do
          TsgDXFPolyLine(Result).AddEntity(CreateVertex(GetTransformPoint(vPoints^[N])));
        TsgDXFPolyLine(Result).Closed := AClosed;
      end;
      Result.Visibility := HasNormalPolyPoint(vPoints, ACount);
      vProps.Add(Result, vSubEntProp);
    finally
      FreeMem(vPoints);
    end;
  end;

  procedure SetSHXFont(const AText: TsgDXFText; const ASHXFont: string);// to be changed in the future versions
  begin
    AText.SetFontName(ASHXFont, MVFontStylesToFontStyles(AText.Properties.FontStyle));
  end;

  function GetString(const AStr: AnsiString): string;
  begin
    Result := ConvertToWideString(AStr, FConv.CodePage);
  end;

  procedure Next(ASize: Integer);
  begin
    FReader.PopPosition;
    FReader.Seek(ASize);
  end;

  procedure ReadMatrix(var AMatrix: TFMatrix; ASkipSkew: Boolean);
  var
    vCol, vRow: Integer;
  begin
    for vCol := 0 to 2 do
      for vRow := 0 to 3 do
        AMatrix.M[vRow, vCol] := FReader.ReadDouble;
    if ASkipSkew then
      FReader.Seek(32);//for vRow := 0 to 3 do FReader.ReadDouble;
  end;

  function CustomReadText(var AText: TsgDXFText): Boolean;
  var
    vPoint: TFPoint;
  begin
    AText := nil;
    Result := False;
    vPoint := Read3RD;
    if IsPointIncludeNotBadProxyCoordValue(vPoint) then
    begin
      AText := TsgDXFText.Create;
      AText.Point := GetTransformPoint(vPoint);
      AText.Extrusion := Read3RD;
      AText.Rotation := GetAngle(cnstFPointZero, Read3RD);// Read3RD!
      Result := True;
    end;
  end;

  procedure ReadCommonTextProps(AText: TsgDXFText);
  begin
    FReader.Seek(4);//"raw"; 0 if raw, 1 if not. raw means don't interpret %% stuff
    AText.Height := GetTransformSize(FReader.ReadDouble);
    AText.Scale := FReader.ReadDouble;
    AText.ObliqueAngle := FReader.ReadDouble * f180DividedByPi;
    AText.Tracking := FReader.ReadDouble; //RD: Tracking percentage
    AText.Properties.Backward := FReader.ReadInteger <> 0;
    AText.Properties.UpsideDown := FReader.ReadInteger <> 0;
    if FReader.ReadInteger <> 0 then //RL : Is vertical (0/1)
      AText.Properties.FontStyle := AText.Properties.FontStyle + [fmUpward];
    if FReader.ReadInteger <> 0 then //RL : Is underlined (0/1)
      AText.Properties.FontStyle := AText.Properties.FontStyle + [fmUnderline];
    if FReader.ReadInteger <> 0 then //RL : Is overlined (0/1)
      AText.Properties.FontStyle := AText.Properties.FontStyle + [fmStrikeOut];
  end;

begin
  vProps := TsgProxyEntPropList.Create;
  FReader.Seek(4); //seRL
  vSubEntCount := FReader.ReadInteger;
  vSubEntProp := cnstSubProxyProps;
  vFill := False;
  vTransforms := nil;
  for I := 0 to vSubEntCount - 1 do
  begin
    vDataSize := FReader.ReadInteger - 8;
    vSubEntityType := FReader.ReadInteger;
    FReader.PushPosition;
    case vSubEntityType of
{      1:
        begin
          pt1 := Read3RD;
          pt2 := Read3RD;
        end;                       }
      2:// CIRCLE (normal circle)
        begin
          vPolyline := TsgDXFPolyline.Create;
          vPolyline.Polyline3D := True; //3d Polyline
          pt1 := GetTransformPoint(Read3RD);
          vRadius := FReader.ReadDouble;
          pt2 := Read3RD;
          // Definition of the start vector direction
          if (pt2.X <= 1 + fAccuracy) and not IsEqual(Abs(pt2.Y), 1.0) then
            pt3 := Ort(sgFunction.Vector(pt2, cnstYOrtAxis))
          else
            pt3 := Ort(sgFunction.Vector(pt2, cnstXOrtAxis));
          if ArcFromTwoVectors(vPolyline, vRadius, 2*Pi, pt1, pt2, pt3, GetNumberOfCircleParts) then
            AddPolyToProxy(vPolyline, vFill)
          else
            vPolyline.Free;
        end;
      3:// CIRCLE3PT (3 point circle)
        begin
          vPolyline := TsgDXFPolyline.Create;
          vPolyline.Polyline3D := True; //3d Polyline
          pt1 := GetTransformPoint(Read3RD);
          pt2 := GetTransformPoint(Read3RD);
          pt3 := GetTransformPoint(Read3RD);
          if CircleFromThreePoints(vPolyline, pt1, pt2, pt3, GetNumberOfCircleParts, True) then
            AddPolyToProxy(vPolyline, vFill)
          else
            vPolyline.Free;
        end;
      4:// CIRCULARARC (normal and start vector arc)
        begin
          vPolyline := TsgDXFPolyline.Create;
          vPolyline.Polyline3D := True; //3d Polyline
          pt1 := Read3RD;
          vRadius := FReader.ReadDouble;
          pt2 := Read3RD;
          pt3 := Ort(Read3RD);// start vector direction
          vSweepAngle := FReader.ReadDouble;
          FReader.Seek(4); //seRL
          if ArcFromTwoVectors(vPolyline, vRadius, vSweepAngle, pt1, pt2, pt3, GetNumberOfCircleParts) then
          begin
            for J := 0 to vPolyline.Count - 1 do
              vPolyline.Vertexes[J].Point := GetTransformPoint(vPolyline.Vertexes[J].Point);
            AddPolyToProxy(vPolyline, vFill)
          end
          else
            vPolyline.Free;
        end;
      5:// CIRCULARARC3PT (3 point arc)
        begin
          vPolyline := TsgDXFPolyline.Create;
          vPolyline.Polyline3D := True; //3d Polyline
          pt1 := GetTransformPoint(Read3RD);
          pt2 := GetTransformPoint(Read3RD);
          pt3 := GetTransformPoint(Read3RD);
          FReader.Seek(4);//seRL
          if CircleFromThreePoints(vPolyline, pt1, pt2, pt3, GetNumberOfCircleParts, False) then
            AddPolyToProxy(vPolyline, vFill)
          else
            vPolyline.Free;
        end;
      6:// POLYLINE
        begin
          Count := FReader.ReadInteger;
          if Count > 0 then
            DoPolyline(Count, False, True);
        end;
      7:// POLYGON
        begin
          Count := FReader.ReadInteger;
          if vFill then
          begin
            vPolygon := TsgCADPolyPolygon.Create;
            vPolygon.Boundaries.Add(TF2DPointList.Create);
            for J := 0 to Count-1 do
              TF2DPointList(vPolygon.Boundaries[0]).Add(GetTransformPoint(Read3RD).Point2D);
            vProps.Add(vPolygon, vSubEntProp);
          end
          else
            if Count > 0 then
              DoPolyline(Count, True, True);
        end;
      8:// MESH
        begin
          vPolyline := TsgDXFPolyline.Create;
          vRowsNumber := FReader.ReadInteger;
          vColumnsNumber := FReader.ReadInteger;
          for J := 0 to vRowsNumber - 1 do
            for K := 0 to vColumnsNumber - 1 do
              vPolyline.AddEntity(CustomReadVertexTransformed);
          vPolyline.MeshM := vRowsNumber;
          vPolyline.MeshN := vColumnsNumber;
          AddPolyToProxy(vPolyline, vFill);
          Next(vDataSize);// if it is commented downwards
          { epf := FReader.ReadInteger;
          if epf and $FFFF <> 0 then
          begin
            meshEdgesNumber := (vRowsNumber - 1) * vColumnsNumber +
              (vColumnsNumber - 1) * vRowsNumber;
            if epf and $00000001 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                FReader.ReadInteger;
            if epf and $00000002 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                eLayerID := FReader.ReadInteger;
            if epf and $00000004 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                FReader.ReadInteger;
            if epf and $00000020 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                FReader.ReadInteger;
            if epf and $00000040 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                K := FReader.ReadInteger;// visibility
          end;
          fpf := FReader.ReadInteger;
          if fpf and $FFFF <> 0 then
          begin
            meshFacesNumber := (vRowsNumber - 1) * (vColumnsNumber - 1);
            if fpf and $00000001 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                FReader.ReadInteger;
            if fpf and $00000002 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                fLayerID := FReader.ReadInteger;
            if fpf and $00000020 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                FReader.ReadInteger;
            if fpf and $00000080 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                pt1 := Read3RD;
            if fpf and $00000040 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                FReader.ReadInteger;
            end;
            vpf := FReader.ReadInteger;
            if vpf and $FFFF <> 0 then
            begin
              vertNumber := vRowsNumber * vColumnsNumber;
              if vpf and $00000080 <> 0 then
                for J := 0 to vertNumber - 1 do
                  pt1 := Read3RD;
              if vpf and $00000400 <> 0 then
                FReader.ReadInteger;
          end;                                              }
        end;
      9:// SHELL
        begin
          vPolyline := TsgDXFPolyline.Create;
          vPolyline.Flags := 64; // PolyFaceMesh(?)
          Count := FReader.ReadInteger;
          for J := 0 to Count - 1 do
            vPolyline.AddEntity(CustomReadVertexTransformed);
          vPolyline.MeshM := Count;
          vPolyline.MeshN := 1;// only for correct TsgDXFPolyline loading
          // TODO: make vPolyline as solid in 3d mode
          vEntriesNumber := FReader.ReadInteger;
          vPolygon := nil;
          try
            //face entries -3,2,3,4 would mean a 3 sided face of vertices 2,3 and 4.

            vEntriesCount := 0;
            while vEntriesNumber > 0 do
            begin
              if vEntriesCount = Length(vEntries) then
                SetLength(vEntries, ListGrow(Length(vEntries)));
              K := Abs(FReader.ReadInteger);
              SetLength(vEntries[vEntriesCount], K);
              FReader.ReadBytes(vEntries[vEntriesCount][0], K * SizeOf(Integer));
              Inc(vEntriesCount);
              Dec(vEntriesNumber, K + 1);
            end;

            if vEntriesCount = 1 then //??
            begin
              if not vPolyline.Closed and (Count > 2) then
                if not IsEqualFPoints(vPolyline.Vertexes[0].Point, vPolyline.Vertexes[vPolyline.Count - 1].Point) then
                  vPolyline.AddEntity(CreateVertex(vPolyline.Vertexes[0].Point));
              vPolyline.Closed := True;
            end;

            for J := 0 to vEntriesCount - 1 do
            begin
              L := 0;
              repeat
                vVertex := CreateVertex(vPolyline.Vertexes[vEntries[J][L]].Point);
                vVertex.Flags := 128;
                vVertexCount := 4;
                M := 0;
                while (M < vVertexCount) and (L <= High(vEntries[J])) do
                begin
                  vVertex.PolyFaceVertexIndex[M + 1] := vEntries[J][L] + 1;
                  Inc(L);
                  Inc(M);
                end;
                vPolyline.AddEntity(vVertex);
              until L > High(vEntries[J]);
            end;
            if vFill and (vEntriesCount > 0) then
            begin
              vPolygon := TsgCADPolyPolygon.Create;
              for J := 0 to vEntriesCount - 1 do
                FillPolygon(vPolyline, vEntries[J], vPolygon);
            end;
          finally
            Finalize(vEntries);
          end;
          if Assigned(vPolygon) then
            vProps.Add(vPolygon, vSubEntProp);
          vProps.Add(vPolyline, vSubEntProp);
          Next(vDataSize);// if it is commented downwards
          { meshEdgesNumber := vEntriesNumber - 1;
          meshFacesNumber := Integer(vEntries[0]);
          epf := FReader.ReadInteger;
          if epf and $0000FFFF <> 0 then
          begin
            if epf and $00000001 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                rrr := FReader.ReadInteger;
            if epf and $00000002 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                eLayerID := FReader.ReadInteger;
            if epf and $00000004 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                rrr := FReader.ReadInteger;
            if epf and $00000020 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                rrr := FReader.ReadInteger;
            if epf and $00000040 <> 0 then
              for J := 0 to meshEdgesNumber - 1 do
                rrr := FReader.ReadInteger;
          end;
          fpf := FReader.ReadInteger;
          if fpf and $0000FFFF <> 0 then
          begin
            if fpf and $00000001 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                rrr := FReader.ReadInteger;
            if fpf and $00000002 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                fLayerID := FReader.ReadInteger;
            if fpf and $00000020 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                rrr := FReader.ReadInteger;
            if fpf and $00000080 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                pt1 := Read3RD;
            if fpf and $00000040 <> 0 then
              for J := 0 to meshFacesNumber - 1 do
                rrr := FReader.ReadInteger;
          end;
          vpf := FReader.ReadInteger;
          if vpf and $0000FFFF <> 0 then
          begin
            if vpf and $00000080 <> 0 then
              for J := 0 to Count - 1 do
                pt1 := Read3RD;
            if vpf and $00000400 <> 0 then
              rrr := FReader.ReadInteger;
          end;                               }
        end;
      {10:
        begin
          vText := TsgDXFText.Create;
          vText.Point := GetTransformPoint(Read3RD);
          vText.Extrusion := Read3RD;
          vText.Rotation := GetAngle(cnstFPointZero, Read3RD);
          vText.Height := FReader.ReadDouble;
          vText.Scale := FReader.ReadDouble;
          vText.ObliqueAngle := FReader.ReadDouble;
          vAStr := FReader.ReadAnsiPadding;
          vStr := GetString(vAStr);
          vText.Text := vStr;
          Next(vDataSize);
          AddEntityToProxy(vText);
        end;}
      11:
        begin
          if CustomReadText(vText) then
          begin
            vAStr := FReader.ReadAnsiPadding;
            Count := FReader.ReadInteger; // Text length
            if Count <> -1 then
              SetLength(vAStr, Count);
            vStr := GetString(vAStr);
            vText.Text := vStr;
            ReadCommonTextProps(vText);
            vAStr := FReader.ReadAnsiPadding;
            vFontName := GetString(vAStr);
            vAStr := FReader.ReadAnsiPadding;
            vBigFontName := GetString(vAStr);
            vText.Properties.BigFont := vBigFontName;
            SetSHXFont(vText, vFontName);// to be changed in the future versions
            vProps.Add(vText, vSubEntProp);
          end;
          Next(vDataSize);
        end;
{      12:
        begin
          pt1 := Read3RD;
          pt2 := Read3RD;
        end;
      13:
        begin
          pt1 := Read3RD;
          pt2 := Read3RD;
        end;                      }
      14:
        vSubEntProp.ColorID := cmcIndexed shl 24 or FReader.ReadInteger;
      16:
        vSubEntProp.LayerIndex := FReader.ReadInteger;
      18:
        begin
          vSubEntProp.LTypeIndex := FReader.ReadInteger;
          case vSubEntProp.LTypeIndex of
            $7FFF: vSubEntProp.LTypeIndex := -1;
            $7FFE: vSubEntProp.LTypeIndex := -2;
          end;
        end;
      19:
        vSubEntProp.Marker := FReader.ReadInteger;
      20:// FILL (on/off)
        vFill := FReader.ReadInteger = 1;
      22:
        vSubEntProp.ColorID := FReader.ReadInteger;
      23:
        vSubEntProp.LWeight := FReader.ReadInteger;
      24:
        vSubEntProp.LTScale := FReader.ReadDouble;
      26:
        begin
          vSubEntProp.ProxyType := FReader.ReadInteger;
          vSubEntProp.PlotStyleIndex := FReader.ReadInteger;
        end;
      27:
        begin
          if Length(FProxyClips) = FCount then Grow;
          FProxyClips[FCount].Ent := TsgDXFInsert.Create;
          TsgDXFInsert(FProxyClips[FCount].Ent).BlockRecord := TsgDXFBlockRecord.Create;
          FProxyClips[FCount].Dict := TsgDXFDictionary.Create;
          FProxyClips[FCount].Dict.AddEntity(TsgDXFDictionary.Create);
          FProxyClips[FCount].Dict[0].Name := sAcadFilterDictionary;
          vSpatial := TsgCADSpatialFilter.Create;
          vSpatial.Name := cnstSpatial;
          FProxyClips[FCount].Dict[0].AddEntity(vSpatial);
          vSpatial.Extrusion := Read3RD;
          vSpatial.Clipbdorg := Read3RD;
          Count := FReader.ReadInteger;
          for J := 0 to Count - 1 do
            vSpatial.Bounds.Add(Read2RD);
          ReadMatrix(vSpatial.FClip, True);
          ReadMatrix(vSpatial.FInvBlkTransform, True);
          vSpatial.FrontClip := FReader.ReadInteger = 1;
          vSpatial.BackClip := FReader.ReadInteger = 1;
          vSpatial.FrontDist := FReader.ReadDouble;
          vSpatial.BackDist := FReader.ReadDouble;
          FReader.Seek(4);//FReader.ReadInteger;// unknown
          vProps.Add(FProxyClips[FCount].Ent, vSubEntProp);
          Inc(FCount);
        end;
      28:
        begin
          vProps.Add(FProxyClips[FCount-1].Ent, vSubEntProp);
        end;
      29:// PUSH_MODELXFORM
        begin
          if vTransforms = nil then
            vTransforms := TList.Create;
          New(vPTransform);
          FillChar(vPTransform^, SizeOf(vPTransform^), 0);
          ReadMatrix(vPTransform^.Matrix, True);
          if vTransforms.Count > 0 then
            vPTransform^.Matrix := FMatXMat(vPTransform^.Matrix, PsgCADIterate(vTransforms.Last)^.Matrix);
          DoScale2D(vPTransform^);
          vTransforms.Add(vPTransform);
        end;
{      30:
        for J := 0 to 15 do
          FReader.ReadDouble;      }
      31:// POP_MODELXFORM
        if vTransforms <> nil then
        begin
          if vTransforms.Count > 0 then
          begin
            Dispose(vTransforms.Last);
            vTransforms.Delete(vTransforms.Count-1);
          end;
          if vTransforms.Count = 0 then
            FreeRecordList(vTransforms);
        end;
      32:// ACAD_TABLE line (not documented)
        begin
          Count := FReader.ReadInteger;
          if Count > 0 then
          begin
            vEntity := DoPolyline(Count, False, True);
            if Assigned(vEntity) then
              vEntity.SetExtrusion(Read3RD); //se3RD
          end;
          Next(vDataSize);
        end;
      cnstProxyTypeLWPLine:
        begin
          FReader.Seek(4); // binary data size
          if GetProxyObjectReader(cnstProxyTypeLWPLine, vLWPLineReader) then
          begin
            vPolyline := TsgDXFLWPolyline.Create;
            if vLWPLineReader.ReadObject(FReader, vPolyline) then
            begin
              if Assigned(vTransforms) and (vTransforms.Count > 0) then
                for J := 0 to vPolyline.Count - 1 do
                  vPolyline.Vertexes[J].Point := FPointXMat(vPolyline.Vertexes[J].Point, PsgCADIterate(vTransforms.Last)^.Matrix);
              AddPolyToProxy(vPolyline, False);
            end
            else
              vPolyline.Free;
          end;
          Next(vDataSize);
        end;
      {34:
        begin
          FReader.ReadInteger;
          FReader.ReadInteger;
        end;  }
      36:// AEC undocumented data
        begin
          if CustomReadText(vText) then
          begin
            vText.Height := GetTransformSize(FReader.ReadDouble);
            vText.Scale := FReader.ReadDouble;
            vText.ObliqueAngle := FReader.ReadDouble * f180DividedByPi;
            vText.Text := GetTextString;
            // ... unknow data ...
            vProps.Add(vText, vSubEntProp);
          end;
          Next(vDataSize);
        end;
      38:// ACAD_TABLE text (not documented)
        begin
          if CustomReadText(vText) then
          begin
            vText.Text := GetTextString;
            FReader.Seek(4);//seRL - textlen
            ReadCommonTextProps(vText);
        // ----- True type font descriptor fields -----
            if FReader.ReadInteger <> 0 then //RL : Is bold (0/1)
              vText.Properties.FontStyle := vText.Properties.FontStyle + [fmBold];
            if FReader.ReadInteger <> 0 then //RL : Is italic (0/1)
              vText.Properties.FontStyle := vText.Properties.FontStyle + [fmItalic];
            vText.FCharset := FReader.ReadInteger and $FF;
            vText.FPitch := FReader.ReadInteger and $FF;
            vTrueFace := string(FReader.ReadWidePadding);
            vFontName := string(FReader.ReadWidePadding);
        // ----- True type font descriptor fields -----
            vBigFontName := string(FReader.ReadWidePadding);
            vText.Properties.BigFont := vBigFontName;
            if vFontName <> '' then
              SetSHXFont(vText, vFontName)// to be changed in the future versions
            else
              if vTrueFace <> '' then
                vText.SetTTFFont(vTrueFace, MVFontStylesToFontStyles(vText.Properties.FontStyle));
            vProps.Add(vText, vSubEntProp);
          end;
          Next(vDataSize);
        end;
      else
        Next(vDataSize);//Inc2(APBit, (vDataSize - 8) shl 3);
    end;
  end;
  FreeRecordList(vTransforms);
  FProxyEntityProps.Add(UInt64(AProxy), vProps);
end;

procedure TsgProxyReaderImpl.UpdateHandles;
var
  vConvStatus: TConvStatus;
  I: Integer;
begin
  vConvStatus := FConv.Status;
  try
    FConv.Status := stDefault;
    for I := Low(FProxyClips) to FCount - 1 do
    begin
      FConv.SetHandle(FProxyClips[I].Ent);
      FConv.SetHandle(TsgDXFInsert(FProxyClips[I].Ent).BlockRecord);
      FConv.SetHandle(FProxyClips[I].Dict);
    end;
  finally
    FConv.Status := vConvStatus;
  end;
end;

procedure TsgProxyReaderImpl.UpdateStyleByFont(AStyles: TsgDXFEntity);
var
  I, J: Integer;
  S: string;
  vStyle: TsgDXFStyle;
begin
  for I := 0 to AStyles.Count - 1 do
  begin
    vStyle := TsgDXFStyle(AStyles[I]);
    S := vStyle.GetPrimaryFontName;
    if S <> '' then
      FStylesByFont.AddObject(S, vStyle);
    S := vStyle.FontName;
    if S <> '' then
      FStylesByFont.AddObject(S, vStyle);
    S := vStyle.Name;
    if S = '' then
    begin
      J := 0;
      repeat
        S := 'SHAPE' + IntToStr(J);
        Inc(J);
      until AStyles.FindEntByName(S) = nil;
      vStyle.Name := S;
    end;
  end;
end;

procedure FillSubDMesh(AMesh: TsgDXFEntity; AVerteces: TFPointList;
  AIndexes: TsgIntegerList);
var
  I, J, vCountVertexFace: Integer;
  vFace: TsgDXF3dFace;
begin
  I := 0;
  while I < AIndexes.Count do
  begin
    vCountVertexFace := AIndexes[I];
    Inc(I);
    vFace := TsgDXF3dFace.Create;
    vFace.Flags := $10;

    for J := 0 to vCountVertexFace - 1 do
    begin
      case J of
        0: vFace.Point := AVerteces[AIndexes[I]];
        1: vFace.Point1 := AVerteces[AIndexes[I]];
        2: vFace.Point2 := AVerteces[AIndexes[I]];
        3: vFace.Point3 := AVerteces[AIndexes[I]];
      end;
      Inc(I)
    end;

    if vCountVertexFace = 3 then
      vFace.Point3 := vFace.Point2;

    vFace.ColorCAD := AMesh.ColorCAD;
    vFace.LineType := AMesh.LineType;
    vFace.Layer := AMesh.Layer;

    AMesh.AddEntity(vFace);
  end;
end;

procedure ForceStdDictionaries(AConv: TsgDXFConverter; ANamedObjects: UInt64);

  function ForceDictionarySection(const ADictName: string; const ASection: TsgDXFEntity;
    const ASectionName: string;
    AEntityClass: TsgDXFEntityClass = nil): TsgDXFEntity;
  var
    vNamedObjects: TsgDXFEntity;
  begin
    Result := ASection;
    if not Assigned(Result) then
    begin
      if AEntityClass = nil then
        AEntityClass := TsgDXFDictionary;
      if AConv.Counts[csObjects] > 0 then
      begin
        vNamedObjects := AConv.Sections[csObjects].FindEntByHandle(ANamedObjects);
        if Assigned(vNamedObjects) then
        begin
          Result := vNamedObjects.FindEntByName(ADictName);
          if Assigned(Result) then
            vNamedObjects.RemoveEntity(Result)
          else
            Result := AEntityClass.Create;
          Result.Name := ASectionName;
          AConv.Sections[csObjects].AddEntity(Result);
        end;
      end
      else
      begin
        Result := AEntityClass.Create;
        Result.Name := ASectionName;
        AConv.Sections[csObjects].AddEntity(Result);
      end;
    end;
  end;

begin
  ForceDictionarySection(sAcadLayoutDictionary, AConv.Sections[csLayouts], cnstObjectsLAYOUTS);
  ForceDictionarySection(sAcadImageDict, AConv.Sections[csImageDefs], cnstObjectsIMAGEDEFS);
  ForceDictionarySection(sAcadMLineStyleDictionary, AConv.Sections[csMLineStyles], cnstObjectsMLINESTYLES);
  ForceDictionarySection(sAcadTableStyleDictionary, AConv.Sections[csTableStyles], cnstObjectsTABLESTYLES);
  ForceDictionarySection(sAcadPlotSettingsDictionary, nil, cnstObjectsPLOTSETTINGS);
  ForceDictionarySection(sAcadImageVars, nil, sRasterVariables, TsgCADRasterVariables);
  ForceDictionarySection(sAcadWipeOutVarsDictionary, nil, cntClassDXFWIPEOUTVARIABLES, TsgCADWipeoutVariables);
  ForceDictionarySection(sAcDbVariableDictionary, nil, sAcDbVariableDictionary);
{$IFDEF DATA_LINK}
  ForceDictionarySection(sDictionaryAcadDataLink, nil, sDictionaryAcadDataLink);
{$ENDIF}
  ForceDictionarySection(sAcadColor, nil, cnstObjectsCOLORS);
  ForceDictionarySection(sAcadScaleListDictionary, AConv.FScaleList, cnstObjectsSCALELIST);
  ForceDictionarySection(sAcadMaterialDictionary, nil, cnstObjectsMATERIALS);
  ForceDictionarySection(sAcadFieldListDictionary, nil, cnstObjectsFIELDLIST, TsgDXFFieldList);
  ForceDictionarySection(sAcadMLeaderStyleDictionary, nil, cnstObjectsMLEADERSTYLES);
  ForceDictionarySection(sAcadGroupDictionary, AConv.FGroups, cnstObjectsGROUPS);
end;

procedure LinkDataBase(AConv: TsgDXFConverter);
var
  I: Integer;
  E: TsgDXFEntity;
{$IFDEF SG_BTI}
  vXDataProcs: TsgXDataProcs;
{$ENDIF}
  Objects: TsgDXFSectionObjects;
  Obj: TsgDXFEntity;

  procedure LinkTable(const AEnt: TsgDXFEntity; const AConv: TsgDXFConverter);
  var
    K, L: Integer;
  begin
    if Assigned(AEnt) then
    begin
      for K := 0 to AEnt.Count - 1 do
      begin
        for L := 0 to AEnt[K].Count - 1 do
          AEnt[K][L].Link(AConv);
        AEnt[K].Link(AConv);
      end;
      AEnt.Link(AConv);
    end;
  end;

  procedure DoLink(const AEnt: TsgDXFEntity; const AConv: TsgDXFConverter);
  begin
{$IFDEF SG_BTI}
    if (vXDataProcs <> nil) and (AEnt.EntClass.EG = gtBTI) then
      vXDataProcs.LinkEntity(AEnt)
    else
{$ENDIF}
      AEnt.Link(AConv);
  end;

  procedure LinkEntity(const AEnt: TsgDXFEntity;
    const AConv: TsgDXFConverter
    {$IFDEF SG_BTI}; const AMode: Integer = -1{$ENDIF});
  var
    K: Integer;
    vEnt: TsgDXFEntity;
  begin
    for K := 0 to AEnt.Count - 1 do
    begin
      vEnt := AEnt[K];
{$IFDEF SG_BTI}
      case AMode of
        0:
          begin
            if vEnt.EntClass.EG <> gtBTI then
              LinkEntity(vEnt, AConv);
          end;
        1:
          begin
            if vEnt.EntClass.EG = gtBTI then
              LinkEntity(vEnt, AConv);
          end;
      else
{$ENDIF}
        LinkEntity(vEnt, AConv);
{$IFDEF SG_BTI}
      end;
{$ENDIF}
    end;
    DoLink(AEnt, AConv);
  end;

begin
{$IFDEF SG_BTI}
  vXDataProcs := AConv.XDataProcs;
{$ENDIF}
  DoLink(AConv.Main, AConv);
  E := AConv.Main.FindEntByName(cnstSectionHEADER);
  if Assigned(E) then
    DoLink(E, AConv);
  // link tables
  LinkTable(AConv.Sections[csStyles], AConv);
  LinkTable(AConv.Sections[csLTypes], AConv);
  AConv.Sections[csLTypes].SortEntByHandle;
  LinkTable(AConv.Sections[csLayers], AConv);
  AConv.Sections[csLayers].SortEntByHandle;
  LinkTable(AConv.Sections[csDimStyles], AConv);
  LinkTable(AConv.Sections[csBlockRecords], AConv);

  // link objects
  Objects := TsgDXFSectionObjects(AConv.Sections[csObjects]);
  if Assigned(Objects) then
    for I := 0 to Objects.Count - 1 do
    begin
      Obj := Objects[I];
      if Obj = AConv.Groups then // do link group items
        DoLink(Obj, AConv)
      else
        if Obj <> AConv.Sections[csLayouts] then
          LinkEntity(Obj, AConv)
        else
          LinkTable(Obj, AConv); // do not link papers
    end;

  // link blocks
{$IFDEF SG_BTI}
  LinkEntity(AConv.Sections[csBlocks], AConv, 1);
  LinkEntity(AConv.Sections[csBlocks], AConv, 0);
  if Assigned(vXDataProcs) then
    vXDataProcs.RestoreNames(AConv);
{$ELSE}
  LinkEntity(AConv.Sections[csBlocks], AConv);
{$ENDIF}
end;

type
  TLoader = class
  private
    FConv: TsgDXFConverter;
    FBlocks: TsgList;
  protected
    procedure DoLoad(const AEnt: TsgDXFEntity); virtual;
    function IsLoading: Boolean;
    function LoadEntity(const AEnt: TsgDXFEntity): Boolean;
    procedure LoadEntities(const AEnt: TsgDXFEntity);
    function LoadBlock(Entity: TsgDXFEntity): Integer;
  public
    constructor Create;
    destructor Destroy; override;
  end;

{$IFDEF SG_BTI}
  TBTILoader = class(TLoader)
  private
    FXDataProcs: TsgXDataProcs;
  protected
    procedure DoLoad(const AEnt: TsgDXFEntity); override;
  end;
{$ENDIF}

{ TLoader }

constructor TLoader.Create;
begin
  FBlocks := TsgList.Create;
  FBlocks.Duplicates := dupIgnore;
  FBlocks.Sorted := True;
end;

destructor TLoader.Destroy;
begin
  FBlocks.Free;
  inherited Destroy;
end;

procedure TLoader.DoLoad(const AEnt: TsgDXFEntity);
begin
  FConv.Loads(AEnt);
end;

function TLoader.IsLoading: Boolean;
begin
  Result := not FConv.LoadStopped;
end;

procedure TLoader.LoadEntities(const AEnt: TsgDXFEntity);
var
  I: Integer;
begin
  if Assigned(AEnt) then
    for I := 0 to AEnt.Count - 1 do
      FConv.Loads(AEnt[I]);
end;

function TLoader.LoadEntity(const AEnt: TsgDXFEntity): Boolean;
var
  K: Integer;
begin
  Result := False;
  for K := 0 to AEnt.Count - 1 do
  begin
    if not LoadEntity(AEnt[K]) then
      Break;
  end;
  if IsLoading then
  begin
    DoLoad(AEnt);
    Result := True;
  end;
end;

function TLoader.LoadBlock(Entity: TsgDXFEntity): Integer;
var
  C: Integer;
begin
  C := FBlocks.Count;
  FBlocks.Add(Entity);
  if FBlocks.Count > C then
    try
      LoadEntity(Entity);
    finally
      FBlocks.Remove(Entity);
    end;
  Result := 0;
end;

{$IFDEF SG_BTI}

{ TBTILoader }

procedure TBTILoader.DoLoad(const AEnt: TsgDXFEntity);
begin
  if AEnt.EntClass.EG = gtBTI then
    FXDataProcs.LoadEntity(AEnt)
  else
    inherited DoLoad(AEnt);
end;
{$ENDIF}

procedure LoadDataBase(AConv: TsgDXFConverter);
var
  I: Integer;
  vBlock: TsgDXFBlock;
  Loader: TLoader;
  Objects: TsgDXFSectionObjects;
  Obj: TsgDXFEntity;
  UCS: TFMatrix;
  vFilter: TsgCADSpatialFilter;

  function GetUniqueName(Section: TsgDXFEntity; const AFmt: string; var Index: Integer): string;
  begin
    Index := 1;
    repeat
      Result := Format(AFmt, [Index]);
      Inc(Index);
    until Section.FindEntByName(Result) = nil;
    Dec(Index);
  end;

  procedure CorrectTableItemNames(ASection: TsgDXFEntity; const AExcludeChars: TSysCharSet = []);
  var
    K, L, M, vLen: Integer;
    vName, vNewName: string;
    vEnt: TsgDXFEntity;
  begin
    if Assigned(ASection) then
      for K := 0 to ASection.Count - 1 do
      begin
        vEnt := ASection[K];
        vName := vEnt.Name;
        vLen := Length(vName);
        vNewName := '';
        for L := 1 to vLen do
          if CharInSet(vName[L], cnstInvalidSymbolAutoCadName - AExcludeChars) then
            vNewName := vNewName + '$' + IntToHex(Ord(vName[L]), 2)
          else
            vNewName := vNewName + vName[L];
        if vNewName = '' then
          vNewName := GetUniqueName(ASection, ASection.Name + '%d', M);
        if vName <> vNewName then
        begin
          vLen := Length(vNewName);
          if vLen > 255 then
            vNewName := GetUniqueName(ASection, Copy(vNewName, 1, 252) + '%.3d', M);
        end;
        vEnt.Name := vNewName;
      end;
  end;

begin
  AConv.Status := stDefault;
  //ContainerOfTextGlyphs.Lock;
  try
{$IFDEF SG_BTI}
  if AConv.XDataProcs <> nil then
  begin
    Loader := TBTILoader.Create;
    TBTILoader(Loader).FXDataProcs := AConv.XDataProcs;
  end
  else
{$ENDIF}
    Loader := TLoader.Create;
  try
  if Assigned(AConv.ActiveVPort) and AConv.ActiveVPort.UCSVP then
  begin
    UCS.EX := Ort(AConv.ActiveVPort.UCSXDir);
    UCS.EY := Ort(AConv.ActiveVPort.UCSYDir);
    UCS.EZ := Ort(sgFunction.Vector(UCS.EX, UCS.EY));
    UCS.E0 := AConv.ActiveVPort.UCSOrigin;
    for I := 0 to AConv.GetModelLayout.PaperSpaceBlock.Count - 1 do
    begin
      Obj := AConv.GetModelLayout.PaperSpaceBlock[I];
      if (Obj.EntType = ceInsert) and HasSpatialFilter(AConv.Dictionary[Obj.Handle], TsgDXFEntity(vFilter)) then
      begin
        vBlock := TsgDXFInsert(Obj).Block;
        if not Assigned(vBlock) or (Assigned(vBlock) and not (vBlock.IsBlockByXRef or (vBlock.XrefPath <> ''))) then
        begin
          vFilter.Clip := FMatXMat(vFilter.Clip, UCS);
          vFilter.Clipbdorg := SubFPoint(vFilter.Clipbdorg, UCS.E0);
          vFilter.InvBlkTransform := FMatXMat(vFilter.InvBlkTransform, UCS);
        end;
      end;
    end;
  end;
  Loader.FConv := AConv;
  Loader.LoadEntities(AConv.Sections[csStyles]);
  Loader.LoadEntities(AConv.Sections[csLTypes]);
  Loader.LoadEntities(AConv.Sections[csLayers]);
  Loader.LoadEntities(AConv.Sections[csDimStyles]);

  Objects := TsgDXFSectionObjects(AConv.Sections[csObjects]);
  if Assigned(Objects) then
    for I := 0 to Objects.Count - 1 do
    begin
      Obj := Objects[I];
      if Obj = AConv.Groups then
        Loader.DoLoad(Obj)
      else
        if Obj <> AConv.Sections[csLayouts] then
          Loader.LoadEntity(Obj);
    end;

  AConv.OnLoad := Loader.LoadBlock;

  for I := 0 to AConv.Counts[csBlocks] - 1 do
  begin
    vBlock := TsgDXFBlock(AConv.Sections[csBlocks][I]);
    if not Assigned(vBlock.Layout) then
      Loader.LoadBlock(vBlock);
  end;
{$IFDEF SG_BTI}
  if AConv.XDataProcs <> nil then
    AConv.XDataProcs.Finalize;
{$ENDIF}
  for I := 0 to AConv.LayoutsCount - 1 do
    Loader.LoadBlock(AConv.Layouts[I].PaperSpaceBlock);
  for I := 0 to AConv.LayoutsCount - 1 do
    AConv.Loads(AConv.Layouts[I]);
  finally
    AConv.OnLoad := nil;
    Loader.Free;
  end;
  finally
   // ContainerOfTextGlyphs.Unlock;
  end;
  if GlobalAutoCorrectSymbolTableRecordNames then
  begin
    CorrectTableItemNames(AConv.Sections[csAppID]);
    CorrectTableItemNames(AConv.Sections[csDimStyles]);
    CorrectTableItemNames(AConv.Sections[csLTypes]);
    CorrectTableItemNames(AConv.Sections[csStyles]);
    CorrectTableItemNames(AConv.Sections[csLayers], [cnstVertSlash, cnstAsterisk]);
    CorrectTableItemNames(AConv.Sections[csBlockRecords], [cnstAsterisk]);
    CorrectTableItemNames(AConv.Sections[csVPorts], [cnstAsterisk]);
  end;
end;

function ExtractMLAttData(AExtData: TsgCADExtendedData; var AData: TAcadMLAttData): Boolean; overload;
var
  J, K, vCount: Integer;
begin
  J := 0;
  AData.Flag := AExtData.DataInt16[J]; Inc(J);
  AData.Locked := AExtData.DataInt16[J] = 1; Inc(J);
  vCount := AExtData.DataInt16[J]; Inc(J);
  if vCount < 0 then vCount := 0;
  SetLength(AData.SecondaryAtt, vCount);
  for K := Low(AData.SecondaryAtt) to High(AData.SecondaryAtt) do
  begin
    AData.SecondaryAtt[K] := AExtData.DataInt64[J];
    Inc(J);
  end;
  AData.AnnotationScale := AExtData.DataDouble[J]; Inc(J);
  AData.Tag := AExtData.DataString[J]; Inc(J);
  {AExtData.DataString[J];  }Inc(J);//cnstEmbeddedObject
  while J < AExtData.DataCount do
  begin
    case AExtData.DataCode[J] of
      10: AData.InsertionPoint := AExtData.DataPoint[J];
      40: AData.NominalTextHeight := AExtData.DataDouble[J];
      41: AData.ReferenceRectangleWidth := AExtData.DataDouble[J];
      46: AData.DefinedAnnotationHeight := AExtData.DataDouble[J];
      71: AData.Align := AExtData.DataInt16[J];
      72: AData.DrawingDirection := AExtData.DataInt16[J];
      1: AData.Text := AExtData.DataString[J];
      73: AData.LinespacingStyle := AExtData.DataInt16[J];
      44: AData.LinespacingFactor := AExtData.DataDouble[J];
      7: AData.Style := AExtData.DataString[J];
    end;
    Inc(J);
  end;
  Result := True;
end;

function ExtractMLAttData(AMText: TsgDXFMText; var AData: TAcadMLAttData): Boolean; overload;
var
  K: Integer;
begin
  AData.Flag := 4;
  AData.Locked := False;
  SetLength(AData.SecondaryAtt, AMText.Attribs.Count);
  for K := Low(AData.SecondaryAtt) to High(AData.SecondaryAtt) do
    AData.SecondaryAtt[K] := AMText.Attribs[K].Handle;
  AData.AnnotationScale := 1;
  AData.Tag := '';
  {AMText.DataString[J]; //cnstEmbeddedObject }
  AData.InsertionPoint := AMText.Point;
  AData.NominalTextHeight := AMText.Height;
  AData.ReferenceRectangleWidth := AMText.RectWidth;
  AData.DefinedAnnotationHeight := 0;
  AData.Align := AMText.Align;
  AData.DrawingDirection := 1;
  AData.Text := AMText.Text;
  AData.LinespacingStyle := AMText.LineSpacingStyle;
  AData.LinespacingFactor := AMText.LineSpacingFactor;
  if Assigned(AMText.Style) then
    AData.Style := AMText.Style.Name;
  Result := True;
end;

function FillExtDataFromMLAttData(const AData: TAcadMLAttData;
  AExtData: TsgCADExtendedData): Boolean;
var
  I: Integer;
begin
  AExtData.AddInt16(70, AData.Flag);
  AExtData.AddInt16(70, Ord(AData.Locked));
  AExtData.AddInt16(70, Length(AData.SecondaryAtt));
  for I := Low(AData.SecondaryAtt) to High(AData.SecondaryAtt) do
    AExtData.AddInt64(340, AData.SecondaryAtt[I]);
  AExtData.AddDouble(40, AData.AnnotationScale);
  AExtData.AddString(2, AData.Tag);
  AExtData.AddString(1, cnstEmbeddedObject);
  AExtData.AddPoint(10, AData.InsertionPoint);
  AExtData.AddDouble(40, AData.NominalTextHeight);
  AExtData.AddDouble(41, AData.ReferenceRectangleWidth);
  AExtData.AddDouble(46, AData.DefinedAnnotationHeight);
  AExtData.AddInt16(71, AData.Align);
  AExtData.AddInt16(72, AData.DrawingDirection);
  AExtData.AddString(1, AData.Text);
  if AData.Style <> '' then
    AExtData.AddString(7, AData.Style);
  AExtData.AddInt16(73, AData.LinespacingStyle);
  AExtData.AddDouble(44, AData.LinespacingFactor);
  Result := True;
end;

function ApplyMTextFromMLAttData(const AData: TAcadMLAttData; AMText: TsgDXFMText): Boolean;
begin
  //AData.Flag;
  //AData.Locked;
  // handles
  //AData.AnnotationScale;
  //AData.Tag;
  //cnstEmbeddedObject;
  AMText.Point := AData.InsertionPoint;
  AMText.Height := AData.NominalTextHeight;
  AMText.RectWidth := AData.ReferenceRectangleWidth;
  //AData.DefinedAnnotationHeight;
  AMText.Align := AData.Align;
  //AData.DrawingDirection;
  AMText.Text := AData.Text;
  AMText.LineSpacingStyle := AData.LinespacingStyle;
  AMText.LineSpacingFactor := AData.LinespacingFactor;
  Result := True;
end;

  {All operations with colors}
function EntColor(E: TsgDXFEntity; Ins: TsgDXFInsert): TColor;
begin
  Result := GetEntColorCAD(E, Ins, nil);
end;

function GetColorCADLink(const AColor: PsgColorCAD): Integer;//{$IFDEF SG_INLINE}inline;{$ENDIF}
begin
  Result := -1;
  if AColor^.Active = acIndexColor then
  begin
    case AColor^.Color of
      clDXFByLayer: Result := AColor^.Color;
      clDXFByBlock: Result := AColor^.Color;
    end;
  end;
end;

function GetEntColorCAD(E: TsgDXFEntity; Ins: TsgDXFInsert;
  const AColorCAD: PsgColorCAD): Integer;
var
  vIns: TsgDXFInsert;
  vLayer, vInsLayer: TsgDXFLayer;
  vEntColor: TsgColorCAD;

  function IsAlfaChannelCanBe(AColor: TColor): Boolean;
  begin
    Result := (AColor < 0) and (AColor <> clByBlock) and (AColor <> clByLayer) and
      (AColor <> clEmpty);
  end;

begin
  vLayer := nil;
  vEntColor := E.ColorCAD;
  vIns := Ins;
//  if (vEntColor < 0) and (not IsAlfaChannelCanBe(vEntColor)) then
//    vEntColor := cnstColorCADNone;
  if (vIns <> nil) and (GetColorCADLink(@vEntColor) >= 0) then //check for xrefs!!!
  begin
    vLayer := EntLayer(E, Ins);
    if vLayer = nil then
    begin
      if AColorCAD <> nil then
        AColorCAD^ := vEntColor;
      Result := ConvertColorCADToRGB(vEntColor);
      Exit;
    end;
    if (vEntColor.Color = clDXFByLayer) and (vLayer.NameID <> slrnZero) then
      vEntColor := vLayer.ColorCAD;
    if GetColorCADLink(@vEntColor) >= 0 then
    begin
      if (vIns = nil) or
        ((vEntColor.Color = clDXFByLayer) and (vLayer.NameID <> slrnZero)) then
      begin
        if vEntColor.Color = clDXFByLayer then
          vEntColor := vLayer.ColorCAD;
      end
      else
      begin
        vInsLayer := nil;
        while vIns <> nil do
        begin
          if vEntColor.Color = clDXFByBlock then
            vEntColor := vIns.ColorCAD;
          vInsLayer := EntLayer(vIns, nil);
          if (GetColorCADLink(@vEntColor) = clDXFByLayer) and (vInsLayer.NameID <> slrnZero) then
            vEntColor := vInsLayer.ColorCAD;
          if GetColorCADLink(@vEntColor) < 0 then
            Break;
          vIns := vIns.OwnerInsert;
        end;
        if (vInsLayer <> nil) and (GetColorCADLink(@vEntColor) = clDXFByLayer) then
          vEntColor := vInsLayer.ColorCAD;
      end;
    end;
  end //speed up
  else
  begin
    if E.Layer <> nil then
      vLayer := E.Layer //evg speed up
    else
      vEntColor := cnstColorCADNone;
  end;
  if (vLayer <> nil) and (GetColorCADLink(@vEntColor) = clDXFByLayer) then
    vEntColor := vLayer.ColorCAD;    // It should be Layer.name = '0' and Entity.color = ByLayer!
  case GetColorCADLink(@vEntColor) of
    clDXFByBlock:  vEntColor := cnstColorCADByBlackWhite;
    clDXFByLayer:  vEntColor := cnstColorCADNone;
  end;
  if AColorCAD <> nil then
    AColorCAD^ := vEntColor;
  Result := ConvertColorCADToRGB(vEntColor);
end;

function EntLayer(E: TsgDXFEntity; Ins: TsgDXFInsert;
  const ANeedContainerLayer: Boolean = True): TsgDXFLayer;
var
  vContainerLayer: TsgDXFLayer;
begin
  Result := E.Layer;
  if (Result <> nil) and ANeedContainerLayer then
  begin
    vContainerLayer := Result.ContainerLayer;
    if Assigned(vContainerLayer) then
      Result := vContainerLayer;
  end;
  if (Ins <> nil) and ((Result = nil) or (Result.NameID = slrnZero)) then
    Result := Ins.RealLayer;
end;

function EntLines(E: TsgDXFEntity; const P: TsgCADIterate;
  var ALayerLines: TsgLines): TsgLines;
var
  vLayer, vEntLayer: TsgDXFLayer;
  vLineType: TsgDXFLineType;
begin
  ALayerLines := nil;
  Result := E.Lines;
  vLineType := E.LineType; 
  if vLineType <> nil then
    if vLineType.NameID = sltnByBlock then
      Result := P.LType
    else
      if vLineType.NameID = sltnByLayer then
      begin
        vLayer := EntLayer(E, P.Insert);
        if Assigned(vLayer) then
        begin
          if (vLayer.Flags and 16 <> 0) and Assigned(vLayer.LineType) and
            (vLayer.LineType.NameID = sltnContinious) then
          begin
            vEntLayer := EntLayer(E, P.Insert, False);
            if Assigned(vEntLayer) then
              vLayer := vEntLayer;
          end;
          Result := vLayer.Lines;
          ALayerLines := Result;
        end;
      end;
  if Result = nil then
    Result := StdLines;
end;

  {All operations with lineweights}
function EntLineWeight(E: TsgDXFEntity; Ins: TsgDXFInsert): Double;
var
  vIns: TsgDXFInsert;
  Entity: TsgDXFEntity;
begin
  if not E.HasLineWeight then
  begin
    Result := 0;
    Exit;
  end;
  Result := E.LineWeight;
  if Result >= 0 then Exit;
  if Result < fLineWeightByBlock{fLineWeightDefault - for future versions} then Result := 0;
  if E.Layer = nil then
    Exit;
  Entity := E;
  vIns := Ins;
  if (Result < 0) and (Result <> fLineWeightByBlock) and (Result <> fLineWeightDefault) then
    Result := fLineWeightByLayer;
  if (Result = fLineWeightByLayer) and (Entity.Layer.NameID <> slrnZero) then
    Result := Entity.Layer.LineWeight;
  if (Result = fLineWeightByLayer) or (Result = fLineWeightByBlock) then
  begin
    if (vIns = nil) or ((Result = fLineWeightByLayer)
      and (Entity.Layer.NameID <> slrnZero)) then
    begin
      if Result = fLineWeightByLayer then
        Result := Entity.Layer.LineWeight;
    end
    else
    begin
      while vIns <> nil do
      begin
        if Result = fLineWeightByBlock then
          Result := vIns.LineWeight;
        if (Result = fLineWeightByLayer) and (vIns.Layer <> nil) and (vIns.Layer.NameID <> slrnZero) then
          Result := vIns.Layer.LineWeight;
        if not ((Result = fLineWeightByBlock) or (Result = fLineWeightByLayer)) then
          Break;
        vIns := vIns.OwnerInsert;
      end;
    end;
  end;
  if (Result = fLineWeightByLayer) then
    Result := Entity.Layer.LineWeight;    // I should be Layer.name = '0' and Entity.color = ByLayer!
  if (Result = fLineWeightByLayer) or (Result = fLineWeightByBlock)
    or (Result = fLineWeightDefault) then
    Result := 0;
end;

function EntStyle(E: TsgDXFEntity): TPenStyle;
var
  A, B: Single;
  L: TsgLines;
begin
  Result := psSolid;
  if E is TsgCADHatch then
    Exit;
  if not (E is TsgDXFPenLine) then
    Exit;
  L := TsgDXFPenLine(E).Lines;
  if L = nil then
    Exit;
  if L.IsSolid then
    Exit;
  A := L.Elements[0].Dash;
  B := L.Elements[1].Dash;
  if (A <> 0) and (Abs(B / A) <= 0.25) then
    Result := psDash
  else
    Result := psDot;
  if (Result = psDash) and (L.ElementsCount > 2) and (Abs(L.Elements[2].Dash / A) <= 0.125) then
    Result := psDashDot;
end;

function EntXrefBlock(E: TsgDXFEntity; Converter: TsgDXFConverter): TsgDXFBlockRecord;
var
  vBlockName: string;
  I, vPos: Integer;
  vGroup: TsgDXFGroup;
begin
  Result := nil;
  if (Converter = nil) or (E = nil) then Exit;
  if IsXRefInName(E.Name) then
  begin
    vPos := Pos(cnstXRefNameDelimiter, E.Name);
    vBlockName := Copy(E.Name, 1, vPos - 1);
    vGroup := Converter.Sections[csBlockRecords];
    if vBlockName = '' then Exit;
    for I := 0 to vGroup.Count - 1 do
      if vGroup.Entities[I] is TsgDXFBlockRecord then
        if SameText(TsgDXFBlockRecord(vGroup.Entities[I]).Name, vBlockName) then
        begin
          Result := TsgDXFBlockRecord(vGroup.Entities[I]);
          Exit;
        end;
  end;
end;

function MaterialEnt(E: TsgDXFEntity; EntNode: TsgDXFInsert; Group: TsgDXFEntity;
  GroupNode: TsgDXFInsert): TsgDXFEntity;
var
  Mode: Integer;
  vTestMaterial: TsgDXFEntity;
begin
  Result := E;
  if not Assigned(EntNode) then
  begin
    Result := nil;
    Exit;
  end;
  vTestMaterial := E.Material;
  if Assigned(vTestMaterial) then
  begin
    Mode := Ord(SameText(vTestMaterial.Name, sByLayer)) or
      Ord(SameText(vTestMaterial.Name, sByBlock)) shl 1;
    case Mode of
      1: // bylayer
        begin
          Result := EntLayer(E, EntNode);
        end;
      2: // byblock
        begin
          if Assigned(Group) then
            Result := MaterialEnt(Group, GroupNode, nil, nil)
          else
            Result := MaterialEnt(EntNode, EntNode.OwnerInsert, nil, nil);
        end;
    end;
  end
  else
    if Assigned(Group) then
      Result := MaterialEnt(Group, GroupNode, nil, nil)
    else
      Result := EntLayer(E, EntNode);
end;

procedure ApplyBulge(const P1,P2: TFPoint; const Bulge: Double;
  const AList: TList; const ANumberOfCircleParts: Integer;
  const AGetPointProc: TsgCreatePPoint; var AResultArc: TsgArcR);
var
  vGenerator: TsgGeneratorShapeEdge;
begin
  vGenerator := TsgGeneratorShapeEdge.Create;
  try
    vGenerator.SetListAndProc(AList, nil, AGetPointProc);
    vGenerator.NumberCirclePart := ANumberOfCircleParts;
    AResultArc := vGenerator.CreateBulgesArc(P1, P2, Bulge);
  finally
    vGenerator.Free;
  end;
end;

function BulgeByArc(AArc: TsgArcR; AVertexPoint: TFPoint;
  const Epsilon: Double = fDoubleResolution): Double;
var
  vArcStart, vArcEnd, vMiddleHord, vMiddleArcPoint, vNextVertexPoint: TFPoint;
  vHeightOfHord, vDistance: Double;
begin
  Result := 0;
  vArcStart := GetPointOnCircle(AArc.Center, AArc.Radius, AArc.AngleS);
  vArcEnd := GetPointOnCircle(AArc.Center, AArc.Radius, AArc.AngleE);
  if not IsEqualFPoints(vArcStart, vArcEnd) then
  begin
    vMiddleHord := MiddleFPoint(vArcStart, vArcEnd);
    vMiddleArcPoint := GetPointOnCircle(AArc.Center, AArc.Radius,
      GetMiddleAngleAP(AArc));
    vHeightOfHord := Sqrt(DistanceFPointSqr(vMiddleHord, vMiddleArcPoint));
    if vHeightOfHord > fExtendedResolution then
    begin
      vDistance := Sqrt(DistanceFPointSqr(vArcStart, vMiddleHord));
      if vDistance > fExtendedResolution then
      begin
        Result := vHeightOfHord / vDistance;
        if IsEqualFPoints(AVertexPoint, vArcStart, Epsilon) then
          vNextVertexPoint := vArcEnd
        else
          vNextVertexPoint := vArcStart;
        if PointClassify(AVertexPoint, vNextVertexPoint, vMiddleArcPoint) = pcLEFT then
          Result := - Result;
      end;
    end;
  end;
end;

function GetArcROfVertexes(const AVertex1, AVertex2: TsgDXFVertex; var AArc: TsgArcR): Boolean;
begin
  Result := False;
  if AVertex1.Bulge <> 0 then
  begin
    AArc := GetArcROfBulge(AVertex1.Point, AVertex2.Point, AVertex1.Bulge);
    if AArc.Radius > 0 then
      Result := True;
  end;
end;

procedure ReCalcBulgeParams(const APrev, ACur, ANext: TsgDXFVertex);

  procedure SetArcRAngles(const AStart: TsgDXFVertex; const AEnd, ATest: TFPoint; const ArcR: TsgArcR);
  var
    vMiddle: TFPoint;
    vAngle, vA1, vA2: Double;
    vBulge: Double;
  begin
    vA1 := GetAngleByPoints(ArcR.Center, AStart.Point, False);
    vA2 := GetAngleByPoints(ArcR.Center, AEnd, False);
    vAngle := GetAngleByPoints(ArcR.Center, ATest, False);
    if IsAngleInAngles(vAngle, vA1, vA2) then
      SwapDoubles(vA1, vA2);
    vAngle := GetMiddleAngle(vA1, vA2);
    if vAngle < 0 then
      vAngle := vAngle + 360;
    vMiddle := GetPointOnCircle(ArcR.Center, ArcR.Radius, vAngle);
    if GetBulgeWithCorrect(AStart.Point, AEnd, vMiddle, vBulge) then
      AStart.Bulge := vBulge;
  end;

var
  vArc: TsgArcR;
  vLine: TsgLine;
  vCrossCnt: Integer;
  vCP1, vCP2: TFPoint;
  vSignSourceBulge: TValueSign;
begin
  vSignSourceBulge := Sign(APrev.Bulge);
  if GetArcROfVertexes(APrev, ANext, vArc) then
  begin
    vLine := MakeLine(vArc.Center, ACur.Point);
    vLine.Point2 := GetPointOnLine(vLine.Point1, vLine.Point2, vArc.Radius * 2);
    vCrossCnt := IsCrossArcAndSegmentAP(vArc, vLine, @vCP1, @vCP2);
    if vCrossCnt = 1 then
    begin
      ACur.Point := vCP1;
      SetArcRAngles(APrev, ACur.Point, ANext.Point, vArc);
      SetArcRAngles(ACur, ANext.Point, APrev.Point, vArc);
      //FIX INVERT BULGE
      APrev.Bulge := Abs(APrev.Bulge);
      ACur.Bulge := Abs(ACur.Bulge);
      if vSignSourceBulge < 0 then
      begin
        APrev.Bulge := -Abs(APrev.Bulge);
        ACur.Bulge := -Abs(ACur.Bulge);
      end;
      ///////////////////
    end;
  end;
end;

{  GenerateLineTypes

   Description:
     Lines.Scale = 1 as default;
     '+' - length of the "solid" part of a line;
     '-' - length of the "empty" part of a line;
     '0' - point.                                    }
procedure GenerateLineTypes(AConverter: TsgDXFConverter; const AComplex: Boolean);
begin
  GenerateLineTypesEx(AConverter, '', AComplex, 0);
end;

procedure GenerateLineTypesEx(const AConverter: TsgDXFConverter;
  const APrefix: string; const AComplex: Boolean; AUniform: Integer);
const
  cnstCenter        = 'CENTER';
  cnstLTypeDash     = 'ISO dash';
  cnstLTypeDot      = 'ISO dot';
  cnstLTypeDashDot  = 'ISO dash dot';
  cnstLTypeDash2Dot = 'ISO dash double-dot';
  cnstLTypeDash3Dot = 'ISO dash triple-dot';
  cnstOTKOS      = 'OTKOS';      // |_|_|_|_|_|_|
  cnstDEREV      = 'DEREV';      // |___|___|___|
  cnstSETKA      = 'SETKA';      // v---^---v---^---
  cnstKOLPROV    = 'KOLPROV';    // ---- + ---- + ---- +
  cnstMET        = 'MET';        // ----0----0----0
  cnstKAMEN      = 'KAMEN';      // ----[]----[]----[]
  cnstBETON      = 'BETON';      // |___|___|___|
  cnstSHTRIX     = 'SHTRIX';     // __    __    __    __
  cnstKAMSET     = 'KAMSET';     // --^--[]--^--[]--^--[]
  cnstKAMDER     = 'KAMDER';     // ,--[]--,--[]--,--[]
  cnstMETSET     = 'METSET';     // --^--O--^--O--^--O
  cnstTFcable    = 'TFcable';    // --0-- --0-- --0--
  cnstELcable    = 'ELcable';    // <--->---<--->---
  cnstVELcable   = 'VELcable';   // <<--->>---<<--->>---
  cnstVELcable10 = 'VELcable10'; // <<--->>---<<--->>---
  cnstOBR        = 'OBR';        // -v-v-v-v-v-
  cnstGRANZ      = 'GRANZ';      // __ . . __ . . __ . . __ . . (ISO dash double-dot)
  cnstSTRELA     = 'STRELA';     // ----->----->-----
  cnstSTRELA10   = 'STRELA10';   // ----->----->-----
  cnstLVoltageTL = 'LVoltageTL';//-<----->-<----->-
  cnstHVoltageTL = 'HVoltageTL';//-<<----->>-<<----->>-
  cnstLTypeDashLongGaps = 'ISO dash long gaps';//----  ----  ----
  cnstLTypeLongDahs = 'Long dahs';//--   --   --
  cnstFromStartToEnd = 'From start to end';//->->-
  cnstFromEndToStart = 'From end to start';//-<-<-

var
  vLType: TsgDXFLineType;
  vStyle: TsgDXFStyle;
  I: Integer;

  function CreateLineType(const ALTypeName: string): TsgDXFLineType;
  begin
    Result := nil;
    if AConverter.LTypeByName(ALTypeName) = nil then
      Result := TsgDXFLineType(AConverter.NewNamedEntity(nil, TsgDXFLineType,
        ALTypeName));
  end;

  procedure LoadLineType(ALType: TsgDXFLineType);
  begin
    AConverter.Loads(ALType);
    AConverter.Sections[csLTypes].AddEntity(ALType);
  end;

begin
  // CONTINUOUS _______________________
  AConverter.AddLineType(APrefix + sContinuous, AUniform, []);
  // CENTER ___ _ ___ _ ___ _ ___ _ ___
  AConverter.AddLineType(APrefix + cnstCenter, AUniform, [1.25, -0.25, 0.25, -0.25]);
  // ACAD_ISO2W100 __ __ __ __ __ __
  AConverter.AddLineType(APrefix + cnstLTypeDash, AUniform, [1.2, -0.3]);
  // ACAD_ISO7W100 . . . . . . . . .
  AConverter.AddLineType(APrefix + cnstLTypeDot, AUniform, [0, -0.3]);
  // ACAD_ISO10W100 __.__.__.__.__.
  AConverter.AddLineType(APrefix + cnstLTypeDashDot, AUniform, [1.2, -0.3, 0, -0.3]);
  // ACAD_ISO12W100 __..__..__..__..
  AConverter.AddLineType(APrefix + cnstLTypeDash2Dot, AUniform, [1.2, -0.3, 0, -0.3, 0, -0.3]);
  // ACAD_ISO14W100 __...__...__...
  AConverter.AddLineType(APrefix + cnstLTypeDash3Dot, AUniform, [1.2, -0.3, 0, -0.3, 0, -0.3, 0, -0.3]);
  // ACAD_ISO03W100 --   --   --
  AConverter.AddLineType(APrefix + cnstLTypeDashLongGaps, AUniform, [1.2, -1.8]);

//  AConverter.AddLineType(APrefix + cnstLTypeLongDahs, AUniform, [2, -1]);

  if AComplex then
  begin
    // Styles section must be empty here
    vStyle := AConverter.StyleByPrimaryFont(cnstFileNameOfShapes);
    if vStyle = nil then
    begin
      vStyle := TsgDXFStyle.Create;
      vStyle.Name := '';
      vStyle.Flags := 1;
      vStyle.PrimaryFont := cnstFileNameOfShapes;
      AConverter.Loads(vStyle);
      AConverter.Sections[csStyles].AddEntity(vStyle);
    end;

    vLType := CreateLineType(cnstBETON);
    if vLType <> nil then
    begin
      vLType.AddDashElement(120);
      vLType.AddComplexElement(4, -0.01, 0, 5, -18.05, -10, vStyle, 2, '');
      vLType.AddDashElement(-0.1);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstDEREV);
    if vLType <> nil then
    begin
      for I := 1 to 3 do
      begin
        vLType.AddDashElement(15);
        vLType.AddDashElement(-0.01);
      end;
      vLType.AddDashElement(15);
      vLType.AddComplexElement(4, -0.01, 0, 7, -18.05, -14, vStyle, 2, '');
      vLType.AddDashElement(-0.01);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstELcable);
    if vLType <> nil then
    begin
      vLType.AddDashElement(6);
      vLType.AddComplexElement(4, -8, 90, 5, 4.0, -5.0, vStyle, 3, '');
      vLType.AddDashElement(-1);
      vLType.AddComplexElement(4, 25, 270, 5, -4.0, 5.0, vStyle, 3, '');
      vLType.AddDashElement(-8);
      vLType.AddDashElement(25);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstVELcable);
    if vLType <> nil then
    begin
      vLType.AddDashElement(8);
      vLType.AddComplexElement(4, -8, 90, 5, 4.0, -5.0, vStyle, 3, '');
      vLType.AddComplexElement(4, -5, 90, 5, 4.0, -5.0, vStyle, 3, '');
      vLType.AddDashElement(-1);
      vLType.AddComplexElement(4, 25, 270, 5, -4.0, 5.0, vStyle, 3, '');
      vLType.AddComplexElement(4, -5, 270, 5, -4.0, 5.0, vStyle, 3, '');
      vLType.AddDashElement(-8);
      vLType.AddDashElement(25);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstTFcable);
    if vLType <> nil then
    begin
      vLType.AddDashElement(8.1);
      vLType.AddComplexElement(4, -8.05, 0, 2, 16.55, 0, vStyle, 5, '');
      vLType.AddDashElement(-1.04);
      vLType.AddDashElement(25.1);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstKAMEN);
    if vLType <> nil then
    begin
      vLType.AddDashElement(90);
      vLType.AddComplexElement(4, -0.01, 0, 9, 0, 0, vStyle, 4, '');
      vLType.AddDashElement(-18);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstKAMDER);
    if vLType <> nil then
    begin
      vLType.AddDashElement(20);
      vLType.AddComplexElement(4, -0.01, 0, 9, 0, 0, vStyle, 4, '');
      vLType.AddDashElement(-18);
      vLType.AddDashElement(40);
      vLType.AddComplexElement(4, -0.01, 0, 5, -7.05, -10, vStyle, 2, '');
      vLType.AddDashElement(40);
      vLType.AddComplexElement(4, -0.01, 0, 5, -7.05, -10, vStyle, 2, '');
      vLType.AddDashElement(-0.01);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstKAMSET);
    if vLType <> nil then
    begin
      vLType.AddDashElement(40);
      vLType.AddComplexElement(4, -0.01, 0, 9, 0, 0, vStyle, 4, '');
      vLType.AddDashElement(-18);
      vLType.AddDashElement(90);
      vLType.AddComplexElement(4, -1, 0, 4, -55.01, 8, vStyle, 11, '');
      vLType.AddDashElement(-0.01);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstKOLPROV);
    if vLType <> nil then
    begin
      vLType.AddDashElement(60);
      vLType.AddComplexElement(4, -20, 0, 4, 0, -8, vStyle, 10, '');
      vLType.AddDashElement(-20);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstMET);
    if vLType <> nil then
    begin
      vLType.AddDashElement(80);
      vLType.AddComplexElement(4, -0.01, 0, 8, 0, 0, vStyle, 5, '');
      vLType.AddDashElement(-16);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstMETSET);
    if vLType <> nil then
    begin
      vLType.AddDashElement(40);
      vLType.AddComplexElement(4, -0.01, 0, 9, 0, 0, vStyle, 5, '');
      vLType.AddDashElement(-18);
      vLType.AddDashElement(90);
      vLType.AddComplexElement(4, -1, 0, 4, -55.01, 8, vStyle, 11, '');
      vLType.AddDashElement(-0.01);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstOTKOS);
    if vLType <> nil then
    begin
      vLType.AddDashElement(24);
      vLType.AddComplexElement(4, -0.01, 0, 6, -8.005, -36, vStyle, 9, '');
      vLType.AddDashElement(-0.1);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstSETKA);
    if vLType <> nil then
    begin
      for I := 1 to 3 do
      begin
        vLType.AddDashElement(22);
        vLType.AddDashElement(-0.01);
      end;
      vLType.AddDashElement(22);
      vLType.AddComplexElement(4, -0.01, 0, 4, -76.01, 8, vStyle, 11, '');
      vLType.AddDashElement(-0.01);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstOBR);
    if vLType <> nil then
    begin
      vLType.AddDashElement(30);
      vLType.AddComplexElement(4, -0.01, 0, 5, 1, 0, vStyle, 13, '');
      vLType.AddDashElement(-0.1);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstSTRELA);
    if vLType <> nil then
    begin
      vLType.AddDashElement(250);
      vLType.AddComplexElement(4, -1, 0, 5, 1, 0, vStyle, 8, '');
      vLType.AddDashElement(-50);
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstSTRELA10);
    if vLType <> nil then
    begin
      vLType.AddDashElement(50);
      vLType.AddComplexElement(4, -1, 0, 5, 1, 0, vStyle, 8, '');
      vLType.AddDashElement(-50);
      vLType.AddDashElement(150);
      vLType.AddDashElement(-0.1);
      vLType.AddDashElement(150);
      vLType.AddDashElement(-0.1);
      LoadLineType(vLType);
    end;

   vLType := CreateLineType(cnstLVoltageTL);
    if vLType <> nil then
    begin
      vLType.AddComplexElement(4, 100, 90,  8.333,
        -16.667, -8.333, vStyle, 13, '');
      vLType.AddComplexElement(4, 1533.333, 270, 8.333,
        16.667, 8.333, vStyle, 13, '');
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstHVoltageTL);
    if vLType <> nil then
    begin
      vLType.AddComplexElement(4, 100, 90, 8.333,
        -16.667, -8.333, vStyle, 13, '');
      vLType.AddComplexElement(4, 25, 90, 8.333,
        -16.667, -8.333, vStyle, 13, '');
      vLType.AddComplexElement(4, 1483.333, 270, 8.333,
         16.667, 8.333, vStyle, 13, '');
      vLType.AddComplexElement(4, 25, 270, 8.333,
         16.667, 8.333, vStyle, 13, '');
      LoadLineType(vLType);
    end;

   vLType := CreateLineType(cnstFromStartToEnd);
    if vLType <> nil then
    begin
      vLType.AddDashElement(25);
      vLType.AddComplexElement(4, 100, 90, 8.333, -16.667, -8.333, vStyle, 13, '');
      LoadLineType(vLType);
    end;

    vLType := CreateLineType(cnstFromEndToStart);
    if vLType <> nil then
    begin
      vLType.AddDashElement(25);
      vLType.AddComplexElement(4, 100, 270, 8.333, 16.667, 8.333, vStyle, 13, '');
      LoadLineType(vLType);
    end;
  end;
end;

procedure GetSinglePts(APts: array of TFPoint; AList: TList);
var
  I: Integer;
  P: PFPoint;
begin
  for I := 0 to AList.Count - 1 do
    Dispose(AList[I]);
  AList.Clear;
  for I := Low(APts) to High(APts) do
  begin
    New(P);
    P^ := APts[I];
    AList.Add(P);
  end;
end;

function GetTextAlignedRotation(const ATextAlign: Integer;
   const ARotation: Double): Double;
begin
  Result := 0;
  if ATextAlign > 0 then//align and iso
  begin
    if (ARotation > 90) and (ARotation < 180) then
      Result := ARotation + 180
    else
      if (ARotation >= 180) and (ARotation <= 270) then
        Result:= ARotation - 180
      else
        Result := ARotation;
  end;
end;

procedure OffsetFRect(var R: TFRect; DX, DY, DZ: Extended);
begin
  R.Left := R.Left + DX;
  R.Top := R.Top + DY;
  R.Right := R.Right + DX;
  R.Bottom := R.Bottom + DY;
  R.Z1 := R.Z1 + DZ;
  R.Z2 := R.Z2 + DZ;
end;

function OffsetFPoint(const APt, AOffset: TFPoint; const Add: Boolean): TFPoint;
begin
  if Add then
    Result := MakeFPoint(APt.X + AOffset.X, APt.Y + AOffset.Y, APt.Z + AOffset.Z)
  else
    Result := MakeFPoint(APt.X - AOffset.X, APt.Y - AOffset.Y, APt.Z - AOffset.Z);
end;

{
procedure DoScale2D(var P: TsgCADIterate);
  procedure Cut(var A, B: TFPoint);
  begin
    A.X := A.X - B.X;
    A.Y := A.Y - B.Y;
    A.Z := A.Z - B.Z;
  end;
var
  P0, P1, P2: TFPoint;
begin
  if (P.XScale <> 0) or (P.YScale <> 0) then
    Exit;
  P0 := PtXMat(FloatPoint(0, 0), P.Matrix);
  P1 := PtXMat(FloatPoint(0, 1), P.Matrix);
  P2 := PtXMat(FloatPoint(1, 0), P.Matrix);
  Cut(P1, P0);
  Cut(P2, P0);
  P.XScale := Sqrt(P2.X * P2.X + P2.Y * P2.Y);
  P.YScale := Sqrt(P1.X * P1.X + P1.Y * P1.Y);
  P.Angle := 180 / Pi * ArcTan2(P2.Y, P2.X);
  if P2.X * P1.Y < P2.Y * P1.X then
    P.XScale := -P.XScale;
end;
}
procedure DoScale2D(var P: TsgCADIterate);
var
  P1, P2: TFPoint;
begin
  if (P.XScale <> 0) or (P.YScale <> 0) then
    Exit;
  P1 := MakeFPoint(P.Matrix.M[1, 0], P.Matrix.M[1, 1], P.Matrix.M[1, 2]);
  P2 := MakeFPoint(P.Matrix.M[0, 0], P.Matrix.M[0, 1], P.Matrix.M[0, 2]);
  P.XScale := Sqrt(P2.X * P2.X + P2.Y * P2.Y + P2.Z * P2.Z);
  P.YScale := Sqrt(P1.X * P1.X + P1.Y * P1.Y + P1.Z * P1.Z);
  if Abs(P.XScale) < 1E-10 then P.XScale := 0;
  if P2.X * P1.Y < P2.Y * P1.X then
    P.XScale := -P.XScale;
  P.Angle := Degree(ArcTan2(P2.Y, P2.X));
end;

procedure TextParms(var P: TsgCADIterate);
begin
  DoScale2D(P);
end;

function MirrorPoint(const APoint, ACenter: TFPoint): TFPoint;
begin
  Result.X := ACenter.X - APoint.X + ACenter.X;
  Result.Y := ACenter.Y - APoint.Y + ACenter.Y;
  Result.Z := ACenter.Z - APoint.Z + ACenter.Z;
end;

procedure NormFRect(var R: TFRect);
begin
  if R.Left > R.Right then SwapSGFloats(R.Left, R.Right);
  if R.Bottom > R.Top then SwapSGFloats(R.Bottom, R.Top);
end;

{ IntersectRects

  In Rects Bottom <= Top.

  Returns:
    -1 - AFirstRect not in ARect;
     0 - AFirstRect intersect (part in) ARect;
     1 - AFirstRect full in ARect.              }

function IntersectRects(const AFirstRect, ARect: TFRect; AMatrix: TFMatrix): Integer;
var
  R: TFRect;
begin
  Result := -1;// not in rect
  if IsBadRect(AFirstRect) or IsBadRect(ARect) then
    Exit;
  R := AFirstRect;
  R.TopLeft := FPointXMat(R.TopLeft, AMatrix);
  R.BottomRight := FPointXMat(R.BottomRight, AMatrix);
  NormFRect(R);
  Result := sgFunction.IntersectFRect2D(ARect, R);
end;

{ IntersectLineRect

  In Rect Bottom <= Top.

  Returns:
    -1 - line not in ARect;
     1 - line full in ARect.              }
function IntersectLineRect(const APt1, APt2: TFPoint; ARect: TFRect;
  AMatrix: TFMatrix; AZCompare: Boolean): Integer;
var
  vPt1, vPt2: TFPoint;
begin
  Result := -1;// not in rect
  if IsBadRect(ARect) then
    Exit;
  vPt1 := FPointXMat(APt1, AMatrix);
  vPt2 := FPointXMat(APt2, AMatrix);
  // full in ARect
  if (vPt1.X >= ARect.Left) and (vPt1.X <= ARect.Right) and
    (vPt1.Y >= ARect.Bottom) and (vPt1.Y <= ARect.Top) and
    (vPt2.X >= ARect.Left) and (vPt2.X <= ARect.Right) and
    (vPt2.Y >= ARect.Bottom) and (vPt2.Y <= ARect.Top) then
    Result := 1;// full 2D in rect
  if AZCompare then
  begin
    if (Result = 1) and (vPt1.Z >= ARect.Z1) and (vPt1.Z <= ARect.Z2) and
      (vPt2.Z >= ARect.Z1) and (vPt2.Z <= ARect.Z2) then
      Result := 1// full 3D in rect
    else
      Result := -1;// not in 3D rect
  end;
end;

function GetLineInViewPort(var APt1, APt2: TFPoint; ARect: TFRect;
  AMatrix: TFMatrix): Boolean;

  function GetYByX(X: Single): Single;
  begin
    Result := BadSingValue;
    if ((APt1.X > X) and (APt2.X < X)) or
      ((APt1.X < X) and (APt2.X > X)) then
      Result := APt1.Y + (APt2.Y - APt1.Y) * (X - APt1.X) /
          (APt2.X - APt1.X);
   if (Result < ARect.Bottom) or (Result > ARect.Top) then
      Result := BadSingValue;
  end;

  function GetXByY(Y: Single): Single;
  begin
    Result := BadSingValue;
    if ((APt1.Y > Y) and (APt2.Y < Y)) or
      ((APt1.Y < Y) and (APt2.Y > Y)) then
      Result := APt1.X + (APt2.X - APt1.X) * (Y - APt1.Y)
        / (APt2.Y - APt1.Y);
    if (Result > ARect.Right) or (Result < ARect.Left) then
      Result := BadSingValue;
  end;

var
  vSg: Single;
begin
  Result := False;
  if IsBadRect(ARect) then
    Exit;
  NormFRect(ARect);
  APt1 := FPointXMat(APt1, AMatrix);
  APt2 := FPointXMat(APt2, AMatrix);
  vSg := GetYByX(ARect.Left); // left
  if vSg <> BadSingValue then
  begin
    if APt1.X < ARect.Left then
    begin
      APt1.X := ARect.Left;
      APt1.Y := vSg;
    end
    else
    begin
      APt2.X := ARect.Left;
      APt2.Y := vSg;
    end;
    Result := True;
  end;
  vSg := GetYByX(ARect.Right);
  if vSg <> BadSingValue then
  begin
    if APt2.X > ARect.Right then
    begin
      APt2.X := ARect.Right;
      APt2.Y := vSg;
    end
    else
    begin
      APt1.X := ARect.Right;
      APt1.Y := vSg;
    end;
    Result := True;
  end;
  vSg := GetXByY(ARect.Bottom);
  if vSg <> BadSingValue then
  begin
    if APt1.Y < ARect.Bottom then
    begin
      APt1.Y := ARect.Bottom;
      APt1.X := vSg;
    end
    else
    begin
      APt2.Y := ARect.Bottom;
      APt2.X := vSg;
    end;
    Result := True;
  end;
  vSg := GetXByY(ARect.Top);
  if vSg <> BadSingValue then
  begin
    if APt2.Y > ARect.Top then
    begin
      APt2.Y := ARect.Top;
      APt2.X := vSg;
    end
    else
    begin
      APt1.Y := ARect.Top;
      APt1.X := vSg;
    end;
    Result := True;
  end;
end;

function NotZeroPoint(const P: TFPoint): Boolean;
begin
  Result := (P.X <> 0) or (P.Y <> 0) or (P.Z <> 0);
end;

procedure SetArcParams(const Arc: TsgDXFArc; const AP1, AP2: TFPoint;
  const ABulge: Double);
var
  vArcR: TsgArcR;
begin
  vArcR := GetArcROfBulge(AP1, AP2, ABulge);
  Arc.Point := vArcR.Center;
  Arc.Radius := vArcR.Radius;
  Arc.StartAngle := vArcR.AngleS;
  Arc.EndAngle := vArcR.AngleE;
end;

function SetTextStr(const Value: string): string;
var
  vPos, I: Integer;
begin
  Result := Value;
  if MacroStrings <> nil then
  begin
    for I := 0 to MacroStrings.Count - 1 do
    begin
      vPos := AnsiPos('=', MacroStrings[I]);
      if vPos = 0 then
     	  Continue;
      ReplaceAnsi(Result, MacroStrings.Names[I],
        Copy(MacroStrings[I], vPos + 1, Length(MacroStrings[I])));
    end;
  end;
  ReplaceAnsi(Result,'%%d', Char(cnstDegree));
  ReplaceAnsi(Result,'%%p', Char(cnstPlusMinusSign));
  ReplaceAnsi(Result,'%%c', cnstDiameterArialUni);
  // Replacement of tabulations accordingly DXF
  ReplaceAnsi(Result, #$9, '^I');
  ReplaceAnsi(Result, #$D#$A, '\P');
  ReplaceAnsi(Result, #$A, '^J');
end;

procedure SubStr(var S: AnsiString; var P: PAnsiChar; Limit: PAnsiChar);
var
  P0: PAnsiChar;
  C: TsgNativeInt;
begin
  P0 := P;
  while (P < Limit) and not (P^ in [#10,#13]) do
    Inc(P);
  C := P - P0;
  if P <> Limit  then
  begin
    if P^ = #13 then
      Inc(P);
    if P^ = #10 then
      Inc(P);
  end;
  SetLength(S, C);
  if C > 0 then
    Move(P0^, S[1], C);
end;

function GetBinaryDataAsBase64(const ABinaryData: AnsiString;
  out AString; AStringTypeInfo: Pointer = nil): Boolean;
var
  vInputStream: TMemoryStream;
  vOutputStream: TStringStream;
begin
  Pointer(AString) := nil;
  if ABinaryData <> '' then
  begin
    vInputStream := TMemoryStream.Create;
    try
      vInputStream.Write(PPointer(ABinaryData)^, Length(ABinaryData));
      vInputStream.Position := 0;
      vOutputStream := TStringStream.Create('');
      try
        EncodeBase64(vInputStream, TStream(vOutputStream));
{$IFDEF UNICODESTRING_TYPE_DEFINED}
        if AStringTypeInfo = TypeInfo(UnicodeString) then
          UnicodeString(AString) := UnicodeString(vOutputStream.DataString)
        else
{$ENDIF}
{$IFDEF SG_HAS_CPSTRING}
        if AStringTypeInfo = TypeInfo(UTF8String) then
          UTF8String(AString) := UTF8String(vOutputStream.DataString)
        else
          if AStringTypeInfo = TypeInfo(RawByteString) then
            RawByteString(AString) := RawByteString(vOutputStream.DataString)
        else
{$ENDIF}
        if AStringTypeInfo = TypeInfo(WideString) then
          WideString(AString) := WideString(vOutputStream.DataString)
        else
          if AStringTypeInfo = TypeInfo(AnsiString) then
            AnsiString(AString) := AnsiString(vOutputStream.DataString)
        else
          if (AStringTypeInfo = nil){$IFNDEF UNICODE}or (AStringTypeInfo = TypeInfo(string)){$ENDIF} then
            string(AString) := vOutputStream.DataString
      finally
        vOutputStream.Free;
      end;
    finally
      vInputStream.Free;
    end;
  end;
  Result := Pointer(AString) <> nil;
end;

function LoadFromBase64(const AContentBase64: string; out ABinaryData: AnsiString): Boolean;
var
  vOutputStream: TMemoryStream;
begin
  Result := False;
  vOutputStream := TMemoryStream.Create;
  try
    DecodeBase64(AContentBase64, nil, TStream(vOutputStream));
    if vOutputStream.Size > 0 then
    begin
      SetString(ABinaryData, PAnsiChar(vOutputStream.Memory), vOutputStream.Size);
      Result := True;
    end;
  finally
    vOutputStream.Free;
  end;
end;

procedure SetPolyPolylineOwner(const AEnt, AOwner: TsgDXFEntity);
begin
{$IFDEF SG_BTI}
  if AEnt.EntType = cePolyPolyline2D then
    AEnt.SetOwner(AOwner);
{$ENDIF}
end;

function BSwap(Value: Integer): Integer;
{$IFNDEF ASSEMBLER}
begin
  Result := (Word(Swap(Value)) shl 16 or Word(Swap(Value shr 16))) and $FFFFFF;
end;
{$ELSE}
asm
{$IFDEF SG_CPUX64}
  MOV EAX,ECX
{$ENDIF}
	XOR	AL,AL
	BSWAP	EAX
end;
{$ENDIF}

function FileExists(const FileName: string): Boolean;
var S: string;
begin
  S := Copy(FileName,1,2);
  Result := (S <> '//') and (S <> '\\') and SysUtils.FileExists(FileName);
end;


//function StrPos(Str1, Str2, Limit: PChar): PChar;
//asm
//{$IFDEF SGDEL_XE2}
//{$ELSE}
//	PUSH    EDI
//	PUSH    ESI
//	PUSH    EBX
//	OR      EAX,EAX
//	JE      @@2
//	OR      EDX,EDX
//	JE      @@2
//	SUB	ECX,EAX
//	JBE	@@2
//        MOV     EBX,EAX
//        MOV     EDI,EDX
//	XOR     AL,AL
//	PUSH	ECX
//	MOV     ECX,0FFFFFFFFH
//	REPNE   SCASB
//	NOT     ECX
//	DEC     ECX
//	MOV     ESI,ECX
//	POP	ECX
//	JE      @@2
//        SUB     ECX,ESI
//        JBE     @@2
//        MOV     EDI,EBX
//        LEA     EBX,[ESI-1]
//@@1:    MOV     ESI,EDX
//        LODSB
//        REPNE   SCASB
//        JNE     @@2
//        MOV     EAX,ECX
//        PUSH    EDI
//        MOV     ECX,EBX
//        REPE    CMPSB
//        POP     EDI
//        MOV     ECX,EAX
//        JNE     @@1
//	LEA     EAX,[EDI-1]
//	JMP     @@3
//@@2:    XOR     EAX,EAX
//@@3:    POP     EBX
//	POP     ESI
//	POP     EDI
//{$ENDIF}
//end;

function StrIndex(const S: string; const Map: array of string): Integer;
begin
  Result := IndexOfStrings(S, Map);
end;


function WideStrScan(const S: WideString; const C: WideChar): Integer;
var
  vLen: Integer;
begin
  Result := 1;
  vLen := Length(S);
  while (Result <= vLen) and (S[Result] <> C) do
    Inc(Result);
  if Result > vLen then
    Result := 0;
end;

procedure CopyEntitiesLnk(const ADest, ASource: TsgDXFEntity);
var
  I: Integer;
begin
  ADest.Clear(True);
  for I := 0 to ASource.Count - 1 do
    ADest.AddEntity(ASource[I]);
end;

procedure CopyEntitiesLnk(const ADest: TsgObjectList; const ASource: TsgDXFEntity);
var
  I: Integer;
begin
  ADest.Count := ASource.Count;
  for I := 0 to ASource.Count - 1 do
    ADest[I] := ASource[I];
end;

procedure CopyEntitiesLnk(const ADest: TsgDXFEntity; const ASource: TsgObjectList);
var
  I: Integer;
begin
  ADest.Clear(True);
  for I := 0 to ASource.Count - 1 do
    ADest.AddEntity(TsgDXFEntity(ASource[I]));
end;

function IsCADGradient(const AEntity: TsgDXFEntity): Boolean;
begin
  Result := (AEntity is TsgCADGradientPolygon) and
    (TsgCADGradientPolygon(AEntity).FType <> gtNone);
end;

function IsEntity(const AEntity: TObject): Boolean;
begin
  Result := IsEntity(AEntity, [TsgDXFEntity]);
end;

function IsEntity(const AEntity: TObject;const AClasses: array of TClass): Boolean;
var
  I: Integer;
begin
  Result := False;
  if not Assigned(AEntity) then
    Exit;
  try
    for I := Low(AClasses) to High(AClasses) do
      if AEntity is AClasses[I] then
      begin
        Result := True;
        Break;
      end;
  except
  end;
end;

function IsIncludeBlock(const Value1, Value2: Pointer): Boolean;
begin
  Result := (TObject(Value1) is TsgDXFInsert) and (TsgDXFInsert(Value1).Block = Value2);
end;

function IsIncludeStyle(const Value1, Value2: Pointer): Boolean;
begin
  Result := False;
  if Value1 <> nil then
    Result := TsgDXFEntity(Value1).HasTextStyle(Value2);
end;

function IsIncludeDimStyle(const Value1, Value2: Pointer): Boolean;
begin
  Result := False;
  if Value1 <> nil then
    Result := TsgDXFEntity(Value1).HasDimesionStyle(Value2);
end;

function IsIncludeAllDimesionStyle(const Value1, Value2: Pointer): Boolean;
begin
  Result := False;
  if Value1 <> nil then
    Result := TsgDXFEntity(Value1).HasDimesionStyle;
end;

function ReLoadEntitiesInBlock(const AConv: TsgDXFConverter; const ABlock: TsgDXFBlock; const AChanged: TsgDXFEntity;
  const AProc: TsgProcEqual; const ABox: PFRect): Boolean;
var
  I, J: Integer;
  vEnt: TsgDXFEntity;
  vInsReload: Boolean;

  procedure LoadEnt;
  begin
    Result := True;
    if ABox <> nil then
    begin
      UnionFRect(ABox^, vEnt.Box);
      if (vEnt.EntType = ceDimension) and TsgDXFDimension(vEnt).IsInternalDimension then
        TsgDXFDimension(vEnt).GenerateBlock(AConv);
      AConv.Loads(vEnt);
      UnionFRect(ABox^, vEnt.Box);
    end
    else
      AConv.Loads(vEnt);
  end;

begin
  Result := False;
  if ABox <> nil then
    ABox^ := cnstBadRect;
  if ABlock = nil then Exit;
  for I := 0 to ABlock.Count - 1 do
  begin
    vEnt := ABlock.Entities[I];
    if AProc(vEnt, AChanged) then
      LoadEnt
    else
    begin
      if vEnt is TsgDXFInsert then
      begin
        vInsReload := False;
        for J := 0 to TsgDXFInsert(vEnt).Attribs.Count - 1 do
        begin
          if AProc(TsgDXFInsert(vEnt).Attribs.List[J], AChanged) then
          begin
            vInsReload := True;
            AConv.Loads(TsgDXFEntity(TsgDXFInsert(vEnt).Attribs[J]));
          end;
        end;
        if ReLoadEntitiesInBlock(AConv, TsgDXFInsert(vEnt).Block, AChanged, AProc, nil) then
          vInsReload := True;
        if vInsReload then
          LoadEnt;
      end;
    end;
  end;
  if Result then
  begin
    ABlock.IsLoaded := False;
    AConv.Loads(ABlock);
    if ABlock.Layout <> nil then
      ABlock.IsLoaded := False;
  end;
end;

function ReLoadEntities(const AImage: Pointer; const AChanged: TsgDXFEntity;
  const AProc: TsgProcEqual;
  const AReload: PInteger = nil): TFRect;
var
  vImg: TsgCADImage absolute AImage;
  I: Integer;
  vBox: TFRect;
begin
  Result := cnstBadRect;
  if AReload <> nil then
    AReload^ := 0;
  if Assigned(vImg.CurrentLayout) then
  begin
    if ReLoadEntitiesInBlock(vImg.Converter, vImg.CurrentLayout.PaperSpaceBlock, AChanged, AProc, @vBox) then
    begin
      UnionFRect(Result, vBox);
      if AReload <> nil then
        Inc(AReload^);
    end;
  end;
  for I := 0 to vImg.LayoutsCount - 1 do
  begin
    if vImg.CurrentLayout <> vImg.Layouts[I] then
    begin
      if ReLoadEntitiesInBlock(vImg.Converter, vImg.Layouts[I].PaperSpaceBlock, AChanged, AProc, nil) then
      begin
        if AReload <> nil then
          Inc(AReload^);
      end;
    end;
  end;
end;

procedure AddVertexList(const AList: TsgObjectList; const APoint: TFPoint);
begin
  AddVertexInList(AList, APoint);
end;

function AddVertexInList(const AList: TsgObjectList; const APoint: TFPoint;
  const ABulge: Double = 0): TsgDXFVertex;
begin
  Result := TsgDXFVertex.Create;
  AList.Add(Result);
  Result.Point := APoint;
  if ABulge <> 0 then
    Result.Bulge := ABulge;
end;

function AddVertexInPolyline(const APoly: TsgDXFPolyline; const APoint: TFPoint;
  const ABulge: Double = 0): TsgDXFVertex;
begin
  Result := AddVertexInList(APoly.FEntities, APoint, ABulge);
end;

function AddVertexCopyInPolyline(const APoly: TsgDXFPolyline;
  const AVertex: TsgDXFVertex): TsgDXFVertex;
begin
  Result := AddVertexInList(APoly.FEntities, AVertex.Point, AVertex.Bulge);
end;

function InsertVertexInPolyline(const APoly: TsgDXFPolyline; const AIndex: Integer;
  const APoint: TFPoint; const ABulge: Double = 0): TsgDXFVertex;
begin
  Result := TsgDXFVertex.Create;
  APoly.FEntities.Insert(AIndex, Result);
  Result.Point := APoint;
  if ABulge <> 0 then
    Result.Bulge := ABulge;
end;

procedure AddVertesesInPolyline(const APoly: TsgDXFPolyline; const APoints: TList;
  const ARevers: Boolean = False);
var
  I: Integer;
begin
  if ARevers then
  begin
    for I := APoints.Count - 1 downto 0 do
      AddVertexInPolyline(APoly, PFPoint(APoints.List[I])^);
  end
  else
  begin
    for I := 0 to APoints.Count - 1 do
      AddVertexInPolyline(APoly, PFPoint(APoints.List[I])^);
  end;
end;

procedure AddVertexesInPolyline(const APoly: TsgDXFPolyline; const APoints: array of TFPoint;
  const ARevers: Boolean = False);
var
  I,vCount: Integer;
begin
  vCount := Length(APoints) - 1;
  if ARevers then
    for I := vCount downto 0 do
      AddVertexInPolyline(APoly, APoints[I])
  else
    for I := 0 to vCount do
      AddVertexInPolyline(APoly, APoints[I]);
end;

procedure AddVertexesInPolyline(const APoly: TsgDXFPolyline; const APoints: IsgArrayFPoint;
  const ARevers: Boolean = False);
var
  I, vCnt: Integer;
begin
  vCnt := APoints.FPointCount;
  if APoly.List.Capacity - APoly.List.Count < vCnt then
    APoly.List.Capacity := APoly.List.Capacity - APoly.List.Count + vCnt;
  if ARevers then
    for I := vCnt - 1 downto 0 do
      AddVertexInPolyline(APoly, APoints.FPoints[I])
  else
    for I := 0 to vCnt - 1 do
      AddVertexInPolyline(APoly, APoints.FPoints[I]);
end;

function CreateCADEllipticArc(const APoint, ARatPt1, ARatPt2: TFPoint;
  const APStart, APEnd: PFPoint): TsgDXFEllipse;
var
  vRatio: Double;
  vMajorPoint: TFPoint;
begin
  Result := nil;
  if SetRatioAndMajorPointByPoints(APoint, ARatPt1, ARatPt2, vRatio, vMajorPoint) then
  begin
    Result := TsgDXFEllipse.Create;
    Result.Point := APoint;
    Result.Ratio := vRatio;
    Result.EndPoint := vMajorPoint;
    Result.StartAngle := 0;
    Result.EndAngle := 360;
    if APStart <> nil then
      Result.StartAngle := sgFunction.GetAngleParam(Result.Point, Result.RadPt,
        Result.Ratio, APStart^, False);
    if APEnd <> nil then
      Result.EndAngle := sgFunction.GetAngleParam(Result.Point, Result.RadPt,
        Result.Ratio, APEnd^, False);
  end;
end;

function FindByHandle(const AList: TList; const AHandle: UInt64;
  var AIndex: Integer): Boolean;
{$IFDEF SGDEL_XE2}
begin
  Result := False;
  AIndex := AList.Count - 1;
  while (AIndex >= 0) and not Result do
    if TsgDXFEntity(AList.List[AIndex]).Handle = AHandle then
      Inc(Result)
    else
      Dec(AIndex);
end;
{$ELSE}
var
  vPList: PPointerList;
begin
  Result := False;
  AIndex := AList.Count - 1;
  vPList := @AList.List[0];
  while (AIndex >= 0) and not Result do
    if TsgDXFEntity(vPList^[AIndex]).Handle = AHandle then
      Inc(Result)
    else
      Dec(AIndex);
end;
{$ENDIF}

function FindByHandle(const AOwner: TsgDXFEntity; const AHandle: UInt64;
  var AIndex: Integer): Boolean;
begin
  AIndex := AOwner.IndexOfHandle(AHandle);
  Result := AIndex > -1;
end;

function FindChildByEntName(const AOwner: TsgDXFEntity; const AName: string;
  const ACaseSensitive: Boolean; var AIndex: Integer): Boolean;
type
  TCompareFunc = function(const S1, S2: string): Integer;
var
  CompareFunc: TCompareFunc;
begin
  Result := False;
  AIndex := AOwner.Count - 1;
  if ACaseSensitive then
    CompareFunc := AnsiCompareStr
  else
    CompareFunc := AnsiCompareText;
  while (AIndex >= 0) and not Result do
    if CompareFunc(AName, AOwner[AIndex].EntName) = 0 then
      Inc(Result)
    else
      Dec(AIndex);
end;

procedure DimStylePropsToHeadVarStruct(const ADimStyle: TsgDXFDimensionStyle;
  const AConv: TsgDXFConverter);
var
  vHeader: TsgHeadVarStruct;
begin
  vHeader := AConv.HeadVarStruct;
//  vHeader.DimProps.Alt := //Boolean;
//  vHeader.DimProps.AltF := //Double;
//  vHeader.DimProps.APost := //string;
  vHeader.DimProps.Asz := ADimStyle.ArrowSize; //Double;
  vHeader.DimProps.Sah := ADimStyle.DIMSAH;
  vHeader.DimProps.Arrows.Blk := ADimStyle.DIMBLKT; //Byte;
  vHeader.DimProps.Arrows.Blk1 := ADimStyle.DIMBLK1T; //Byte;
  vHeader.DimProps.Arrows.Blk2 := ADimStyle.DIMBLK2T; //Byte;
  vHeader.DimProps.Arrows.LrBlk := ADimStyle.DIMLDRBLKT; //Byte;
  vHeader.DimProps.Cen := ADimStyle.SizeCenterMark; //Double;
  vHeader.DimProps.ClrD := ADimStyle.DIMCLRD; //TsgColorCAD;
  vHeader.DimProps.ClrE := ADimStyle.DIMCLRE; //TsgColorCAD;
  vHeader.DimProps.ClrT := ADimStyle.DIMCLRT; //TsgColorCAD;
  vHeader.DimProps.SD1 := ADimStyle.DIMSD1; //Boolean;
  vHeader.DimProps.SD2 := ADimStyle.DIMSD2; //Boolean;
  vHeader.DimProps.SE1 := ADimStyle.DIMSE1; //Boolean;
  vHeader.DimProps.SE2 := ADimStyle.DIMSE2; //Boolean;
  vHeader.DimProps.Dec := ADimStyle.DIMDEC; //Integer;
  vHeader.DimProps.Exe := ADimStyle.ExtLineExt; //Double;
  vHeader.DimProps.Exo := ADimStyle.ExtLineOffset; //Double;
  vHeader.DimProps.Gap := ADimStyle.TextOffset; //Double;
  vHeader.DimProps.LFac := ADimStyle.GetLFAC; //Double;
  vHeader.DimProps.LwD := ADimStyle.DIMLWD; //Double;
  vHeader.DimProps.LwE := ADimStyle.DIMLWE; //Double;
  vHeader.DimProps.Post := ADimStyle.DIMPOST;//string;
  vHeader.DimProps.Scale := ADimStyle.Scale; //Double;
  vHeader.DimProps.Tad := Integer(ADimStyle.TextPosVert); //Integer;
  vHeader.DimProps.Tih := ADimStyle.DIMTIH; //Boolean;
  vHeader.DimProps.Tix := ADimStyle.DIMTIX; //Integer;
  vHeader.DimProps.Toh := ADimStyle.DIMTOH; //Boolean;
  vHeader.DimProps.Txt := ADimStyle.TextHeight; //Double;
  vHeader.DimProps.Tp := ADimStyle.DIMTP; //Double;
  vHeader.DimProps.Tm := ADimStyle.DIMTM; //Double;
  vHeader.DimProps.DSep := ADimStyle.DIMDSep; //Char;
  vHeader.DimProps.LUnit := ADimStyle.DIMLUNIT; //TsgDimLimitUnits;
  AConv.HeadVarStruct := vHeader;
end;

function CheckStandartNames(var AName: string): TsgStandardLineTypeName;
const
  cnstLineTypesDefault: array [Low(TsgStandardLineTypeName)..sltnContinious]
    of string = ('', sByBlock, sByLayer, sContinuous);
var
  vFind: Boolean;
begin
  vFind := False;
  Result := Low(TsgStandardLineTypeName);
  while (Result <= sltnContinious) and not vFind do
    if sgSameText(AName, cnstLineTypesDefault[Result]) then
      Inc(vFind)
    else
      Inc(Result);
  if vFind then
    AName := cnstLineTypesDefault[Result];
end;

function SetBlockByInsert(const Entity: TsgDXFEntity;
  const Converter: TsgDXFConverter): Boolean;
var
  vInsert: TsgDXFInsert;
begin
  Result := False;
  if Entity is TsgDXFInsert then
  begin
    vInsert := TsgDXFInsert(Entity);
    if Assigned(vInsert.Block) and not vInsert.Block.IsLoaded then
      vInsert.Resolve(Converter);
    if (vInsert.Block = nil) and (Entity is TsgDXFDimension) then
      TsgDXFDimension(Entity).GenerateBlock(Converter);
    Result := Assigned(vInsert.Block);
  end;
end;

procedure ResetHandleEntity(const AEntity: TsgDXFEntity; const AConv: TsgDXFConverter);
var
  I: Integer;
begin
  if Assigned(AEntity) then
  begin
    AEntity.Handle := cnstBadHandle;
//    AConv.SetHandle(AEntity);
    for I := 0 to AEntity.Count - 1 do
      ResetHandleEntity(AEntity.Entities[I], AConv);
  end;
end;
{$IFDEF DEMO}
function DrawSGBlock(AOwner: TsgDXFEntity; const AConv: TsgDXFConverter): TsgDXFEntity;
const
  cnstTrialMessagesCount: Integer = 3;
const
  cnstXDATAITEMS = 'XDATAITEMS';
  cnstXDATA = 'XDATA';
  cnstMessage = 'Trial version CAD VCL - www.cadsofttools.com';
  cnstRectWidth = 1/2;
  cnstLineSpacingFactor = 1;
  cnstTextHeight = 1/35;
var
  I, J, C, K, vIndex: Integer;
  vMText: TsgDXFMText;
  vSGBlock: TsgDXFBlock;
  vXData, vXDataItems: TsgDXFDictionary;
  vInsert: TsgDXFInsert;
  vNeedLoaded, vNeedRecreate: Boolean;
  vBox: TFRect;
  vDelta: TFPoint;
  vLayer: TsgDXFLayer;
  vLayers, vObjects, vBlockRecords: TsgDXFGroup;

  procedure InitMessage(const AMText: TsgDXFMText);
  begin
    AMText.RectWidth := cnstRectWidth;
    AMText.LineSpacingFactor := cnstLineSpacingFactor;
    AMText.Height := cnstTextHeight;
    AMText.ColorCAD := MakeColorCAD(acIndexColor, clDXFBlackWhite);
    AMText.Text := cnstMessage;
    AMText.Visible := True;
    AMText.Visibility := True;
    AMText.Point := cnstFPointZero;
  end;

begin
  vLayers := AConv.Sections[csLayers];
  if not Assigned(vLayers) then
  begin
    vLayers := AConv.NewTable(csLayers);
    AConv.Sections[csLayers] := vLayers;
  end;
  vObjects := AConv.Sections[csObjects];
  if not Assigned(vObjects) then
  begin
    vObjects := AConv.NewTable(csObjects);
    AConv.Sections[csObjects] := vObjects;
  end;
  vBlockRecords := AConv.Sections[csBlockRecords];
  if not Assigned(vBlockRecords) then
  begin
    vBlockRecords := AConv.NewTable(csBlockRecords);
    AConv.Sections[csBlockRecords] := vBlockRecords;
  end;
  vLayer := TsgDXFLayer(vLayers.FindEntByName(AConv.HeadVarStruct.CLayer));
  if not Assigned(vLayer) or ((not vLayer.Visible) or vLayer.Frozen) then
  begin
    I := 0;
    vLayer := nil;
    while (I < vLayers.Count) and not Assigned(vLayer) do
    begin
      vLayer := TsgDXFLayer(vLayers[I]);
      if (not vLayer.Visible) or vLayer.Frozen then
        vLayer := nil;
      Inc(I);
    end;
  end;
  vXData := TsgDXFDictionary(vObjects.FindEntByName(cnstXDATA));
  if not Assigned(vXData) then
  begin
    vXData := TsgDXFDictionary.Create;
    vXData.Name := cnstXDATA;
    vXData.Loaded(AConv);
    vObjects.AddEntity(vXData);
  end;
  vIndex := vObjects.IndexOfEntity(vXData);
  vSGBlock := TsgDXFBlock(vXData.FindEntByName(cnstCompany));
  if not Assigned(vSGBlock) then
  begin
    vSGBlock := TsgDXFBlock.Create;
    vSGBlock.Name := cnstCompany;
    vXData.AddEntity(vSGBlock);
  end;
  vSGBlock.Layer := vLayer;
  vMText := nil;
  if (vSGBlock.Count > 0) and (vSGBlock[0] is TsgDXFMText) then
    vMText := TsgDXFMText(vSGBlock[0]);
  if not Assigned(vMText) then
  begin
    vMText := TsgDXFMText.Create;
    vSGBlock.AddEntity(vMText);
    vNeedLoaded := True;
  end
  else
  begin
    vNeedLoaded := (vMText.Text <> cnstMessage) or
      not IsEqual(vMText.RectWidth, cnstRectWidth) or
      not IsEqual(vMText.LineSpacingFactor, cnstLineSpacingFactor) or
      not IsEqual(vMText.Height, cnstTextHeight) or
      not IsEqualColorCAD(vMText.ColorCAD, MakeColorCAD(acIndexColor, clDXFBlackWhite)) or
      not vMText.Visible or not IsEqualFPoints(vMText.Point, cnstFPointZero);
  end;
  if vNeedLoaded then
  begin
    InitMessage(vMText);
    vMText.Loaded(AConv);
    vSGBlock.IsLoaded := False;
    vSGBlock.Loaded(AConv);
    vBlockRecords.RemoveEntity(vSGBlock.BlockRecord);
  end;
  if Assigned(vMText.Block) then
    for I := 0 to vMText.Block.Count - 1 do
      vMText.Block[I].Visibility := True;
  vMText.Layer := vLayer;
  vSGBlock.Offset := cnstFPointZero;
  vSGBlock.Visible := True;
  vSGBlock.Visibility := True;
  vXDataItems := TsgDXFDictionary(vObjects.FindEntByName(cnstXDATAITEMS));
  if not Assigned(vXDataItems) then
  begin
    vXDataItems := TsgDXFDictionary.Create;
    vXDataItems.Name := cnstXDATAITEMS;
    vXDataItems.Loaded(AConv);
    vObjects.InsertEntity(vIndex, vXDataItems);
  end;
  vNeedRecreate := False;
  C := cnstTrialMessagesCount;
  I := 0;
  while (I < C) and not vNeedRecreate do
  begin
    J := 0;
    while (J < C) and not vNeedRecreate do
    begin
      K := I * C + J;
      if (K < vXDataItems.Count) and (vXDataItems[K] is TsgDXFInsert) and
         (TsgDXFInsert(vXDataItems[K]).Block = vSGBlock) then
        Inc(J)
      else
        Inc(vNeedRecreate);
    end;
    Inc(I);
  end;
  if vNeedRecreate then
  begin
    vXDataItems.Clear(True);
    for I := 0 to C - 1 do
      for J := 0 to C - 1 do
      begin
        vInsert := TsgDXFInsert.Create;
        vInsert.Block := vSGBlock;
        vXDataItems.AddEntity(vInsert);
      end;
  end;
  vBox := AOwner.Box;
  vDelta.X := (vBox.Right - vBox.Left) / C;
  vDelta.Y := (vBox.Top - vBox.Bottom) / C;
  vDelta.Z := (vBox.Z2 - vBox.Z1) / C;
  for I := 0 to C - 1 do
    for J := 0 to C - 1 do
    begin
      K := I * C + J;
      vInsert := TsgDXFInsert(vXDataItems[K]);
      vInsert.Scale := MakeFPoint(vDelta.X, vDelta.Y, 1);
      vInsert.Point := MakeFPoint(vBox.Left + I*vDelta.X, vBox.Top - J*vDelta.Y,
        (vBox.Z2 - vBox.Z1) / 2);
      vInsert.Layer := vLayer;
      vInsert.Visible := True;
      vInsert.Visibility := True;
      vInsert.Loaded(AConv);
    end;
  Result := vXDataItems;
end;
{$ENDIF}

function HasSpatialFilter(ADictionary: TsgDXFEntity; var AFilter: TsgDXFEntity): Boolean;
begin
  AFilter := nil;
  if Assigned(ADictionary) then
  begin
    ADictionary := ADictionary.FindEntByName(sAcadFilterDictionary);
    if Assigned(ADictionary) then
      AFilter := ADictionary.FindEntByName(cnstSpatial);
  end;
  Result := Assigned(AFilter);
end;

function GetSpatialFilter(AInsert: TsgDXFInsert; var AFilter: TsgDXFEntity): Boolean;
begin
  Result := HasSpatialFilter(AInsert.Dictionary, AFilter);
end;

function ParseURLData(const AURLData: TsgCADExtendedData; var AURLName, AURLValue: string): Boolean;
var
  I, vHyperLinkAct: Integer;
begin
  AURLName := '';
  AURLValue := '';
  vHyperLinkAct := 0;
  I := 1;
  while I < AURLData.DataCount do
  begin
    case AURLData.DataCode[I] of
      String_1000:
         begin
           Inc(vHyperLinkAct);
           case vHyperLinkAct of
             1:  AURLValue := AURLData.DataString[I];
             2:
                 begin
                   AURLName := AURLData.DataString[I];
                   I := AURLData.DataCount;
                 end;
           end;
         end;
    end;
    Inc(I);
  end;
  Result := vHyperLinkAct > 0;
end;

{ TsgMTextWords }

function TsgMTextWords.AddWord(const AWord: string): Integer;
var
  vWordID: Integer;
begin
  case Length(AWord) of
    1: vWordID := Ord(AWord[1]);
  else
    vWordID := -(ListAddWord(AWord) + 1);
  end;
  Result := FCount;
  if FCount = Length(FWords) then
    SetLength(FWords, ListGrow(Length(FWords)));
  Inc(FCount);
  FWords[Result] := vWordID;
end;

procedure TsgMTextWords.Clear;
begin
  FListCount := 0;
  FCount := 0;
end;

function TsgMTextWords.ExpandText(AFrom, ATo: Integer): string;
var
  I: Integer;
begin
  Result := '';
  for I := AFrom to ATo do
    Result := Result + Words[I];
end;

function TsgMTextWords.GetText: string;
begin
  Result := ExpandText(0, FCount - 1);
end;

function TsgMTextWords.GetWordID(Index: Integer): Integer;
begin
  Result := FWords[Index];
end;

function TsgMTextWords.GetWords(Index: Integer): string;
begin
  if FWords[Index] < 0 then
    Result := FList[-(FWords[Index] + 1)]
  else
    Result := Char(FWords[Index]);
end;

function TsgMTextWords.ListAddWord(const AWord: string): Integer;
begin
  Result := FListCount;
  if FListCount = Length(FList) then
    SetLength(FList, ListGrow(Length(FList)));
  Inc(FListCount);
  FList[Result] := AWord;
end;

procedure TsgMTextWords.SetText(const Value: string);
var
  vPos, vStart, vLen: Integer;
  vCh: WideChar;
  vWord: string;
  vIsSingleByte: Boolean;
  vValue: sgUnicodeStr;
begin
  Clear;
  vPos := 1;
  vValue := sgUnicodeStr(Value);
  vLen := Length(vValue);
  while vPos <= vLen do
  begin
    vStart := vPos;
    repeat
      vCh := vValue[vPos];
      vIsSingleByte := EncMgr.FromChar(Ord(vCh)).IsSingleByte;
      Inc(vPos);
    until (vPos > vLen) or ((vCh <> #$A0) and IsSpace(vCh)) or not vIsSingleByte;
    if not vIsSingleByte and (vPos - vStart > 1) then
    begin
      vWord := string(Copy(vValue, vStart, vPos - vStart - 1));
      AddWord(vWord);
      AddWord(string(vValue[vPos - 1]));
    end
    else
    begin
      vWord := string(Copy(vValue, vStart, vPos - vStart));
      AddWord(vWord);
    end;
  end;
end;

{TsgMTextParser}

constructor TsgMTextParser.Create(const AConv: TsgDXFConverter);
begin
  inherited Create;
  FLevels := TsgIntegerList.Create;
  FConverter := AConv;
  FNeedSetupOptions := False;
  FListCarry := TsgEntitiesList.Create;
end;

procedure TsgMTextParser.DestNotify(const Obj: TObject;
  Action: TListNotification);
begin
  if (Action in [lnExtracted, lnDeleted]) and (FPrevText = Obj) then
    FPrevText := nil;
  if Assigned(FDestNotify) then
    FDestNotify(Obj, Action);
end;

destructor TsgMTextParser.Destroy;
begin
  FLevels.Free;
  DoClearListCarry;
  FreeAndNil(FListCarry);
  inherited Destroy;
end;

procedure TsgMTextParser.DoClearListCarry;
var
  J: Integer;
begin
  for J := 0 to FListCarry.Count - 1 do
    TsgDXFText(FListCarry.List[J]).Free;
  FListCarry.Count := 0;
end;

procedure TsgMTextParser.CarryString(const AText: TsgDXFText);
var
  I: Integer;
  vText: TsgDXFText;

  function NewLine(AText: TsgDXFText): Double;
  begin
    if AText.IsSHXFont then
      Result := GetTextHeight(AText) +
        AText.FTextParse^.FontParams.Below +
        //FFontParams.Below +
        FFontParams.DY
    else
      Result := AText.FTextParse^.FontParams.Height +
        0.5 * AText.FTextParse^.FontParams.Below + FFontParams.DY;
  end;

  function IsTextEmpty(AText: TsgDXFText): Boolean;
  begin
    Result := (Length(AText.FText) = 0) and (Length(AText.FUnicodeText) = 0);
  end;

  function IsDestEmpty: Boolean;
  var
    I: Integer;
  begin
    Result := True;
    if FDest.Count > 0 then
    begin
      for I := FDest.Count - 1 downto 0 do
      begin
        if TsgDXFText(FDest[I]).FTextParse.Level = 0 then
        begin
          Result := False;
          Break;
        end;
      end;
    end;
  end;

begin
  AText.FTextParse^.ParagraphParams.IsFirstLine := ((FListCarry.Count = 0) and IsDestEmpty) or (FListCarry.Count > 0);
  if (FListCarry.Count > 0) and not IsTextEmpty(AText) then
  begin
    if (FDest.Count > 0) or (not (FAlign in [7, 8 ,9])) then
    begin
      AText.FPoint.X := 0;
      AText.FPoint1.X := 0;
      vText := TsgDXFText(FListCarry.First);
      vText.Text := '@';
      ConvertUnicode(vText);
      vText.Loaded(FConverter);
      if IsDestEmpty then
        AText.FTextParse^.Offset.Y := NewLine(vText)
      else
        AText.FTextParse^.Offset.Y := FFontParams.DY;
      vText.Free;
      FListCarry.List[0] := nil;
      for I := 1 to FListCarry.Count - 1 do
      begin
        vText := TsgDXFText(FListCarry[I]);
        try
          vText.Text := '@';
          ConvertUnicode(vText);
          vText.Loaded(FConverter);
          AText.FTextParse^.Offset.Y := AText.FTextParse^.Offset.Y + NewLine(vText);
          FListCarry.List[I] := nil;
        finally
          vText.Free;
        end;
      end;
    end;
    DoClearListCarry;
  end;
  if (FListCarry.Count > 0) and AText.FTextParse^.ParagraphParams.IsFirstLine then
    if not IsTextEmpty(AText) then
      DoClearListCarry;
end;

function TsgMTextParser.Parse(const Source, Dest: TsgDXFEntity): Boolean;
const
  cnstInvalidHeightToRectWidthRatio = 10.0;
var
  vText: TsgDXFText;
  I: Integer;
  vIsDestBlock, vIsDestGroup, vHasDivision: Boolean;
  vDestWidth: Double;
  vFontStyles: TmvFontStyles;
begin
  Result := False;
  FHasLine := False;
  vHasDivision := False;
  FDest := Dest;
  FSource := TsgDXFMText(Source);
  FSourceAlign := FSource.Align;
  vIsDestBlock := False;
  vIsDestGroup := False;
  if Dest is TsgDXFGroup then
  begin
    vIsDestGroup := True;
    vIsDestBlock := Dest is TsgDXFBlock;
    FDestNotify := TsgDXFGroup(Dest).OnListNotify;
    TsgDXFGroup(Dest).OnListNotify := DestNotify;
  end;
  if vIsDestBlock then
  begin
    FDest.Clear;
    TsgDXFBlock(FDest).IsLoaded := False;
  end;
  FSourceRectWidth := FSource.RectWidth;
  if not IsZero(FSourceRectWidth) then
  begin
    if FSource.Height / FSourceRectWidth >= cnstInvalidHeightToRectWidthRatio then
      FSourceRectWidth := 0;
  end;
  FDestWidth := FSourceRectWidth;
  FString := SetTextStr(FSource.Text);
  if Length(Trim(FString)) = 0 then Exit;
  FLevels.Count := 0;
  TsgObjectList.ClearList(FListCarry, True);
  FIndex := 1;
  FLength := Length(FString);
  FLenByRow := 0;
  FPos.X := 0;
  FTextParse := cnstTextParseZero;
  vText := CreateDefaultText;
  try
    vText.Text := '0';
    ConvertUnicode(vText);
    vText.Loaded(FConverter);
    FFontParams := vText.FTextParse^.FontParams;
  finally
    FreeAndNil(vText);
  end;
  while FIndex <= FLength do
  begin
    ReadParams(vText);
    ConvertUnicode(vText);
    vFontStyles := vText.Properties.FontStyle;
    if (not vText.WinFont) and (fmItalic in vFontStyles) then
      vText.ObliqueAngle := 15;
    if vText.FTextParse^.Level = 0 then
    begin
      CarryString(vText);
      FTextParse := vText.FTextParse^;
      FTextParse.Level := 0;
      if not IsTextEmpty(vText) then
      begin
        FTextParse.ParagraphParams.T := 0;
        vText.FTextParse^.HasLine := FHasLine and (FCells <> nil);
        vText.FTextParse^.IsEmpty := vText.GetIsEmpty;
        FHasLine := False;
        FConverter.DoCreate(vText);
        FDest.AddEntity(vText);
        vText.Loaded(FConverter);
        if vText.FTextParse^.TextPos = csNone then
        begin
          if FSourceRectWidth > 0 then
          begin
            if FSource.Hyphenation then//change in future version
              DivisionStringWithHyphenation
            else
              DivisionString;
          end;
          vText := TsgDXFText(FDest.Entities[FDest.Count - 1]);
          vText.Loaded(FConverter);
          if not IsBadRect(vText.Box) then
            FPos.X := vText.Box.Right
          else
          begin
            vText := TsgDXFText(FDest.DeleteEntity(FDest.Count - 1));
            vText.Free;
          end;
        end
        else
        begin
          if MakeFraction(vText) = 3 then
            vHasDivision := True;
        end;
      end
      else
        vText.Free;
      vText := nil;
    end
    else
    begin
      FDest.AddEntity(vText);
      FTextParse := vText.FTextParse^;
      FTextParse.Level := 0;
      vText := nil;
    end;
  end;
  for I := FDest.Count - 1 downto 0 do
  begin
    vText := TsgDXFTExt(FDest[I]);
    if vText.FTextParse^.Level > 0 then
    begin
      FDest.DeleteEntity(I);
      vText.Free;
    end;
  end;

  LevelingString;
  if (FDest.Count > 0) and ((not (GetSourceAlign(0) in [0, 1, 4, 7])) or FHorzAlignDropped) then
  begin
    vDestWidth := GetDestWidth;
    if FDestWidth < vDestWidth then
      FDestWidth := vDestWidth;
    if FDestWidth > 0 then
    begin
      if FSource.Hyphenation then
        CorrectTextByHyphenation;
      AdjustChildren;
    end;
  end;
  if vHasDivision then
    CorrectTextByDivision;
  if FCells <> nil then
    CorrectTextByTolerance;
  if {not FHorzAlignDropped or }IsZero(FSourceRectWidth) then
    FSource.Align := GetSourceAlign(0);//FSourceAlign;
  for I := FDest.Count - 1 downto 0 do
  begin
    vText := TsgDXFText(FDest.Entities[I]);
    if (vText.EntType = ceText) and (vText.FTextParse <> nil) then
    begin
      Result := Result or (not vText.FTextParse.IsEmpty);
      Dispose(vText.FTextParse);
      vText.FTextParse := nil;
    end;
  end;
  if vIsDestGroup then
  begin
    TsgDXFGroup(Dest).OnListNotify := FDestNotify;
    FDestNotify := nil;
  end;
end;

procedure TsgMTextParser.CorrectTextByDivision;
var
  I, Cnt: Integer;
  vText, vText2: TsgDXFText;
  vCenter: TFPoint;

  procedure AddLine(const ABase: TsgDXFText; const Center: TFPoint);
  var
    vLine: TsgDXFLine;
  begin
    vLine := TsgDXFLine.Create;
    FDest.AddEntity(vLine);
    vLine.AssignEntity(ABase);
    vLine.ColorCAD := ABase.ColorCAD;
    vLine.Point := GetPointOnCircle(Center, ABase.Height, 55);
    vLine.Point1 := GetPointOnCircle(Center, ABase.Height, 235);
    FConverter.Loads(vLine);
  end;

begin
  vCenter := cnstFPointZero;
  I := 0;
  Cnt := FDest.Count;
  while I < Cnt do
  begin
    vText := TsgDXFText(FDest.Entities[I]);
    case vText.FTextParse^.TextPos of
      csDivision:
        begin
          vCenter.X := vText.Box.Right + vText.FTextParse^.FontParams.DX * 0.5;
          vCenter.Y := vText.Box.Bottom;
          AddLine(vText, vCenter);
        end;
      csDivHi:
        begin
          Inc(I);
          if I < Cnt then
          begin
            vText2 := TsgDXFText(FDest.Entities[I]);
            vCenter.X := (vText.Box.Right + vText2.Box.Left) * 0.5;
            vCenter.Y := (vText.Box.Bottom + vText2.Box.Top) * 0.5;
            AddLine(vText, vCenter);
          end
          else
          begin
            vCenter.X := vText.Box.Right + vText.FTextParse^.FontParams.DX * 0.5;
            vCenter.Y := vText.Box.Bottom;
            AddLine(vText, vCenter);
          end;
        end;
      csDivend:
        begin
          vCenter.X := vText.Box.Left - vText.FTextParse^.FontParams.DX * 0.5;
          vCenter.Y := vText.Box.Top;
          AddLine(vText, vCenter);
        end;
    end;
    Inc(I);
  end;
end;

procedure TsgMTextParser.CorrectTextByHyphenation;
var
  vFirstStr, vLastStr: string;
  I, J: Integer;
  vTextFirst, vTextLast: TsgDXFText;
begin
  if not (FDest is TsgDXFBlock) then Exit;
  I := 0;
  while I < FDest.Count do
  begin
    if IsFirstText(FDest[I]) then
    begin
      J := I + 1;
      while (J < FDest.Count) and (not IsFirstText(FDest[J])) do
        Inc(J);
      Dec(J);
      while (I <= J) and (Length(Trim(TsgDXFText(FDest[I]).Text)) < 1) do
      begin
        FDest.DeleteEntity(I).Free;
        Dec(J);
      end;
      if I <= J then
      begin
        while (J > I) and (Length(Trim(TsgDXFText(FDest[J]).Text)) < 1) do
        begin
          FDest.DeleteEntity(J).Free;
          Dec(J);
        end;
        vTextFirst := TsgDXFText(FDest[I]);
        vTextLast := TsgDXFText(FDest[J]);
        I := J + 1;
        if vTextFirst <> vTextLast then
        begin
          vFirstStr := TrimLeft(vTextFirst.Text);
          if vFirstStr <> vTextFirst.FText then
          begin
            vTextFirst.Text := vFirstStr;
            ConvertUnicode(vTextFirst);
            vTextFirst.Loaded(FConverter);
          end;
          vLastStr := TrimRight(vTextLast.Text);
        end
        else
          vLastStr := Trim(vTextLast.Text);
        if vLastStr <> vTextLast.FText then
        begin
          ConvertUnicode(vTextLast);
          vTextLast.Loaded(FConverter);
        end;
      end;
    end
    else
      Inc(I);
  end;
end;

procedure TsgMTextParser.CorrectTextByTolerance;
var
  vIsR14: Boolean;
  LS, LE, vDestCount, I, vIndexLine: Integer;
  vBreak, vIsNotInit: Boolean;
  vT, vTPrev: TsgDXFText;
  vXS, vXE, vYS, vYE, vYM, vMaxHeight, vHeight: Double;

  procedure AddBoundary(const X1, Y1, X2, Y2: Double);
  var
    vPoly: TsgDXFPolyline;
    V: TsgDXFVertex;
  begin
    vPoly := TsgDXFPolyline.Create;
    vPoly.Polyline3D := True;
    FCells.Add(vPoly);
    vPoly.ColorCAD := FCellColor;
    V := TsgDXFVertex.Create;
    vPoly.AddEntity(V);
    V.Point := MakeFPoint(X1, Y1, 0);
    V := TsgDXFVertex.Create;
    vPoly.AddEntity(V);
    V.Point := MakeFPoint(X2, Y1, 0);
    V := TsgDXFVertex.Create;
    vPoly.AddEntity(V);
    V.Point := MakeFPoint(X2, Y2, 0);
    V := TsgDXFVertex.Create;
    vPoly.AddEntity(V);
    V.Point := MakeFPoint(X1, Y2, 0);
    vPoly.Closed := True;
    vPoly.Loaded(FConverter);
  end;

  procedure AddLine(const X1, Y1, X2, Y2: Double);
  var
    vLine: TsgDXFLine;
  begin
    vLine := TsgDXFLine.Create;
    FCells.Add(vLine);
    vLine.ColorCAD := FCellColor;
    vLine.Point := MakeFPoint(X1, Y1, 0);
    vLine.Point1 := MakeFPoint(X2, Y2, 0);
    vLine.Loaded(FConverter);
  end;

begin
  vIsR14 := (FConverter <> nil) and (FConverter.HeadVarStruct.Version = Byte(acR14));
  vIsNotInit := True;
  vYE := -FSource.Height;
  LE := 0;
  vIndexLine := 0;
  vDestCount := FDest.Count;
  while LE < vDestCount do
  begin
    vMaxHeight := -1;
    vBreak := True;
    LS := LE;
    while LE < vDestCount do
    begin
      vT := TsgDXFText(FDest.Entities[LE]);
      vHeight := vT.FBox.Top - vT.FBox.Bottom;
      if vT.FTextParse^.ParagraphParams.IsFirstText then
        vBreak := not vBreak;
      if vBreak then
        Break;
      if vMaxHeight < vHeight then
        vMaxHeight := vHeight;
      Inc(LE);
    end;
    if vIsR14 then
    begin
      vYS := vYE;
      if vIsNotInit then
      begin
        vYS := vYS + FCellSize + vMaxHeight * 0.5;
        vIsNotInit := False;
      end;
      vYM := vYS - FCellSize - vMaxHeight * 0.5;
      vYE := vYS - FCellSize * 2 - vMaxHeight;
    end
    else
    begin
      vYS := - FCellSize * vIndexLine;
      vYE := vYS - FCellSize;
      vYM := vYS - FCellSize * 0.25;
    end;
    I := LS;
    while I < LE do
    begin
      vT := TsgDXFText(FDest.Entities[I]);
      if vT.FTextParse^.HasLine and (I > LS) then
      begin
        vTPrev := TsgDXFText(FDest.Entities[I - 1]);
        vXS := (vTPrev.FBox.Right + vT.FBox.Left) * 0.5;
        AddLine(vXS, vYS, vXS, vYE);
      end;
      Inc(I);
      if vIsR14 then
        vT.FPoint1.Y := vT.FPoint1.Y + vYM - (vT.FBox.Top + vT.FBox.Bottom) * 0.5
      else
        vT.FPoint1.Y := vYM;
      vT.Loaded(FConverter);
    end;
    if vIsR14 then
      vXE := TsgDXFText(FDest.Entities[LE - 1]).FBox.Right + FCellSize
    else
      vXE := TsgDXFText(FDest.Entities[LE - 1]).FBox.Right + FCellSize * 0.25;
    AddBoundary(0, vYS, vXE, vYE);
    Inc(vIndexLine);
  end;
end;

procedure TsgMTextParser.AdjustChildren;
var
  vLengthString: TsgFloat;
  I, K: Integer;
//  T: TsgDXFText;
  X: Single;

  procedure DoXOffsetText(T: TsgDXFText; const AXOffs: Double);
  begin
    T.FPoint.X := T.FPoint.X + X;
    if T.HasSecond then
      T.FPoint1.X := T.FPoint1.X + X;
    T.FStartPoint.X := T.FStartPoint.X + X;
    OffsetFRect(T.FBox, X, 0, 0);
    T.FMatrix.M[3, 0] := T.FMatrix.M[3, 0] + X;
  end;

  procedure Row(AStart, AEnd: Integer);
  var
    L: Integer;
    //vOnewordPerLine: Boolean;

    function CalculateLengthString: Boolean;
    var
      J: Integer;
      vText: TsgDXFText;
    begin
      J := AStart;
      while (J < FDest.Count - 1) and (not TsgDXFText(FDest.Entities[J + 1]).FTextParse^.ParagraphParams.IsFirstText) do
        Inc(J);
      if J < FDest.Count then
      begin
        if (TsgDXFText(FDest.Entities[J]).FTextParse^.TextPos <> csNone) and
           (J > 0) and
           (TsgDXFText(FDest.Entities[J-1]).FTextParse^.TextPos <> csNone) then
          vLengthString := Max(TsgDXFText(FDest.Entities[J]).FBox.Right, TsgDXFText(FDest.Entities[J-1]).FBox.Right)
        else
        begin
          vText := TsgDXFText(FDest.Entities[J]);
          if (GetSourceAlign(AStart) in [2, 5, 8]) and (vText.FTextParse^.Spaces <> 0) then
          begin
            vText.Text := TrimRight(vText.Text);
            if vText.IsEmpty then
              vLengthString := vText.FBox.Left
            else
            begin
              if vText.IsSHXFont then ConvertUnicode(vText);
              vText.Loaded(FConverter);
              vLengthString := vText.FBox.Right;
            end;
          end
          else
            vLengthString := vText.FBox.Right;
        end;
      end
      else
        vLengthString := TsgDXFText(FDest.Entities[AStart]).FBox.Right;
      Result := AStart = J;
    end;

  begin
    //vOnewordPerLine := False;
    if (AStart >= 0) and not (GetSourceAlign(AStart) in [1, 4, 7]) then
    begin
      if TsgDXFText(FDest.Entities[AStart]).FTextParse^.ParagraphParams.IsFirstText then
      begin
        //vOnewordPerLine := CalculateLengthString;
        CalculateLengthString;
        X := (FDestWidth - vLengthString);
        if GetSourceAlign(AStart) in [2, 5, 8] then
          X := X / 2;
      end;
    end
    else
      X := 0;
    if X < 0 then Exit;
    if AStart < 0 then
      AStart := 0;
    for L := AStart to AEnd - 1 do
      DoXOffsetText(TsgDXFText(FDest.Entities[L]), X);
  end;

begin
  X := 0;
  K := 0;
  vLengthString := 0;
  for I := 0 to FDest.Count - 1 do
  begin
//    T := TsgDXFText(FDest.Entities[I]);
//    if T.FBox.Top <> Y then
    begin
      Row(K, I);
      K := I;
    end;
  end;
  Row(FDest.Count - 1, FDest.Count);
end;

procedure TsgMTextParser.CopyTextOptions(const ATextBase, AText: TsgDXFText);
var
  vFontStyles: TmvFontStyles;
begin
  AText.SetStyle(ATextBase.Style);
  AText.ChangeByStyle(ATextBase.Style);// after SetStyle in MTEXT
  AText.Scale := ATextBase.Scale;
  AText.Layer := ATextBase.Layer;
  AText.Height := ATextBase.Height;
  AText.FVAlign := ATextBase.FVAlign;
  AText.FHAlign := ATextBase.FHAlign;
  AText.Properties := ATextBase.Properties;
  AText.FCharset := ATextBase.Charset;
  AText.ColorCAD := ATextBase.ColorCAD;
  AText.Text := ATextBase.Text;
  SetLength(AText.FIndices, 0);
  AText.FInternalFlags := ATextBase.FInternalFlags;
  AText.FTextParse^ := ATextBase.FTextParse^;
  AText.FTextParse^.Level := 0;
  AText.FTextParse^.Offset := cnstF2DPointZero;
  AText.FTextParse^.TextPos := csNone;
  AText.FTextParse^.ParagraphParams.IsFirstLine := False;
  AText.FTextParse^.ParagraphParams.PXQAlign := ATextBase.FTextParse^.ParagraphParams.PXQAlign;
  //AText.FTextParse^.FOffsetX := 0;
  AText.FLineWeight := ATextBase.FLineWeight;
  AText.ObliqueAngle := ATextBase.ObliqueAngle;
  vFontStyles := ATextBase.Properties.FontStyle;
  if (not AText.WinFont) and (fmItalic in vFontStyles) then
    AText.ObliqueAngle := 15;
  AText.Tracking := ATextBase.Tracking;
end;

function TsgMTextParser.CreateDefaultText: TsgDXFText;
begin
  Result := TsgDXFText.Create;
  Result.InsideMText := True;
  Result.SetStyle(FSource.Style);
  Result.ChangeByStyle(FSource.Style);// after SetStyle in MTEXT
  Result.Scale := FSource.Style.WidthFactor;
  Result.Layer := FSource.Layer;
  Result.Height := FSource.Height;
  Result.FVAlign := 3;
  Result.HAlign := 0;
  Result.FPoint := MakeFPoint(FPos.X, 0, 0);
  Result.Point1 := Result.FPoint;
  Result.ColorCAD := FSource.ColorCAD;
  Result.Text := '';
  Result.CreateTextParse;
  Result.FTextParse^ := FTextParse;
  Result.FTextParse^.Level := 0;
  Result.FTextParse^.Offset := cnstF2DPointZero;
  Result.FTextParse^.TextPos := csNone;
  Result.FTextParse^.ParagraphParams.PXQAlign := GetSourceAlign(FDest.Count - 1);
  Result.FLineWeight := FSource.FLineWeight;
end;

procedure TsgMTextParser.LevelingString;
var
  vFirstIndex, vLastIndex, vModeLine, vDestCount: Integer;
  vMaxHeigth, vMaxHeigthFraction, vDY, vLineSpaceFactor: Double;
  vSizeByTolerance1, vSizeByTolerance2: Double;
  vText, vTextWithMaxHeigth: TsgDXFText;
  vBreak, vIsExactly: Boolean;
  vVAlign: Byte;
  vSign: Integer;
  vTextLow: TsgDXFText;

  function GetFractionHeigth(const F, D: TsgDXFText): Double;
  begin
    Result := F.FBox.Top - D.FBox.Bottom + D.FBox.Top - D.FBox.Bottom + F.FTextParse^.FontParams.Below;
  end;

  function GetDivisionHeigth(const D: TsgDXFText): Double;
  begin
    Result := (D.FBox.Top - D.FBox.Bottom) * 2;
  end;

  procedure FindIndexs;
  var
    vHeight, vFractionHeight: Double;
  begin
    vVAlign := 0;
    vBreak := True;
    vFirstIndex := vLastIndex;
    vMaxHeigth := -1;
    vMaxHeigthFraction := -1;
    vTextWithMaxHeigth := nil;
    vTextLow := nil;
    vModeLine := 0;
    vDY := 0;
    while vLastIndex < vDestCount do
    begin
      vText := TsgDXFText(FDest.Entities[vLastIndex]);
      vText.FTextParse^.ParagraphParams.IsFirstText := False;
      if vText.Point.X = 0 then
        vBreak := not vBreak;
      if vBreak then
        Break;
      if vText.FTextParse^.FontParams.DY > vDY then
        vDY := vText.FTextParse^.FontParams.DY;
      if vVAlign < vText.FVAlign then
        vVAlign := vText.FVAlign;
      vHeight := GetTextHeight(vText);
      case vText.FTextParse^.TextPos of
        csNone:
          begin
            if vMaxHeigth < vHeight then
            begin
              vMaxHeigth := vHeight;
              vTextWithMaxHeigth := vText;
            end;
          end;
        csHiWord:
          begin
            if vModeLine < 2 then vModeLine := 2;
            vFractionHeight := GetFractionHeigth(vText, vText);
            if vMaxHeigthFraction < vFractionHeight then
              vMaxHeigthFraction := vFractionHeight;
          end;
        csLowWord, csDenominator:
          begin
            vTextLow := vText;
            if vModeLine < 3 then vModeLine := 3;
            vFractionHeight := GetFractionHeigth(vText, vText);
            if vMaxHeigthFraction < vFractionHeight then
              vMaxHeigthFraction := vFractionHeight;
          end;
        csFraction, csIndexes:
          begin
            if vModeLine < 4 then vModeLine := 4;
            Inc(vLastIndex);
            if vText.FTextParse^.TextPos = csFraction then
              Include(vText.Properties.FFontStyle, fmUnderline);
            vFractionHeight := GetFractionHeigth(vText, TsgDXFText(FDest.Entities[vLastIndex]));
            if vMaxHeigthFraction < vFractionHeight then
              vMaxHeigthFraction := vFractionHeight;
          end;
        csDivHi, csDivLow:
          begin
            if vModeLine < 5 then vModeLine := 5;
            vFractionHeight := GetDivisionHeigth(vText);
            if vMaxHeigthFraction < vFractionHeight then
              vMaxHeigthFraction := vFractionHeight;
          end;
        csDivision, csDivend:
          begin
            if vModeLine < 6 then vModeLine := 6;
            vFractionHeight := vText.FTextParse^.FontParams.Above;
            if vMaxHeigthFraction < vFractionHeight then
              vMaxHeigthFraction := vFractionHeight;
          end;
      end;
      Inc(vLastIndex);
    end;
    if (vFirstIndex > -1) and  (vFirstIndex < vDestCount) then
      TsgDXFText(FDest.Entities[vFirstIndex]).FTextParse^.ParagraphParams.IsFirstText := True;
  end;

  procedure Leveling;
  var
    I: Integer;
    vFraction: TsgDXFText;
    vIsHeigthByFraction: Boolean;
    vTextByNextPos: TsgDXFText;
    vHeigthByNextPos, vTestHeigthByNextPos: Double;


    procedure MakePosX;
    var
      vPrevText, vPrev2Text: TsgDXFText;
    begin
      if I > vFirstIndex then
      begin
        vPrevText := TsgDXFText(FDest.Entities[I - 1]);
        if I - 1 > vFirstIndex then
        begin
          case vPrevText.FTextParse.TextPos of
            csDenominator:
              begin
                vPrev2Text := TsgDXFText(FDest.Entities[I - 2]);
                if (vPrev2Text.FTextParse^.TextPos in [csFraction, csIndexes]) and (vPrev2Text.FBox.Right > vPrevText.FBox.Right) then
                  vPrevText := vPrev2Text;
              end;
          end;
        end;
        if vText.FTextParse^.HasLine then
          vText.FPoint1.X := vPrevText.FBox.Right + vSizeByTolerance1 - vText.FTextParse^.FontParams.Left
        else
          vText.FPoint1.X := vPrevText.FBox.Right + vPrevText.FTextParse^.FontParams.DX;
      end
      else
      begin
        vPrevText := nil;
        if FCells <> nil then
          vText.FPoint1.X := vText.FPoint1.X + vSizeByTolerance2;
      end;
      if (vText.FTextParse^.TextPos = csDivend) then
        vText.FPoint1.X := vText.FPoint1.X + vText.FTextParse^.FontParams.DX;
      if (vPrevText <> nil) and (vPrevText.FTextParse^.TextPos = csDivision) then
        vText.FPoint1.X := vText.FPoint1.X + vPrevText.FTextParse^.FontParams.DX;
      if (vText.FTextParse^.TextPos = csDenominator) and (vPrevText <> nil) and (vPrevText.FTextParse^.TextPos in [csFraction, csIndexes]) then
        vText.FPoint1.X := vPrevText.FPoint1.X
      else
      begin
        if FCells = nil then
        begin
          if vText.FTextParse^.ParagraphParams.IsFirstText then
          begin
            vText.FPoint1.X := vText.FTextParse^.ParagraphParams.I * Integer(vText.FTextParse^.ParagraphParams.IsFirstLine) + vText.FTextParse^.ParagraphParams.L;
            if vText.FTextParse^.ParagraphParams.IsFirstLine and (vText.FTextParse^.ParagraphParams.I < 0) and (vText.FPoint1.X < 0) then
              vText.FPoint1.X := 0;
          end;
          if vText.FTextParse^.ParagraphParams.T > 0 then
            vText.FPoint1.X := GetTextTab(vText);
        end;
      end;
      if I = vFirstIndex then
        vText.FPoint1.X := vText.FPoint1.X - FTextParse.FontParams.Left;
    end;

    procedure MakePosYByFraction(const AText: TsgDXFText);
    begin
      AText.FVAlign := 3;
      if vIsHeigthByFraction then
        AText.FPoint1.Y := FPos.Y - (vMaxHeigthFraction - GetFractionHeigth(vText, vText)) * 0.5
      else
      begin
        AText.FPoint1.Y := FPos.Y;
        case vVAlign of
          3: AText.FPoint1.Y := AText.FPoint1.Y - (vTextWithMaxHeigth.Height - vMaxHeigthFraction);
          4: AText.FPoint1.Y := AText.FPoint1.Y - (vTextWithMaxHeigth.Height - vMaxHeigthFraction) * 0.5;
        end;
      end;
    end;

    procedure MakePosYByDivision(const AText: TsgDXFText);
    begin
      AText.FVAlign := 3;
      if vIsHeigthByFraction then
        AText.FPoint1.Y := FPos.Y - (vMaxHeigthFraction - GetDivisionHeigth(vText)) * 0.5
      else
      begin
        AText.FPoint1.Y := FPos.Y;
        case vVAlign of
          3: AText.FPoint1.Y := AText.FPoint1.Y - (vTextWithMaxHeigth.Height - vMaxHeigthFraction);
          4: AText.FPoint1.Y := AText.FPoint1.Y - (vTextWithMaxHeigth.Height - vMaxHeigthFraction) * 0.5;
        end;
      end;
    end;

  begin
    FTextParse := TsgDXFText(FDest.Entities[vFirstIndex]).FTextParse^;
    FTextParse.Level := 0;
    FPos.Y := FPos.Y - vSign * FTextParse.Offset.Y;
    vTextByNextPos := vTextWithMaxHeigth;
    vHeigthByNextPos := vMaxHeigth;
    if vModeLine = 0 then
    begin
      if vIsExactly then
        vDY := 0;
      if (vTextWithMaxHeigth = nil) and (vFirstIndex < vLastIndex) then Exit;
      for I := vFirstIndex to vLastIndex - 1 do
      begin
        vText := TsgDXFText(FDest.Entities[I]);
        vText.FPoint := cnstFPointZero;
        MakePosX;
        vText.FPoint1.Y := FPos.Y - vSign * vLineSpaceFactor * (vTextWithMaxHeigth.Height - vText.Height + vDY);
        Self.ConvertUnicode(vText);
        vText.Loaded(FConverter);
      end;
    end
    else
    begin
      if vMaxHeigthFraction < fAccuracy then
        if vTextWithMaxHeigth = nil then
          vMaxHeigthFraction := FSource.Height
        else
          vMaxHeigthFraction := vTextWithMaxHeigth.Height;
      vIsHeigthByFraction := (vTextWithMaxHeigth = nil) or (vMaxHeigthFraction >= vTextWithMaxHeigth.FTextParse^.FontParams.Above);
      I := vFirstIndex;
      while I < vLastIndex do
      begin
        vText := TsgDXFText(FDest.Entities[I]);
        vText.FPoint := cnstFPointZero;
        MakePosX;
        case vText.FTextParse^.TextPos of
          csHiWord:
            begin
              MakePosYByFraction(vText);
              vTestHeigthByNextPos := vText.FBox.Top - vText.FBox.Bottom;
            end;
          csLowWord, csDenominator:
            begin
              MakePosYByFraction(vText);
              vText.FPoint1.Y := vText.FPoint1.Y - vText.FBox.Top + vText.FBox.Bottom - vText.FTextParse^.FontParams.Below;
              if (vTextLow = vText) and (vModeLine = 3) and vIsHeigthByFraction and (vVAlign = 4) then
                TsgDXFText(FDest[I]).FPoint1.Y := TsgDXFText(FDest[I]).FPoint1.Y + (vTextLow.FTextParse^.FontParams.Above + vTextLow.FTextParse^.FontParams.Below) * 0.5;
              vTestHeigthByNextPos := vText.FBox.Top - vText.FBox.Bottom;
            end;
          csFraction, csIndexes:
            begin
              vFraction := vText;
              Inc(I);
              vText := TsgDXFText(FDest.Entities[I]);
              vText.FVAlign := 3;
              MakePosYByFraction(vFraction);
              vText.FPoint := cnstFPointZero;
              MakePosX;
              vText.FPoint1.Y := vFraction.FPoint1.Y - vFraction.FBox.Top + vFraction.FBox.Bottom - vFraction.FTextParse^.FontParams.Below;
              Self.ConvertUnicode(vText);
              vFraction.Loaded(FConverter);
              vTestHeigthByNextPos := vText.FBox.Top - vText.FBox.Bottom;
            end;
          csDivHi, csDivision:
            begin
              MakePosYByDivision(vText);
              vTestHeigthByNextPos := vText.FBox.Top - vText.FBox.Bottom;
            end;
          csDivLow, csDivend:
            begin
              MakePosYByDivision(vText);
              vText.FPoint1.Y := vText.FPoint1.Y - (vText.FBox.Top - vText.FBox.Bottom);
              vTestHeigthByNextPos := vText.FBox.Top - vText.FBox.Bottom;
            end;
        else
          vText.FPoint1.Y := FPos.Y - (vTextWithMaxHeigth.FTextParse^.FontParams.Above - vText.FTextParse^.FontParams.Above + vText.FTextParse^.FontParams.DY);
          if vIsHeigthByFraction then
          begin
            case vVAlign of
              3: vText.FPoint1.Y := vText.FPoint1.Y + (vTextWithMaxHeigth.Height - vMaxHeigthFraction);
              4:
                begin
                  vText.FPoint1.Y := vText.FPoint1.Y + (vTextWithMaxHeigth.Height - vMaxHeigthFraction) * 0.5;
                  if Assigned(vTextLow) and (vModeLine = 3) then
                    vText.FPoint1.Y := vText.FPoint1.Y + (vTextLow.FTextParse^.FontParams.Above + vTextLow.FTextParse^.FontParams.Below) * 0.5;
                end;
            end;
          end;
          vText.FVAlign := 3;
          vTestHeigthByNextPos := GetTextHeight(vText);
        end;
        vText.Loaded(FConverter);
        if (vTextByNextPos = nil) or (Abs(vTextByNextPos.FPoint1.Y - vHeigthByNextPos) < Abs(vText.FPoint1.Y - vTestHeigthByNextPos)) then
        begin
          vTextByNextPos := vText;
          vHeigthByNextPos := vTestHeigthByNextPos;
        end;
        Inc(I);
      end;
    end;
    FPos.Y := vTextByNextPos.Point1.Y - vLineSpaceFactor * vSign * (vHeigthByNextPos + FFontParams.Below);
  end;

begin
  if (FConverter <> nil) and (FConverter.HeadVarStruct.Version = Byte(acR14)) then
  begin
    vSizeByTolerance1 := FCellSize * 2;
    vSizeByTolerance2 := FCellSize;
  end
  else
  begin
    vSizeByTolerance1 := FCellSize * 0.5;
    vSizeByTolerance2 := FCellSize * 0.25;
  end;
  vSign := 1 - Integer(not FConverter.IsCrossoverMatrix) shl 1;
  vFirstIndex := 0;
  vLastIndex := 0;
  vDestCount := FDest.Count;
  FPos.Y := 0;
  vIsExactly := FSource.LineSpacingStyle = 2;
  vLineSpaceFactor := FSource.LineSpacingFactor;
  while (vLastIndex < vDestCount) and (vLastIndex <> -1) do
  begin
    FindIndexs;
    Leveling;
  end;
end;

(*procedure TsgMTextParser.DivisionString;
var
  vP, I, J{, K}, vL: Integer;
  vTabValue: Double;
  vText: TsgDXFTExt;
  vTextOrigin: TFPoint;
  S: string;

  procedure ReCalcOffset(AIndex: Integer);
  var
    vText: TsgDXFText;
  begin
    Inc(AIndex);
    if AIndex < FDest.Count then
    begin
      vText := TsgDXFText(FDest.Entities[AIndex]);
      ResetCaret(vText);
      vText.Loaded(FConverter);
    end;
  end;

  procedure DoLoadText(AText: TsgDXFText);
  begin
    if AText.IsSHXFont then ConvertUnicode(AText);
    AText.Loaded(FConverter);
  end;

  function SplitingText(AIndexSplit: Integer): Boolean;
  var
    vText,vTextBase: TsgDXFText;
    vPosSpace: Integer;
    vStr, vStrCpy, vTextString: string;
    vIsLastSpace: Boolean;
    vLastChar, vPrevLastChar: Char;

    function AddText: Boolean;
    var
      vLenString: Integer;
    begin
      Result := False;
      vStrCpy := vStr;
      vLenString := Length(vTextString);
      while (vPosSpace < vLenString) and (vTextString[vPosSpace] <> ' ') do
      begin
        Result := True;
        vStr := vStr + vTextString[vPosSpace];
        Inc(vPosSpace);
      end;
      if vPosSpace <= vLenString then
      begin
        Result := True;
        vStr := vStr + vTextString[vPosSpace];
      end;
      Inc(vPosSpace);
    end;

    procedure LoadFirstWord;
    var
      vIsNotSpace: Boolean;
    begin
      vStr := vTextString;
      vPosSpace := 1;
      vIsNotSpace := False;
      while vPosSpace <= Length(vStr) do
      begin
        if vStr[vPosSpace] <> ' ' then
          vIsNotSpace := True
        else
          if vIsNotSpace then
            Break;
        Inc(vPosSpace);
      end;
      Delete(vStr, vPosSpace,  Length(vStr) - vPosSpace + 1);
    end;

  begin
    Result := False;
    vIsLastSpace := True;
    if (TsgDXFText(FDest.Entities[AIndexSplit]).Point.X <> 0) and (AIndexSplit - 1 >= 0) and (AIndexSplit - 1 < FDest.Count) then
    begin
      vTextBase := TsgDXFText(FDest.Entities[AIndexSplit - 1]);
      if Length(vTextBase.Text) > 0 then
        vIsLastSpace := vTextBase.Text[Length(vTextBase.Text)] = ' '
      else
        vIsLastSpace := False;
    end;
    vTextBase := TsgDXFText(FDest.Entities[AIndexSplit]);
    if Length(vTextBase.Text) <= 1 then
      Exit;
    vTextString := vTextBase.Text;
    LoadFirstWord;
    vTextBase.Text := vStr;
    DoLoadText(vTextBase);
    if (Length(vStr) + 1 < Length(vTextString)) then
      vIsLastSpace := vTextString[Length(vStr) + 1] = ' ';

    if vIsLastSpace then
    begin
      if FDestWidth < (FLenByRow + GetBoxWidth(vTextBase)) then
      begin
        ResetCaret(vTextBase);
        vTextBase.FPoint1.Y := 0;
        FLenByRow := 0;
        DoLoadText(vTextBase);
      end;
    end;
    while FDestWidth > (FLenByRow + GetBoxWidth(vTextBase)) do
    begin
      if not AddText then
        Break;
      vTextBase.Text := vStr;
      DoLoadText(vTextBase);
    end;
    vLastChar := vStr[Length(vStr)];
    vPrevLastChar := #0;
    if Length(vStr) > 1 then
      vPrevLastChar := vStr[Length(vStr) - 1];
    if (vLastChar = ' ') or ((vLastChar = '(') and (Ord(vPrevLastChar) >= 255)) then
    begin
      SetLength(vStr, Length(vStr) - 1);
      vTextBase.Text := vStr;
      DoLoadText(vTextBase);
      if FDestWidth > (FLenByRow + GetBoxWidth(vTextBase)) then
        vStrCpy := vStr;
    end;
    if Length(vStrCpy) = 0 then
      vStrCpy := vStr;
    vTextBase.Text := vStrCpy;
    DoLoadText(vTextBase);
    vPosSpace := Length(vStrCpy);
    vStr := vTextString;
    while vStr[vPosSpace + 1] = ' ' do
      Inc(vPosSpace);
    Delete(vStr, 1, vPosSpace);
    Result := Length(vStr) > 0;
    if Result then
    begin
      vText := TsgDXFText.Create;
      vText.CreateTextParse;
      CopyTextOptions(vTextBase, vText);
      vText.FTextParse^.ParagraphParams.IsFirstText := True;
      if vText.FTextParse^.ParagraphParams.T > 0 then
        Dec(vText.FTextParse^.ParagraphParams.T);
      vText.Text := vStr;
      ResetCaret(vText);
      vText.FPoint1.Y := 0;
      FConverter.DoCreate(vText);
      FDest.AddEntity(vText);
      DoLoadText(vText);
    end
    else
      vTextBase.Text := vTextBase.Text + ' ';
  end;

begin
  I := FDest.Count - 1;
  vText := TsgDXFText(FDest.Entities[I]);
  if vText.Point.X = 0 then
  begin
    FLenByRow := 0;
    if {(I = 0) and }(vText.FTextOrigin > 0) then
    begin
      vTextOrigin := FPointXMat(MakeFPoint(vText.FTextOrigin, 0, 0), vText.FMatrix);
      FLenByRow := -vTextOrigin.X;
    end;
  end;
//  S := TsgDXFText(FDest.Entities[I]).Text;
//  K := 1;
//  if (Length(S) > 0) and (S[K] = ' ') then
//  begin
//    while (K <= Length(S)) and (S[K] <> ' ') do Inc(K);
//    if K < Length(S) then
//    begin
//      vText := TsgDXFText.Create;
//      try
//        vText.AssignEntity(FDest[I]);
//        vText.Text := Copy(S, 1, K); // text with K spaces
//        FConverter.Loads(vText);
//        FLenByRow := -(vText.Box.Right - vText.Box.Left);
//      finally
//        vText.Free;
//      end;
//    end;
//  end;
  vText := TsgDXFText(FDest.Entities[I]);
  if vText.FTextParse^.ParagraphParams.T > 0 then
  begin
    vTabValue := GetTextTab(vText);
    if FLenByRow < vTabValue then
      FLenByRow := vTabValue;
  end
  else
    if vText.FTextParse^.ParagraphParams.IsFirstLine then
      if vText.FTextParse^.ParagraphParams.L + vText.FTextParse^.ParagraphParams.I <> 0 then
        FLenByRow := vText.FTextParse^.ParagraphParams.L + vText.FTextParse^.ParagraphParams.I;
  while I < FDest.Count do
  begin
    FLenByRow := FLenByRow + GetTextWidth(FDest.Entities[I]);
    if FLenByRow > FDestWidth then
    begin
      J := I;
      FLenByRow := FLenByRow - GetTextWidth(FDest.Entities[I]);
      S := TsgDXFText(FDest.Entities[I]).Text;
      vP := AnsiPos(' ', S);
      if (vP = 0) and (I > 0) then
      begin
        J := I - 1;
        vText := TsgDXFText(FDest.Entities[J]);
        vP := AnsiPos(' ', vText.Text);
        vL := Length(vText.Text);
        if ((vL > 0) and (vText.Text[vL] = ' ')) or ((S <> '') and (Ord(S[1]) > 127)) then
           vP := Length(vText.Text);
      end;
      if vP > 0 then
      begin
        if (vP = Length(TsgDXFText(FDest.Entities[J]).Text)) then
        begin
          ReCalcOffset(J);
          FLenByRow := 0;
        end
        else
          if not SplitingText(J) then
            FLenByRow := FLenByRow + GetTextWidth(FDest.Entities[I])
          else
            FLenByRow := TsgDXFText(FDest.Entities[I]).FTextParse^.ParagraphParams.L;
      end;
    end;
    Inc(I);
  end;
end;*)
procedure TsgMTextParser.DivisionString;
var
  I, J{, K}, K: Integer;
  vTabValue: Double;
  vText, vNewText: TsgDXFTExt;
  vTextOrigin: TFPoint;
  S, vTmpStr: string;
  vWords: TsgMTextWords;
  vTextWidth, vFullTextWidth: Double;
  vTextOverflow, vStopSplit, vNeedSplit: Boolean;

  procedure DoLoadText(AText: TsgDXFText);
  begin
    if AText.IsSHXFont then ConvertUnicode(AText);
    AText.Loaded(FConverter);
  end;

  procedure ResetText(AText: TsgDXFText);
  begin
    AText.FTextParse^.ParagraphParams.IsFirstText := True;
    ResetCaret(AText);
    vNeedSplit := False;
    vStopSplit := (J+1) >= vWords.Count;
    DoLoadText(AText);
  end;

begin
  I := FDest.Count - 1;
  vText := TsgDXFText(FDest.Entities[I]);
  if vText.Point.X = 0 then
  begin
    FLenByRow := 0;
    if {(I = 0) and }(vText.FTextOrigin > 0) then
    begin
      vTextOrigin := FPointXMat(MakeFPoint(vText.FTextOrigin, 0, 0), vText.FMatrix);
      FLenByRow := -vTextOrigin.X;
    end;
  end;
//  S := TsgDXFText(FDest.Entities[I]).Text;
//  K := 1;
//  if (Length(S) > 0) and (S[K] = ' ') then
//  begin
//    while (K <= Length(S)) and (S[K] <> ' ') do Inc(K);
//    if K < Length(S) then
//    begin
//      vText := TsgDXFText.Create;
//      try
//        vText.AssignEntity(FDest[I]);
//        vText.Text := Copy(S, 1, K); // text with K spaces
//        FConverter.Loads(vText);
//        FLenByRow := -(vText.Box.Right - vText.Box.Left);
//      finally
//        vText.Free;
//      end;
//    end;
//  end;
  vText := TsgDXFText(FDest.Entities[I]);
  if vText.FTextParse^.ParagraphParams.T > 0 then
  begin
    vTabValue := GetTextTab(vText);
    if FLenByRow < vTabValue then
      FLenByRow := vTabValue;
  end
  else
    if vText.FTextParse^.ParagraphParams.IsFirstLine then
    begin
      if vText.FTextParse^.ParagraphParams.L + vText.FTextParse^.ParagraphParams.I <> 0 then
        FLenByRow := vText.FTextParse^.ParagraphParams.L + vText.FTextParse^.ParagraphParams.I;
      FPrevText := nil;
    end;
  //vNewText := vText;
  vWords := TsgMTextWords.Create;
  try
    J := 0;
    vStopSplit := False;
    vWords.Text := vText.Text;
    if vText.FTextParse^.ParagraphParams.IsFirstLine or vText.FTextParse^.ParagraphParams.IsFirstText then
      if GetSourceAlign(I) in [2, 5, 8] then
      begin
        vText.FTextParse^.SpacesBefore := 0;
        while (J < vWords.Count) and (vWords.WordID[J] = 32) do
        begin
          Inc(vText.FTextParse^.SpacesBefore);
          Inc(J);
        end;
      end;
    while not vStopSplit and (J < vWords.Count) do
    begin
      vNeedSplit := True;
      vTextOverflow := False;
      vText.Text := '';
      K := J;
      while (J < vWords.Count) and not vTextOverflow do
      begin
        vTmpStr := vWords.ExpandText(K, J);
        vText.Text := vTmpStr;
        DoLoadText(vText);
        if vText.FTextParse^.ParagraphParams.IsFirstText or vText.FTextParse^.ParagraphParams.IsFirstLine then
          vFullTextWidth := vText.Box.Right - vText.Box.Left
        else
          vFullTextWidth := GetTextWidth(vText);
        vTextOverflow := FLenByRow + vFullTextWidth > FDestWidth;

        if vTextOverflow and (vTmpStr[Length(vTmpStr)] = ' ') then
        begin
          S := TrimRight(vTmpStr);
          vText.FTextParse^.Spaces := Length(vTmpStr) - Length(S);
          if S <> '' then
          begin
            vText.Text := S;
            DoLoadText(vText);
            if vText.FTextParse^.ParagraphParams.IsFirstText or vText.FTextParse^.ParagraphParams.IsFirstLine then
              vTextWidth := vText.Box.Right - vText.Box.Left
            else
              vTextWidth := GetTextWidth(vText);
            vTextOverflow := FLenByRow + vTextWidth > FDestWidth;
          end;
        end
        else
          vText.FTextParse^.Spaces := Length(vTmpStr) - Length(TrimRight(vTmpStr));
        if not vTextOverflow then
          Inc(J);
      end;
      if vTextOverflow then
      begin
        if J - K > 0 then
        begin
          vTmpStr := vWords.ExpandText(K, J - 1);
          vText.Text := TrimRight(vTmpStr);
          vText.FTextParse^.Spaces := Length(vTmpStr) - Length(TrimRight(vText.Text));
          if (vText.Text = '') and (vText.FTextParse^.Spaces > 0) then
          begin
            vText.Text := vTmpStr;
            vText.FTextParse^.Spaces := 0;
          end;
          DoLoadText(vText);
          vFullTextWidth := GetTextWidth(vText);
          FLenByRow := FLenByRow + vFullTextWidth;
        end
        else
        begin
          if not (vText.FTextParse^.ParagraphParams.IsFirstText or vText.FTextParse^.ParagraphParams.IsFirstLine) then
          begin
            if Assigned(FPrevText) and (FPrevText.FTextParse^.Spaces = 0) then
            begin
              if IsSpace(vWords[K][1]) then
              begin
                if GetSourceAlign(I) in [2, 5, 8] then
                  Inc(J);
                ResetText(vText);
              end
              else
              begin
                vNeedSplit := False;
                vStopSplit := (J+1) >= vWords.Count;
              end;
            end
            else
            begin
              vText.Text := vWords.ExpandText(K, J);
              ResetText(vText);
            end;
            FLenByRow := vText.FTextParse^.ParagraphParams.L;
            FPrevText := nil;
          end
          else
          begin
            vNeedSplit := (J+1) < vWords.Count;
            vStopSplit := (J+1) >= vWords.Count;
            {if J = 0 then }Inc(J);
          end;
        end;
        if not vStopSplit and vNeedSplit then
        begin
          vNewText := TsgDXFText.Create;
          vNewText.CreateTextParse;
          CopyTextOptions(vText, vNewText);
          vNewText.Text := 'A';
          vNewText.FTextParse^.ParagraphParams.IsFirstText := True;
          if vNewText.FTextParse^.ParagraphParams.T > 0 then
            Dec(vNewText.FTextParse^.ParagraphParams.T);
          ResetCaret(vNewText);
          vNewText.FPoint1.Y := 0;
          FConverter.DoCreate(vNewText);
          FDest.AddEntity(vNewText);
          DoLoadText(vNewText);
          FLenByRow := vText.FTextParse^.ParagraphParams.L;
          FPrevText := nil;
          vText := vNewText;
        end;
      end
      else
      begin
        if (vText.FTextParse^.Spaces > 0) or (vText.FTextParse^.SpacesBefore > 0) then
        begin
          vText.Text := vWords.ExpandText(K, J - 1);
          if vText.FTextParse^.SpacesBefore > 0 then
            vText.Text := StringOfChar(' ', vText.FTextParse^.SpacesBefore) + vText.Text;
          DoLoadText(vText);
        end;
        FPrevText := vText;
        FLenByRow := FLenByRow + GetTextWidth(vText);
        vStopSplit := True;
      end;
    end;
  finally
    vWords.Free;
  end;
end;

procedure TsgMTextParser.DivisionStringWithHyphenation;
var
  I, vCopyLength: Integer;
  vTextBase, vTextNew: TsgDXFText;
  vTextWidth: Double;
  vText, vTextPrev: string;
begin
  if not (FDest is TsgDXFBlock) then
  begin
    DivisionString;
    Exit;
  end;
  I := FDest.Count - 1;
  SpliteTextbySpace(FDest, FDest.Count - 1);
  if TsgDXFText(FDest[I]).Point.X = 0 then
    FLenByRow := 0;
  while I < FDest.Count do
  begin
    vTextBase := TsgDXFText(FDest[I]);
    Inc(I);

    vText := vTextBase.Text;
    vCopyLength := Length(vText);
    vTextWidth := GetTextWidth(vTextBase);

    if FLenByRow + vTextWidth > FDestWidth then
    begin
      if I > 1 then
      begin
        vTextPrev := TsgDXFText(FDest[I - 2]).Text;
        if (Length(vTextPrev) > 0) and (vTextPrev[Length(vTextPrev)] = ' ') then
        begin
          vText := TrimLeft(vTextBase.Text);
          vTextBase.Text := vText;
          SetIsFirstTextAndLoad(vTextBase);
          vTextWidth := GetTextWidth(vTextBase);
        end;
      end;

      while FLenByRow + vTextWidth > FDestWidth do
      begin
        Dec(vCopyLength);
        if vCopyLength > 0 then
        begin
          vTextBase.Text := Copy(vText, 1, vCopyLength);
          vTextBase.Loaded(FConverter);
          vTextWidth := GetTextWidth(vTextBase);
        end
        else
          Break;
      end;
    end;

    if vCopyLength > 0 then
    begin
      if vCopyLength < Length(vText) then
      begin
        if vText[vCopyLength + 1] = ' ' then
          vTextBase.Text := vTextBase.Text + ' ';
        Delete(vText, 1, vCopyLength);
        vText := TrimLeft(vText);
        if Length(vText) > 0 then
        begin
          vTextNew := TsgDXFText.Create;
          if I >= FDest.Count then
            FDest.AddEntity(vTextNew)
          else
            FDest.InsertEntity(I, vTextNew);
          vTextNew.CreateTextParse;
          CopyTextOptions(vTextBase, vTextNew);
          vTextNew.Text := vText;
          SetIsFirstTextAndLoad(vTextNew);
          vTextWidth := 0;
        end;
      end;
    end
    else
    begin
      vTextBase.Text := TrimLeft(vText);
      if Length(vTextBase.Text) > 0 then
      begin
        SetIsFirstTextAndLoad(vTextBase);
        vTextWidth := GetTextWidth(vTextBase);
      end
      else
      begin
        Dec(I);
        FDest.RemoveEntity(vTextBase);
        vTextBase.Free;
        vTextWidth := 0;
      end;
    end;

    FLenByRow := FLenByRow + vTextWidth;
  end;
end;

function TsgMTextParser.MakeFraction(const AText: TsgDXFText): Integer;
var
  vPosSlash, I: Integer;
  vDenominator: TsgDXFText;
  vTwiddle: Boolean;
  vStrOrg, vDenom: string;

  procedure Smoothing;
  var
    K, L, M: Integer;
    LenN, LenD: Integer;
    SN, SD: string;
    vSpaces: string;
  begin
    SN := Trim(AText.Text);
    SD := Trim(vDenominator.Text);
    LenN := Length(SN);
    LenD := Length(SD);
    K := 1;
    L := 1;
    while (K <= LenN) and (L <= LenD) and (SN[K] = ' ') and (SD[L] = ' ') do
    begin
      Inc(K);
      Inc(L);
    end;
    if K > 1 then
    begin
      Delete(SN, 1, K - 1);
      Delete(SD, 1, L - 1);
    end;
    LenN := Length(SN);
    LenD := Length(SD);
    if (LenN > 0) and (LenD > 0) then
    begin
      M := Ord(CharInSet(SN[1], ['+', '-'])) or (Ord(CharInSet(SD[1], ['+', '-'])) shl 1);
      case M of
        0:;
        1: SD := ' ' + SD;
        2: SN := ' ' + SN;
        3:;
      end;
    end;
    if vTwiddle then
    begin
      vSpaces := ' ';
      for K := 0 to Abs(Length(SN) - Length(SD)) div 2 - 1 do vSpaces := vSpaces + ' ';
      if Length(SD) < Length(SN) then
        SD := vSpaces + SD + vSpaces
      else
        if Length(SD) > Length(SN) then
          SN := vSpaces + SN + vSpaces;
    end;
    AText.Text := SN;
    vDenominator.Text := SD;
  end;

begin
  vDenominator := nil;
  Result := 0;
  vTwiddle := False;
  vPosSlash := AnsiPos('/', AText.Text);
  if vPosSlash = 0 then
  begin
    vPosSlash := AnsiPos('^', AText.Text);
    if vPosSlash > 0 then
      Result := 2
    else
    begin
      vPosSlash := AnsiPos('#', AText.Text);
      if vPosSlash > 0 then
        Result := 3
      else
      begin
        vPosSlash := AnsiPos('~.', AText.Text);
        if vPosSlash > 0 then
        begin
          vTwiddle := True;
          Inc(vPosSlash);
          Result := 2;
        end
      end;
    end;
  end
  else
    Result := 1;
  if Result > 0 then
  begin
    vStrOrg := AText.Text;
    if ((Result = 1) and (vPosSlash > 1)) or (Result > 1) then
    begin
      AText.Text := Copy(vStrOrg, 1, vPosSlash - (1 + Ord(vTwiddle)));
      if Result = 3 then
        AText.FTextParse^.TextPos := csDivision
      else
        AText.FTextParse^.TextPos := csHiWord;
      ConvertUnicode(AText);
      AText.Loaded(FConverter);
      Delete(vStrOrg, 1, vPosSlash);
      vPosSlash := 0;
      for I := 1 to Length(vStrOrg) do
      begin
        if vStrOrg[I] <> ' ' then
        begin
          vPosSlash := I;
          Break;
        end;
      end;
    end
    else
    begin
      vPosSlash := 0;
      AText.FTextParse^.TextPos := csLowWord;
      I := 1;
      if I <= Length(AText.Text) then
      begin
        AText.FUnicodeText := '';
        while (I <= Length(AText.Text)) and CharInSet(AText.Text[I], [' ', '/', '^', '#']) do
          Delete(AText.FText, 1, 1);
        ConvertUnicode(AText);
      end;
    end;
    if IsTextEmpty(AText) then
    begin
      TsgDXFGroup(FDest).RemoveEntity(AText);
      AText.Free;
      Exit;
    end;
    if vPosSlash > 0 then
    begin
      vDenom := Copy(vStrOrg, vPosSlash, Length(vStrOrg) - vPosSlash + 1);
      if Length(Trim(AText.FText)) > 0 then
      begin
        vDenominator := TsgDXFText.Create;
        vDenominator.CreateTextParse;
        CopyTextOptions(AText, vDenominator);
        vDenominator.Point := AText.Point;
        vDenominator.Point1 := AText.Point1;
        vDenominator.Text := vDenom;
        FConverter.DoCreate(vDenominator);
        FDest.AddEntity(vDenominator);
        case Result of
          2:
            begin
              AText.FTextParse^.TextPos := csIndexes;
              vDenominator.FTextParse^.TextPos := csDenominator;
            end;
          3:
            begin
              AText.FTextParse^.TextPos := csDivHi;
              vDenominator.FTextParse^.TextPos := csDivLow;
              vDenominator.Point := MakeFpoint(AText.Box.Right, vDenominator.Point.Y, vDenominator.Point.Z);
              ConvertUnicode(vDenominator);
              vDenominator.Loaded(FConverter);
            end;
        else
          AText.FTextParse^.TextPos := csFraction;
          vDenominator.FTextParse^.TextPos := csDenominator;
        end;
      end
      else
      begin
        if Result = 3 then
          AText.FTextParse^.TextPos := csDivend
        else
          AText.FTextParse^.TextPos := csDenominator;
        AText.Text := vDenom;
        ConvertUnicode(AText);
        AText.Loaded(FConverter);
        FPos.X := AText.Box.Right;
      end;
    end;
    case AText.FTextParse^.TextPos of
      csFraction, csIndexes:
        begin
          Smoothing;
          ConvertUnicode(vDenominator);
          vDenominator.Loaded(FConverter);
          AText.FUnicodeText := '';
          ConvertUnicode(AText);
          AText.Loaded(FConverter);
          FPos.X := Max(AText.Box.Right, vDenominator.Box.Right);
        end;
      csDivLow, csDivHi, csDivision, csDivend:
        begin
          if vDenominator = nil then
            FPos.X := AText.Box.Right + AText.FTextParse^.FontParams.DX
          else
            FPos.X := Max(AText.Box.Right, vDenominator.Box.Right);
        end;
    end;
  end
  else
  begin
    AText.FTextParse^.TextPos := csNone;
    FPos.X := AText.Box.Right;
  end;
end;

procedure TsgMTextParser.SeekChars(const AChars: TSysCharSet);
begin
  while (FIndex <= FLength) and not CharInSet(FString[FIndex], AChars) do
    Inc(FIndex);
end;

procedure TsgMTextParser.ReadParams(var AText: TsgDXFText);
const
  cnstCharLimits = [cnstCommaPoint, cnstComma, cnstVertSlash, cnstLeftBracket, cnstRigthBracket, cnstBackSlash];
  cnstHeigth = 0.083330266656;

  tknOpMultiply = TToken({$IFDEF SG_DWORD_TOKEN}$0078{$ELSE}$78{$ENDIF});

  tknAlignLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0061005C{$ELSE}$615C{$ENDIF});
  tknAlignUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0041005C{$ELSE}$415C{$ENDIF});

  tknTTFace = TToken2({$IFDEF SG_DWORD_TOKEN}$0066005C{$ELSE}$665C{$ENDIF});
  tknSHXFace = TToken2({$IFDEF SG_DWORD_TOKEN}$0046005C{$ELSE}$465C{$ENDIF});

  tknBoldLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0062007C{$ELSE}$627C{$ENDIF});
  tknBoldUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0042007C{$ELSE}$427C{$ENDIF});

  tknItalicLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0069007C{$ELSE}$697C{$ENDIF});
  tknItalicUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0049007C{$ELSE}$497C{$ENDIF});

  tknUnderlineLower = TToken2({$IFDEF SG_DWORD_TOKEN}$006C005C{$ELSE}$6C5C{$ENDIF});
  tknUnderlineUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$004C005C{$ELSE}$4C5C{$ENDIF});

  tknStrikeKLower = TToken2({$IFDEF SG_DWORD_TOKEN}$006B005C{$ELSE}$6B5C{$ENDIF});
  tknStrikeKUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$004B005C{$ELSE}$4B5C{$ENDIF});
  tknStrikeOLower = TToken2({$IFDEF SG_DWORD_TOKEN}$006F005C{$ELSE}$6F5C{$ENDIF});
  tknStrikeOUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$004F005C{$ELSE}$4F5C{$ENDIF});

  tknNewLine = TToken2({$IFDEF SG_DWORD_TOKEN}$0050005C{$ELSE}$505C{$ENDIF});
  tknPara = TToken2({$IFDEF SG_DWORD_TOKEN}$0070005C{$ELSE}$705C{$ENDIF});

  tknCharset = TToken2({$IFDEF SG_DWORD_TOKEN}$0063007C{$ELSE}$637C{$ENDIF});
  tknPitch = TToken2({$IFDEF SG_DWORD_TOKEN}$0070007C{$ELSE}$707C{$ENDIF});
  tknColorRGB = TToken2({$IFDEF SG_DWORD_TOKEN}$0063005C{$ELSE}$635C{$ENDIF});
  tknColorIndex = TToken2({$IFDEF SG_DWORD_TOKEN}$0043005C{$ELSE}$435C{$ENDIF});

  tknTwiddle = TToken2({$IFDEF SG_DWORD_TOKEN}$007E005C{$ELSE}$7E5C{$ENDIF});

  tknHeightLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0068005C{$ELSE}$685C{$ENDIF});
  tknHeightUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0048005C{$ELSE}$485C{$ENDIF});

  tknWidthLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0077005C{$ELSE}$775C{$ENDIF});
  tknWidthUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0057005C{$ELSE}$575C{$ENDIF});

  tknMCodeLower = TToken2({$IFDEF SG_DWORD_TOKEN}$006D005C{$ELSE}$6D5C{$ENDIF});
  tknMCodeUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$004D005C{$ELSE}$4D5C{$ENDIF});

  tknNewColLower = TToken2({$IFDEF SG_DWORD_TOKEN}$006E005C{$ELSE}$6E5C{$ENDIF});
  tknNewColUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$004E005C{$ELSE}$4E5C{$ENDIF});

  tknObliquingLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0071005C{$ELSE}$715C{$ENDIF});
  tknObliquingUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0051005C{$ELSE}$515C{$ENDIF});

  tknStackLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0073005C{$ELSE}$735C{$ENDIF});
  tknStackUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0053005C{$ELSE}$535C{$ENDIF});

  tknTrakingLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0074005C{$ELSE}$745C{$ENDIF});
  tknTrakingUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0054005C{$ELSE}$545C{$ENDIF});

  tknUnicodeLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0075005C{$ELSE}$755C{$ENDIF});
  tknUnicodeUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0055005C{$ELSE}$555C{$ENDIF});

  tknLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0024005C{$ELSE}$245C{$ENDIF});

  tknDblBackSlash = TToken2({$IFDEF SG_DWORD_TOKEN}$005C005C{$ELSE}$5C5C{$ENDIF});
  tknVertBackSlash = TToken2({$IFDEF SG_DWORD_TOKEN}$007C005C{$ELSE}$7C5C{$ENDIF});
  tknLeftBraketBackSlash = TToken2({$IFDEF SG_DWORD_TOKEN}$007B005C{$ELSE}$7B5C{$ENDIF});
  tknRightBraketBackSlash = TToken2({$IFDEF SG_DWORD_TOKEN}$007D005C{$ELSE}$7D5C{$ENDIF});

  tknTabLower = TToken2({$IFDEF SG_DWORD_TOKEN}$0069005E{$ELSE}$695E{$ENDIF});
  tknTabUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$0049005E{$ELSE}$495E{$ENDIF});
  tknCaretLower = TToken2({$IFDEF SG_DWORD_TOKEN}$006A005E{$ELSE}$6A5E{$ENDIF});
  tknCaretUpper = TToken2({$IFDEF SG_DWORD_TOKEN}$004A005E{$ELSE}$4A5E{$ENDIF});

  tknFractionEmpty = TToken2({$IFDEF SG_DWORD_TOKEN}$002E007E{$ELSE}$2E7E{$ENDIF});

var
  vSetupLastOptions, vDone, vIsChangeLevel, vReadTextOption: Boolean;
  vIndexTextModel: Integer;

  procedure TextAddChar(AText: TsgDXFText);
  begin
    AText.FText := AText.FText + FString[FIndex];
    AText.FTextParse^.Level := 0;
    vReadTextOption := False;
  end;

  function GetParagraphValue(AMultiplyOp: Boolean; const AStrValue: string): Double; overload;
  begin
    if AMultiplyOp then
      Result := FSource.Height * ConvToFloatDef(AStrValue, 0)
    else
      Result := 12 * cnstHeigth * ConvToFloatDef(AStrValue, 0);
  end;

  function GetParagraphValue(AOpToken: TToken; const AStrValue: string): Double; overload;
  begin
    Result := GetParagraphValue(AOpToken = Ord('x'), AStrValue);
  end;

  function PString(var S: string; const ADefault: string;
    const AChars: TSysCharSet = cnstCharLimits): PToken;
  begin
    Inc(FIndex, 2);
    Result := PTken[FIndex];
    SeekChars(AChars);
    S := GetString(Result);
    if S = '' then S := ADefault;
    Dec(FIndex, Ord(Token <> Ord(cnstCommaPoint)));
  end;

  function PFloat(var AValue: Double; ADefault: Double): Integer;
  var
    P: PToken;
  begin
    Inc(FIndex, 2);
    P := PTken[FIndex];
    while (FIndex <= FLength) and (Token in [Ord('0') .. Ord('9'), Ord('-'), Ord('.')]) do Inc(FIndex);
    Val(GetString(P), AValue, Result);
    if Result <> 0 then AValue := ADefault;
    Dec(FIndex, Ord(Token <> Ord(cnstCommaPoint)));
  end;

  function PInt(var AValue: Integer; ADefault: Integer): PToken;
  var
    Err: Integer;
  begin
    Inc(FIndex, 2);
    Result := PTken[FIndex];
    while (FIndex <= FLength) and (Token in [Ord('0') .. Ord('9')]) do Inc(FIndex);
    Val(GetString(Result), AValue, Err);
    if Err <> 0 then AValue := ADefault;
    Dec(FIndex, Ord(Token <> Ord(cnstCommaPoint)));
  end;

  function PAlign: Integer;
  begin
    PInt(Result, 0);
    case Result of
      1:  AText.FVAlign := 4;
      2:  AText.FVAlign := 5;
    else
      AText.FVAlign := 3;
    end;
  end;

  procedure PEnter;
  var
    vText: TsgDXFText;
  begin
    while (FIndex <= FLength) and (Token2 = tknNewLine) do
    begin
      vText := TsgDXFText.Create;
      FListCarry.Add(vText);
      vText.AssignEntity(AText);
      vText.InsideMText := True;
      vText.CreateTextParse;
      vText.FTextParse^ := AText.FTextParse^;
      vText.FTextParse^.Level := 0;
      Inc(FIndex, 2);
    end;
    Dec(FIndex);
  end;

  procedure PFont;
  var
    vFontName, vExt: string;
    vFonts: TStringList;
    vIsSHX: Boolean;
    W: WideChar;
    Err, CvtErrCnt: Integer;
    vEndOfFontNames, vEndOfFontName: Boolean;
    vToken2: TToken2;

    function DoGetFontName(AFontName: string; AIsSHX: Boolean): string;
    begin
      if AFontName = '' then
        if AIsSHX then
          AFontName := sDefaultSHXFont
        else
          AFontName := cnstDefaultTTFFont;
      if AIsSHX then
        Result := ChangeFileExt(AFontName, '.shx')
      else
        Result := AFontName;
    end;

  begin
    vIsSHX := Token2 = tknSHXFace;
    Inc(FIndex, 2);
    vFonts := TStringList.Create;
    try
      CvtErrCnt := 0;
      vFontName := '';
      vEndOfFontNames := False;
      while (FIndex <= FLength) and not vEndOfFontNames and (Token <> Ord(cnstVertLine)) do
      begin
        Err := 0;
        vToken2 := Token2;
        case vToken2 of
          tknUnicodeLower, tknUnicodeUpper, tknMCodeLower, tknMCodeUpper:
            begin
              Inc(FIndex, 2);
              if Token = Ord('+') then
              begin
                Inc(FIndex, 1 + Ord((vToken2 = tknMCodeLower) or (vToken2 = tknMCodeUpper)));
                Val(HexDisplayPrefix + Copy(FString, FIndex, 4), Word(W), Err);
                Inc(FIndex, 3);
              end
              else
                W := WideChar(Char(Token));
            end;
        else
          W := WideChar(Char(Token));
        end;
        if Err <> 0 then
        begin
          Inc(CvtErrCnt);
          W := '?';
        end;
        vEndOfFontName := Char(W) = cnstComma;
        if not vEndOfFontName then
          vFontName := vFontName + Char(W);
        Inc(FIndex);
        vEndOfFontNames := (FIndex <= FLength) and
          (Token in [Ord(cnstCommaPoint), Ord(cnstLeftBracket), Ord(cnstRigthBracket), Ord(cnstVertSlash)]);
        if vEndOfFontName or vEndOfFontNames then
        begin
          if CvtErrCnt > 0 then
            vFonts.Add(DoGetFontName('', vIsSHX))
          else
            vFonts.Add(DoGetFontName(vFontName, vIsSHX));
          vFontName := '';
          CvtErrCnt := 0;
        end;
      end;
      if vFonts.Count > 0 then
      begin
        AText.WinFont := not vIsSHX;
        AText.Properties.FFontName := ChangeFileExt(vFonts[0], '');
        vExt := ExtractFileExt(vFonts[0]);
        if vExt <> '' then
        begin
          if AnsiCompareText(vExt, cnstSHXFontExt) = 0  then
            AText.WinFont := False;
          AText.Properties.PrimaryFont := vFonts[0];
        end;
        if vFonts.Count > 1 then
          AText.Properties.BigFont := vFonts[1];
      end;
      AText.Properties.FontStyle := AText.Properties.FontStyle - [fmBold, fmItalic];
    finally
      vFonts.Free;
    end;
    Dec(FIndex, Ord(Token <> Ord(cnstCommaPoint)));
  end;

  function PFontBold: Integer;
  begin
    PInt(Result, Ord(fmBold in AText.Properties.FontStyle));
    if Result = 1 then
      Include(AText.Properties.FFontStyle, fmBold)
    else
      Exclude(AText.Properties.FFontStyle, fmBold);
  end;

  function PFontPitch: Integer;
  begin
    PInt(Result, DEFAULT_PITCH);
    AText.FPitch := Result;
  end;

  function PFontCharset: Integer;
  begin
    PInt(Result, DEFAULT_CHARSET);
    AText.FCharset := Result;
  end;

  function PFontRGBColor: Integer;
  begin
    PInt(Result, clByLayer);
    AText.ColorCAD := MakeColorCAD(acRGBColor, Cardinal(Result));
  end;

  function PFontIndexColor: Integer;
  begin
    PInt(Result, clByLayer);
    AText.ColorCAD := MakeColorCAD(acIndexColor, Cardinal(Result));
  end;

  function PFontItalic: Integer;
  begin
    PInt(Result, Ord(fmItalic in AText.Properties.FontStyle));
    if Result = 1 then
      Include(AText.Properties.FFontStyle, fmItalic)
    else
      Exclude(AText.Properties.FFontStyle, fmItalic)
  end;

  procedure PFractionToken;
  var
    A, B: string;
    PA, PB: PToken;
    vFindFractionToken: Boolean;
    OpToken2: TToken2;
    OpToken: TToken;
  begin
    Inc(FIndex, 2);
    PA := PTken[FIndex];
    OpToken := 0;
    OpToken2 := 0;
    if FIndex <= FLength then
    begin
      repeat
        OpToken := Token;
        OpToken2 := Token2;
        vFindFractionToken := (OpToken in [Ord(cnstCaret), Ord('#'), Ord(cnstForwardSlash), Ord(cnstCommaPoint)]) or
          (OpToken2 = tknFractionEmpty);
        Inc(FIndex, Ord(not vFindFractionToken));
      until (FIndex > FLength) or vFindFractionToken;
    end;
    if OpToken2 = tknFractionEmpty then
    begin
      OpToken := Ord(cnstCaret);
      A := GetString(PA);
      Inc(FIndex, 2);
    end
    else
    begin
      A := GetString(PA);
      Inc(FIndex, Ord(OpToken in [Ord(cnstCaret), Ord('#'), Ord(cnstForwardSlash)]));
    end;
    PB := PTken[FIndex];
    while (FIndex <= FLength) and not (Token in [Ord(cnstCommaPoint), Ord(cnstBackSlash), Ord(cnstLeftBracket), Ord(cnstRigthBracket)]) do Inc(FIndex);
    B := GetString(PB);
    AText.FTextParse.Level := 0;
    if Char(OpToken) = cnstCommaPoint then
    begin
      if A <> '' then
        AText.FText := A + '^';
    end
    else
      if OpToken2 = tknFractionEmpty then
        AText.FText := A + '~.' + B
      else
        AText.FText := A + Char(OpToken) + B;
    if A = '' then
    begin
      AText.FText := '/' + AText.FText;
      AText.FTextParse^.TextPos := csLowWord;
    end
    else
      AText.FTextParse^.TextPos := csFraction;
    if not vIsChangeLevel then
    begin
      vIsChangeLevel := True;
      FLevels.Add(FDest.Count);
      FNeedSetupOptions := True;
    end;
    Dec(FIndex, Ord(Token <> Ord(cnstCommaPoint)));
  end;

  function PHeight: Double;
  var
    S: string;
    Operation: TToken;
    Err: Integer;
  begin
    Result := AText.Height;
    PString(S, '');
    if Length(S) > 0 then
    begin
      Operation := Ord(S[Length(S)]) or $20;
      if Operation = tknOpMultiply then
        Delete(S, Length(S), 1);
      Val(S, Result, Err);
      if Err > 0 then
      begin
        AText.FText := AText.FText + Copy(S, Err, MaxInt);
        Delete(S, Err, MaxInt);
        Val(S, Result, Err);
      end;
      if (Err = 0) and (Result <> 0) then
      begin
        if Operation = tknOpMultiply then
          Result := AText.Height * Result;
        Result := Result - AText.Height;
        case AText.VAlign of
          3: AText.FPoint.Y := AText.FPoint.Y + Result;
          4: AText.FPoint.Y := AText.FPoint.Y + Result / 2;
        end;
        AText.Height := AText.Height + Result;
      end;
    end;
  end;

  procedure PLower;
  begin
    Inc(FIndex, 2);
    if FLevels.Count > 0 then
    begin
      vIndexTextModel := FLevels.Last;
      AText.Height := TsgDXFText(FDest.Entities[vIndexTextModel]).Height;
      AText.Properties.FontName := TsgDXFText(FDest.Entities[vIndexTextModel]).Properties.FontName;
      AText.Properties.FontStyle := TsgDXFText(FDest.Entities[vIndexTextModel]).Properties.FontStyle;
      AText.FCharset := TsgDXFText(FDest.Entities[vIndexTextModel]).Charset;
      AText.FPoint.X := TsgDXFText(FDest.Entities[vIndexTextModel]).FPoint.X;
      AText.FPoint.Y := AText.FPoint.Y - AText.Height;
    end;
    Dec(FIndex, Ord(Token <> Ord(cnstCommaPoint)));
  end;

  function DoAddUni(AWideChar: WideChar): Integer;
  begin
    Result := Length(AText.FUnicodeText) + 1;
    SetLength(AText.FUnicodeText, Result);
    AText.FUnicodeText[Result] := AWideChar;
    AText.FText := string(AText.FUnicodeText);
    AText.FTextParse^.Level := 0;
    vReadTextOption := False;
  end;

  function PMCodeToken: Boolean;
  var
    vCP: Cardinal;
    vMBytes: array[0 .. 1] of Word;
    W: WideChar;
    Err: Integer;
//    HasDiametr: Boolean;
  begin
    FNeedSetupOptions := True;
//    HasDiametr := False;
    while (FIndex <= FLength) and ((Token2 = tknMCodeLower) or (Token2 = tknMCodeUpper)) {and not HasDiametr} do
    begin
      Inc(FIndex, 2);
      if Token = Ord('+') then
      begin
        Inc(FIndex);
        if FIndex + 4 <= FLength then
        begin
          Val(HexDisplayPrefix + Copy(FString, FIndex, 5), Integer(vMBytes), Err);
          if Err = 0 then
          begin
            vCP := GetCodePageByIndex(vMBytes[1]);
            if vCP = CP_ACP then vCP := FConverter.HeadVarStruct.CodePage;//??
            vMBytes[0] := Swap(vMBytes[0]);
            UnicodeFromLocaleChars(vCP, 0, PAnsiChar(@vMBytes[0]), 2, @W, 1);
          end
          else
            W := cnstUndefinedSymbol;
          Inc(FIndex, 5);
//          if FConverter.CheckUnicode then
//            HasDiametr := (W = wcDiametr) or (W = wcDiameterUni);
//          if not HasDiametr then
            DoAddUni(W);
        end;
      end;
    end;
    Result := True;
    Dec(FIndex);
  end;

  function PTraking: Double;
  begin
    PFloat(Result, 1);
    AText.Tracking := Result;
  end;

  procedure PParapraphToken;
  const
    ParaTknsStop = [Ord(cnstCommaPoint), Ord(cnstBackSlash), Ord(cnstLeftBracket), Ord(cnstRigthBracket), Ord(cnstVertSlash)];
    ParaChrsStop = [cnstCommaPoint, cnstBackSlash, cnstLeftBracket, cnstRigthBracket, cnstVertSlash];
  var
    vOpToken: TToken;
    vP: PsgParagraphParams;
    vT: PToken;
    vIsSetparams: Boolean;
    vHAlign: Byte;

    function DoReadValue: string;
    var
      vT: PToken;
    begin
      Inc(FIndex);
      vT := PTken[FIndex];
      SeekChars(ParaChrsStop + [cnstComma]);
      Result := GetString(vT);
    end;

  begin
    vP := @AText.FTextParse^.ParagraphParams;
    vIsSetparams := False;
    Inc(FIndex, 2);
    vOpToken := Token;
    Inc(FIndex, Ord(vOpToken = Ord('x')));
    while (FIndex <= FLength) and not (Token in ParaTknsStop) do
    begin
      case Token or $20 of
        Ord(cnstComma): Inc(FIndex);
        Ord('i'): vP^.I := GetParagraphValue(vOpToken, DoReadValue);
        Ord('l'): vP^.L := GetParagraphValue(vOpToken, DoReadValue);
        Ord('t'):
          begin
            while (FIndex <= FLength) and not (Token in ParaTknsStop) do
            begin
              Inc(FIndex);
              vT := PTken[FIndex];
              if (vP^.TabsCount > 0) and (not vIsSetparams) then
              begin
                FillChar(vP^.Tabs, SizeOf(vP^.Tabs), 0);
                vP^.TabsCount := 0;
              end;
              vIsSetparams := True;
              if vP^.TabsCount <= High(vP^.Tabs) - Low(vP^.Tabs) then
              begin
                case Token of
                  Ord('D'):
                    begin
                      Inc(FIndex);
                      vP^.DecimalSymStyle := Char(Token);
                      vP^.Tabs[vP^.TabsCount] := GetParagraphValue(vOpToken, DoReadValue);
                      Inc(vP^.TabsCount);
                    end;
                  Ord('z'):
                    begin
                      FillChar(vP^.Tabs, SizeOf(vP^.Tabs), 0);
                      vP^.TabsCount := 0;
                      Inc(FIndex);
                    end;
                else
                  SeekChars(ParaChrsStop + [cnstComma]);
                  vP^.Tabs[vP^.TabsCount] := GetParagraphValue(vOpToken, GetString(vT));
                  Inc(vP^.TabsCount);
                end;
              end
              else
                SeekChars(ParaChrsStop + [cnstComma]);
            end;
          end;
        Ord('r'): FDestWidth := FSourceRectWidth - GetParagraphValue(vOpToken, DoReadValue);
        Ord('q'):
          begin
            Inc(FIndex);
            vHAlign := 255;
            case Token of
              Ord('l'): vHAlign := 0;
              Ord('c'): vHAlign := 1;
              Ord('r'): vHAlign := 2;
              Ord('j'): vHAlign := 5;
              Ord('d'): vHAlign := 3;
              Ord(cnstAsterisk):
                begin
                  vP^.PXQAlign := FSourceAlign;
                  FHorzAlignDropped := True;
                end;
            end;
            if vHAlign in [0 .. 2] then
              vP^.PXQAlign := ((vP^.PXQAlign - 1) div 3) * 3 + vHAlign + 1;
            SeekChars(ParaChrsStop + [cnstComma]);
          end;
        Ord('s'):
          begin
            Inc(FIndex);
            if Token = Ord('m') then
            begin
              vP^.LineSpacingStyle := 2;
              Inc(FIndex);
            end;
            if Token = Ord(cnstAsterisk) then
              vP^.LineSpacingFactor := FSource.LineSpacingFactor
            else
            begin
              vT := PTken[FIndex];
              SeekChars(ParaChrsStop + [cnstComma]);
              vP^.LineSpacingFactor := GetParagraphValue(vOpToken, GetString(vT));
            end;
          end;
        Ord('a'): vP^.AfterSpacingFactor := GetParagraphValue(vOpToken, DoReadValue);
        Ord('b'): vP^.BeforeSpacingFactor := GetParagraphValue(vOpToken, DoReadValue);
      else
        Inc(FIndex);
        SeekChars(ParaChrsStop + [cnstComma]);
      end;
    end;
    Dec(FIndex, Ord(Token <> Ord(cnstCommaPoint)));
  end;

  function PUnicodeToken: Boolean;
  var
    P: PToken;
    S: string;
    W: WideChar;
    Err: Integer;
    vAdded: Boolean;
  begin
    vAdded := False;
    FNeedSetupOptions := True;
    while (FIndex <= FLength) and ((Token2 = tknUnicodeLower) or (Token2 = tknUnicodeUpper)) do
    begin
      Inc(FIndex, 2);
      if Token = Ord('+') then
      begin
        Inc(FIndex);
        P := PTken[FIndex];
        if FIndex + 3 <= FLength then
        begin
          Inc(FIndex, 4);
          S := GetString(P);
          Val(HexDisplayPrefix + S, Word(W), Err);
          if vReadTextOption then
          begin
            vAdded := True;
            vReadTextOption := False;
            FLevels.Add(FDest.Count);
          end;
          if Err = 0 then
            DoAddUni(W)
          else
            DoAddUni('?');
        end;
      end;
    end;
    Result := True;
    if not vAdded then
    begin
      vIsChangeLevel := True;
      FLevels.Add(FDest.Count);
    end;
    Dec(FIndex);
  end;

  function PWeigth: Double;
  var
    S: string;
    Err: Integer;
    Operation: TToken;
  begin
    Result := AText.Scale;
    PString(S, '');
    if Length(S) > 0 then
    begin
      Operation := Ord(S[Length(S)]) or $20;
      if Operation = tknOpMultiply then
        Delete(S, Length(S), 1);
      Val(S, Result, Err);
      if Err = 0 then
      begin
        if Operation = tknOpMultiply then
          Result := AText.Scale * Result;
        AText.Scale := Result;
      end;
    end;
  end;

  function PReadTwiddle: Integer;
  begin
    Result := 0;
    while Token2 = tknTwiddle do begin Inc(Result); Inc(FIndex, 2); end;
    AText.FText := AText.FText + StringOfChar(Char(#$A0), Result);
    Dec(FIndex);
  end;

  function PReadObliqueAngle: Double;
  begin
    PFloat(Result, AText.ObliqueAngle);
    if not ((Result >= -85) and (Result <= 85)) then//See AutoCAD MText editor
      Result := Result - Int(Result / 360) * 360;
    AText.ObliqueAngle := Result;
  end;

  procedure PReadUnknowData;
  begin
    SeekChars([cnstCommaPoint, cnstBackSlash]);
  end;

  procedure PNewCol;
  begin
    Inc(FIndex, 1);
  end;

  function PTestToke2IsParam: Boolean;
  begin
    Result := False;
    case Token2 of
      tknTwiddle,
      tknAlignLower, tknAlignUpper,
      tknBoldLower, tknBoldUpper,
      tknItalicLower, tknItalicUpper,
      tknUnderlineUpper,
      tknUnderlineLower,
      tknStrikeKUpper, tknStrikeOUpper,
      tknStrikeKLower, tknStrikeOLower,
      tknCharset,
      tknPitch,
      tknColorRGB,
      tknColorIndex,
      tknNewLine,
      tknHeightLower, tknHeightUpper,
      tknWidthLower, tknWidthUpper,
      tknNewColLower, tknNewColUpper,
      tknObliquingLower, tknObliquingUpper,
      tknLower,
      tknStackLower, tknStackUpper,
      tknTrakingLower, tknTrakingUpper,
      //tknUnicodeLower, tknUnicodeUpper,
      //tknMCodeLower, tknMCodeUpper,
      tknPara,
      tknSHXFace, tknTTFace,
      tknDblBackSlash:
      //tknVertBackSlash,
      //tknLeftBraketBackSlash,
      //tknRightBraketBackSlash:
        Result := True;
    end;
  end;

  procedure PMakeTextOption;
  begin
    vReadTextOption := True;
    case Token2 of
      tknTwiddle: PReadTwiddle;
      tknAlignLower, tknAlignUpper: PAlign;
      tknBoldLower, tknBoldUpper: PFontBold;
      tknItalicLower, tknItalicUpper: PFontItalic;
      tknUnderlineUpper: begin Inc(FIndex, 1); Include(AText.Properties.FFontStyle, fmUnderline); end;
      tknUnderlineLower: begin Inc(FIndex, 1); Exclude(AText.Properties.FFontStyle, fmUnderline); end;
      tknStrikeKUpper, tknStrikeOUpper: begin Inc(FIndex, 1); Include(AText.Properties.FFontStyle, fmStrikeOut); end;
      tknStrikeKLower, tknStrikeOLower: begin Inc(FIndex, 1); Exclude(AText.Properties.FFontStyle, fmStrikeOut); end;
      tknCharset: PFontCharset;
      tknPitch: PFontPitch;
      tknColorRGB: PFontRGBColor;
      tknColorIndex: PFontIndexColor;
      tknNewLine: PEnter;
      tknHeightLower, tknHeightUpper: PHeight;
      tknWidthLower, tknWidthUpper: PWeigth;
      tknNewColLower, tknNewColUpper: PNewCol;
      tknObliquingLower, tknObliquingUpper: PReadObliqueAngle;
      tknLower: PLower;
      tknStackLower, tknStackUpper: PFractionToken;
      tknTrakingLower, tknTrakingUpper: PTraking;
      tknUnicodeLower, tknUnicodeUpper: {vDone := }PUnicodeToken;
      tknMCodeLower, tknMCodeUpper: vDone := PMCodeToken;
      tknPara: PParapraphToken;
      tknSHXFace, tknTTFace: PFont;
      tknDblBackSlash: begin Inc(FIndex, 1); TextAddChar(AText); end;
      tknVertBackSlash: begin Inc(FIndex, 1); TextAddChar(AText); end;
      tknLeftBraketBackSlash: begin Inc(FIndex, 1); TextAddChar(AText); end;
      tknRightBraketBackSlash: begin Inc(FIndex, 1); TextAddChar(AText); end;
    else
      Inc(FIndex);
      vReadTextOption := False;
      if FIndex > 1 then
        case FString[FIndex - 1] of
          cnstBackSlash:
            begin
              if FConverter.Version < acR2007 then
              begin
                AText.FText := AText.FText + cnstBackSlash;
                if FString[FIndex] <> cnstBackSlash then
                  Dec(FIndex)
                else
                  AText.FText := AText.FText + cnstBackSlash;//for ConvertUnicode
              end;
            end;
          cnstVertSlash: Dec(FIndex, Integer(FString[FIndex] = cnstVertSlash));
        end;
    end; { case Token2 }
  end;

  procedure SetupLastOptions;
  var
    vTextBase: TsgDXFText;
    vFontStyle: TmvFontStyle;
  begin
    vIndexTextModel := -1;
    if FLevels.Count > 0 then
      vIndexTextModel := FLevels.Last;
    if (vIndexTextModel > -1) and (not vSetupLastOptions) and (vIndexTextModel < FDest.Count) then
    begin
      vTextBase := TsgDXFText(FDest.Entities[vIndexTextModel]);
      AText.Height := vTextBase.Height;
      AText.Scale := vTextBase.Scale;//vTextBase.Style.WidthFactor;
      AText.Tracking := vTextBase.Tracking;
      AText.Layer := vTextBase.Layer;
      AText.WinFont := vTextBase.WinFont;
      AText.Height := vTextBase.Height;
      AText.FVAlign := vTextBase.FVAlign;
      AText.FHAlign := vTextBase.FHAlign;
      AText.ObliqueAngle := vTextBase.ObliqueAngle;
      AText.ColorCAD := vTextBase.ColorCAD;
      AText.Properties.FFontName := vTextBase.Properties.FFontName;
      AText.Properties.FPrimaryFont := vTextBase.Properties.FPrimaryFont;
      AText.FInternalFlags := AText.FInternalFlags + vTextBase.FInternalFlags * [itfSetFontName];
      AText.UseDefaultFontName := vTextBase.UseDefaultFontName;
      vSetupLastOptions := True;
      for vFontStyle := Low(TmvFontStyle) to High(TmvFontStyle) do
        if vFontStyle in vTextBase.Properties.FFontStyle then
          Include(AText.Properties.FFontStyle, vFontStyle)
        else
          Exclude(AText.Properties.FFontStyle, vFontStyle);
      AText.FCharset := vTextBase.Charset;
      AText.FTextParse^.ParagraphParams.PXQAlign := vTextBase.FTextParse^.ParagraphParams.PXQAlign;
    end;
  end;

  function IsLastOnlySpace: Boolean;
  var
    I, vIndexLevelText: Integer;
    vStr: string;
  begin
    Result := False;
    if FLevels.Count > 0 then
    begin
      Result := True;
      vIndexLevelText := FLevels.Last;
      if FDest.Count < vIndexLevelText then
       vIndexLevelText := FDest.Count;
      if vIndexLevelText < FDest.Count then
        vStr := TsgDXFText(FDest[vIndexLevelText]).Text;
      for I := 1 to Length(vStr) do
        if vStr[I] <> cnstSpace then
        begin
          Result := False;
          Break;
        end;
    end;
  end;

  procedure UpdateLevels;
  begin
    if not vIsChangeLevel then
    begin
      vIsChangeLevel := True;
      if not IsLastOnlySpace then
        FLevels.Add(FDest.Count)
      else
        FLevels.Last := FDest.Count;
    end;
  end;

begin
//  FCarryCount := 0;
  if AText = nil then
    AText := CreateDefaultText;
  vSetupLastOptions := False;
  vDone := False;
  vIsChangeLevel := False;
  vReadTextOption := False;
  if FLevels.Count > 0 then
  begin
    if (FLevels.Last < FDest.Count) and FNeedSetupOptions then
    begin
      SetupLastOptions;
      FNeedSetupOptions := False;
    end;
  end;
  while (FIndex <= FLength) and (AText.FTextParse^.TextPos = csNone) and not (vDone) do
  begin
    case FString[FIndex] of
      cnstBackSlash, cnstVertSlash:
        begin
          if (Length(AText.FText) = 0) or (Token2 = tknTwiddle) then
          begin
            SetupLastOptions;
            PMakeTextOption;
          end
          else
          begin
            case Token2 of
              tknUnicodeLower, tknUnicodeUpper:
                begin
                  UpdateLevels;
                  Break;
                end;
              tknMCodeLower, tknMCodeUpper: Break;
              tknLeftBraketBackSlash: begin Inc(FIndex, 1); TextAddChar(AText); end;
              tknRightBraketBackSlash: begin Inc(FIndex, 1); TextAddChar(AText); end;
            else
              if not PTestToke2IsParam then
              begin
                TextAddChar(AText);
              end
              else
                if (FIndex < FLength) and (FString[FIndex + 1] <> cnstBackSlash) then
                begin
                  UpdateLevels;
                  Break;
                end
                else
                begin
                  Inc(FIndex);
                  AText.FText := AText.FText + cnstBackSlash;
                  vReadTextOption := False;
                end;
            end;
          end;
        end;
      cnstCommaPoint:
        begin
          TextAddChar(AText);
        end;
      cnstLeftBracket:
        begin
          if Length(AText.FText) > 0 then
            Break
          else
          begin
            if FIndex > 1 then
            begin
              SetupLastOptions;
              if not vIsChangeLevel then
              begin
                vIsChangeLevel := True;
                FLevels.Add(FDest.Count);
                Inc(AText.FTextParse^.Level);
                if vReadTextOption then
                begin
                  if FDest.Count = 0 then
                  begin
                    //AText.FTextParse^.ParagraphParams.I := 0;
                    //AText.FTextParse^.ParagraphParams.L := 0;
                    //AText.FTextParse^.ParagraphParams.T := 0;
                  end;
                  FNeedSetupOptions := True;
                  Inc(FIndex);
                  Break;
                end;
              end;
            end;
          end
        end;
      cnstRigthBracket:
        begin
          Inc(FIndex);
          if FLevels.Count > 0 then
          begin
            vIndexTextModel := FLevels.Last;
            FLevels.Delete(FLevels.Count - 1);
            if (Length(AText.FText) = 0) and (FLevels.Count > 0) and (vIndexTextModel = FLevels.Last) then
              FLevels.Delete(FLevels.Count - 1);
          end;
          Break;
        end;
      cnstCaret:
        begin
          case Token2 of
            tknTabLower, tknTabUpper, tknCaretLower, tknCaretUpper:
              if Length(AText.FText) = 0 then
              begin
                case Token2 of
                  tknCaretLower, tknCaretUpper: ResetCaret(AText);
                else
                  Inc(AText.FTextParse^.ParagraphParams.T);
                end;
                Inc(FIndex);
              end
              else
              begin
                if not vIsChangeLevel then
                begin
                  vIsChangeLevel := True;
                  FLevels.Add(FDest.Count);
                end;
                FNeedSetupOptions := True;
                Break;
              end;
          else
            TextAddChar(AText);
          end;
        end;
      cnstPercent:
        begin
          if (FCells <> nil) and (FIndex + 2 <= FLength) and (FString[FIndex + 1] = '%') and
            ((FString[FIndex + 2] = 'v') or (FString[FIndex + 2] = 'V')) then
          begin
            if Length(AText.FText) = 0 then
            begin
              FHasLine := True;
              Inc(FIndex, 3);
            end;
            Break;
          end
          else
            TextAddChar(AText);
        end;
      else
        TextAddChar(AText);
    end;
    Inc(FIndex);
  end;
  if not vSetupLastOptions then
    SetupLastOptions;
end;

procedure TsgMTextParser.ResetCaret(AText: TsgDXFText);
begin
  AText.FPoint.X := 0;
  AText.FPoint1.X := 0;
end;

procedure TsgMTextParser.SetIsFirstTextAndLoad(const AText: TsgDXFText);
begin
  FLenByRow := 0;
  AText.FTextParse^.ParagraphParams.IsFirstText := True;
  ResetCaret(AText);
  AText.FPoint1.Y := 0;
  if AText.IsSHXFont then ConvertUnicode(AText);
  AText.Loaded(FConverter);
end;

procedure TsgMTextParser.SpliteTextbySpace(const AEntities: TsgDXFEntity; AStart: Integer);
var
  vTextBase, vTextNew: TsgDXFText;
  vBeginSpace, vEndSpace: Integer;
  vStr: string;
begin
  while AStart < AEntities.Count do
  begin
    vTextBase := TsgDXFText(AEntities[AStart]);
    Inc(AStart);
    vStr := vTextBase.Text;
    vBeginSpace := StringScan(' ', vStr, 1);
    if vBeginSpace > 0 then
    begin
      vEndSpace := vBeginSpace + 1;
      while (vEndSpace <= Length(vStr)) and (vStr[vEndSpace] = ' ') do
        Inc(vEndSpace);
      vTextBase.Text := Copy(vStr, 1, vEndSpace - 1);
      ConvertUnicode(vTextBase);
      vTextBase.Loaded(FConverter);
      if vEndSpace < Length(vStr) then
      begin
        vTextNew := TsgDXFText.Create;
        if AStart >= AEntities.Count then
          AEntities.AddEntity(vTextNew)
        else
          AEntities.InsertEntity(AStart, vTextNew);
        vTextNew.CreateTextParse;
        CopyTextOptions(vTextBase, vTextNew);
        vTextNew.Point := MakeFPoint(vTextBase.Box.Right, vTextBase.Point.Y, vTextBase.Point.Z);
        vTextNew.Point1 := vTextNew.FPoint;
        vTextNew.Text := Copy(vStr, vEndSpace, Length(vStr) - vEndSpace + 1);
        ConvertUnicode(vTextNew);
        vTextNew.Loaded(FConverter);
      end;
    end;
  end;
end;

function TsgMTextParser.GetTextTab(const AText: TsgDXFText): Double;
var
  vFirstTab, vTabCnt, vIndex: Integer;
  vTab, vTabSize, vTabIndex, vTabFirst: Double;
  vIsHasFirstTab, vFind: Boolean;

  function GetTab(const AIndex: Integer): Double;
  begin
    vFind := True;
    if AIndex = 0 then
    begin
      if vIsHasFirstTab then
        Result := vTabFirst
      else
        if AText.FTextParse^.ParagraphParams.TabsCount > 0 then
          Result := AText.FTextParse^.ParagraphParams.Tabs[0]
        else
          Result := vTabSize;
    end
    else
    begin
      if AIndex - Integer(vIsHasFirstTab) < AText.FTextParse^.ParagraphParams.TabsCount then
        Result := AText.FTextParse^.ParagraphParams.Tabs[AIndex - Integer(vIsHasFirstTab)]
      else
      begin
        vFind := False;
        Result := 0;
      end;
    end;
  end;

begin
  Result := AText.FTextParse^.Offset.X;
  if AText.FTextParse^.ParagraphParams.T > 0 then
  begin
    vTabSize := 4 * FSource.FHeight;
    if AText.FTextParse^.ParagraphParams.I < 0 then
      vTabFirst := Abs(AText.FTextParse^.ParagraphParams.I)
    else
      vTabFirst := Abs(AText.FTextParse^.ParagraphParams.L);
    vIsHasFirstTab := (vTabFirst > 0);
    vFirstTab := 0;
    vFind := False;
    while vFirstTab < AText.FTextParse^.ParagraphParams.TabsCount + Integer(vIsHasFirstTab) do
    begin
       vTab := GetTab(vFirstTab);
       if vFind and (vTab < AText.FPoint1.X) then
       begin
         vFind := False;
         Inc(vFirstTab);
       end
       else
         Break;
    end;
    if vFind then
      Result := GetTab(vFirstTab + AText.FTextParse^.ParagraphParams.T - 1);
    if not vFind then
    begin
      if (AText.FTextParse^.ParagraphParams.TabsCount > 0) and
        (AText.FTextParse^.ParagraphParams.Tabs[AText.FTextParse^.ParagraphParams.TabsCount - 1] > AText.FPoint1.X) then
      begin
        vIndex := AText.FTextParse^.ParagraphParams.TabsCount;
        vTabIndex := vTabSize * Round(AText.FTextParse^.ParagraphParams.Tabs[vIndex - 1] / vTabSize);
        vTabCnt := AText.FTextParse^.ParagraphParams.T - vIndex - Integer(vIsHasFirstTab);
        Result := (vTabCnt + Integer(vTabCnt = 0)) * vTabSize + vTabIndex;
      end
      else
      begin
        vIndex := Floor(AText.FPoint1.X / vTabSize) + AText.FTextParse^.ParagraphParams.T;
        Result := vIndex * vTabSize;
      end;
//------------------------- need to be fixed in future -------------------------
      if (vIndex = 1) and (FDestWidth <> 0) and (Result / FDestWidth > 2) then // ??
        Result := 0;
//------------------------------------------------------------------------------
    end;
//------------------------- need to be fixed in future -------------------------
    if (FDestWidth <> 0) and (Result / FDestWidth > 10) then // tab size is big ??
      Result := vTabSize;
//------------------------------------------------------------------------------
  end;
end;

function TsgMTextParser.GetTextWidth(const AText: Pointer): Double;
begin
  Result := TsgDXFText(AText).Box.Right - TsgDXFText(AText).Point.X;
end;

function TsgMTextParser.GetToken: TToken;
begin
  Result := PTken[FIndex]^;
end;

function TsgMTextParser.GetToken2: TToken2;
begin
  Result := PToken2(PTken[FIndex])^;
end;

function TsgMTextParser.GetDestWidth: Double;
var
  vText: TsgDXFText;
  vLeft, vRight: Double;
  I: Integer;
begin
  vLeft := cnstBadRect.Left;
  vRight := cnstBadRect.Right;
  for I := FDest.Count - 1 downto 0 do
  begin
    vText := TsgDXFText(FDest.Entities[I]);
    if vLeft > vText.FBox.Left then
      vLeft := vText.FBox.Left;
    if vLeft > vText.FBox.Right then
      vLeft := vText.FBox.Right;
    if vRight < vText.FBox.Left then
      vRight := vText.FBox.Left;
    if vRight < vText.FBox.Right then
      vRight := vText.FBox.Right;
  end;
  Result := vRight - vLeft;
end;

function TsgMTextParser.GetPTken(Index: Integer): PToken;
begin
  Result := PToken(TsgNativeInt(FString) + (Index - 1) * SizeOf(FString[1]));
end;

function TsgMTextParser.GetSourceAlign(Index: Integer): Byte;
begin
  if (FDest.Count > 0) and (Index < FDest.Count) then
    Result := TsgDXFText(FDest[Index]).FTextParse^.ParagraphParams.PXQAlign
  else
    if Index = -1 then
      Result := FSourceAlign
    else
      Result := 1;
end;

function TsgMTextParser.GetString(P: PToken): string;
{$IFDEF UNICODE}
begin
  SetString(Result, PChar(P), (TsgNativeUInt(PTken[FIndex]) - TsgNativeUInt(P)) div SizeOf(Char));
end;
{$ELSE}
{$IFDEF SG_DWORD_TOKEN}
var
  W: UnicodeString;
{$ENDIF}
begin
{$IFDEF SG_DWORD_TOKEN}
  SetString(W, PWideChar(P), (TsgNativeUInt(PTken[FIndex]) - TsgNativeUInt(P)) div SizeOf(UnicodeChar));
  Result := string(W);
{$ELSE}
  SetString(Result, PChar(P), (TsgNativeUInt(PTken[FIndex]) - TsgNativeUInt(P)) div SizeOf(Char));
{$ENDIF}
end;
{$ENDIF}

function TsgMTextParser.GetTextHeight(const AText: TsgDXFText): Double;
begin
  Result := AText.FTextParse^.FontParams.Above + AText.FTextParse^.FontParams.Below;
end;

function TsgMTextParser.GetBoxWidth(const AText: TsgDXFText): Double;
begin
  Result := AText.FBox.Right - AText.FBox.Left;
end;

function TsgMTextParser.IsFirstText(const AText: Pointer): Boolean;
begin
  Result := TsgDXFText(AText).FTextParse^.ParagraphParams.IsFirstText;
end;

function TsgMTextParser.IsTextEmpty(const AText: TsgDXFText): Boolean;
begin
  Result := (Length(AText.FText) = 0) and (Length(AText.FUnicodeText) = 0);
end;

procedure TsgMTextParser.ConvertUnicode(const AText:  TsgDXFText);
begin
  AText.UpdateProperties(FConverter);
  AText.ParseUnicodeText2(FConverter.CodePage, AText.FText,
    FConverter.GetSHXFont(AText.Properties, False, AText.InternalSHXFont, AText.IsSHXFont),
    FConverter.GetSHXFont(AText.Properties, True, AText.SHXFont, AText.IsSHXFont), False);
  if AText.WinFont or (Length(AText.Properties.BigFont) = 0) then
    AText.FText := AText.FUnicodeText
end;

{ TsgUnicodeParser }

procedure TsgUnicodeParser.AddUnicodeSymbol(ASymbol: Integer;
  const ACodePage: Integer = CP_ACP; const ACheckCodePage: Boolean = False);
var
  I: Integer;
  vSHXSymbolType: TsgSymbolType;
  vUseDefault: LongBool;
  vCodePage: Integer;
  vUnicodeSymbol: WideChar;
  vSymbolIndex: Integer;
  vFind: Boolean;
  vCodePageListIndex: Integer;

  function CheckPair(var AChar: WideChar): Boolean;
  var
    vLen, J: Integer;
    vMBytes: Word;
  begin
    Result := False;
    vLen := Length(FUnicode);
    if (vLen > 1) and (Ord(FUnicode[vLen]) <= 255) and
       (Ord(FUnicode[vLen - 1]) <= 255) then
    begin
      PByteArray(@vMBytes)^[0] := Ord(FUnicode[vLen]);
      PByteArray(@vMBytes)^[1] := Ord(FUnicode[vLen - 1]);
      if FBigFont.Find(vMBytes, vSymbolIndex) then
      begin
        Dec(vLen);
        SetLength(FSHXMap, vLen);
        FSHXMap[vLen] := AnsiChar(stBigFont);

        J := FCodepagesList.Count - 1;
        Result := False;
        while (J >= 0) and not Result do
        begin
          vCodePage := FCodepagesList[J];
          AChar := #0;
          Result := UnicodeFromLocaleChars(vCodePage, 0, PAnsiChar(@vMBytes), 2, @AChar, 1) > 0;
          Dec(J);
        end;

        SetLength(FUnicode, vLen);
        FUnicode[vLen] := AChar;
        SetLength(FIndices, Length(FIndices) - 1);
        FIndices[High(FIndices)] := vSymbolIndex;
      end;
    end;
  end;

  function DoFind(ACodepage: Cardinal; ASym: Word): Integer;
  var
    vMBytes: Word;
  begin
    vMBytes := 0;
    Result := LocaleCharsFromUnicode(ACodepage, 0, PWideChar(@ASym), 1, PAnsiChar(@vMBytes), 2, #0, @vUseDefault);
    if not vUseDefault then
    begin
      if Assigned(FBigFont) then
      begin
        if Result = 1 then
          vFind := FBigFont.Find(vMBytes, vSymbolIndex)
        else
          vFind := FBigFont.Find(Swap(vMBytes), vSymbolIndex);
        if vFind then
          vSHXSymbolType := stBigFont;
      end
      else
        if Result = 1 then
          vFind := FFont.Find(vMBytes, vSymbolIndex);
    end;
  end;

begin
  vSHXSymbolType := stNormal;
  vUnicodeSymbol := #0;
  vCodePage := CP_ACP;
  vSymbolIndex := -1;
  vFind := False;
  vCodePageListIndex := -1;
  try
  if ASymbol > $FFFF then
  begin
    vCodePage := GetCodePageByIndex(ASymbol shr 16);
    vCodePageListIndex := TryAddCodepage(vCodePage);
    if UnicodeFromLocaleChars(vCodePage, 0, PAnsiChar(@ASymbol), 2, PWideChar(@vUnicodeSymbol), 1) = 0 then
      vUnicodeSymbol := WideChar(Swap(ASymbol));
    if Assigned(FBigFont) then
    begin
      if FBigFont.CodePage <> 0 then
        DoFind(FBigFont.CodePage, Ord(vUnicodeSymbol));
      if not vFind and FBigFont.Find(Swap(ASymbol), vSymbolIndex) then
      begin
        vSHXSymbolType := stBigFont;
        vFind := True;
      end;
    end;
    if not vFind then
      vFind := FFont.Find(Word(vUnicodeSymbol), vSymbolIndex);
  end
  else
  begin
    vUnicodeSymbol := WideChar(ASymbol);
    vCodePageListIndex := TryAddCodepage(ACodePage);
    if (FFont.Kind = tkNormSHX) and (ASymbol > 255) then
      TryAddCodepage(sgEncMgr.EncMgr.FromChar(ASymbol).Codepage);
    vFind := FFont.Find(ASymbol, vSymbolIndex);
    if not vFind then
    begin
      I := FCodepagesList.Count - 1;
      while (I >= 0) and not vFind do
      begin
        vCodePage := FCodepagesList[I];
        DoFind(vCodePage, ASymbol);
        Dec(I);
      end;
    end;
  end;

  if not vFind then
  begin
    vSymbolIndex := FDefaultIndex;
    if FTestUndefinedUnicodeSymbol and (Ord(vUnicodeSymbol) > 255) then
      FHasUndefinedUnicodeSymbol := True;
  end;

  SetLength(FIndices, Length(FIndices) + 1);
  FIndices[High(FIndices)] := vSymbolIndex;

  FUnicode := FUnicode + vUnicodeSymbol;
  FSHXMap := FSHXMap + AnsiChar(vSHXSymbolType);

  if Assigned(FBigFont) and (not FBigFontInternal) then
    CheckPair(vUnicodeSymbol);
  finally
    if vCodePageListIndex > 0 then
      FCodepagesList.Delete(vCodePageListIndex);
  end;
end;

constructor TsgUnicodeParser.Create(const AText: string;
  const ACodePage: Integer; const AFont, ABigFont: TsgSHXFont);
{$IFNDEF SG_NON_WIN_PLATFORM}
var
{$IFDEF HAS_FEATURE_ENCODING}
  vEncoding: TEncoding;
{$ELSE}
{$IFDEF MSWINDOWS}
  vCPInfo: TCPInfo;
{$ENDIF}
{$ENDIF}
{$ELSE}
{$IFDEF HAS_FEATURE_ENCODING}
  var vEncoding: TEncoding;
{$ENDIF}
{$ENDIF}
begin
  inherited Create;
  FHasUndefinedUnicodeSymbol := False;
  FCodepagesList := TsgIntegerList.Create;
  FText := AText;
  FCodePage := ACodePage;
  FFont := TsgSHXFontAccess(AFont);
  FBigfont := TsgSHXFontAccess(ABigFont);
  FBigFontCodePage := -1;
  FLastUnicode := True;
  TryAddCodepage(FCodePage);
  if not FFont.Find(Ord(cnstUndefinedSymbol), FDefaultIndex) then
    FFont.Find(Ord(' '), FDefaultIndex);
  if Assigned(FBigfont) then
  begin
    FBigFontCodePage := FBigfont.GetCodePage;
    FBigFontInternal := GetBigFontFlagsInternal(FBigfont.Name) and 1 <> 0;
    TryAddCodepage(FBigFontCodePage);
  end
  else
{$IFDEF HAS_FEATURE_ENCODING}
  begin
    vEncoding := TEncoding.GetEncoding(FCodePage);
    try
      FTestUndefinedUnicodeSymbol := not vEncoding.IsSingleByte;
    finally
      vEncoding.Free;
    end;
  end;
{$ELSE}
{$IFDEF MSWINDOWS}
    if GetCPInfo(FCodePage, vCPInfo) then
      FTestUndefinedUnicodeSymbol := vCPInfo.MaxCharSize > 1;
{$ENDIF}
{$ENDIF}
end;

destructor TsgUnicodeParser.Destroy;
begin
  FCodepagesList.Free;
  inherited Destroy;
end;

function TsgUnicodeParser.TryAddCodepage(ACodepage: Integer): Integer;
begin
  Result := -1;
  if (ACodepage <> CP_ACP) and (ACodepage <> -1) and (FCodepagesList.IndexOf(ACodepage) = -1) then
    Result := FCodepagesList.Add(ACodepage);
end;

procedure TsgUnicodeParser.Execute(const AParsePercentSymbols: Boolean = True);
const
  cnstMinLen = 2;
  cnstTypeU = '\U+';
  cnstTypeM = '\M+';
  cnstTypeDP = '%%';
var
  vAdd: Boolean;
  I, J, vLength, vCodeLen, Err: Integer;
  vCode: string;
  vCheckCodePage: Boolean;
  vSymbol: Integer;

  function CPToMCodeIndex(ACodePage: Cardinal): Integer;
  begin
    Result := CodepageToMCodeIndex(ACodePage);
  end;

begin
  FUnicode := '';
  FSHXMap := '';
  I := 1;
  vLength := Length(FText);
  while I <= vLength do
  begin
    vAdd := True;
    case FText[I] of
      '\':
        begin
          if (not AParsePercentSymbols) and (I + 1 <= vLength) and (FText[I + 1] = cnstBackSlash) then//for MTEXT
          begin
            Inc(I)
          end
          else
          begin
            vCodeLen := ReadUnicode(FText, I, vCode);
            if vCodeLen > 0 then
            begin
              vCheckCodePage := False;
              Val(HexDisplayPrefix + vCode, vSymbol, Err);
              if Err = 0 then
              begin
                vAdd := False;
                if (vSymbol > $FFFF) or (vCodeLen > 4) then
                begin
                  vCheckCodePage := not AParsePercentSymbols;
                  if vSymbol <= $FFFF then
                    vSymbol := vSymbol or (CPToMCodeIndex(FBigFontCodePage) shl 16);
                  vSymbol := Swap(vSymbol);
                end;
                AddUnicodeSymbol(vSymbol, CP_ACP, vCheckCodePage);
                Inc(I, 3 + vCodeLen);
              end;
            end;
          end;
        end;
      '%':
        begin
          if AParsePercentSymbols and (I + 1 <= vLength) and (FText[I + 1] = '%') then
          begin
            Inc(I, 2);
            vAdd := False;
            vCode := Copy(FText, I, 3);
            if Length(vCode) > 0 then
            begin
              case vCode[1] of
                '%':
                  begin
                    Inc(I);
                    AddUnicodeSymbol(Ord('%'));
                  end;
                'd', 'D':
                  begin
                    Inc(I);
                    AddUnicodeSymbol(Ord(cnstDegree));
                  end;
                'p', 'P':
                  begin
                    Inc(I);
                    AddUnicodeSymbol(Ord(cnstPlusMinusSign));
                  end;
                'c', 'C':
                  begin
                    Inc(I);
                    AddUnicodeSymbol($2205);
                  end;
              else
                for J := 1 to Length(vCode) do
                begin
                  if not CharInSet(vCode[J], ['0'..'9']) then
                  begin
                    SetLength(vCode, J - 1);
                    Break;
                  end;
                end;
                vCodeLen := Length(vCode);
                if vCodeLen > 0 then
                begin
                  Inc(I, vCodeLen);
                  AddUnicodeSymbol(StrToIntDef(vCode, Ord('?')));
                end;
              end;
            end;
          end;
        end;
    end;
    if vAdd then
    begin
      AddUnicodeSymbol(Ord(FText[I]));
      Inc(I);
    end;
  end;
end;

class function TsgUnicodeParser.ReadPercent(const AStr: string;
  const AIndex: Integer; var AUnicode: string): Integer;
var
  vLength, vLengtCode, J: Integer;
  vCode: string;
begin
  Result := 0;
  AUnicode := '';
  vLength := Length(AStr);
  if (AIndex + 1 <= vLength) and (AStr[AIndex + 1] = '%') then
  begin
    vCode := Copy(AStr, AIndex + 2, 3);
    if Length(vCode) > 0 then
    begin
      Result := 2;
      case vCode[1] of
        '%':
          begin
            Inc(Result);
            AUnicode := '%';
          end;
        'd', 'D':
          begin
            Inc(Result);
            AUnicode := cnstDegree;
          end;
        'p', 'P':
          begin
            Inc(Result);
            AUnicode := cnstPlusMinusSign;
          end;
        'c', 'C':
          begin
            Inc(Result);
            AUnicode := WideChar($2205);
          end;
      else
        for J := 1 to Length(vCode) do
        begin
          if not CharInSet(vCode[J], ['0'..'9']) then
          begin
            SetLength(vCode, J - 1);
            Break;
          end;
        end;
        vLengtCode := Length(vCode);
        if vLengtCode > 0 then
        begin
          Inc(Result, vLengtCode);
          AUnicode := WideChar(StrToIntDef(vCode, Ord('?')));
        end;
      end;
    end;
  end;
end;

class function TsgUnicodeParser.ReadUnicode(const AStr: string;
  const AIndex: Integer; var AUnicode: string): Integer;
var
  vLength, vLengtCode, vLengthStr, J: Integer;
begin
  Result := 0;
  AUnicode := '';
  vLength := Length(AStr);
  if (AIndex + 3 <= vLength) and (AStr[AIndex + 2] = '+') then
  begin
    case AStr[AIndex + 1] of
      'u', 'U':  vLengtCode := 4;
      'm', 'M':  vLengtCode := 5;
    else
      vLengtCode := 0;
    end;
    if vLengtCode > 0 then
    begin
      vLengthStr := 0;
      J := AIndex + 3;
      while (J <= vLength) and IsHexDigit(AStr[J]) do
      begin
        Inc(J);
        Inc(vLengthStr);
      end;
      if vLengthStr < vLengtCode then
        vLengtCode := 0;
    end;
    if vLengtCode > 0 then
    begin
      Result := vLengtCode;
      AUnicode := Copy(AStr, AIndex + 3, vLengtCode);
    end;
  end;
end;

{Tsg2DCurve}

constructor Tsg2DCurve.Create;
begin
  inherited Create;
end;

function Tsg2DCurve.FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample;
  const AIsChild: Boolean; const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
end;

procedure Tsg2DCurve.Assign(const AVal: Tsg2DCurve);
begin
end;

procedure Tsg2DCurve.ClearPoints;
begin
end;

function Tsg2DCurve.GetConverter: TsgDXFConverter;
begin
  Result := nil;
  if Assigned(FOwner) then
    Result := FOwner.Converter;
end;

function Tsg2DCurve.GetCount: Integer;
begin
  Result := 0;
end;

function Tsg2DCurve.GetEndPoint: TF2DPoint;
begin
  Result := cnstF2DPointZero;
end;

function Tsg2DCurve.GetEdgeType: Byte;
begin
  Result := cnst2DCurveUndefined;
end;

function Tsg2DCurve.GetPoints(const AIndex: Integer): TF2DPoint;
begin
  Result := cnstF2DPointZero;
end;

function Tsg2DCurve.GetStartPoint: TF2DPoint;
begin
  Result := cnstF2DPointZero;
end;

function Tsg2DCurve.IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean;
begin
  Result := EdgeType = ACurve.EdgeType;
end;

procedure Tsg2DCurve.Loaded(const AOwner: TsgDXFEntity{ = nil});
begin
  Owner := AOwner;
  LoadedInt;
end;

function Tsg2DCurve.IsImportMode: Boolean;
var
  vOwner: TsgDXFEntity;
begin
  Result := False;
  vOwner := Owner;
  if Assigned(vOwner) and Assigned(vOwner.Converter) then
    Result := vOwner.Converter.ImportMode = imImport;
end;

procedure Tsg2DCurve.LoadedInt;
begin
end;

procedure Tsg2DCurve.Reverse(ANeedLoad: Boolean);
begin
end;

procedure Tsg2DCurve.SetOwner(const AValue: TsgDXFEntity);
begin
  FOwner := AValue;
end;

{ Tsg2DPoints }

procedure Tsg2DPoints.Assign(const AVal: Tsg2DCurve);
begin
  ClearPoints;
  inherited Assign(AVal);
end;

procedure Tsg2DPoints.ClearPoints;
begin
  FreeAndNil(FPoints);
end;

destructor Tsg2DPoints.Destroy;
begin
  FreeAndNil(FPoints);
  inherited Destroy;
end;

function Tsg2DPoints.GetCount: Integer;
begin
  Result := GetPointsCount;
end;

function Tsg2DPoints.GetEndPoint: TF2DPoint;
begin
  if GetPointsCount > 0 then
    Result := FPoints.Last
  else
    Result := inherited GetEndPoint;
end;

function Tsg2DPoints.GetPointsCount: Integer;
begin
  Result := 0;
  if FPoints <> nil then
    Result := FPoints.Count;
end;

function Tsg2DPoints.GetPoints(const AIndex: Integer): TF2DPoint;
begin
  if GetPointsCount > 0 then
    Result := FPoints[AIndex]
  else
    Result := inherited GetPoints(AIndex);
end;

function Tsg2DPoints.GetStartPoint: TF2DPoint;
begin
  if GetPointsCount > 0 then
    Result := FPoints.First
  else
    Result := inherited GetStartPoint;
end;

procedure Tsg2DPoints.LoadedInt;
begin
  inherited LoadedInt;
  ClearPoints;
  if FPoints = nil then
  begin
    FPoints := TF2DPointList.Create;
    FPoints.Capacity := MaxI(Count, 4);
  end;
end;

{Tsg2DArc}

constructor Tsg2DArc.Create;
begin
  inherited Create;
  FPoints := nil;
end;

destructor Tsg2DArc.Destroy;
begin
  ClearPoints;
  inherited Destroy;
end;

function Tsg2DArc.FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample;
  const AIsChild: Boolean; const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlCenterPoint:
      FCenterPoint := MakeF2DPointFrom3D(ANode.ValueAsFPoint);
    xmlEndParam:
      FEndParam := ANode.ValueAsDouble;
    xmlRadius:
      FRadius := ANode.ValueAsDouble;
    xmlStartParam:
      FStartParam := ANode.ValueAsDouble;
    xmlClockwise:
      CounterClockWise := ANode.ValueAsBool;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function Tsg2DArc.GetArcRec(out AArcR: TsgArcR): Boolean;
begin
  AArcR.Center.Point2D := FCenterPoint;
  AArcR.Center.Z := 0;
  AArcR.Radius := FRadius;
  AArcR.AngleS := FStartParam;
  AArcR.AngleE := FEndParam;
  Result := True;
end;

procedure Tsg2DArc.Assign(const AVal: Tsg2DCurve);
var
  vArc: Tsg2DArc absolute AVal;
begin
  inherited Assign(AVal);
  if AVal is Tsg2DArc then
  begin
    FCenterPoint := vArc.FCenterPoint;
    FFlag := vArc.FFlag;
    FEndParam := vArc.FEndParam;
    FRadius := vArc.FRadius;
    FStartParam := vArc.FStartParam;
  end;
end;

procedure Tsg2DArc.AngleParams(var AStartParam,AEndParam: Double);
begin
  if CounterClockWise then
  begin
    AEndParam := FEndParam;
    AStartParam := FStartParam;
  end
  else
  begin
    AEndParam := -FStartParam;
    AStartParam := -FEndParam;
  end;
  AStartParam := sgMod(AStartParam, 360);
  AEndParam := sgMod(AEndParam, 360);
  AStartParam := GetParamByAngle(AStartParam);
  AEndParam := GetParamByAngle(AEndParam);
  if (AEndParam < AStartParam) or IsEqual(AEndParam, AStartParam, fDoubleResolution {fExtendedResolution}) then
    AEndParam := AEndParam + 360;
end;

function Tsg2DArc.GetCounterClockWise: Boolean;
begin
  Result := FFlag and 1 <> 0;
end;

function Tsg2DArc.GetEdgeType: Byte;
begin
  Result := cnst2DCurveArc;
end;

function Tsg2DArc.GetNumberPartsOfCircle: Integer;
begin
  Result := NumberOfCirclePartsByRadius(GetConverter, FRadius);
end;

function Tsg2DArc.GetParamByAngle(const Angle: Double): Double;
begin
  Result := Angle;
end;

function Tsg2DArc.GetCount: Integer;
var
  vDelta,vStartParam,vEndParam: Double;
begin
  Result := GetNumberPartsOfCircle;
  AngleParams(vStartParam, vEndParam);
  Result := TsgGeneratorShapeEdge.GetNumberArcPart(Result, vStartParam,
    vEndParam, IsImportMode, vDelta) + 1;
end;

function Tsg2DArc.IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean;
var
  vArc: Tsg2DArc absolute ACurve;
begin
  Result := False;
  if inherited IsEdgeEqual(ACurve) then
  begin
    Result := (FFlag = vArc.FFlag) and IsEqualF2DPoints(FCenterPoint, vArc.FCenterPoint) and
      IsEqual(FRadius, vArc.FRadius) and IsEqual(FStartParam, vArc.FStartParam) and IsEqual(FRadius, vArc.FRadius) and
      IsEqual(FEndParam, vArc.FEndParam);
  end;
end;

procedure Tsg2DArc.LoadedInt;
var
  A, B, ASin, ACos, vStartParam, vEndParam: Double;
  vGenerator: TsgGeneratorShapeEdge;
begin
  inherited LoadedInt;
  AngleParams(vStartParam, vEndParam);
  Params(A, B, ASin, ACos);
  vGenerator := TsgGeneratorShapeEdge.Create;
  try
    vGenerator.SetBaseList(FPoints);
    vGenerator.NumberCirclePart := GetNumberPartsOfCircle;
    vGenerator.IsImportMode := IsImportMode;
    vGenerator.CreateEllipticArcByRadiuses(MakeFPointFrom2D(FCenterPoint), A, B,
      vStartParam, vEndParam, ASin, ACos, not CounterClockWise);
  finally
    vGenerator.Free;
  end;
end;
(*  For future versions
function Tsg2DArc.GetCount: Integer;
begin
  if FPoints = nil then
    Result := iDefaultNumberOfCircleParts
  else
    Result := FPoints.Count;
end;

procedure Tsg2DArc.Loaded;
var
  vAngle: Double;
  A, B, ASin, ACos, X, Y, Angle, vStartParam, vEndParam: Double;
  S, C: Extended;
  vPt: PF2DPoint;
  I, Cnt: Integer;

  function CheckParam(const AParam: Double): Double;
  var
    vParam: Double;
    Kd: Double;
    Ki: Integer;
    vMode: Integer;
  begin
    vParam := Abs(AParam);
    if AParam > fAccuracy then
      vMode := 1
    else
      if AParam < -fAccuracy then
        vMode := -1
      else
        vMode := 0;
    if vMode <> 0 then
    begin
      Kd := vParam / 360;
      Ki := Floor(Kd);
      if IsEqual(Kd, Ki) then
      begin
        if vMode > 0 then
          Result := 360
        else
          Result := 0;
      end
      else
      begin
        if vMode > 0 then
          Result := vParam - Ki * 360
        else
          Result := (Ki + 1) * 360 - vParam;
      end;
    end
    else
      Result := 0;
  end;

begin
  ClearPoints;
  FPoints := TList.Create;
  vEndParam := FEndParam;
  vStartParam := FStartParam;
  if not CounterClockWise then
  begin
    vAngle := vEndParam;
    vEndParam := -vStartParam;
    vStartParam := -vAngle;
  end;
  vStartParam := CheckParam(vStartParam);
  vEndParam := CheckParam(vEndParam);  
  Params(A, B, ASin, ACos);
  vStartParam := GetParamByAngle(vStartParam);
  vEndParam := GetParamByAngle(vEndParam);
  if (GetEdgeType = 2) and IsEqual(vEndParam, vStartParam) then
  begin
    SinCos(Radian(vStartParam), S, C);
    New(vPt);
    FPoints.Add(vPt);
    X := A * C;
    Y := B * S;
    vPt^.X := FCenterPoint.X + X * ACos - Y * ASin;
    vPt^.Y := FCenterPoint.Y + X * ASin + Y * ACos;
  end
  else
  begin
    FPoints.Capacity := iDefaultNumberOfCircleParts;
    if vEndParam <= vStartParam then
      vEndParam := vEndParam + 360;
    Cnt := iDefaultNumberOfCircleParts - 1;
    for I := 0 to Cnt do
    begin
      Angle := Radian(vStartParam + I * (vEndParam- vStartParam) / Cnt);
      SinCos(Angle, S, C);
      X := A * C;
      Y := B * S;
      New(vPt);
      FPoints.Add(vPt);
      vPt^.X := FCenterPoint.X + X * ACos - Y * ASin;
      vPt^.Y := FCenterPoint.Y + X * ASin + Y * ACos;
    end;
  end;
end;
*)
procedure Tsg2DArc.Params(var A, B, ASin, ACos: Double);
begin
  A := FRadius;
  B := FRadius;
  ASin := 0;
  ACos := 1;
end;

procedure Tsg2DArc.Reverse(ANeedLoad: Boolean);
//var
//  I, Cnt: Integer;
begin
  CounterClockWise := not CounterClockWise;
  SwapSGFloats(FStartParam, FEndParam);
  FStartParam := 360 - FStartParam;
  FEndParam := 360 - FEndParam;
  if ANeedLoad then
    LoadedInt
//  else
//  begin
//    Cnt := FPoints.Count;
//    for I := 0 to Cnt div 2 - 1 do
//      SwapPointers(FPoints.List^[I], FPoints.List^[Cnt - I - 1]);
//  end;
end;

procedure Tsg2DArc.SetCounterClockWise(const AVal: Boolean);
begin
  FFlag := (FFlag and 254) or Byte(AVal);
end;

function Tsg2DArc.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlCenterPoint].Name).ValueData,
    MakeFPointFrom2D(FCenterPoint), xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlEndParam].Name).ValueData,
    FEndParam, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlRadius].Name).ValueData,
    FRadius, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlStartParam].Name).ValueData,
    FStartParam, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlClockwise].Name).ValueAsBool := CounterClockWise;
end;

{Tsg2DEllipse}

constructor Tsg2DEllipse.Create;
begin
  inherited Create;
  IsAngleInParam := True;
end;

function Tsg2DEllipse.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlMajorPoint:
      FMajorPoint := MakeF2DPointFrom3D(ANode.ValueAsFPoint);
  else
   Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure Tsg2DEllipse.Assign(const AVal: Tsg2DCurve);
begin
  inherited Assign(AVal);
  if AVal is Tsg2DEllipse then
    FMajorPoint := Tsg2DEllipse(AVal).FMajorPoint;
end;

function Tsg2DEllipse.GetEdgeType: Byte;
begin
  Result := cnst2DCurveEllipse;
end;

function Tsg2DEllipse.GetIsAngleInParam: Boolean;
begin
  Result := FFlag and 2 <> 0;
end;

function Tsg2DEllipse.GetParamByAngle(const Angle: Double): Double;
var
  vTan: Double;
  S, C: Extended;
begin
  if IsAngleInParam then
  begin
    SinCos(Radian(Angle), S, C);
    if Abs(C) > fAccuracy then
    begin
      vTan :=  S / C ;
      Result := Degree(ArcTan(vTan / FRadius));
      case Integer(S < 0) shl 1 + Integer(C < 0) of
        1, 3:
           begin
             Result := Result + 180;
             Result := Result - 360 * Floor(Result / 360);
           end;
      end;
    end
    else
      Result := Angle;
  end
  else
    Result := Angle;
end;

function Tsg2DEllipse.IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean;
var
  vEllipse: Tsg2DEllipse absolute ACurve;
begin
  Result := False;
  if inherited IsEdgeEqual(ACurve) then
    Result := IsEqualF2DPoints(FMajorPoint, vEllipse.FMajorPoint);
end;

procedure Tsg2DEllipse.Params(var A, B, ASin, ACos: Double);
var
  S, C: Extended;
  vRot: Double;
begin
  A := Sqrt(Sqr(FMajorPoint.X) + Sqr(FMajorPoint.Y));
  B := A * FRadius;
  vRot := ArcTan2(FMajorPoint.Y, FMajorPoint.X);
  SinCos(vRot, S, C);
  ASin := S; ACos := C;
end;

procedure Tsg2DEllipse.Reverse(ANeedLoad: Boolean);
begin
end;

procedure Tsg2DEllipse.SetIsAngleInParam(const AVal: Boolean);
begin
  FFlag := (FFlag and 253) or (Byte(AVal) shl 1);
end;

function Tsg2DEllipse.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlMajorPoint].Name).ValueData,
    MakeFPointFrom2D(FMajorPoint), xmlForViewing in AParams.Mode);
end;

{Tsg2DLine}

procedure Tsg2DLine.Assign(const AVal: Tsg2DCurve);
var
  vLine: Tsg2DLine absolute AVal;
begin
  inherited Assign(AVal);
  if AVal is Tsg2DLine then
  begin
    FEndPoint := vLine.FEndPoint;
    FStartPoint := vLine.FStartPoint;
  end;
end;

function Tsg2DLine.FromXMLNode(const AType: TsgXMLType; const ANode: TsgNodeSample;
  const AIsChild: Boolean; const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlStartPoint:
      FStartPoint := MakeF2DPointFrom3D(ANode.ValueAsFPoint);
    xmlEndPoint:
      FEndPoint := MakeF2DPointFrom3D(ANode.ValueAsFPoint);
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function Tsg2DLine.GetCount: Integer;
begin
  Result := 2;
end;

function Tsg2DLine.GetEndPoint: TF2DPoint;
begin
  Result := FEndPoint;
end;

function Tsg2DLine.GetEdgeType: Byte;
begin
  Result := cnst2DCurveLine;
end;

function Tsg2DLine.GetPoints(const AIndex: Integer): TF2DPoint;
begin
  if AIndex = 0 then
    Result := FStartPoint
  else
    Result := FEndPoint;
end;

function Tsg2DLine.GetStartPoint: TF2DPoint;
begin
  Result := FStartPoint;
end;

procedure Tsg2DLine.Reverse(ANeedLoad: Boolean);
begin
  SwapF2DPoints(FStartPoint, FEndPoint);
  if ANeedLoad then
    LoadedInt;
end;

function Tsg2DLine.IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean;
var
  vLine: Tsg2DLine absolute ACurve;
begin
  Result := False;
  if inherited IsEdgeEqual(ACurve) then
    Result := IsEqualF2DPoints(FStartPoint, vLine.FStartPoint) and IsEqualF2DPoints(FEndPoint, vLine.FEndPoint);
end;

procedure Tsg2DLine.SetEndPoint(const AVal: TF2DPoint);
begin
  FEndPoint := AVal;
end;

procedure Tsg2DLine.SetStartPoint(const AVal: TF2DPoint);
begin
  FStartPoint := AVal;
end;

function Tsg2DLine.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlStartPoint].Name).ValueData,
    MakeFPointFrom2D(FStartPoint), xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlEndPoint].Name).ValueData,
    MakeFPointFrom2D(FEndPoint), xmlForViewing in AParams.Mode);
end;

{Tsg2DPolyline}

procedure Tsg2DPolyline.Clear;
begin
  FVertexes.Count := 0;
  FreeAndNil(FBulges);
end;

constructor Tsg2DPolyline.Create;
begin
  inherited Create;
  FVertexes := TF2DPointList.Create;
  FBulges := nil;
end;

destructor Tsg2DPolyline.Destroy;
begin
  if FBulges <> nil then
    FBulges.Free;
  FVertexes.Free;
  ClearPoints;
  inherited Destroy;
end;

function Tsg2DPolyline.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  I, J: Integer;
  vNodeVertex: TsgNode;
  vAttrib: TsgNodeSample;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlClosed:   Closed := ANode.ValueAsBool;
    xmlVertexes:
      begin
        Clear;
        vAttrib := ANode.GetAttributeByName(cnstXMLNames[xmlCount].Name);
        if Assigned(vAttrib) then
          FVertexes.Capacity := vAttrib.ValueAsInt;
        for I := 0 to ANode.ChildNodesCount - 1 do
        begin
          vNodeVertex := TsgNode(ANode.ChildNodes[I]);
          if GetXMLId(vNodeVertex.Name) = xmlVertex then
          begin
            for J := 0 to vNodeVertex.AttributeNodesCount - 1 do
            begin
              vAttrib := vNodeVertex.AttributeNodes[J];
              case GetXMLId(vAttrib.Name) of
                xmlPoint:  AddVertex(MakeF2DPointFrom3D(vAttrib.ValueAsFPoint));
                xmlBulge:  AddBulge(vAttrib.ValueAsDouble);
              end;
            end;
          end;
        end;
      end;
   else
     Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure Tsg2DPolyline.AddBulge(const AVal: Single);
var
  I, Cnt: Integer;
begin
  if FBulges = nil then
  begin
    FBulges := TsgSingleList.Create;
    FBulges.Capacity := FVertexes.Count;
  end;
  I := FBulges.Count;
  Cnt := FVertexes.Count - 1;
  while I < Cnt do
  begin
    FBulges.Add(0);
    Inc(I);
  end;
  FBulges.Add(AVal);
end;

procedure Tsg2DPolyline.AddVertex(const APoint: TF2DPoint);
begin
  FVertexes.Add(APoint);
end;

procedure Tsg2DPolyline.ApplyBulge(const AP1, AP2: TF2DPoint;
  const ABulge: Double);
var
  vGenerator: TsgGeneratorShapeEdge;
  vConverter: TsgDXFConverter;
begin
  vGenerator := TsgGeneratorShapeEdge.Create;
  try
    vGenerator.SetBaseList(FPoints);
    vConverter := GetConverter;
    vGenerator.NumberCirclePart := NumberOfCirclePartsByBulge(vConverter,
      MakeFPointFrom2D(AP1), MakeFPointFrom2D(AP2), ABulge);
    vGenerator.IsImportMode := vConverter.ImportMode = imImport;
    vGenerator.CreateBulgesArc(MakeFPointFrom2D(AP1), MakeFPointFrom2D(AP2), ABulge);
  finally
    vGenerator.Free;
  end;
end;

procedure Tsg2DPolyline.Assign(const AVal: Tsg2DCurve);
var
  vPoly: Tsg2DPolyline absolute AVal;
begin
  inherited Assign(AVal);
  if AVal is Tsg2DPolyline then
  begin
    FProps := vPoly.FProps;
    Clear;
    FVertexes.Assign(vPoly.FVertexes);
    if vPoly.FBulges <> nil then
    begin
      FBulges := TsgSingleList.Create;
      FBulges.Assign(vPoly.FBulges);
    end;
  end;
end;

function Tsg2DPolyline.GetBulge(const AIndex: Integer): Single;
begin
  if (FBulges <> nil) and (AIndex < FBulges.Count) then
    Result := FBulges[AIndex]
  else
    Result := 0;
end;

function Tsg2DPolyline.GetBulgesCount: Integer;
begin
  if FBulges <> nil then
    Result := FBulges.Count
  else
    Result := 0;
end;

function Tsg2DPolyline.GetClosed: Boolean;
begin
  Result := FProps and 1 <> 0;
end;

function Tsg2DPolyline.GetEdgeType: Byte;
begin
  Result := cnst2DCurvePoly;
end;

function Tsg2DPolyline.GetStartPoint: TF2DPoint;
begin
  if FVertexes.Count > 0 then
    Result := FVertexes.First
  else
    Result := inherited GetStartPoint;
end;

function Tsg2DPolyline.GetEndPoint: TF2DPoint;
begin
  if FVertexes.Count > 0 then
    Result := FVertexes.Last
  else
    Result := inherited GetEndPoint;
end;

function Tsg2DPolyline.GetHasBulge: Boolean;
begin
  Result := Assigned(FBulges) and (FBulges.Count > 0);
end;

function Tsg2DPolyline.GetLastVertex: PF2DPoint;
begin
  if FVertexes.Count > 0 then
    Result := @FVertexes.List[FVertexes.Count - 1]
  else
    Result := nil;
end;

function Tsg2DPolyline.GetVertex(const AIndex: Integer): TF2DPoint;
begin
  if AIndex < FVertexes.Count then
    Result := FVertexes[AIndex]
  else
    Result := cnstF2DPointZero;
end;

function Tsg2DPolyline.GetVertexesCount: Integer;
begin
  Result := FVertexes.Count;
end;

function Tsg2DPolyline.IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean;
var
  vPoly: Tsg2DPolyline absolute ACurve;
begin
  Result := False;
  if inherited IsEdgeEqual(ACurve) then
  begin
    if (FProps = vPoly.FProps) then
    begin
      if not ((FBulges = nil) xor (vPoly.FBulges = nil)) then
      begin
        if FBulges <> nil then
          Result := FBulges.IsEqual(vPoly.FBulges, TsgPointerTypeComparer.CmpSingle)
        else
          Result := True;
      end;
      if Result then
        Result := FPoints.IsEqual(vPoly.FPoints);
    end;
  end;
end;

procedure Tsg2DPolyline.LoadedInt;
var
  I, Cnt: Integer;
  P1, P2: TF2DPoint;
  vBulge: Single;
begin
  inherited LoadedInt;
  Cnt := FVertexes.Count - 1;
  for I := 0 to Cnt do
  begin
    P1 := FVertexes[I];
    vBulge := Bulges[I];
    if (vBulge <> 0) then
    begin
      if (I < Cnt) then
        P2 := FVertexes[I + 1]
      else
        P2 := FVertexes[0];
      ApplyBulge(P1, P2, vBulge);
    end
    else
      FPoints.Add(P1);
  end;
end;

procedure Tsg2DPolyline.SetBulge(const AIndex: Integer; const AVal: Single);
begin
  if (FBulges <> nil) and (AIndex < FBulges.Count) then
    FBulges[AIndex] := AVal;
end;

procedure Tsg2DPolyline.SetClosed(const AVal: Boolean);
begin
  FProps := (FProps and 254) or Byte(AVal);
end;

procedure Tsg2DPolyline.SetVertex(const AIndex: Integer; const APoint: TF2DPoint);
begin
  if AIndex < FVertexes.Count then
    FVertexes[AIndex] := APoint;
end;

function Tsg2DPolyline.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vBulge: Single;
  vNodeVertex, vNodeVertexes: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlClosed].Name).ValueAsBool := Closed;
  vNodeVertexes := ANode.AddChildNV(cnstXMLNames[xmlVertexes].Name);
  vNodeVertexes.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := VertexesCount;
  if IsXMLHelp(AParams.Mode) and (VertexesCount = 0) then
  begin
    vNodeVertex := vNodeVertexes.AddChildNV(cnstXMLNames[xmlVertex].Name);
    vNodeVertex.AddAttribNV(cnstXMLNames[xmlPoint].Name).ValueAsFPoint :=
      cnstFPointZero;
    vNodeVertex.AddAttribNV(cnstXMLNames[xmlBulge].Name).ValueAsDouble := 0;
  end
  else
  begin
    for I := 0 to VertexesCount - 1 do
    begin
      vNodeVertex := vNodeVertexes.AddChildNV(cnstXMLNames[xmlVertex].Name);
      SetDataValueAsFPoint(vNodeVertex.AddAttribNV(cnstXMLNames[xmlPoint].Name).ValueData,
        MakeFPointFrom2D(Vertexes[I]), xmlForViewing in AParams.Mode);
      vBulge := Bulges[I];
      if IsFullPropsOrXMLHelp(AParams.Mode) or (vBulge <> 0) then
        SetDataValueAsDouble(vNodeVertex.AddAttribNV(cnstXMLNames[xmlBulge].Name).ValueData,
          vBulge, xmlForViewing in AParams.Mode);
    end;
  end;
end;

{Tsg2DSpline}

constructor Tsg2DSpline.Create;
begin
  inherited Create;
  FControls := TF2DPointList.Create;
  FKnots := TsgDoubleList.Create;
  FPoints := nil;
end;

destructor Tsg2DSpline.Destroy;
begin
  FKnots.Free;
  FControls.Free;
  FWeights.Free;
  ClearPoints;
  inherited Destroy;
end;

function Tsg2DSpline.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlDegree:         Degree := ANode.ValueAsInt;
    xmlPeriodic:       Periodic := ANode.ValueAsBool;
    xmlRational:       Rational := ANode.ValueAsBool;
    xmlControlPoints:  FControls.FromXML(ANode{, AResult});
    xmlKnotsPoints:    FKnots.FromXML(ANode{, AResult});
    xmlWeights:
      begin
        if not Assigned(FWeights) then
          FWeights := TsgDoubleList.Create;
        FWeights.FromXML(ANode{, AResult});
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure Tsg2DSpline.AddControl(const APoint: TF2DPoint);
begin
  FControls.Add(APoint);
end;

procedure Tsg2DSpline.AddKnot(const AVal: Double);
begin
  FKnots.Add(AVal);
end;

procedure Tsg2DSpline.AddWeight(const AVal: Double);
begin
  if FWeights = nil then
    FWeights := TsgDoubleList.Create;
  FWeights.Add(AVal);
end;

function Tsg2DSpline.GetLastVertex: PF2DPoint;
begin
  if FControls.Count > 0 then
    Result := @FControls.List[FControls.Count - 1]
  else
    Result := nil;
end;

procedure Tsg2DSpline.Assign(const AVal: Tsg2DCurve);
var
  vSpline: Tsg2DSpline absolute AVal;
begin
  inherited Assign(AVal);
  if AVal is Tsg2DSpline then
  begin
    FParams := vSpline.FParams;
    FControls.Assign(vSpline.FControls);
    FKnots.Assign(vSpline.FKnots);
    FreeAndNil(FWeights);
    if vSpline.FWeights <> nil then
    begin
      FWeights := TsgDoubleList.Create;
      FWeights.Assign(vSpline.FWeights);
    end;
  end;
end;

function Tsg2DSpline.GetDegree: Byte;
begin
  Result := FParams and 255;
end;

function Tsg2DSpline.GetEdgeType: Byte;
begin
  Result := cnst2DCurveSpline;
end;

function Tsg2DSpline.GetKnot(const AIndex: Integer): Double;
begin
  if AIndex < FKnots.Count then
    Result := FKnots[AIndex]
  else
    Result := 0;
end;

function Tsg2DSpline.GetPeriodic: Boolean;
begin
  Result := FParams and $200 <> 0;
end;

function Tsg2DSpline.GetRational: Boolean;
begin
  Result := FParams and $100 <> 0;
end;

function Tsg2DSpline.GetWeight(const AIndex: Integer): Double;
begin
  if AIndex < WeightsCount then
    Result := FWeights[AIndex]
  else
    Result := 0;
end;

function Tsg2DSpline.GeWeightsCount: Integer;
begin
  Result := 0;
  if Assigned(FWeights) then
    Result := FWeights.Count;
end;

function Tsg2DSpline.IsEdgeEqual(const ACurve: Tsg2DCurve): Boolean;
var
  vSpline: Tsg2DSpline absolute ACurve;
begin
  Result := False;
  if inherited IsEdgeEqual(ACurve) then
  begin
    if not ((FKnots = nil) xor (vSpline.FKnots = nil)) then
    begin
      if FKnots <> nil then
        Result := FKnots.IsEqual(vSpline.FKnots, TsgPointerTypeComparer.CmpSingle)
      else
        Result := True;
    end;
    if Result then
      Result := FControls.IsEqual(vSpline.FControls, TsgPointerTypeComparer.CmpF2DPoint);
  end;
end;

procedure Tsg2DSpline.LoadedInt;
var
  vGenerator: TsgGeneratorShapeEdge;
  vWeights: TsgDoubleList;
begin
  inherited LoadedInt;
  vGenerator := TsgGeneratorShapeEdge.Create;
  try
    vGenerator.NumberSplinePart := GetNumberOfSplineParts;
    vGenerator.SetBaseList(FPoints);
    if vGenerator.IsBSpline(Degree) then
    begin
      vWeights := nil;
      if Rational then
        vWeights := FWeights;
      vGenerator.CreateBSpline(FControls, FKnots, vWeights, Degree);
    end
    else
      vGenerator.CreateSplineByKnots(FControls, FKnots, 1 / vGenerator.NumberSplinePart);
  finally
    vGenerator.Free;
  end;
end;

function Tsg2DSpline.GetControl(const AIndex: Integer): TF2DPoint;
begin
  if AIndex < FControls.Count then
    Result := FControls[AIndex]
  else
    Result := cnstF2DPointZero;
end;

function Tsg2DSpline.GetControlsCount: Integer;
begin
  Result := FControls.Count;
end;

function Tsg2DSpline.GetKnotsCount: Integer;
begin
  Result := FKnots.Count;
end;

procedure Tsg2DSpline.SetControl(const AIndex: Integer; const APoint: TF2DPoint);
begin
 if AIndex < FControls.Count then
    FControls[AIndex] := APoint;
end;

procedure Tsg2DSpline.SetDegree(const Value: Byte);
begin
  FParams := (FParams and $FFFFFF00) or Value;
end;

procedure Tsg2DSpline.SetKnot(const AIndex: Integer; const AVal: Double);
begin
  if AIndex < FKnots.Count then
    FKnots[AIndex] := AVal;
end;

procedure Tsg2DSpline.SetPeriodic(const Value: Boolean);
begin
  FParams := (FParams and $FFFFFDFF) or (Cardinal(Value) shl 9);
end;

procedure Tsg2DSpline.SetRational(const Value: Boolean);
begin
  FParams := (FParams and $FFFFFEFF) or (Cardinal(Value) shl 8);
end;

procedure Tsg2DSpline.SetWeight(const AIndex: Integer; const Value: Double);
begin
  if AIndex < WeightsCount then
    FWeights[AIndex] := Value;
end;

function Tsg2DSpline.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vNodeControls, vNodeKnots, vNodeWeights: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlDegree].Name).ValueAsInt := Degree;
  ANode.AddAttribNV(cnstXMLNames[xmlPeriodic].Name).ValueAsBool := Periodic;
  ANode.AddAttribNV(cnstXMLNames[xmlRational].Name).ValueAsBool := Rational;
  if (ControlsCount > 0) or IsXMLHelp(AParams.Mode) then
  begin
    vNodeControls := ANode.AddChildNV(cnstXMLNames[xmlControlPoints].Name);
    if ControlsCount > 0 then
      FControls.ToXML(vNodeControls, cnstXMLNames[xmlPoint].Name);
  end;
  if (KnotsCount > 0) or IsXMLHelp(AParams.Mode) then
  begin
    vNodeKnots := ANode.AddChildNV(cnstXMLNames[xmlKnotsPoints].Name);
    if KnotsCount > 0 then
      FKnots.ToXML(vNodeKnots, cnstXMLNames[xmlKnot].Name);
  end;
  if (WeightsCount > 0) or IsXMLHelp(AParams.Mode) then
  begin
    vNodeWeights := ANode.AddChildNV(cnstXMLNames[xmlWeights].Name);
    if WeightsCount > 0 then
      FWeights.ToXML(vNodeWeights, cnstXMLNames[xmlWeight].Name);
  end;
end;

{Tsg2DBoundaryList}

procedure Tsg2DBoundaryList.Clear;
begin
  TsgObjectList.ClearList(FObjects);
end;

procedure Tsg2DBoundaryList.CopyFrom(const AList: Tsg2DBoundaryList;
  const AIndex, ACount: Integer);
begin
  FObjects.Capacity := ACount;
  FObjects.Count := FObjects.Capacity;
  CopyMemory(FObjects.List, @AList.FObjects.List[AIndex],
    ACount * SizeOf(Pointer));
end;

constructor Tsg2DBoundaryList.Create;
begin
  inherited Create;
  FBoundaryType := 1;
  FObjects := TsgObjectList.Create;
end;

procedure Tsg2DBoundaryList.Delete(const AIndex: Integer);
begin
  FObjects.Delete(AIndex);
end;

destructor Tsg2DBoundaryList.Destroy;
begin
  Clear;
  FObjects.Free;
  inherited Destroy;
end;

function Tsg2DBoundaryList.GetCount: Integer;
begin
  Result := FObjects.Count;
end;

function Tsg2DBoundaryList.GetItem(const AIndex: Integer): Tsg2DCurve;
begin
  Result := Tsg2DCurve(FObjects[AIndex]);
end;

function Tsg2DBoundaryList.IsTextBox: Boolean;
begin
  Result := FBoundaryType and 8 <> 0;
end;

procedure Tsg2DBoundaryList.SetCount(const AValue: Integer);
begin
  FObjects.Count := AValue;
end;

procedure Tsg2DBoundaryList.SetItem(const AIndex: Integer;
  const AValue: Tsg2DCurve);
begin
  FObjects.List[AIndex] := AValue;
end;

procedure Tsg2DBoundaryList.Add(const AValue: Tsg2DCurve);
begin
  FObjects.Add(AValue);
end;

procedure Tsg2DBoundaryList.AssignBoundary(const AObject: TObject);
type
  Tsg2DCurveClass = class of Tsg2DCurve;
var
  I: Integer;
  vObjects: TsgObjectList;
  vCurve: Tsg2DCurve;
begin
  vObjects := nil;
  Clear;
  if AObject is Tsg2DBoundaryList then
  begin
    FBoundaryType := Tsg2DBoundaryList(AObject).FBoundaryType;
    vObjects := Tsg2DBoundaryList(AObject).FObjects;
  end
  else
  begin
    if AObject is TList then
    begin
      FBoundaryType := 0;
      vObjects := TsgObjectList(AObject);
    end;
  end;
  if (vObjects <> nil) and (vObjects.Count > 0) then
  begin
    FObjects.Capacity := vObjects.Count;
    for I := 0 to vObjects.Count - 1 do
    begin
      vCurve := Tsg2DCurveClass(Tsg2DCurve(vObjects[I]).ClassType).Create;
      FObjects.Add(vCurve);
      vCurve.Assign(Tsg2DCurve(vObjects[I]));
    end;
  end;
end;

procedure Tsg2DBoundaryList.Insert(const AIndex: Integer;
  const AValue: Tsg2DCurve);
begin
  FObjects.Insert(AIndex, AValue);
end;

function Tsg2DBoundaryList.IsBoundaryEqual(const AList: Tsg2DBoundaryList): Boolean;

  function ProcEqualCurves(const Value1, Value2: Pointer): Boolean;
  begin
    Result := Tsg2DCurve(Value1).IsEdgeEqual(Value2)
  end;

begin
  Result := False;
  if FBoundaryType = AList.FBoundaryType then
    Result := IsEqualObjectListsEnum(Self.FObjects, AList.FObjects, @ProcEqualCurves);
end;

//-1 invalide
// 0 points
// 1 line
function Tsg2DBoundaryList.ViewType(const ALine: PsgF2DLine = nil): Integer;
var
  vPoints2D: Tsg2DPoints;
  vCurve: Tsg2DCurve;

  procedure SetLine;
  begin
    if IsEqualF2DPoints(vCurve.StartPoint, vCurve.EndPoint) then
      Result := -1
    else
    begin
      Result := 1;
      if ALine <> nil then
      begin
        ALine^.Point1 := vCurve.StartPoint;
        ALine^.Point2 := vCurve.EndPoint;
      end;
    end;
  end;

begin
  Result := 0;
  if Self.Count = 1 then
  begin
    vCurve := Self.Items[0];
    case vCurve.EdgeType of
      cnst2DCurveLine:  SetLine;
      cnst2DCurvePoly, cnst2DCurveSpline:
        begin
          vPoints2D := Tsg2DPoints(vCurve);
          vPoints2D.LoadedInt;
          case vPoints2D.GetPointsCount of
            0, 1:  Result := -1;
            2:     SetLine;
            3:
            begin
              if IsEqualF2DPoints(vPoints2D.Points[0], vPoints2D.Points[2]) then
                Result := -1
              else
                if IsPointOnLinePts(MakeFPointFrom2D(vPoints2D.Points[0]), MakeFPointFrom2D(vPoints2D.Points[2]), MakeFPointFrom2D(vPoints2D.Points[1])) then
                  Result := 1;
              if Result = 1 then
                SetLine;
            end;
          end;
        end;
    end;
  end
end;

{TsgDXFConverter}

function TsgDXFConverter.AddAttribsByBlock(const AIns: TsgDXFInsert;
  const ABlock: TsgDXFBlock): Boolean;
var
  I, Cnt: Integer;
  vAttrib: TsgDXFAttrib;
  vEnt: TsgDXFEntity;
  M: TFMatrix;
begin
  Result := False;
  M :=  AIns.GetMatrix;
  Cnt := ABlock.Count - 1;
  for I := 0 to Cnt do
  begin
    vEnt := ABlock.Entities[I];
    if vEnt.EntType = ceAttdef then
    begin
      vAttrib := TsgDXFAttrib.Create;
      AIns.AddEntity(vAttrib);
      vAttrib.AssignEntity(TsgDXFAttdef(vEnt));
      vAttrib.Point := FPointXMat(vAttrib.Point, M);
      Self.Loads(vAttrib);
      Result := True;
    end;
  end;
end;

procedure TsgDXFConverter.CreateDefaultDrawingProp;
begin
  DrwPropInfo.Clear;
  DrwPropCustomSummaryInfo.Clear;
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropTitle)] := 'CADSoftTools';
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropSubject)] := '';
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropAuthor)] := '';
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropComments)] := sExporterSoftwareInfo;
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropKeywords)] := '';
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropLastSavedBy)] := '';
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropRevisionNumber)] := '';
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropHyperlinkBase)] := '';
end;

constructor TsgDXFConverter.Create;
var
  vParam: TsgConverterParams;
begin
  inherited Create;
  FillChar(vParam, SizeOf(vParam), 0);
  CreateEx(vParam);
end;

procedure TsgDXFConverter.CreateXDataProcs(AClass: TsgClassXDataProcs = nil);
begin
{$IFDEF SG_BTI}
  FillChar(FBTIExtDataVersion, SizeOf(FBTIExtDataVersion), 0);
  FBTIExtDataVersion.Major := -1;
  if AClass = nil then
    AClass := DXFConv.GetClassXDataProcs;
  FreeAndNil(FXDataProcs);
  if AClass <> nil then
    FXDataProcs := AClass.Create;
{$ENDIF}
end;

function TsgDXFConverter.CreateDimStyles(const AppLanguage: TsgLangugeID;
  const ACreate: Boolean): TsgDXFDimensionStyle;
var
  I: Integer;
  vHeadVarStruct: PsgHeadVarStruct;
  vStyle: TsgDXFDimensionStyle;
begin
  vHeadVarStruct := PHeadVarStruct;
  if ACreate then
  begin
    vHeadVarStruct^.DimTextStyle := cnstActiveStyles[AppLanguage];
    Result := DimensionStyleByName(vHeadVarStruct^.TextStyle);
    for I := Low(cnstCadStyles) to High(cnstCadStyles) do
    begin
      if (cnstCadStyles[I].LangIds = []) or (AppLanguage in cnstCadStyles[I].LangIds) then
      begin
        vStyle := DimensionStyleByName(cnstCadStyles[I].Name);
        if cnstCadStyles[I].Name = vHeadVarStruct^.TextStyle then
          vStyle.InitProps(vHeadVarStruct);
        vStyle.TextStyle := StyleByName(vStyle.Name);
        if vStyle.Name = cnstGost then
        begin
          vStyle.DIMTIH := False;
          vStyle.DIMTOH := False;
          vStyle.TextPosVert := pvAbove;
        end;
        vStyle.Loaded(Self);
      end;
    end;
  end
  else
    Result := DimensionStyleByName(vHeadVarStruct^.DimStyle);
  if not Assigned(Result.TextStyle) then
    Result.TextStyle := StyleByName(vHeadVarStruct.DimTextStyle);
end;

procedure TsgDXFConverter.CreateEntitiesWithGeneratedHandles;
begin
  if not FMapEntities.HasGeneratedList then
    FMapEntities.CreateGeneratedList;
end;

constructor TsgDXFConverter.CreateEx(const AParams: TsgConverterParams);
var
  vPaths: TStringList;
  I: Integer;
  vFonstPaths: string;
  vLayout:TsgDXFLayout;
begin
  inherited Create;
{$IFDEF SG_OPENING_IN_THEADS}
  FLock := SyncObjs.TCriticalSection.Create;
{$ENDIF}
  FEntityProxyList := TsgObjectList.Create;//TsgCollection.Create;
  FUpdateEvent := AParams.UpdateEvent;
  FEntityDictionaries := CreateCollection;
  FEntityEEDItems := CreateObjectCollection;
  //FCurversQuality := 0;
  Self.RegenerateArcs := bRegenerateArcs;
  Self.HighQualityRegenerateArcs := cnstHighQualityRegenerateArcs;
  IniProcResolve;
  FConvExtended := TsgConverterExtented.Create(Self);
{$IFDEF CONV_REFCOUNT}
  FRefEnts := TsgList.Create;
  FRefEnts.Duplicates := dupIgnore;
  FRefEnts.Sorted := True;
{$ENDIF}
  FMapEntities := TsgMapEntities.Create(Self);
  FTotalACISLoading := 0;
  FileName := AParams.FileName;
  if AParams.CheckHandles then
    CreateEntitiesWithGeneratedHandles;
  FOnFindFont := GlobalFindFont;
(*
  {$IFDEF DEMO}
    Application.MessageBox('CAD Import VCL demo - please register at www.cadsofttools.com',
     'CAD Import VCL demo', MB_OK);
  {$ENDIF}
  {$IFDEF FRDEMO}
    Application.MessageBox('Fast Report plugin demo - please register at www.cadsofttools.com',
     'Fast Report plugin demo', MB_OK);
  {$ENDIF}
*)
  FAllArcsAsCurves := True;
  ImportMode := imView;
  FRefs := 1;

  FMain := TsgDXFSection(NewNamedEntity(nil, TsgDXFSection, 'SECTIONS'));
  FMain.OnListNotify := MainNotify;

  FTablesSection := TsgDXFSection(NewNamedEntity(FMain, cnstSectionNames[csTables].ClassType,
    cnstSectionNames[csTables].Name));
  FTablesSection.OnListNotify := TablesNotify;

  FObjectsSection := TsgDXFSection(NewNamedEntity(FMain, cnstSectionNames[csObjects].ClassType,
    cnstSectionNames[csObjects].Name));
  FObjectsSection.OnListNotify := ObjectsNotify;

  FBlocksSection := TsgDXFSection(NewNamedEntity(FMain, cnstSectionNames[csBlocks].ClassType,
   cnstSectionNames[csBlocks].Name));
  FClassesSection := TsgDXFSection(NewNamedEntity(FMain,cnstSectionNames[csClasses].ClassType,cnstSectionNames[csClasses].Name));
//  FBlockRecords := TsgDXFSection(NewNamedEntity(FTablesSection, cnstSectionNames[csBlockRecords].ClassType,
//    cnstSectionNames[csBlockRecords].Name));
  FMStyles := TsgDXFTable(NewNamedEntity(FObjectsSection, cnstSectionNames[csMLineStyles].ClassType,
    cnstSectionNames[csMLineStyles].Name));
  FLayouts := TsgDXFTable(NewNamedEntity(FObjectsSection, cnstSectionNames[csLayouts].ClassType,
    cnstSectionNames[csLayouts].Name));
  FLayouts.OnListNotify := LayoutsNotify;

  FImageDefs := TsgDXFTable(NewNamedEntity(FObjectsSection, cnstSectionNames[csImageDefs].ClassType,
    cnstSectionNames[csImageDefs].Name));

  FXRefs := TList.Create;
//  FContainerXref := nil;
  FNumberOfPartsInSpline := GetNumberOfSplineParts;
  FNumberOfPartsInCircle := GetNumberOfCircleParts;
  FDefaultLayoutIndex := -1;
  FTransform3D := cnstIdentityMat;

  AddLayout(TsgDXFLayout.Create);
  vLayout := TsgDXFLayout.Create;
  vLayout.Name := sLayout + '1';
  AddLayout(vLayout);

  FViewTwistMatrix := cnstIdentityMat;
  vFonstPaths := '';
  if bSearchSHXPaths then
  begin
    vPaths := TStringList.Create;
    try
      FindAutoCADSHXPaths(vPaths);
      for I := 0 to vPaths.Count - 1 do
        vFonstPaths := vFonstPaths + vPaths[I] + ';';
    finally
      vPaths.Free;
    end;
  end;
  vFonstPaths := vFonstPaths + sSHXSearchPaths;
  while AnsiPos(';;', vFonstPaths) > 0 do
    Delete(vFonstPaths, AnsiPos(';;', vFonstPaths), 1);
  if vFonstPaths <> '' then
  begin
    if vFonstPaths[1] = ';' then Delete(vFonstPaths, 1, 1);
    if vFonstPaths[Length(vFonstPaths)] <> ';' then
      vFonstPaths := vFonstPaths + ';'
  end;
  FSHXFonts := TsgSHXFontList.Create(vFonstPaths, sDefaultSHXFont);
  FUseSHXFonts := bUseSHXFonts;
  SetCrossoverMatrix(True);
{$IFNDEF SG_NO_USE_KERNEL3D}
  FMeshQuality := cnstModLinDeflection;
{$ENDIF}  
  Initialize;
  HeadVarStructInit;
  SetCodePage(FHeadVarStruct.CodePage);
  ClearTimeStamps;
  FOleFrame := cnstOleFrameDefault;
end;

constructor TsgDXFConverter.CreateFromFile(const AFileName: string);
begin
  Create;
  FileName := AFileName;
end;

function TsgDXFConverter.CreateTextStyles(const AppLanguage: TsgLangugeID;
  const ACreate: Boolean): TsgDXFStyle;
var
  I: Integer;
  vStyle: TsgDXFStyle;
  vHeadVarStruct: PsgHeadVarStruct;
begin
  vHeadVarStruct := PHeadVarStruct;
  if ACreate then
  begin
    vHeadVarStruct^.TextStyle := cnstActiveStyles[AppLanguage];
    vHeadVarStruct^.DimTextStyle := vHeadVarStruct^.TextStyle;
    Result := StyleByName(vHeadVarStruct^.TextStyle);
    for I := Low(cnstCadStyles) to High(cnstCadStyles) do
    begin
      if (cnstCadStyles[I].LangIds = []) or (AppLanguage in cnstCadStyles[I].LangIds) then
      begin
        vStyle := StyleByName(cnstCadStyles[I].Name);
        vStyle.FontName := cnstCadStyles[I].Font;
        vStyle.PrimaryFont := cnstCadStyles[I].FFile;
        if vStyle.Name = cnstGost then
          vStyle.ObliqueAngle := 15;
        vStyle.Loaded(Self);
      end;
    end;
  end
  else
    Result :=  StyleByName(vHeadVarStruct^.TextStyle);
end;

function TsgDXFConverter.CreateAcadTableStyles(const AppLanguage: TsgLangugeID;
  const ACreate: Boolean): TsgDXFAcadTableStyle;
var
  I: Integer;
  vStyle: TsgDXFStyle;
  vHeadVarStruct: PsgHeadVarStruct;
  vTableStyles: TsgDXFGroup;
  vCellType: TsgAcadTableCellType;
  vCellStyle: TsgAcadTableCellStyle;
begin
  Result := nil;
  vTableStyles := Self.Sections[csTableStyles];
  if Assigned(vTableStyles) then
  begin
    I := vTableStyles.IndexOfName(sStandardName);
    if I > -1 then
      Result := TsgDXFAcadTableStyle(vTableStyles[I]);
  end;
  if ACreate and (not Assigned(Result)) then
  begin
    vHeadVarStruct := PHeadVarStruct;
    vStyle := StyleByName(vHeadVarStruct.TextStyle);
    Result := TableStyleByName(sStandardName);
    for vCellType := Low(TsgAcadTableCellType) to High(TsgAcadTableCellType) do
    begin
      vCellStyle := Result.CellStyle[vCellType];
      vCellStyle.CellAlignment := 5;
      vCellStyle.TextStyle := vStyle;
      vCellStyle.TextHeight := vHeadVarStruct.TextSize;
      vCellStyle.TextColor := vHeadVarStruct.CEColor;
    end;
  end;
end;

function TsgDXFConverter.CustomEntByName(const AName: string;
  const ASection: TConvSection; const ACreateNew: Boolean = True): TsgDXFEntity;
var
  vSection: TsgDXFTable;
begin
  vSection := TsgDXFTable(GetSectionInt(ASection));
  Result := vSection.FindEntByName(AName);
  if ACreateNew and (not Assigned(Result)) then
  begin
    Result := NewNamedEntity(vSection, GetTableItemClasses(ASection),
      AName);
    Loads(Result);
  end;
end;

procedure TsgDXFConverter.CustomSummaryInfoAdd(const Key, Value: string);
begin
  if (Key <> '') and (Value <> '') and (DrwPropCustomSummaryInfo.Count < 10) then
    DrwPropCustomSummaryInfo.Values[Key] := Value;
end;

procedure TsgDXFConverter.CustomSummaryInfoDelete(const Key: string);
begin
  DrwPropCustomSummaryInfo.Values[Key] := '';
end;

destructor TsgDXFConverter.Destroy;
begin
  DestroyXDataProcs;
  FreeAndNil(FConvExtended);
  ClearBegin;
  Clear;
  FStatus := stDestroying;
  FreeSource;

  FTablesSection.Free;
  FObjectsSection.Free;
  FBlocksSection.Free;
  FClassesSection.Free;
  FHeaderSection.Free;
  FEntitiesSection.Free;

  FXRefs.Free;

  DeletePaperLayout;
  DeleteModelLayout;
  FLayouts.Free;

  FMain.Free;
  FSHXFonts.Free;
  FreeAndNil(FXRefSearchPaths);
  FreeAndNil(FDrwPropInfo);
  FreeAndNil(FDrwPropCustomSummaryInfo);
  ClearEnd;
  FreeAndNil(FMapEntities);
{$IFDEF CONV_REFCOUNT}
  if FRefCount > 0 then
    //if FRefEnts.Count > 0 then;
    raise Exception.CreateFmt('Converter (FRefcount=%d) > 0', [FRefCount]);
  FRefEnts.Free;
{$ENDIF}
  FEntityDictionaries.Free;
  FEntityEEDItems.Free;
  TsgObjectList.ClearList(FEntityProxyList);//TsgCollection.FreeList(FEntityProxyList);
  FEntityProxyList.Free;
  FreeAndNil(FModellerLinker);
{$IFDEF SG_OPENING_IN_THEADS}
  FreeAndNil(FCADIterateThreadParams);
  FreeAndNil(FLock);
{$ENDIF}
  inherited Destroy;
end;

procedure TsgDXFConverter.DestroyXDataProcs;
begin
{$IFDEF SG_BTI}
  FreeAndNil(FXDataProcs);
{$ENDIF}
end;

procedure TsgDXFConverter.Clear;
var
  I: Integer;
  vLayout: TsgDXFLayout;
  vStatus: TConvStatus;
  vObj: TsgDXFEntity;
  vEEDList: TsgObjectCollection;

  function RemoveSection(const ASection: TsgDXFSection): TsgDXFSection;
  begin
    ASection.Clear;
    Result := ASection;
    FMain.RemoveEntity(ASection);
  end;

begin
  vStatus := FStatus;
  try
    try
      if Assigned(FGroups) then
      begin
        vObj := FGroups;
        if Assigned(FGroups.Owner) then
          FGroups.Owner.RemoveEntity(FGroups);
        FreeAndNil(vObj);
      end;
      for I := 0 to FEntityDictionaries.Count - 1 do
      begin
        TsgTableItem(FEntityDictionaries.List^[I].Data).Item := nil;
        FreeAndNil(TsgTableItem(FEntityDictionaries.List^[I].Data));
      end;
      FAppIdIntHandle := cnstBadHandle;
      FEntityDictionaries.Clear;
      I := FEntityEEDItems.Count - 1;
      while I >= 0 do
      begin
        vEEDList := TsgObjectCollection(FEntityEEDItems.Objects[I]);
        vEEDList.Clear;
        vEEDList.Free;
        FEntityEEDItems.Delete(I);
        Dec(I);
      end;
      Status := stClearing;
      FCount := 0;

      // clear xref blocks
      for I := FXRefs.Count - 1 downto 0 do
      begin
        vObj := FXRefs[I];
        vObj.Owner.RemoveEntity(vObj); // vObj removes from FXRefs list
        vObj.Free;
      end;

      if Assigned(FLayouts) then
      begin
        vObj := FLayouts;
        FObjectsSection.RemoveEntity(FLayouts);
        FLayouts := TsgDXFTable(vObj);
        for I := FLayouts.Count - 1 downto 0 do
        begin
          vLayout := Layouts[I];
          vLayout.PaperSpaceBlock := nil;
          if I >= 2 then
          begin
            FLayouts.DeleteEntity(I);
            vLayout.Free;
          end;
        end;
      end;

      FBlocksSection := RemoveSection(FBlocksSection);
      FObjectsSection := RemoveSection(FObjectsSection);
      FTablesSection := RemoveSection(FTablesSection);
      FClassesSection := RemoveSection(FClassesSection);

      FMain.Clear;
      Status := stDefault;
    except
    end;
  finally
    if vStatus = stLoading then
      Status := stLoading;
  end;
end;

procedure TsgDXFConverter.ClearBegin;
begin
end;

procedure TsgDXFConverter.ClearBlocks;
var
  I, J, vCountBlockFinded: Integer;
  vIsBlockOfLayout: Boolean;
  vBlock: TsgDXFBlock;
  vStatus: TConvStatus;
begin
  vStatus := FStatus;
  try
    Status := stClearing;
    FCount := 0;
    I := 0;
    TsgSortedItem(FBlocksSection.FLinkID).SortList.Clear;
    vCountBlockFinded := 0;
    while I < FBlocksSection.Count do
    begin
      vBlock := TsgDXFBlock(FBlocksSection[I]);
      vIsBlockOfLayout := False;
      if (FLayouts <> nil) and (vCountBlockFinded < FLayouts.Count) then
        for J := 0 to FLayouts.Count - 1 do
          if TsgDXFLayout(FLayouts.Entities[J]).PaperSpaceBlock = vBlock then
          begin
            vIsBlockOfLayout := True;
            Inc(vCountBlockFinded);
            Break;
          end;
      if vIsBlockOfLayout then
      begin
        vBlock.Clear(True);
        FBlocksSection.AddItem(vBlock.GetNamedItem);
        Inc(I);
      end
      else
      begin
        FBlocksSection.DeleteEntity(I);
        vBlock.Free;
      end;
    end;
  finally
    Status := vStatus;
  end;
end;

procedure TsgDXFConverter.ClearDrawingProp;
begin
  DrwPropInfo.Clear;
  DrwPropCustomSummaryInfo.Clear;
  ClearTimeStamps;
end;

procedure TsgDXFConverter.ClearEED(const AAppID: Variant);
const
  cnstEmpty: TVarData = ();
var
  I: Integer;
  vAppIDEntity: TsgDXFEntity;
  vAppID: UInt64;
  vObject: TObject;
{$IFDEF SGDEL_6}
  vRef: IVarInstanceReference;
{$ENDIF}
begin
  vAppID := cnstBadHandle;
  if VarType(AAppID) in [varInt64, varUInt64] then
{$IFDEF SGDEL_6}
    vAppID := AAppID
{$ELSE}
    vAppID := sgVarAsUInt64(AAppID)
{$ENDIF}
  else
    if Assigned(FAppIDs) then
    begin
      vAppIDEntity := nil;
      if (TVarData(AAppID).VType = varString) or (TVarData(AAppID).VType = varOleStr) or
         (TVarData(AAppID).VType = varUString) then
        vAppIDEntity := FAppIDs.FindEntByName(AAppID)
      else
        if TVarData(AAppID).VType in [varSmallInt, varInteger, varBoolean, varShortInt, varByte, varWord, varLongWord] then
        begin
          I := AAppID;
          if (I > 0) and (I < FAppIDs.Count) then
            vAppIDEntity := FAppIDs[I];
        end
{$IFDEF SGDEL_6}
        else
          if VarType(AAppID) in [varUnknown, varDispatch] then
            if Supports(AAppID, IVarInstanceReference, vRef) then
            begin
              vObject := vRef.GetInstance(cnstEmpty);
              if vObject is TsgDXFEntity then
                vAppIDEntity := TsgDXFEntity(vObject);
            end
{$ENDIF};
      if Assigned(vAppIDEntity) then
        vAppID := vAppIDEntity.Handle;
    end;
  ClearEED(vAppID);
end;

procedure TsgDXFConverter.ClearEED(const AAppID: UInt64);
var
  I, J: Integer;
  vEntityExtDataCollection: TsgObjectCollection;
  vExtDataObject: TObject;
begin
  if AAppID <> cnstBadHandle then
    for I := FEntityEEDItems.Count - 1 downto 0 do
    begin
      vEntityExtDataCollection := TsgObjectCollection(FEntityEEDItems.Objects[I]);
      J := vEntityExtDataCollection.IndexOf(AAppID);
      if J >= 0 then
      begin
        vExtDataObject := vEntityExtDataCollection.Objects[J];
        vEntityExtDataCollection.Delete(J);
        vExtDataObject.Free;
      end;
      if vEntityExtDataCollection.Count = 0 then
      begin
        FEntityEEDItems.Delete(I);
        vEntityExtDataCollection.Free;
      end;
    end;
end;

procedure TsgDXFConverter.ClearEnd;
begin
end;

procedure TsgDXFConverter.ClearEntEED(const AEnt: TsgDXFEntity);
var
  I: Integer;
  vItem: TsgObjectCollection;
begin
  if Assigned(FEntityEEDItems) and Assigned(AEnt) and (AEnt.Handle <> cnstBadHandle) then
  begin
    I := FEntityEEDItems.IndexOf(AEnt.Handle);
    if I >= 0 then
    begin
      vItem := TsgObjectCollection(FEntityEEDItems.Objects[I]);
      FEntityEEDItems.Delete(I);
      vItem.Clear;
      vItem.Free;
    end;
  end;
end;

procedure TsgDXFConverter.ClearTimeStamps;
begin
  DrwPropCreatedDateTime := Now;
  DrwPropModifiedDateTime := DrwPropCreatedDateTime;
  DrwPropTotalEditingTime := CreateTimeStamp;
  FLastSave := Double(DrwPropCreatedDateTime);
end;

class function TsgDXFConverter.CompareEntities(const AEnt1, AEnt2: Pointer): Integer;
begin
  Result := CompareHandleEntities(AEnt1, AEnt2);
end;

procedure TsgDXFConverter.CompositeMLAtt;
var
  I: Integer;
begin
  for I := 0 to Counts[csBlocks] - 1 do
    DoCompositeMLAtt(Sections[csBlocks][I]);
end;

procedure TsgDXFConverter.DoCompositeMLAtt(ANode: TsgDXFEntity);
type
  TAcadMLAtt = record
    Att: TsgDXFAttdef;
    Xrec: TsgDXFXRecord;
    Data: TAcadMLAttData;
  end;
var
  I, J: Integer;
  vAtt: TAcadMLAtt;
  vAtts: array of TAcadMLAtt;
  vEnt: TsgDXFEntity;
  vDictionary: TsgDXFDictionary;
begin
  for I := 0 to ANode.Count - 1 do
  begin
    case ANode[I].EntType of
      ceAttdef, ceAttrib:
        begin
          Finalize(vAtt);
          FillChar(vAtt, SizeOf(vAtt), 0);
          vAtt.Att := TsgDXFAttdef(ANode[I]);
          vAtt.Xrec := TsgDXFXRecord(vAtt.Att.GetExtensionDictionary(cnstAcadMLAtt));
          if Assigned(vAtt.Xrec) then
          begin
            ExtractMLAttData(vAtt.Xrec.Data, vAtt.Data);

            vAtt.Att.Point := vAtt.Data.InsertionPoint;
            vAtt.Att.Value := vAtt.Data.Text;
            vAtt.Att.Tag := vAtt.Data.Tag;
            vAtt.Att.LockPosition := vAtt.Data.Locked;

            vAtt.Att.TypeValue := atMText;
            if Status <> stLoading then
              vAtt.Att.LoadedInternal(Self);
          end
          else
          begin
            if Assigned(vAtt.Att.MTextRef) then
            begin
              ExtractMLAttData(vAtt.Att.MTextRef, vAtt.Data);
              vAtt.Data.Flag := 2 shl Ord(vAtt.Att.EntType = ceAttdef);
              vAtt.Data.Locked := vAtt.Att.LockPosition;
              vAtt.Data.Tag := vAtt.Att.Tag;

              vDictionary := TsgDXFDictionary(Dictionary[vAtt.Att.Handle]);
              if vDictionary = nil then
              begin
                vDictionary := TsgDXFDictionary.Create;
                vDictionary.Name := cnstDictionary;
                DoCreate(vDictionary);
                Loads(vDictionary);
                Sections[csObjects].AddEntity(vDictionary);
                SetEntDict(vAtt.Att, vDictionary);
              end;
              vAtt.Xrec := TsgDXFXRecord.Create;
              vAtt.Xrec.Name := cnstAcadMLAtt;
              DoCreate(vAtt.Xrec);
              Loads(vAtt.Xrec);
              vDictionary.AddEntity(vAtt.Xrec);
              FillExtDataFromMLAttData(vAtt.Data, vAtt.Xrec.Data);

              vAtt.Att.TypeValue := atMText;
              if Status <> stLoading then
                vAtt.Att.LoadedInternal(Self);
            end;
          end;
          if Assigned(vAtt.Xrec) then
          begin
            SetLength(vAtts, Length(vAtts) + 1);
            vAtts[High(vAtts)] := vAtt;
          end;
        end;
      ceInsert: DoCompositeMLAtt(ANode[I]);
    end;
  end;
  for I := Low(vAtts) to High(vAtts) do
    for J := Low(vAtts[I].Data.SecondaryAtt) to High(vAtts[I].Data.SecondaryAtt) do
    begin
      vEnt := ANode.FindEntByHandle(vAtts[I].Data.SecondaryAtt[J]);
      if Assigned(vEnt) then
      begin
        ANode.RemoveEntity(vEnt);
        vEnt.Free;
      end;
    end;
end;

procedure TsgDXFConverter.DoDecompositeMLAtt(ANode: TsgDXFEntity);
const
  fmtAttTag = '%s_%.3d';
var
  I, J, vNodeCount: Integer;
  vText: TsgDXFEntity;
  vAtt, vNewAtt: TsgDXFAttdef;
  vAttData: TAcadMLAttData;
  vXRec: TsgDXFXRecord;
  vAttTag: string;
  vAttribs: TsgEntitiesList;
  vMText: TsgDXFMText;
  E, S, P: TFPoint;
  A: Double;
  vFlags: Integer;
begin
  vNodeCount := ANode.Count;
  for I := 0 to vNodeCount - 1 do
  begin
    case ANode[I].EntType of
      ceAttdef, ceAttrib:
        begin
          vAtt := TsgDXFAttdef(ANode[I]);
          if vAtt.TypeValue = atMText then
          begin
            vAttTag := vAtt.Tag;
            vXRec := TsgDXFXRecord(vAtt.GetExtensionDictionary(cnstAcadMLAtt));
            if not Assigned(vXRec) then Continue;
            ExtractMLAttData(vXRec.Data, vAttData);
            vAttData.Flag := 2 shl Ord(vAtt.EntType = ceAttdef);
            vAttData.Tag := vAttTag;
            vAttData.Locked := vAtt.LockPosition;
            vAttribs := TsgEntitiesList.Create;
            try
              vMText := vAtt.MText;
              ExtractMatrixParams(vMText.GetMatrix, P, S, E, A);
              for J := 0 to vMText.Block.Count - 1 do
              begin
                vText := vMText.Block[J];
                if vText is TsgDXFText then
                begin
                  vNewAtt := TsgDXFAttdef(TsgDXFEntityClass(vAtt.ClassType).Create);
                  DoCreate(vNewAtt);
                  vNewAtt.AssignEntity(vText);
                  vNewAtt.Tag := Format(fmtAttTag, [vAttTag, J + 1]);
                  vNewAtt.Value := TsgDXFText(vText).Text;
                  vNewAtt.Point := FPointXMat(vNewAtt.Point, vMText.GetMatrix);
                  if vNewAtt.HasSecond then
                    vNewAtt.Point1 := FPointXMat(vNewAtt.Point1, vMText.GetMatrix);
                  vNewAtt.Rotation := vNewAtt.Rotation + A;
                  vNewAtt.Extrusion := Ort(AffineTransformPoint(vNewAtt.Extrusion, ExtrusionToMatrix(E)));
                  vNewAtt.Height := vNewAtt.Height * S.Y;
                  vNewAtt.Scale := vNewAtt.Scale * S.X;
                  Loads(vNewAtt);
                  vAttribs.Add(vNewAtt);
                end;
              end;
              if vAttribs.Count > 0 then
              begin
                vNewAtt := TsgDXFAttdef(vAttribs[0]);
                vFlags := vAtt.Flags;
                vAtt.AssignEntity(vNewAtt);
                vAtt.TypeValue := atString;
                vAtt.Flags := vFlags;
                vAtt.LoadedInternal(Self);
                SetLength(vAttData.SecondaryAtt, vAttribs.Count - 1);
                if ANode is TsgDXFBlock then
                  TsgDXFBlock(ANode).IsLoaded := False;
                for J := 1 to vAttribs.Count - 1 do
                begin
                  ANode.AddEntity(vAttribs[J]);
                  vAttData.SecondaryAtt[J-1] := vAttribs[J].Handle;
                end;
                vNewAtt.Free;
              end;
            finally
              vAttribs.Free;
            end;
            vXRec.Data.Clear;
            FillExtDataFromMLAttData(vAttData, vXRec.Data);
          end;
        end;
      ceInsert: DoDecompositeMLAtt(ANode[I]);
    end;
  end;
end;

procedure TsgDXFConverter.DoIterateBegin(ASender: TsgDXFEntity);
begin
  if Assigned(FOnIterateBegin) then
    FOnIterateBegin(ASender);
end;

procedure TsgDXFConverter.DoIterateEnd(ASender: TsgDXFEntity);
begin
  if Assigned(FOnIterateEnd) then
    FOnIterateEnd(ASender);
end;

function TsgDXFConverter.Count: TsgNativeUInt;
begin
  if not (FStatus = stLoading) then
    Result := FCount
  else
    Result := FSource.Size;
  if Result = 0 then
    Result := 1;
end;

procedure TsgDXFConverter.GetLayerNames(S: TStrings; DoClear,IncludeUnused: Boolean);
var
  I: Integer;
  L: TsgDXFLayer;
begin
  S.BeginUpdate;
  try
    if DoClear then
      S.Clear;
    for I := 0 to Counts[csLayers] - 1 do
    begin
      L := Layers[I];
      if IncludeUnused or L.Used then
        S.AddObject(L.Name, L);
    end;
  finally
    S.EndUpdate;
  end;
end;

function TsgDXFConverter.GetDynamicBlockTrueName(const AAnnonimusBlockName: string;
  var AName: string): Boolean;
var
  I: Integer;
  vAnnonimusBlockRecord: TsgDXFEntity;
  vBlockRec: TsgDXFBlockRecord;
  vAcDbDynamicBlockTrueName: TsgDXFEntity;
  vEEDItems:  TsgObjectCollection;
  vData: TsgCADExtendedData;
begin
  Result := False;
  vAnnonimusBlockRecord := Sections[csBlockRecords].FindEntByName(AAnnonimusBlockName);
  if Assigned(vAnnonimusBlockRecord) then
  begin
    vBlockRec := TsgDXFBlockRecord(vAnnonimusBlockRecord).GetBlockRepBTagBlockRecord;
    vAcDbDynamicBlockTrueName := Sections[csAppID].FindEntByName(cnstAcDbDynamicBlockTrueName);
    if Assigned(vAcDbDynamicBlockTrueName) and Assigned(vBlockRec) then
    begin
      vEEDItems := EEDItems[vBlockRec.Handle];
      if Assigned(vEEDItems) then
      begin
        I := vEEDItems.IndexOf(vAcDbDynamicBlockTrueName.Handle);
        if I >= 0 then
        begin
          vData := TsgCADExtendedData(vEEDItems[I].Data);
          I := 0;
          while (I < vData.DataCount) and not Result do
          begin
            case vData.DataCode[I] of
              1000:
                if vData.DataType[I] = edtString then
                begin
                  AName := vData.DataString[I];
                  Result := True;
                end;
            end;
            Inc(I);
          end;
        end;
      end;
    end;
  end;
end;

function TsgDXFConverter.IntToColor(Value: Integer): TColor;
begin
  Result := sgFunction.IntToColor(Value);
end;

function TsgDXFConverter.AnnoDesc: string;
var
  E: TsgDXFEntity;
begin
  Result := FAnnoDesc;
  if Result <> '' then
    Exit;
  E := Sections[csObjects].FindEntByName(sAcDbVariableDictionary);
  if not (E is TsgDXFDictionary) then
    Exit;
  E := E.FindEntByName('CANNOSCALE');
  if not (E is TsgDXFDictionaryVar) then
    Exit;
  Result := TsgDXFDictionaryVar(E).Value;
  FAnnoDesc := Result;
end;

procedure TsgDXFConverter.Iterate(Proc, FinishProc: TsgCADEntityProc; var AParams: TsgCADIterate);
var
  vParams, vSavedParams: PsgCADIterate;
begin
  vSavedParams := Params;
  try
    Params := @AParams;
    vParams := Params;
    vParams^.Insert := nil;
    vParams^.ConvertMatrixCurrentInsertToWCS := cnstIdentityMat;
    vParams^.Color := clByLayer;
    vParams^.XScale := 0.0;
    vParams^.YScale := 0.0;
    FEntities.Iterate(Self, Proc, FinishProc);
  finally
    Params := vSavedParams;
  end;
end;

function TsgDXFConverter.IterateEntitiesInBlocks(const AProc: TsgCADLoadEntitiy): Boolean;
var
  vBlock: TsgDXFBlock;
  vBlocks: TsgDXFGroup;
  I, J: Integer;
begin
  Result := False;
  vBlocks := Sections[csBlocks];
  if Assigned(vBlocks) then
  begin
    for I := 0 to vBlocks.Count - 1 do
    begin
      vBlock := TsgDXFBlock(vBlocks.Entities[I]);
      for J := 0 to vBlock.Count - 1 do
      begin
        if not Assigned(vBlock.Layout) then
          if AProc(vBlock.Entities[J], Self) then
            Result := True;
      end;
    end;
    for I := 0 to LayoutsCount - 1 do
    begin
      vBlock := Layouts[I].PaperSpaceBlock;
      for J := 0 to vBlock.Count - 1 do
      begin
        if AProc(vBlock.Entities[J], Self) then
          Result := True;
      end;
    end;
  end;
end;

function TsgDXFConverter.LayerByName(const AName: string): TsgDXFLayer;
begin
  Result := TsgDXFLayer(CustomEntByName(AName, csLayers));
end;

function TsgDXFConverter.LinesByName(const AName: string): TsgLines;
var
  L: TsgDXFLineType;
begin
  L := LTypeByName(AName);
  if L = nil then
    Result := nil
  else
    Result := L.FLines;
end;

function TsgDXFConverter.FEntities: TsgDXFBlock;
begin
  Result := Layouts[0].PaperSpaceBlock;
end;

procedure TsgDXFConverter.FreeEntitiesWithGeneratedHandles;
begin
  if FMapEntities.HasGeneratedList then
    FMapEntities.ApplyAndFreeGeneratedList;
end;

procedure TsgDXFConverter.FreeSource;
begin
  if OwnSource then FSource.Free;
  FSource := nil;
end;

function TsgDXFConverter.FromXML(const ANode: TsgNodeSample;
  const AResult: IsgResultNode = nil): Integer;

  function IsNodeEntity(const ANode: TsgNodeSample): Boolean;
  var
    vSubEntities: TList;
    vNameNode: TsgNodeSample;
    I: Integer;
  begin
    Result := False;
    vSubEntities := TList.Create;
    try
      GetSubEntities(vSubEntities);
      vNameNode := ANode.GetAttributeByName(sgConsts.cnstXMLNames[xmlName].Name);
      if not Assigned(vNameNode)  then
        Exit;
      for I := 0 to vSubEntities.Count - 1 do
      begin
        if SameText(TsgDXFEntity(vSubEntities[I]).Name, vNameNode.ValueAsStr) then
        begin
          Result := True;
          Break;
        end;
      end
    finally
      vSubEntities.Free;
    end;
  end;

var
  vActive, vNodeChild, vNodeEntities, vNodeModel, vSubEntity: TsgNodeSample;
  vEntitiesName: string;
  vEntitiesNodeCreate: Boolean;
begin
  vActive := ANode;
  if not SameText(GetNodeName, ANode.Name) then
  begin
    vSubEntity := nil;
    vActive := TsgNode(ANode).AddChildNV(GetNodeName);
    if not Assigned(FEntitiesSection) then
      FEntitiesSection := TsgDXFSectionEntities.CreateByConverter(Self);
    vEntitiesName :=  FEntitiesSection.GetNodeName;
    vNodeEntities := vActive.GetChildByName(vEntitiesName);
    vEntitiesNodeCreate := False;
    if not Assigned(vNodeEntities) then
    begin
      //  cstSectionEntities
      vNodeEntities :=  TsgNode.Create;
      vEntitiesNodeCreate := True;
      vNodeEntities.Name := vEntitiesName;
      TsgNode(vNodeEntities).AddAttribNV(cnstXMLNames[xmlName].Name).ValueAsStr :=
        FEntitiesSection.Name;
      // Model
      vNodeModel := TsgNode(vNodeEntities).AddChildNV(Sections[csEntities].GetNodeName);
      TsgNode(vNodeModel).AddAttribNV(cnstXMLNames[xmlName].Name).ValueAsStr :=
        Sections[csEntities].Name;
      vSubEntity := TsgNode(vNodeModel).AddChildNV(cnstXMLNames[xmlSubEntities].Name);
    end
    else
    begin
      if vNodeEntities.ChildNodesCount = 1 then
      begin
        vSubEntity := vNodeEntities.ChildNodes[0].GetChildByName(cnstXMLNames[xmlSubEntities].Name);
      end;
    end;
    while ANode.ChildNodesCount > 1 do
    begin
      vNodeChild := ANode.ChildNodes[0];
      if (vActive <> vNodeChild) then
      begin
        TsgNode(ANode).RemoveChild(vNodeChild);
        if (not IsNodeEntity(vNodeChild)) and Assigned(vSubEntity)  then
          TsgNode(vSubEntity).AddChild(vNodeChild)
        else
          TsgNode(vActive).AddChild(vNodeChild);
      end;
    end;
    if vEntitiesNodeCreate then
      TsgNode(vActive).AddChild(vNodeEntities);
  end;
  Result := inherited FromXML(vActive, AResult);
end;

function TsgDXFConverter.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vEntity: TsgDXFEntity;
  vHandleNode, vNameNode: TsgNodeSample;
  vSubEntities: TList;
  I: Integer;
  vHandle: UInt64;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
 if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlClassId:
      begin
        vEntity := nil;
        vHandleNode := nil;
        vHandle := cnstBadHandle;
        vNameNode := ANode.GetAttributeByName(sgConsts.cnstXMLNames[xmlName].Name);
        if not Assigned(vNameNode) then
        begin
          vHandleNode := ANode.GetAttributeByName(sgConsts.cnstXMLNames[xmlHandle].Name);
          if Assigned(vHandleNode) then
          begin
            vHandle := RestoreHandle(vHandleNode);
            if vHandle = cnstBadHandle then
              vHandleNode := nil;
          end;
        end;
        if Assigned(vNameNode) or Assigned(vHandleNode) then
        begin
          vSubEntities := TList.Create;
          try
            GetSubEntities(vSubEntities);
            for I := 0 to vSubEntities.Count - 1 do
            begin
              if Assigned(vNameNode) then
              begin
                if SameText(TsgDXFEntity(vSubEntities[I]).Name, vNameNode.ValueAsStr) then
                begin
                  vEntity := TsgDXFEntity(vSubEntities[I]);
                  Break;
                end;
              end
              else
              begin
                if TsgDXFEntity(vSubEntities[I]).Handle = vHandle then
                begin
                  vEntity := TsgDXFEntity(vSubEntities[I]);
                  Break;
                end;
              end;
            end;
          finally
            vSubEntities.Free;
          end;
        end;
        if Assigned(vEntity) then
        begin
          vEntity.SetConverter(Self);
          vEntity.FromXML(ANode, AResult);
        end
        else
        begin
          raise Exception.Create('Error section!');
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFConverter.FromXMLSubEntities(
  const ANode: TsgNodeSample; const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLSubEntities(ANode, AResult);
end;

procedure TsgDXFConverter.SaveHandle(const AValue: string;
  const AEntity: TsgDXFEntity);
begin
  GetConvExtended.SaveHandle(AValue, AEntity);
end;

procedure TsgDXFConverter.SetActiveVPort(const AValue: TsgDXFVPort);
begin
  FActiveVPort := AValue;
  UpdateViewTwistMatrix;
end;

procedure TsgDXFConverter.SetAngle(const AAngle: Single);
var
  vValue: Double;
begin
  if sgModAngle(AAngle, vValue) then
    ActiveVPort.ViewTwistAngle := vValue;
end;

procedure TsgDXFConverter.SetCircleZoomPercent(const AVal: Integer);
begin
  ActiveVPort.CircleZoomPercent := AVal;
end;

procedure TsgDXFConverter.SetSource(Value: TCustomMemoryStream);
begin
  if Value <> FSource then
  begin
    FreeSource;
    FSource := Value;
  end;
end;

procedure TsgDXFConverter.SetOleFrame(const AValue: Byte);
begin
  if FOleFrame <> AValue then
  begin
    FOleFrame := AValue;
    // notify changes
  end;
end;

procedure TsgDXFConverter.SetOwnSource(Value: Boolean);
begin
  if Value <> FOwnSource then
  begin
    FreeSource;
    FOwnSource := Value;
  end;
end;

class procedure TsgDXFConverter.SetLayerNameOfPassingInspection(
  const ALayer: TsgDXFlayer; const AName: string);
var
  vIsCheckName: Boolean;
begin
  vIsCheckName := ALayer.IsCheckName;
  try
    ALayer.IsCheckName := False;
    ALayer.Name := AName;
  finally
    ALayer.IsCheckName := vIsCheckName;
  end;
end;

procedure TsgDXFConverter.SetLoading(Value: Boolean; APos: PAnsiChar;
  const AOnUpdate: TNotifyEvent = nil);
begin
  FUpdateEvent := AOnUpdate;
  if Value then
  begin
    if (Status <> stLoading) and FMapEntities.HasGeneratedList then
      ResetHandles;
    Status := stLoading
  end
  else
  begin
    Status := stDefault;
    InitializeSectionsEnd(True);
    if Assigned(FOnAcisNumberMsg) then
      DoAcisNumberMsg;
  end;
  FPos := APos;
  if FPos <> nil then
    Inc(FPos);
end;

type
  TMemoryStreamAccess = class(TMemoryStream);

procedure TsgDXFConverter.SetSourceStream(S: TStream);
var
  MS: TMemoryStreamAccess;
  vSize: Int64;
begin
//  MS := TMemoryStream(S);//evg
  MS := TMemoryStreamAccess(TMemoryStream.Create);    //evg???? create without free!
  vSize := S.Size - S.Position;
  MS.Capacity := vSize + 4;
  MS.SetPointer(MS.Memory, vSize);
  S.ReadBuffer(MS.Memory^, vSize);
//  MS.LoadFromStream(S);
  OwnSource := True;
  Source := MS;
  FLimit := MS.Memory;
  if Assigned(FLimit) then
  begin
    Inc(FLimit, vSize);
    PWord(FLimit)^ := $0A0D; // additional eoln for DXF.SkeepLimits
    PWord(TsgNativeUInt(FLimit) + 2)^ := $0000;
  end;
end;

procedure TsgDXFConverter.SetStatus(const AValue: TConvStatus);
begin
  FStatus := AValue;
  if FStatus = stLoading then
    LoadStopped := False;
end;

procedure TsgDXFConverter.SetLoadStopped(const Value: Boolean);
begin
  FLoadStopped := Value;
end;

procedure TsgDXFConverter.SetVPort(const APt: TFPoint);
begin
  ActiveVPort.ViewDirection := APt;
end;

procedure TsgDXFConverter.SetXRefSearchPath(const Value: string);
begin
  XRefSearchPaths.Text := Value;
end;

procedure TsgDXFConverter.DoCreate(Sender: TObject);
begin
  if Assigned(FOnCreate) then
    FOnCreate(Sender);
end;

procedure TsgDXFConverter.DoExtents;
var
  I: Integer;
begin
  for I := 0 to LayoutsCount-1 do
    Layouts[I].Loaded(Self);// corrects Handle value (DoExtents in previous versions)
end;

function TsgDXFConverter.DoFindFont(const AEntity: TsgDXFEntity;
  const ABigFont: Boolean; const AFontName: string): string;
begin
  if not ABigFont then
    Result := sDefaultTTFFont
  else
    Result := sDefaultTTFFontForBigFont;
  if Assigned(FOnFindFont) then
    FOnFindFont(AEntity, Self, ABigFont, AFontName, Result);
end;

procedure TsgDXFConverter.DoModellerMsg(const AObj: TObject; const ACode: Integer;
  const AMsg: string);
var
  vMsg: TsgMessageParams;
begin
  if Assigned(FOnModellerMsg) then
  begin
    vMsg.Code := ACode;
    vMsg.Msg := AMsg;
    FOnModellerMsg(AObj, vMsg);
  end;
end;

procedure CalcAcisNumber(const AEntity: TsgDXFEntity; var ACount: Integer);
var
  I: Integer;
  vEnt: TsgDXFEntity;
begin
  if Assigned(AEntity) then
  begin
    for I := 0 to AEntity.Count - 1 do
    begin
      vEnt := AEntity.Entities[I];
      if vEnt.Is3dObject > 0 then//if vEnt is TsgBrepModEntity then
        Inc(ACount)
      else
      begin
        if vEnt.Count > 0 then
          CalcAcisNumber(vEnt, ACount);
      end;
    end;
  end;
end;

procedure TsgDXFConverter.DoAcisNumberMsg;
var
  vMsg: TsgMessageParams;
begin
  if Assigned(FOnAcisNumberMsg) then
  begin
    if FAcisNumber < 0 then
    begin
      FAcisNumber := 0;
      CalcAcisNumber(Sections[csBlocks], FAcisNumber);
    end;
    vMsg.Code := FAcisNumber;
    vMsg.Msg := 'AcisNumber';
    FOnAcisNumberMsg(nil, vMsg);
  end;
end;

procedure TsgDXFConverter.DoSetEntityPropError(const AEntity: TsgDXFEntity;
  const AParams: TsgMessageParams);
begin
  if Assigned(FOnSetEntityPropError) then
    FOnSetEntityPropError(AEntity, AParams);
end;

procedure TsgDXFConverter.EntityListNotify(const Obj: TObject;
  Action: TListNotification);
begin
  case Action of
    lnAdded:
      begin
        FMapEntities.UnActivateRegister;
      end;
    lnDeleted, lnExtracted:
      begin
        FMapEntities.UnActivateRegister;//??
        //TsgDXFEntity(Obj).Dictionary := nil;
      end;
  end
end;

function TsgDXFConverter.ExchangeParams(AParams: PsgCADIterate): PsgCADIterate;
{$IFDEF SG_OPENING_IN_THEADS}
var
  I: Integer;
  CurrentThreadId: THandle;
begin
  if not Assigned(FCADIterateThreadParams) then
  begin
    FCADIterateThreadParams := TsgCollection.Create;
    FCADIterateThreadParams.Duplicates := dupIgnore;
  end;
{$IFDEF SG_FIREMONKEY}
  if Assigned(TThread.CurrentThread) then
    CurrentThreadId := TThread.CurrentThread.ThreadID
  else
    CurrentThreadId := MainThreadID;
{$ELSE}
  CurrentThreadId := GetCurrentThreadId;
{$ENDIF}
  I := FCADIterateThreadParams.Add(CurrentThreadId, nil);
  Result := FCADIterateThreadParams.List^[I].Data;
  if AParams <> Result then
  begin
    FCADIterateThreadParams.List^[I].Data := AParams;
    if (AParams = nil) and (CurrentThreadId <> MainThreadID) then
      FCADIterateThreadParams.Delete(I);
  end;
end;
{$ELSE}
begin
  Result := FParams;
  FParams := AParams;
end;
{$ENDIF}

procedure TsgDXFConverter.ExcludeFromGroups(const AEnt: TsgDXFEntity);
var
  I: Integer;
begin
  if Assigned(FGroups) then
    for I := 0 to FGroups.Count - 1 do
      TsgCADGroup(FGroups[I]).RemoveEntity(AEnt);
end;

function TsgDXFConverter.ExtractFromTable(const ATable: TsgDXFGroup;
  const AEntity: TsgDXFEntity): TsgDXFEntity;
begin
  Result := nil;
  if (ATable <> nil) and (ATable.Count > 0) then
  begin
    if ATable.RemoveEntity(AEntity) then
      Result := AEntity;
  end;
end;

procedure TsgDXFConverter.Loads(E: TsgDXFEntity);
begin
  E.Loaded(Self);
  Inc(FCount);
end;

procedure TsgDXFConverter.LoadsGroup(E: TsgDXFEntity);
var
  I: Integer;
begin
  SetHandleGroup(E);
  for I := 0 to E.Count - 1 do
    E.Entities[I].LoadedInternal(Self);
  Inc(FCount, E.Count);
end;

procedure TsgDXFConverter.LockLayers;
var
  I: Integer;
  vLayer: TsgDXFLayer;
begin
  for I := 0 to Sections[csLayers].Count - 1 do
  begin
    vLayer := TsgDXFLayer(Sections[csLayers].Entities[I]);
    vLayer.Locked := True;
  end;
end;

procedure TsgDXFConverter.LoadsByClasses(
  const AEntityClasses: array of TsgDXFEntityClass);
var
  I, J, K, C: Integer;
  vEntity: TsgDXFEntity;
  vEntities: TsgDXFEntity;
begin
  for K := Low(AEntityClasses) to High(AEntityClasses) do
    for I := 0 to FBlocksSection.Count - 1 do
    begin
      vEntities := FBlocksSection[I];
      C := vEntities.Count;
      Dec(C);
      for J := 0 to C do
      begin
        vEntity := vEntities[J];
        if Assigned(vEntity) then
        begin
          if vEntity.InheritsFrom(AEntityClasses[K]) then
            vEntity.Loaded(Self)
          else
            if (vEntity.InheritsFrom(TsgDXFXref)) and
               (TsgDXFXref(vEntity).CADImage is TsgCADImage) and
               (TsgCADImage(TsgDXFXref(vEntity).CADImage).Converter <> nil) then
              TsgCADImage(TsgDXFXref(vEntity).CADImage).Converter.LoadsByClasses(AEntityClasses);
        end;
      end;
    end;
end;

function TsgDXFConverter.LTypeByName(const AName: string): TsgDXFLineType;
begin
  Result := nil;
  if FLTypes = nil then
    Exit;
  Result := TsgDXFLineType(FLTypes.FindEntByName(AName));
end;

procedure TsgDXFConverter.MainNotify(const Obj: TObject; Action: TListNotification);
var
  vName: string;
begin
  case Action of
    lnExtracted, lnDeleted:
      begin
        if Obj = FBlocksSection then
          Sections[csBlocks] := nil
        else
        if Obj = FTablesSection then
          Sections[csTables] := nil
        else
        if Obj = FObjectsSection then
        begin
          TsgDXFSection(Obj).OnListNotify := nil;
          Sections[csObjects] := nil;
        end;
      end;
    lnAdded:
      begin
        vName := TsgDXFEntity(Obj).Name;
        if vName = cnstSectionBLOCKS then
          Sections[csBlocks] := TsgDXFSection(Obj)
        else
        if vName = cnstSectionTABLES then
          Sections[csTables] := TsgDXFSection(Obj)
        else
        if vName = cnstSectionOBJECTS then
        begin
          Sections[csObjects] := TsgDXFSection(Obj);
          TsgDXFSection(Obj).OnListNotify := ObjectsNotify;
        end;
      end;
  end;
end;

procedure TsgDXFConverter.ObjectsNotify(const Obj: TObject;
  Action: TListNotification);
var
  vName: string;
  I: Integer;
  Ent: TsgDXFEntity;
begin
  case Action of
    lnDeleted, lnExtracted:
      begin
        Ent := TsgDXFEntity(Obj);
        if Obj = FImageDefs then
          FImageDefs := nil
        else
        if Obj = FMStyles then
          FMStyles := nil
        else
        if Obj = FTableStyles then
          FTableStyles := nil
        else
        if Obj = FLayouts then
          FLayouts := nil
        else
        if Obj = FFieldList then
          FFieldList := nil
        else
        if Obj = FScaleList then
          FScaleList := nil
        else
        if Obj = FGroups then
          FGroups := nil
        else
        if (Ent is TsgDXFDictionary) and Assigned(FLayers) then
          for I := 0 to FLayers.Count - 1 do
            if TsgDXFPenTableItem(FLayers[I]).Dictionary = Ent then
              TsgDXFPenTableItem(FLayers[I]).Dictionary := nil;
      end;
    lnAdded:
      begin
        Ent := TsgDXFEntity(Obj);
        vName := Ent.Name;
        if (vName = cnstObjectsLAYOUTS) or (vName = sAcadLayoutDictionary) then
        begin
          FLayouts := TsgDXFTable(Ent);
          FLayouts.OnListNotify := LayoutsNotify;
//          FLayouts.InternalFlags := FLayouts.InternalFlags or 2;
        end
        else
        if (vName = cnstObjectsIMAGEDEFS) or (vName = sAcadImageDict) then
          FImageDefs := TsgDXFTable(Ent)
        else
        if (vName = cnstObjectsMLINESTYLES) or (vName = sAcadMLineStyleDictionary) then
          FMStyles := TsgDXFTable(Ent)
        else
        if (vName = cnstObjectsTABLESTYLES) or (vName = sAcadTableStyleDictionary) then
          FTableStyles := TsgDXFTable(Ent)
        else
        if (vName = cnstObjectsFIELDLIST) or (vName = sAcadFieldListDictionary) then
          FFieldList := TsgDXFFieldList(Ent)
        else
        if (vName = sAcadScaleListDictionary) or (vName = cnstObjectsSCALELIST) then
          FScaleList := Ent
        else
        if (vName = sAcadGroupDictionary) or (vName = cnstObjectsGROUPS) then
          FGroups := Ent
      end;
  end;
end;

class function TsgDXFConverter.ObjToString(const Sender: TObject): string;
var
  vEnt: TsgDXFEntity;
begin
  if Assigned(Sender) then
  begin
    Result := Sender.ClassName;
    if Sender is TsgDXFEntity then
    begin
      vEnt := TsgDXFEntity(Sender);
      {$IFDEF SG_GLOBALHANDLE}
      Result := Result + ' GlobalHandle=' + IntToStr(vEnt.GlobalHandle);
      {$ENDIF}
      Result := Result + ' Handle=$' + IntToHex(vEnt.Handle, 0);
      if Sender is TsgDXFBlock then
        Result := Result + ' Name=' + TsgDXFBlock(vEnt).Name;
    end;
  end
  else
    Result := 'nil';
end;

class function TsgDXFConverter.CADHatchSetting: TsgHatchSettting;
begin
  Result := cnstCADHatchSetting;
end;

procedure TsgDXFConverter.TablesNotify(const Obj: TObject; Action: TListNotification);
var
  vName: string;
begin
  case Action of
    lnDeleted, lnExtracted:
      begin
        if Obj = FBlockRecords then
          FBlockRecords := nil
        else
        if Obj = FLTypes then
        begin
          //FLTypes.InternalFlags := FLTypes.InternalFlags and not 2;
          FLTypes := nil;
        end
        else
        if Obj = FLayers then
        begin
          //FLayers.InternalFlags := FLayers.InternalFlags and not 2;
          FLayers := nil;
        end
        else
        if Obj = FStyles then
          FStyles := nil
        else
        if Obj = FDimStyles then
          FDimStyles := nil
        else
        if Obj = FVPorts then
          FVPorts := nil
        else
        if Obj = FAppIDs then
          FAppIDs := nil;
      end;
    lnAdded:
      begin
        vName := TsgDXFEntity(Obj).Name;
        if vName = cnstTableBLOCK_RECORD then
          FBlockRecords := TsgDXFTable(Obj)
        else
        if vName = cnstTableLTYPE then
        begin
          FLTypes := TsgDXFTable(Obj);
          FLTypes.InternalFlags := FLTypes.InternalFlags or 2;
        end
        else
        if vName = cnstTableLAYER then
        begin
          FLayers := TsgDXFTable(Obj);
          FLayers.InternalFlags := FLayers.InternalFlags or 2;
        end
        else
        if vName = cnstTableSTYLE then
        begin
          FStyles := TsgDXFTable(Obj);
          FStyles.InternalFlags := FStyles.InternalFlags or 2;
        end
        else
        if vName = cnstTableDIMSTYLE then
        begin
          FDimStyles := TsgDXFTable(Obj);
          FDimStyles.InternalFlags := FDimStyles.InternalFlags or 2;
        end
        else
        if vName = cnstTableVPORT then
          FVPorts := TsgDXFTable(Obj)
        else
        if vName = cnstTableAPPID then
          FAppIDs := TsgDXFTable(Obj);
      end;
  end;
end;

{function TsgDXFConverter.BlockRecordByName(const AName: string): TsgDXFBlockRecord;
begin
  Result := TsgDXFBlockRecord(CustomEntByName(AName, csBlockRecords));
end;}

function TsgDXFConverter.BlockRecordByHandle(
  const AHandle: UInt64): TsgDXFBlockRecord;
begin
  if Counts[csBlockRecords] > 0 then
    Result := TsgDXFBlockRecord(Sections[csBlockRecords].FindEntByHandle(AHandle))
  else
    Result := nil;
end;

function TsgDXFConverter.BlockRecordNameByHandle(const AHandle: UInt64): string;
var
  vBlockRecord: TsgDXFBlockRecord;
begin
  Result := '';
  vBlockRecord := BlockRecordByHandle(AHandle);
  if Assigned(vBlockRecord) then
    Result := vBlockRecord.Name;
end;

function TsgDXFConverter.LayoutByName(AName: string): TsgDXFLayout;
begin
  if Assigned(FLayouts) then
    Result := TsgDXFLayout(FLayouts.FindEntByName(AName))
  else
    Result := nil;
end;

procedure TsgDXFConverter.LayoutsNotify(const Obj: TObject;
  Action: TListNotification);
begin
  case Action of
    lnAdded:
      if Assigned(FOnLayoutAdd) then
        FOnLayoutAdd(Obj);
    lnDeleted, lnExtracted:
      if Assigned(FOnLayoutRemove) then
        FOnLayoutRemove(Obj);
  end;
end;

function TsgDXFConverter.GetLoadStopped: Boolean;
var
  vConv: TsgDXFConverter;
begin
  Result := FLoadStopped;
  if not Result then
  begin
    vConv := GetMainConverter;
    if Assigned(vConv) and (vConv <> Self) then
      Result := vConv.GetLoadStopped;
  end;
end;

function TsgDXFConverter.GetMainConverter: TsgDXFConverter;
begin
  Result := Self;
  while Result.FOwnerConverter <> nil do
    Result := Result.FOwnerConverter;
end;

function TsgDXFConverter.GetNumberOfPartsInCircle: Integer;
begin
  Result := FNumberOfPartsInCircle;
  if HasDispersionFactor then
    Result := iMaxNumberOfPart;
end;

function TsgDXFConverter.GetNumberOfPartsInSpline: Integer;
begin
  Result := FNumberOfPartsInSpline;
  if HasDispersionFactor then
    Result := iMaxNumberOfPart;
end;

function TsgDXFConverter.GetModelLayout: TsgDXFLayout;
begin
  // Model is Layout with zero-index
  Result := TsgDXFLayout(FLayouts.Entities[0]);
end;

function TsgDXFConverter.GetModeller: TsgModeller;
begin
{$IFNDEF SG_NO_USE_KERNEL3D}
  if Assigned(FModellerLinker) then
    Result := FModellerLinker.Modeller
  else
{$ENDIF}  
    Result := nil;
end;

function TsgDXFConverter.GetModelMatrix: TFMatrix;
begin
  Result := GetModelLayout.RotMatrix;
end;

type
  TAddFPoint = function(const Item: TFPoint): Integer of object;

function CastToAddPt(const AAddFPoint: TAddFPoint): TAddPt;{$IFDEF SG_INLINE} inline;{$ENDIF}
begin
  TMethod(Result) := TMethod(AAddFPoint);
end;

function TsgDXFConverter.GetModPolylines(ACompound: TsgModPartCompound;
  ACollection: TsgCustomPolyItemsCollection;
  var AParams: TsgBrepModIterateParams): Integer;
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  I, J, K: Integer;
  vInsert: TsgModPartInstance;
  vShape, vSubShape: TsgModTopoShape;
  vSavedMatrix: TsgMatrix4d;
  vCollection: TNewCollection;
  vAddPt: TAddPt;
  vReversedPoly: TFPointList;

  function DoEnumPolyNodes(ANode: TsgModMeshPolylineNode;
    const ACollect: TAddPt): TFPoint;
  begin
    while Assigned(ANode) do
    begin
      Result := ANode.Point;
      ACollect(Result);
      ANode := ANode.Next;
    end;
  end;

  procedure CollectPoly(const APoly: TsgModMeshPolyline; const ACollect: TAddPt);
  begin
    if Assigned(APoly) then
      DoEnumPolyNodes(APoly.FirstNode, ACollect);
  end;

begin
  Result := 0;
  if not Assigned(ACompound) then
    Exit;
  vReversedPoly := nil;
  //Shapes
  if ACompound.ShapesCount > 0 then
  try
    vCollection := ACollection.NewCollection;
    I := 0;
    repeat
      vShape := ACompound.Shape[I];
      if vShape.GetShapeType = btWire then
      begin
        vAddPt := vCollection();
        for J := 0 to vShape.SubShapesCount - 1 do
        begin
          vSubShape := vShape.SubShape[J];
          if vSubShape.GetShapeType = btEdge then
          begin
            case vShape.SubShapeOrientation[J] of
              bsoForward:  CollectPoly(TsgModTopoEdge(vSubShape).ExtractFirstPolyline, vAddPt);
              bsoReversed:
                begin
                  if vReversedPoly = nil then
                    vReversedPoly := TFPointList.Create;
                  CollectPoly(TsgModTopoEdge(vSubShape).ExtractFirstPolyline,
                    CastToAddPt(vReversedPoly.Add));
                  for K := vReversedPoly.Count - 1 downto 0 do
                    vAddPt(vReversedPoly.List^[K]);
                  vReversedPoly.Clear;
                end;
            else
            end;
          end;
        end;
      end;
      Inc(I);
    until I >= ACompound.ShapesCount;
  finally
    vReversedPoly.Free;
  end;

  //Parts
  vSavedMatrix := AParams.Matrix;
  try
    for I := 0 to ACompound.InsertCount - 1 do
    begin
      vInsert := ACompound.Insert[I];
      AParams.Matrix := MatrixMultiplyFast(vInsert.FullMatrix, vSavedMatrix); //!!
      ACollection.UpdateTransformation(AParams.Matrix, {$IFDEF HAS_UNMANAGED_TYPEINFO}TypeInfo(TsgMatrix4d){$ELSE}SizeOf(TsgMatrix4d){$ENDIF});
      GetModPolylines(vInsert.Compound, ACollection, AParams);
    end;
  finally
    AParams.Matrix := vSavedMatrix;
  end;
{$ELSE}
begin
  Result := 0;
{$ENDIF}  
end;

function TsgDXFConverter.GetNumberOfCirclePartsByRadius(const ARadius: Double): Integer;
var
  vAngleStep,vDelta,vRadius: Double;
  vScale: TFPoint;
  vMaxNumberParts: Integer;
  vParams: PsgCADIterate;
  vRegenDelta: Double;
begin
  vParams := Params;
  vRegenDelta := GetMainConverter.FRegenDelta;
  if Assigned(vParams) and RegenerateArcs and not IsZero(vRegenDelta) and not IsZero(ARadius) then
  begin
    if HighQualityRegenerateArcs then
      vMaxNumberParts := iMaxNumberOfPart
    else
      vMaxNumberParts := iDefaultNumberOfCircleParts;
    vScale := ExtractMatrixAbsoluteScale(Params^.RegenScale);
    vRadius := ARadius * Max(Max(vScale.X, vScale.Y), vScale.Z);
    if vRegenDelta < 2*vRadius then
      vDelta := vRegenDelta
    else
      vDelta := vRadius / 2;
    vAngleStep := (vDelta * vDelta) / (2 * vRadius * vRadius);
    if vAngleStep < 2 then
    begin
      vAngleStep := RadToDeg(ArcCos(1 - vAngleStep));
      if IsZero(vAngleStep) then
        Result := vMaxNumberParts
      else
        Result := MinI(MaxI(2, Trunc(360/vAngleStep)), vMaxNumberParts);
    end
    else
      Result := NumberOfPartsInCircle;
  end
  else
    Result := NumberOfPartsInCircle;
end;

function TsgDXFConverter.GetNumberOfCirclePartsByBulge(const P1,P2: TFPoint;
  const ABulge: Double): Integer;
var
  vCenter: TFPoint;
  vRadius: Double;
begin
  vCenter := GetCenterOfBulge(P1, P2, ABulge);
  vRadius := DistanceFPoint(P1, vCenter);
  Result := GetNumberOfCirclePartsByRadius(vRadius);
end;

function TsgDXFConverter.NewEntity(AOwner: TsgDXFEntity;
  AClass: TsgDXFEntityClass): TsgDXFEntity;
begin
  Result := NewNamedEntity(AOwner, AClass, '');
end;

function TsgDXFConverter.NewNamedEntity(AOwner: TsgDXFEntity;
  AClass: TsgDXFEntityClass; const AName: string): TsgDXFEntity;
begin
  Result := nil;
  if Assigned(AOwner) then
    Result := AOwner.FindEntByName(AName);
  if not Assigned(Result) then
  begin
    Result := AClass.Create;
    DoCreate(Result);
    Result.SetConverter(Self);
    Result.SetName(AName);
    if Assigned(AOwner) and (AOwner.AddEntity(Result) < 0) then
      FreeAndNil(Result);
  end;
end;

function TsgDXFConverter.NewNamedTable(const AName: string;
  AClassType: TsgDXFEntityClass): TsgDXFTable;
var
  vTableClass: TsgDXFEntityClass;
begin
  vTableClass := AClassType;
  if vTableClass = nil then
    vTableClass := TsgDXFTable;
  Result := TsgDXFTable(NewNamedEntity(Sections[csTables], vTableClass, AName));
  Loads(Result); // to set handle
end;

function TsgDXFConverter.NewTable(const AType: TConvSection): TsgDXFTable;
begin
  Result := NewNamedTable(cnstSectionNames[AType].Name,
    cnstSectionNames[AType].ClassType);
end;

function TsgDXFConverter.Pos: TsgNativeUInt;
begin
  if FSource = nil then
    Result := 0
  else
    Result := TsgNativeUInt(FPos) - TsgNativeUInt(FSource.Memory);
end;

function TsgDXFConverter.GetExtents: TFRect;
begin
  Result.TopLeft := HeadVarStruct.ExtMin;
  Result.BottomRight := HeadVarStruct.ExtMax;
  SwapDoubles(Result.Top, Result.Bottom);
end;

function TsgDXFConverter.GetFieldList: TsgDXFFieldList;
begin
  if not Assigned(FFieldList) then
  begin
    FFieldList := TsgDXFFieldList(Sections[csObjects].FindEntByName(cnstObjectsFIELDLIST));
    if not Assigned(FFieldList) then
      FFieldList := TsgDXFFieldList(NewNamedEntity(Sections[csObjects], TsgDXFFieldList,
        cnstObjectsFIELDLIST));
  end;
  Result := FFieldList;
end;

procedure TsgDXFConverter.Reference;
begin
  Inc(FRefs);
end;

procedure TsgDXFConverter.InitRegeneration(const ABlock: TsgDXFBlock;
  const ADelta: Double);
begin
  Status := stRegeneration;
  //ABlock.FRegenFlags := 1;
  FRegenDelta := ADelta;
end;

class procedure TsgDXFConverter.RegisterXRefGraphicClass(AExt: string;
  AGraphicClass: TGraphicClass);
begin
  if (Length(AExt) > 0) and (AExt[1] <> '.') then
    AExt := '.' + AExt;
  if not Assigned(XRefFileClasses) then
    XRefFileClasses := CreateStringListSorted(dupIgnore, False);
  XRefFileClasses.AddObject(AExt, TsgObjectWithField.CreateClass(AGraphicClass));
end;

function TsgDXFConverter.ReInitBlockByEntities(const AInserts: TList): Boolean;
var
  I: Integer;
begin
  if Assigned(AInserts) then
  begin
    Result := False;
    for I := 0 to AInserts.Count - 1 do
      if SetBlockByInsert(AInserts.List[I], Self) then
        Result := True;
  end
  else
    Result := IterateEntitiesInBlocks(@SetBlockByInsert);
end;

procedure TsgDXFConverter.Release;
begin
  if FRefs > 0 then
    Dec(FRefs);
  if FRefs > 0 then
    Exit;
  if FStatus = stLoading then
  begin
    StopLoading;
    Status := stDefault;
  end
  else
    Free;
end;

{function TsgDXFConverter.SortEntities: Boolean;
var
  vSortBlocks: TsgList;
  J, CntJ: Integer;
  vSortEntTable: TsgDXFSortEntsTable;
begin
  vSortBlocks := TsgList.Create;
  try
    vSortBlocks.Sorted := True;
    for J := 0 to LayoutsCount - 1 do
      vSortBlocks.Add(Layouts[J].PaperSpaceBlock);
    if (FSortEntsTables <> nil) and (FSortEntsTables.Count > 0) then
    begin
      CntJ := FSortEntsTables.Count - 1;
      for J := 0 to CntJ do
      begin
        vSortEntTable := TsgDXFSortEntsTable(FSortEntsTables[J]);
        SortEntitiesByHandle(vSortEntTable, vSortEntTable.SortObject);
        vSortBlocks.Remove(vSortEntTable.SortObject);
      end;
    end;
    for J := 0 to vSortBlocks.Count - 1 do
      TsgDXFGroup(vSortBlocks[J]).SortEntByHandle;
    //Result := SortEntitiesInZDepth;
    Result := True;
  finally
    vSortBlocks.Free;
  end;
end;}
procedure TsgDXFConverter.SortEntities;
var
  I: Integer;
  vBlockRecords: TsgDXFBlockRecords;
  vBlock: TsgDXFEntity;
  vSortEntTable: TsgDXFSortEntsTable;
  vDictionary: TsgDXFDictionary;
begin
  vBlockRecords := TsgDXFBlockRecords(FBlockRecords);
  if Assigned(vBlockRecords)  then
  begin
    for I := 0 to vBlockRecords.Count - 1 do
    begin
      vDictionary := TsgDXFDictionary(vBlockRecords[I].Dictionary);
      if Assigned(vDictionary) then
      begin
        vSortEntTable := TsgDXFSortEntsTable(vDictionary.FindEntByName(sAcadSortEnts));
        if Assigned(vSortEntTable) then
        begin
          vBlock := vSortEntTable.SortObject;
          if vBlock is TsgDXFBlockRecord then
            vBlock := TsgDXFBlockRecord(vBlock).Block;
          if not Assigned(vBlock) then
            vBlock := TsgDXFBlockRecord(vBlockRecords[I]).Block;
          if Assigned(vBlock) then
            SortEntitiesByHandle(vSortEntTable, vBlock);
          {vDictionary.RemoveEntity(vSortEntTable);
          vSortEntTable.Free;
          if vDictionary.Count = 0 then
          begin
            vBlockRecords[I].Dictionary := nil;
            if vDictionary.Owner <> nil then
            begin
              vDictionary.Owner.RemoveEntity(vDictionary);
              vDictionary.Free;
            end;
          end;}
        end;
      end;
    end;
  end
  else
    SortEntitiesInZDepth;
end;

procedure TsgDXFConverter.SortEntitiesByHandle(const ATable, ABlock: TsgDXFEntity);
begin
  if (ATable <> nil) and (ABlock <> nil) then
    TsgDXFSortEntsTable(ATable).SortEntities(ABlock);
end;

function TsgDXFConverter.SortEntitiesInZDepth: Boolean;
var
  I, Cnt: Integer;
  vBox: TFRect;
  Z0: Double;
  vIsNeedSort: Boolean;
begin
  vIsNeedSort := False;
  if FEntities.Count > 1 then
  begin
    vIsNeedSort := False;
    vBox := FEntities[0].GetBox;
    Z0 := (vBox.Z1 + vBox.Z2) * 0.5;
    Cnt := FEntities.Count - 1;
    I := 0;
    while (not vIsNeedSort) and (I <= Cnt) do
    begin
      vBox := FEntities[I].GetBox;
      vIsNeedSort := vIsNeedSort or (Abs(Z0 - (vBox.Z1 + vBox.Z2) * 0.5) > fAccuracy);
      Inc(I);
    end;
    if vIsNeedSort then
      QSortArrayBounds(FEntities.FEntities.List, CompareZDepthEntities, 0, FEntities.FEntities.Count - 1);
  end;
  Result := vIsNeedSort;
end;

procedure TsgDXFConverter.StopLoading;
begin
  if FSource <> nil then
    FPos := FSource.Memory;
  LoadStopped := True;
end;

function TsgDXFConverter.DimensionStyleByName(const AName: string): TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(CustomEntByName(AName, csDimStyles));
end;

function TsgDXFConverter.StyleByName(const AName: string): TsgDXFStyle;
var
  vName: string;
begin
  if AName = '' then
    vName := sStandardName
  else
    vName := UpperCase(AName);
  Result := TsgDXFStyle(CustomEntByName(vName, csStyles));
end;

function TsgDXFConverter.StyleByPrimaryFont(const AName: string): TsgDXFStyle;
var
  I: Integer;
begin
  Result := nil;
  if (Length(AName) > 0) and (FStyles <> nil) then
  begin
    for I := 0 to FStyles.Count - 1 do
    begin
      if TsgDXFStyle(FStyles.Entities[I]).GetPrimaryFontName = AName then
      begin
        Result := TsgDXFStyle(FStyles.Entities[I]);
        Break;
      end;
    end;
  end;
end;

function TsgDXFConverter.TableStyleByName(
  const AName: string): TsgDXFAcadTableStyle;
begin
  Result := TsgDXFAcadTableStyle(CustomEntByName(AName, csTableStyles));
end;

class procedure TsgDXFConverter.UnRegisterXRefGraphicClass(
  AGraphicClass: TGraphicClass);
var
  I: Integer;
  C: TGraphicClass;
  Obj: TsgObjectTClass;
begin
  if not Assigned(XRefFileClasses) then
    Exit;
  I := 0;
  while I < XRefFileClasses.Count do
  begin
    Obj := TsgObjectTClass(XRefFileClasses.Objects[I]);
    C := TGraphicClass(Obj.FieldClass);
    if C.InheritsFrom(AGraphicClass) then
    begin
      XRefFileClasses.Delete(I);
      Obj.Free;
    end
    else
      Inc(I);
  end;
end;

procedure TsgDXFConverter.UpdateAcAuthEnvironBlockRecord(ABlockRecord: TsgDXFBlockRecord);
var
  vAcAuthEnvironAppId, vEnvironBlockRecord: TsgDXFEntity;
  vData: TsgCADExtendedData;
  I: Integer;
  vEEDItems: TsgObjectCollection;
begin
  if RenderThroughAcAuthEnviron then
  begin
    if Assigned(Sections[csAppID]) then
    begin
      vAcAuthEnvironAppId := Sections[csAppID].FindEntByName(cnstAcAuthEnviron);
      if Assigned(vAcAuthEnvironAppId) then
      begin
        vEEDItems := EEDItems[ABlockRecord.Handle];
        if Assigned(vEEDItems) then
        begin
          I := vEEDItems.IndexOf(vAcAuthEnvironAppId.Handle);
          if I >= 0 then
          begin
            vData := TsgCADExtendedData(vEEDItems.Objects[I]);
            if Assigned(vData) and (vData.DataCount > 1) and
               (vData.DataType[1] = edtInt64) and
               (vData.DataCode[1] = String_1005) and
               (vData.DataInt64[1] <> ABlockRecord.Handle) then
            begin
              vEnvironBlockRecord := TsgDXFBlockRecord(Sections[csBlockRecords].FindEntByHandle(vData.DataInt64[1]));
              if Assigned(vEnvironBlockRecord) then
              begin
                ABlockRecord.FAuthEnviron := TsgDXFBlockRecord(vEnvironBlockRecord);
                vEnvironBlockRecord.AddDestroyNotification(ABlockRecord.AuthEnvironDestroing);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TsgDXFConverter.UpdateProgressLoaded(AState: Integer);
var
  vCurTick: Cardinal;
  vPercent: Integer;
  vSenderPercent: sgConsts.TsgObjectInt64;
begin
  if Assigned(FUpdateEvent) then
  begin
  {$IFNDEF SG_FIREMONKEY}
    vCurTick := GetTickCount;
  {$ELSE}
    vCurTick := TThread.GetTickCount;
  {$ENDIF}
    case AState of
      0://Start
        begin
           FUpdateTickStart := vCurTick;
           FUpdateTickCurrent := FUpdateTickStart;
        end;
      2://end
        begin
          FUpdateTickCurrent := FUpdateTickStart + cnstLimitTimeByHatch;
        end;
    end;
    if (vCurTick - FUpdateTickCurrent > cnstHatchUpdateInterval) or (AState = 2) then
    begin
      vSenderPercent := sgConsts.TsgObjectInt64.Create(0);
      try
        if AState = 2 then
          vPercent := 100
        else
        begin
          if FUpdateTickCurrent = FUpdateTickStart then
            FUpdateEvent(vSenderPercent);
          FUpdateTickCurrent := vCurTick;
          vPercent := Round(((FUpdateTickCurrent - FUpdateTickStart) * 100 / cnstLimitTimeByHatch) * 10) div 10;
        end;
        vSenderPercent.FieldInt := vPercent;
        FUpdateEvent(vSenderPercent);
      finally
        FreeAndNil(vSenderPercent);
      end;
    end;
  end;
end;

procedure TsgDXFConverter.UpdateViewTwistMatrix;
begin
  if Assigned(FActiveVPort) then
    FViewTwistMatrix := GetViewTwistMatrix(ActiveVPort.ViewDirection, ActiveVPort.ViewTwistAngle)
  else
    FViewTwistMatrix := cnstIdentityMat;
  if not IsCrossoverMatrix then
    FViewTwistMatrix := FMatXMat(FViewTwistMatrix, FMatByScales(1, -1, 1));
end;

function TsgDXFConverter.GetActiveVPortUCSMatrix: TFMatrix;
var
  vVPort: TsgDXFVport;
//  vMatUCS: TFMatrix;
  vOffset: TFPoint;
begin
  Result := cnstIdentityMat;
  vVPort := FActiveVPort;
  if not Assigned(vVPort) then
    Exit;
  Result := GetViewTwistMatrix(vVPort.ViewDirection, vVPort.ViewTwistAngle);
  vOffset := SubFPoint(cnstFPointZero, FPointXMat(vVPort.UCSOrigin, Result));
  Result := FMatXMat(Result, FMatByTranslate(vOffset));
//  vMatUCS := cnstIdentityMat;
//  vMatUCS.EX := vVPort.UCSXDir;
//  vMatUCS.EY := vVPort.UCSYDir;
//  Result := FMatXMat(Result, vMatUCS);
end;

procedure TsgDXFConverter.IniProcResolve;
begin
  FOnImageDefResolve := DefaultImageDefResolver;
  FOnSHXResolve := DefaultSHXResolver;
  FOnXRefResolve := DefaultXRefResolver;
  FOnModellerMsg := DefaultModellerMsg;
  FOnAcisNumberMsg := DefaultAcisNumberMsg;
end;

procedure TsgDXFConverter.Initialize;
begin
end;

procedure TsgDXFConverter.DeleteModelLayout;
begin
  if LayoutsCount > 0 then
    FLayouts.DeleteEntity(0).Free;
end;

procedure TsgDXFConverter.DeletePaperLayout;
begin
  if LayoutsCount > 1 then
    FLayouts.DeleteEntity(1).Free;
end;

// Generates a ViewPort for Model_Space
procedure TsgDXFConverter.GenerateDisplayAndModelViewPort(const ALayout: TsgDXFLayout;
  const AWidth, AHeight: Double; const AMode: Integer; const ABox: PFRect = nil);
var
  vRect: TFRect;
  vRatioKoef, vMWidth, vMHeight, vWidth, vHeight: Double;
  vViewPort: TsgDXFViewport;
  vPaperCenter: TFPoint;
begin
  vWidth := AWidth;
  vHeight := AHeight;
  if AMode > 0 then
  begin
    vRect := Layouts[0].Box;
    TransRectCorners(vRect, GetModelMatrix);
    vMWidth := vRect.Right - vRect.Left;
    if vMWidth <= fDoubleResolution then
      vMWidth := fDoubleResolution;
    vMHeight := vRect.Top - vRect.Bottom;
    vRatioKoef := vMHeight / vMWidth;
    vHeight := AWidth * vRatioKoef;
  end;
  vPaperCenter := MakeFPoint(vWidth * 0.5, vHeight * 0.5);
  vViewPort := GenerateDisplayViewPort(vWidth, vHeight);
  ALayout.AddEntity(vViewPort);
  vViewPort.PSpaceCenter := vPaperCenter;
  Loads(vViewPort);
  if cnstCreateViewportInNewLayouts then
  begin
    vViewPort := GenerateModelViewPort(vPaperCenter, vWidth, vHeight, ABox = nil, True);
    if ABox <> nil then
    begin
      vViewPort.MSpaceCenter := MiddleFPoint(ABox^.TopLeft, ABox^.BottomRight);
      vViewPort.MSpaceHeight := Abs(ABox^.Top - ABox^.Bottom);
      Loads(vViewPort);
    end;
    ALayout.AddEntity(vViewPort);
  end;
  Loads(ALayout);
end;

function TsgDXFConverter.GenerateDisplayViewPort(const AWidth,
  AHeight: Double): TsgDXFViewPort;
begin
  Result := TsgDXFViewPort.Create;
  Result.PSpaceCenter := cnstFPointZero;
  Result.PSpaceWidth := AWidth;
  Result.PSpaceHeight := AHeight;
  Result.MSpaceCenter := Result.PSpaceCenter;
  Result.MSpaceHeight := Result.PSpaceHeight;
  Result.Flags := 32800;// ?special invisible Model flag
  Self.Loads(Result);
end;

function TsgDXFConverter.GenerateModelViewPort(const ACenter: TFPoint;
  const AWidth, AHeight: Double; const ALoad: Boolean;
  const AFitModel: Boolean = False): TsgDXFViewPort;
var
  I: Integer;
  vRect: TFRect;
  vMWidth, vMHeight, vKWidth, vKHeight: Double;
begin
  vRect := GetModelLayout.Box;
  TransRectCorners(vRect, GetModelMatrix);
  Result := TsgDXFViewPort.Create;
  // Add Layer by list - flag set is frozen by default in new viewports
  begin
    if Assigned(Result.FrozenLayers) then
      for I := 0 to Counts[csLayers] - 1 do
      begin
        if Layers[I].IsFrozenByNewViewPort then
          Result.FrozenLayers.Add(Layers[I].Handle);
    end;
  end;
//  Result.Flags := $8020;
  Result.Layer := Self.LayerByName(FHeadVarStruct.CLayer);
  Result.PSpaceCenter := ACenter;
  Result.PSpaceWidth := AWidth;
  Result.PSpaceHeight := AHeight;
  Result.MSpaceCenter := MiddleFPoint(vRect.TopLeft, vRect.BottomRight);
  vMHeight := vRect.Top - vRect.Bottom;
  if AFitModel and (AWidth > fDoubleResolution) and (AHeight > fDoubleResolution) then
  begin
    vMWidth := vRect.Right - vRect.Left;
    vKWidth := vMWidth / AWidth;
    vKHeight := vMHeight / AHeight;
    if vKHeight < vKWidth then
      vMHeight := AHeight * vKWidth;
  end;
  Result.MSpaceHeight := vMHeight;
  if Self.IsCrossoverMatrix then
  begin
    Result.ViewDirection := Self.VPort;
    Result.ViewTwistAngle := Self.Angle;
  end
  else
  begin
    Result.ViewDirection := MakeFPoint(0, 0, -1);
    Result.ViewTwistAngle := 180;
  end;
  Result.ThisID := 0;
  Result.StatusField := -1;
  Result.ViewTarget := cnstFPointZero;
  Result.VisibleBoundary := True;
  if ALoad then
    Self.Loads(Result);
end;

function TsgDXFConverter.GetActiveVPort: TsgDXFVPort;
begin
  if FActiveVPort = nil then
    FActiveVPort := TsgDXFVport(CustomEntByName(sActiveVPort, csVPorts));
  Result := FActiveVPort;
end;

function TsgDXFConverter.GetAngle: Single;
begin
  Result := ActiveVPort.ViewTwistAngle;
end;

function TsgDXFConverter.GetBackGroundLayer: TsgDXFLayer;
begin
  Result := LayerByName(cnstBackGroundLayerName);
  Result.FIsPlotting := not bBackGroundLayerNoPlotting;
end;

function TsgDXFConverter.GetBlock(Index: Integer): TsgDXFBlock;
begin
  Result := TsgDXFBlock(FBlocksSection[Index]);
end;

function TsgDXFConverter.GetCount(Index: TConvSection): Integer;
var
  vSection: TsgDXFGroup;
begin
  vSection := Sections[Index];
  if vSection <> nil then
    Result := vSection.Count
  else
    Result := 0;
end;

class function TsgDXFConverter.GetTableItemClasses(const AIndex: TConvSection): TsgDXFEntityClass;
const
  cnstTableItemClasses: array[TConvSection] of TsgDXFEntityClass = (
    TsgDXFTable, TsgDXFBlock, TsgDXFEntity, TsgDXFAppID, TsgDXFLineType,
    TsgDXFLayer, TsgDXFStyle, TsgDXFDimensionStyle, TsgDXFBlockRecord,
    TsgDXFVport, TsgMLineStyle, TsgDXFImageDef, TsgDXFLayout,
    TsgDXFAcadTableStyle, TsgDXFDictionary, TsgDXFClass);
begin
  Result := cnstTableItemClasses[AIndex];
end;

function TsgDXFConverter.GetEEDItems(AEntHandle: UInt64): TsgObjectCollection;
var
  I: Integer;
begin
  Result := nil;
  if AEntHandle <> cnstBadHandle then
  begin
    I := EntityEEDItems.IndexOf(AEntHandle);
    if I >= 0 then
      Result := TsgObjectCollection(EntityEEDItems.Objects[I]);
  end;
end;

function TsgDXFConverter.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FEntities[AIndex];
end;

procedure TsgDXFConverter.ClearEntityProxy;
begin
  TsgObjectList.ClearList(FEntityProxyList);//TsgCollection.FreeList(FEntityProxyList);
end;

function TsgDXFConverter.GetEntityProxy(const AEntity: TObject;
  const APathKey: string): TsgObjEntity3D;
//var
//  I: Integer;
begin
  Result := TsgObjEntity3D.Create;
  SetHandle(Result);
  Result.SetOrgEntityAndKey(AEntity, APathKey);
  FEntityProxyList.Add(Result);//  FEntityProxyList.Add(UInt64(AEntity), Result);

//  Result := nil;
//  I := FEntityProxyList.IndexOf(UInt64(AEntity));
//  if I < 0 then
//  begin
//    Result := TsgEntityProxy.Create;
//    SetHandle(Result);
//    Result.FOriginalEntity := AEntity;
//    FEntityProxyList.Add(UInt64(AEntity), Result);
//  end
//  else
//    Result := TsgEntityProxy(FEntityProxyList.Items[I].Data);
end;

function TsgDXFConverter.GetLayer(Index: Integer): TsgDXFLayer;
begin
  Result := TsgDXFLayer(FLayers[Index]);
end;

function TsgDXFConverter.GetLayout(const AIndex: Integer): TsgDXFLayout;
begin
  if (AIndex >= 0) and (AIndex < LayoutsCount) then
    Result := TsgDXFLayout(FLayouts.Entities[AIndex])
  else
    Result := nil;
end;

function TsgDXFConverter.GetLayoutsCount: Integer;
begin
  Result := Counts[csLayouts];
end;

function TsgDXFConverter.GetImageDef(const Index: Integer): TsgDXFImageDef;
begin
  Result := TsgDXFImageDef(FImageDefs.Entities[Index]);
end;

function TsgDXFConverter.GetStyle(Index: Integer): TsgDXFStyle;
begin
  Result := TsgDXFStyle(FStyles[Index]);
end;

procedure TsgDXFConverter.GetSubEntities(const AList: TList);
  procedure CheckAndCreateByConverter(var AValue: TsgDXFSection;
    AClassType: TsgDXFSectionForXMLExportClass);
  begin
    if AValue = nil then
      AValue := AClassType.CreateByConverter(Self);
  end;
begin
  if Assigned(AList) then
  begin
    AList.Add(GetHeaderSection);
    CheckAndCreateByConverter(FEntitiesSection, TsgDXFSectionEntities);
    AList.Add(FTablesSection);
    AList.Add(FBlocksSection);
    AList.Add(FEntitiesSection);
    AList.Add(FObjectsSection);
  end;
end;

function TsgDXFConverter.GetMainConverter(AMatrix: PFMatrix): TsgDXFConverter;
begin
  Result := Self;
  AMatrix^ := Result.FTransform3D;
  while Result.FOwnerConverter <> nil do
  begin
    Result := Result.FOwnerConverter;
    AMatrix^ := FMatXMat(Result.FTransform3D, AMatrix^);
  end;
end;

function TsgDXFConverter.GetLType(Index: Integer): TsgDXFLineType;
begin
  Result := TsgDXFLineType(FLTypes[Index]);
end;

function TsgDXFConverter.GetSection(Index: TConvSection): TsgDXFGroup;
begin
  Result := nil;
  if Ord(Index) > Ord(High(TConvSection)) then Exit;
  case Index of
    csTables:       Result := FTablesSection;
    csBlocks:       Result := FBlocksSection;
    csDimStyles:    Result := FDimStyles;
    csEntities:     Result := FEntities;
    csLTypes:       Result := FLTypes;
    csLayers:       Result := FLayers;
    csStyles:       Result := FStyles;
    csVPorts:       Result := FVPorts;
    csAppID:        Result := FAppIDs;
    csBlockRecords: Result := FBlockRecords;
    csMLineStyles:  Result := FMStyles;
    csImageDefs:    Result := FImageDefs;
    csLayouts:      Result := FLayouts;
    csTableStyles:  Result := FTableStyles;
    csObjects:      Result := FObjectsSection;
    csClasses:	    Result := FClassesSection;
  end;
end;

function TsgDXFConverter.GetSectionInt(const AIndex: TConvSection): TsgDXFGroup;
var
  vName: string;
begin
  Result := TsgDXFTable(Sections[AIndex]);
  vName := cnstSectionNames[AIndex].Name;
  if not Assigned(Result) then
  begin
    case AIndex of
      csBlockRecords:
        Result := TsgDXFTable(NewNamedEntity(Sections[csTables],
          cnstSectionNames[AIndex].ClassType, vName));
      csTableStyles, csImageDefs, csMLineStyles, csLayouts:
        Result := TsgDXFTable(NewNamedEntity(Sections[csObjects],
          cnstSectionNames[AIndex].ClassType, vName));
    else
      if AIndex = csEntities then
        vName := '';
      Result := NewNamedTable(vName, cnstSectionNames[AIndex].ClassType);
    end;
    Loads(Result);
    Sections[AIndex] := Result;
  end;
end;

function TsgDXFConverter.GetTable(Index: Integer): TsgDXFTable;
begin
  Result := TsgDXFTable(FTablesSection[Index]);
end;

function TsgDXFConverter.GetVersion: TsgDWGVersion;
begin
  Result := TsgDWGVersion(FHeadVarStruct.Version);
end;

function TsgDXFConverter.GetVPort: TFPoint;
begin
  Result := ActiveVPort.ViewDirection;
end;

function TsgDXFConverter.GetVPortByIndex(const AIndex: Integer): TsgDXFVPort;
begin
  Result := TsgDXFVPort(FVPorts[AIndex]);
end;

function TsgDXFConverter.GetXDataProcs: TsgXDataProcs;
begin
{$IFDEF SG_BTI}
  Result := FXDataProcs;
{$ELSE}
  Result := nil;
{$ENDIF}
end;

procedure TsgDXFConverter.GetXmlSectionNames(const ANames: TStrings;
  const AParams: TsgXMLParams);
const
  cnstXMLSectionNames: array[0..4] of string = (cnstXMLHeader, cnstXMLTables,
    cnstXMLBlocks, cnstXMLEntities, cnstXMLObjects);
var
  I: Integer;
begin
  for I := Low(cnstXMLSectionNames) to High(cnstXMLSectionNames) do
  begin
    if SameText(cnstXMLEntities, cnstXMLSectionNames[I]) then
    begin
      if xmAddSectionEntities in AParams.Mode then
        ANames.Add(cnstXMLSectionNames[I]);
    end
    else
      ANames.Add(cnstXMLSectionNames[I]);
  end;
end;

function TsgDXFConverter.GetXRefSearchPath: string;
var
  vLength: Integer;
begin
  Result := '';
  if FXRefSearchPaths <> nil then
  begin
    Result := FXRefSearchPaths.Text;
    vLength := Length(Result);
    if (vLength > 0) and (Result[vLength] = FXRefSearchPaths.LineBreak) then
      Delete(Result, vLength, 1);
  end;
end;

function TsgDXFConverter.GetXRefSearchPaths: TStringList;
begin
  if FXRefSearchPaths = nil then
  begin
    FXRefSearchPaths := TsgStringList.Create;
    FXRefSearchPaths.LineBreak := ';';
    FXRefSearchPaths.Sorted := True;
    FXRefSearchPaths.Duplicates := dupIgnore;
  end;
  Result := FXRefSearchPaths;
end;

procedure TsgDXFConverter.ReplaceLayout(Index: Integer; ALayout: TsgDXFLayout);
var
  vOldLayout: TsgDXFLayout;
  vTmp: TsgDXFBlock;
begin
  if Index >= FLayouts.Count then
    FLayouts.AddEntity(ALayout)
  else
  begin
    vOldLayout := TsgDXFLayout(FLayouts.Entities[Index]);
    if vOldLayout.FPaperSpaceBlock <> nil then
    begin
      vTmp := ALayout.FPaperSpaceBlock;
      ALayout.PaperSpaceBlock := vOldLayout.FPaperSpaceBlock;
      vOldLayout.PaperSpaceBlock := vTmp;
      SwapEntitiesHandle(ALayout.FPaperSpaceBlock, vOldLayout.FPaperSpaceBlock);
      SwapEntitiesHandle(ALayout.FPaperSpaceBlock.BlockRecord, vOldLayout.FPaperSpaceBlock.BlockRecord);
    end;
    FLayouts.SetEntity(Index, ALayout);
    if vOldLayout.FPaperSpaceBlock <> nil then
    begin
      FBlocksSection.RemoveEntity(vOldLayout.FPaperSpaceBlock);
      vOldLayout.FPaperSpaceBlock.Clear(True);
      FreeAndNil(vOldLayout.FPaperSpaceBlock);
    end;
    vOldLayout.Free;
  end;
end;

{procedure TsgDXFConverter.ResetBlockRecords;
var
  vBlockRec: TsgDXFBlockRecord;
  vBlock: TsgDXFBlock;
  I, J: Integer;

  function TryFreeBlockReckord(const AName: string): Boolean;
  var
    vEnt: TsgDXFEntity;
  begin
    Result := False;
    if FBlocksSection.FindEntByName(AName) = nil then
    begin
      vEnt := FBlockRecords.FindEntByName(AName);
      if Assigned(vEnt) then
      begin
        FBlockRecords.RemoveEntity(vEnt);
        vEnt.Free;
        Result := True;
      end;
    end;
  end;

begin
  for I := FBlocksSection.Count - 1 downto 0 do
  begin
    vBlock := TsgDXFBlock(FBlocksSection[I]);
    vBlock.SetConverter(Self);
    vBlockRec := TsgDXFBlockRecord(FBlockRecords.FindEntByName(vBlock.Name));
    if vBlock.BlockRecord <> vBlockRec then
    begin
      if Assigned(vBlockRec) then
      begin
        J := FBlockRecords.IndexOfEntity(vBlockRec);
        FBlockRecords.DeleteEntity(J);
        vBlock.BlockRecord.Clone(vBlockRec);
        vBlockRec.Destroy;
      end
      else
        J := FBlockRecords.Count;
      FBlockRecords.InsertEntity(J, vBlock.BlockRecord);
    end
    else
      if vBlockRec.Name <> vBlock.Name then
        vBlockRec.Name := vBlock.Name;
  end;
  TryFreeBlockReckord(sModelSpace);
  TryFreeBlockReckord(sPaperSpace);
end;}

procedure TsgDXFConverter.ResetHandles;
var
  vSection: TConvSection;
begin
  for vSection := Low(TConvSection) to High(TConvSection) do
    if vSection <> csEntities then
     ResetHandleEntity(Sections[vSection], Self);
end;

procedure TsgDXFConverter.ResolveNotFoundImageDef(AImageDef: TsgDXFImageDef;
  var AFIleName: string; var AIsResolve: Boolean);
var
  vConv: TsgDXFConverter;
begin
  vConv := Self;
  while Assigned(vConv) do
    if Assigned(vConv.FOnImageDefResolve) then
    begin
      vConv.FOnImageDefResolve(AImageDef, vConv, AFIleName, AIsResolve);
      Exit;
    end
    else
      vConv := vConv.FOwnerConverter;
end;

procedure TsgDXFConverter.ResolveNotFoundSHX(AStyle: TsgDXFStyle;
  const ABigFont: Boolean; AFonts: TsgSHXFontList;
  var ASHXFont: string; var AIsResolve: Boolean);
var
  vConv: TsgDXFConverter;
begin
  vConv := Self;
  while Assigned(vConv) do
    if Assigned(vConv.FOnSHXResolve) then
    begin
      vConv.FOnSHXResolve(AStyle, ABigFont, AFonts, ASHXFont, AIsResolve);
      Exit;
    end
    else
      vConv := vConv.FOwnerConverter;
end;

procedure TsgDXFConverter.ResolveNotFoundXRef(AXRef: TsgDXFXref;
  var AFileName: string; var AIsResolve: Boolean);
var
  vConv: TsgDXFConverter;
begin
  vConv := Self;
  while Assigned(vConv) do
    if Assigned(vConv.FOnXRefResolve) then
    begin
      vConv.FOnXRefResolve(AXRef, AFileName, AIsResolve);
      Exit;
    end
    else
      vConv := vConv.FOwnerConverter;
end;

function TsgDXFConverter.RestoreHandle(const ANode: TsgNodeSample): Int64;
begin
  Result := cnstBadHandle;
  if ANode = nil then Exit;
  Result := RestoreHandle(ANode.Value);
end;

function TsgDXFConverter.GetLayerByNode(const ANode: TsgNodeSample): TsgDXFLayer;
begin
  if IsHandleStr(ANode.Value) then
    Result := TsgDXFLayer(Sections[csLayers].FindEntByHandle(ANode.ValueAsHandle))
  else
    Result := LayerByName(ANode.Value);
end;

function TsgDXFConverter.GetLineTypeByNode(const ANode: TsgNodeSample): TsgDXFLineType;
begin
  if IsHandleStr(ANode.Value)  then
  begin
    Result := TsgDXFLineType(Sections[csLTypes].FindEntByHandle(ANode.ValueAsHandle));
    if not Assigned(Result) then
      Result := LTypeByName(sContinuous);
  end
  else
    Result := LTypeByName(ANode.Value);
end;

function TsgDXFConverter.RestoreHandle(const AExtendHandle: string): Int64;
begin
  Result := GetConvExtended.RestoreHandle(AExtendHandle);
end;

procedure TsgDXFConverter.ReLoadEntities(const AType: Integer; ABlockStack: TsgObjectList = nil);
var
  I, J, C: Integer;
  vBlock: TsgDXFBlock;
  vEnt: TsgDXFEntity;
  vCADImage: TsgCADImage;
  vBlockStack: TsgObjectList;
begin
  if FStatus <> stEditing then
  begin
    vBlockStack := ABlockStack;
    if vBlockStack = nil then
    begin
      vBlockStack := TsgObjectList.Create;
      vBlockStack.Duplicates := dupIgnore;
      vBlockStack.Sorted := True;
    end;
    try
      for I := 0 to Counts[csBlocks] - 1 do
      begin
        vBlock := TsgDXFBlock(FBlocksSection[I]);
        C := vBlockStack.Count;
        vBlockStack.Add(vBlock);
        if C <> vBlockStack.Count then
        try
          for J := 0 to vBlock.Count - 1 do
          begin
            vEnt := vBlock.Entities[J];
            if CheckEntTypeByRealod(vEnt, AType) then
              vEnt.Loaded(Self)
            else
              if (vEnt is TsgDXFXref) and (TsgDXFXref(vEnt).CADImage <> nil) and
                 (TsgDXFXref(vEnt).CADImage is TsgCADImage) and
                 (TsgCADImage(TsgDXFXref(vEnt).CADImage).Converter <> nil) then
              begin
                vCADImage := TsgCADImage(TsgDXFXref(vEnt).CADImage);
                if AType and 4 <> 0 then
                begin
                  if AType and 1 <> 0 then
                    vCADImage.Converter.SetNumberOfPartsInCircleInternal(NumberOfPartsInCircle);
                  if AType and 2 <> 0 then
                    vCADImage.Converter.SetNumberOfPartsInSplineInternal(NumberOfPartsInSpline);
                  vCADImage.Converter.ReLoadEntities(AType, vBlockStack);
                end
                else
                begin
                  if AType and 1 <> 0 then
                    vCADImage.Converter.NumberOfPartsInCircle := NumberOfPartsInCircle;
                  if AType and 2 <> 0 then
                    vCADImage.Converter.NumberOfPartsInSpline := NumberOfPartsInSpline;
                end;
              end;
          end;
        finally
          vBlockStack.Remove(vBlock);
        end;
      end;
    finally
      if vBlockStack <> ABlockStack then
        vBlockStack.Free;
    end;
  end;
end;

procedure TsgDXFConverter.SetSection(Index: TConvSection; Value: TsgDXFGroup);
begin
  case Index of
    // sections
    csTables:       FTablesSection := Value as TsgDXFSection;
    csBlocks:       FBlocksSection := Value as TsgDXFSection;
    csObjects:      FObjectsSection := Value as TsgDXFSection;
    // tables
    csDimStyles:    FDimStyles := Value as TsgDXFTable;
    csLTypes:       FLTypes := Value as TsgDXFTable;
    csLayers:       FLayers := Value as TsgDXFTable;
    csStyles:       FStyles := Value as TsgDXFTable;
    csVPorts:       FVPorts := Value as TsgDXFTable;
    csBlockRecords: FBlockRecords := Value as TsgDXFTable;
    csAppID:        FAppIDs := Value as TsgDXFTable;
    // dictionaries
    csImageDefs:    FImageDefs := Value as TsgDXFTable;
    csTableStyles:  FTableStyles := Value as TsgDXFTable;
    csLayouts:      FLayouts := Value as TsgDXFTable;
  end;
end;

function TsgDXFConverter.AddXRef(ACADFile: TObject; AName: string; APos, AScale: TFPoint;
  Rotation: Single; const ALayout: TsgDXFLayout = nil): TsgDXFInsert;
var
  Insert: TsgDXFInsert;
  Xref: TsgDXFXref;
  vLoaded: Boolean;
begin
  Xref := TsgDXFXref.Create;
  XRef.SetConverter(Self);
  Insert := TsgDXFInsert.Create;
  Result := Insert;
  Insert.Layer := Self.LayerByName(HeadVarStruct.CLayer);
  Insert.Block := TsgDXFBlock.Create;
  Insert.Block.Layer := Insert.Layer;
  XRef.Layer := Insert.Block.Layer;
  if Assigned(Self.OnCreate) then
  begin
    Self.OnCreate(Insert);
    Self.OnCreate(Insert.Block);
    Self.OnCreate(Xref);
  end;
  if ACADFile is TsgCADImage then
  begin
    XRef.FCADImage := TsgCADImage(ACADFile);
    InitXRefConverter(TsgCADImage(ACADFile).Converter, Xref);
  end;
  Xref.Name := AName;
  Xref.Loaded(Self);
  Insert.Block.Name := ChangeFileExt(ExtractFileName(AName), '');
  Insert.FPoint := APos;
  Insert.FScale := AScale;
  Insert.FAngle := Rotation;
  Insert.Block.FXref := Xref;
  Insert.Block.AddEntity(Xref);
  Insert.Block.Loaded(Self);
  Insert.Block.XrefPath := AName;// correct XRef path
  Insert.Block.SetFlags(4);      // correct XRef flag
  Insert.Loaded(Self);
  FBlocksSection.AddEntity(Insert.Block);
  if ALayout = nil then
    FEntities.AddEntity(Insert)
  else
  begin
    vLoaded := ALayout.PaperSpaceBlock.IsLoaded;
    try
      ALayout.PaperSpaceBlock.IsLoaded := False;
      ALayout.PaperSpaceBlock.AddEntity(Insert);
      ALayout.PaperSpaceBlock.Loaded(Self);
    finally
      ALayout.PaperSpaceBlock.IsLoaded := vLoaded;
    end;
    ALayout.FBox := ALayout.PaperSpaceBlock.Box;
  end;
end;

function TsgDXFConverter.AddXRefEx(ACADFile: TObject; AName: string; APos, AScale: TFPoint;
  Rotation: Single; ALayout: TsgDXFLayout; const AddXrefLayers: Boolean = True): TsgDXFInsert;
var
  Insert: TsgDXFInsert;
  Xref: TsgDXFXref;
  I: Integer;
  vLayer: TsgDXFLayer;
  vXrefConv: TsgDXFConverter;
  vName: string;
begin
  try
    vName := ChangeFileExt(ExtractFileName(AName), '');
    Insert := TsgDXFInsert.Create;
    Insert.Layer := Self.LayerByName(HeadVarStruct.CLayer);
    Insert.Block := Self.BlockByName(vName);
    if Assigned(Insert.Block) then
    begin
      Insert.Block.FXref := nil;
      Insert.Block.XrefPath := '';
      Insert.Block.Clear(True);
    end
    else
    begin
      Insert.Block := TsgDXFBlock.Create;
      Insert.Block.Name := vName;
      Insert.Block.SetFlags(0);
      FBlocksSection.AddEntity(Insert.Block);
    end;
    Insert.Block.Layer := Insert.Layer;
    Xref := TsgDXFXref.Create;
    XRef.SetOwner(Insert.Block);
    XRef.Layer := Insert.Block.Layer;
    if Assigned(Self.OnCreate) then
    begin
      Self.OnCreate(Insert);
      Self.OnCreate(Insert.Block);
      Self.OnCreate(Xref);
    end;
    vXrefConv := nil;
    if ACADFile is TsgCADImage then
    begin
      vXrefConv := TsgCADImage(ACADFile).Converter;
      Xref.FCADImage := TsgCADImage(ACADFile);
      InitXRefConverter(vXrefConv, Xref);
    end;
    Xref.Name := AName;
    Xref.Loaded(Self);
    if Assigned(vXrefConv) and AddXrefLayers then
      for I := 0 to vXrefConv.Counts[csLayers] - 1 do
        if TsgDXFLayer(vXrefConv.FLayers[I]).NameID <> slrnZero then
        begin
          vLayer := TsgDXFLayer.Create;
          vLayer.AssignEntity(vXrefConv.FLayers[I]);
          vLayer.Name := vName + cnstXRefNameDelimiter + vXrefConv.FLayers[I].Name;
          vLayer.XrefLink := True;
          vLayer.Loaded(Self);
          if FLayers = nil then
            Sections[csLayers] := NewNamedTable(cnstSectionNames[csLayers].Name,
              cnstSectionNames[csLayers].ClassType);
          FLayers.AddEntity(vLayer);
        end;
    Insert.FPoint := APos;
    Insert.FScale := AScale;
    Insert.FAngle := Rotation;
    Insert.Block.IsLoaded := False;
    Insert.Block.AddEntity(Xref);
    Insert.Block.Loaded(Self);
    Insert.Block.XrefPath := AName;// correct XRef path
    Insert.Block.SetFlags(4);      // correct XRef flag
    Insert.Loaded(Self);
    ALayout.PaperSpaceBlock.IsLoaded := False;
    ALayout.PaperSpaceBlock.AddEntity(Insert);
    ALayout.PaperSpaceBlock.Loaded(Self);
    ALayout.FBox := ALayout.PaperSpaceBlock.Box;
    Result := Insert;
  except
    Result := nil;
  end;
end;

procedure TsgDXFConverter.ApplyXRecodData(AFreeList: TsgObjectList);
const
  COLORACI = 'COLORACI';
  COLORTRUE = 'COLORTRUE';
var
  I, J: Integer;
  vCode: SmallInt;
  S: string;
  vColor: TsgColorCAD;
  vItem: TsgTableItem;
  vData: TsgCADExtendedDataAccess;
  vXrecord: TsgDXFEntity;
  vDictionaryReaded: TsgDXFEntity;
  vEntity: TsgDXFEntity;

  function _getobj(handle: UInt64): TsgDXFEntity;
  begin
    Result := nil;
    if Assigned(FMapExternal) then
      Result := TsgDXFEntity(FMapExternal.GetObj(handle));
  end;

  function UpdateDictItem(const AXrecordName: string; var AXRecord: TsgDXFEntity;
    var AData: TsgCADExtendedDataAccess): Boolean;
  begin
    AXRecord := nil;
    AData := nil;
    if Assigned(vDictionaryReaded) then
    begin
      AXRecord := TsgDXFXRecord(vDictionaryReaded.FindEntByName(AXrecordName));
      if Assigned(AXRecord) and AXRecord.InheritsFrom(TsgDXFXRecord) then
        AData := TsgCADExtendedDataAccess(TsgDXFXRecord(AXRecord).Data);
    end;
    Result := Assigned(AData);
  end;

  procedure ClearXRecord(AListIndex: Integer;
    AXRecord: TsgDXFEntity; var AItem: TsgTableItem);
  var
    vItem: TsgOwneredItem;
  begin
    AXrecord.Owner.RemoveEntity(AXrecord);
    vItem := TsgOwneredItem(AXrecord.GetNamedItem);
    if Assigned(vItem) then
    begin
      vItem.ObjAddRef;
      AFreeList.Add(vItem);
    end;
    if AItem.Item.Count = 0 then
    begin
      TObject(FEntityDictionaries.List^[AListIndex].Data) := nil;
      FEntityDictionaries.Delete(AListIndex);
      AItem.Item.Owner.RemoveEntity(AItem.Item);
      AItem.ItemObj.ObjAddRef;
      AFreeList.Add(AItem.ItemObj);
      AItem.Item := nil;// destroy Item if refcount == 0
      FreeAndNil(AItem);
    end;
  end;

  function MTextChekSum(const AStr: sgUnicodeStr): Double;
  var
    K: Integer;
  begin
    Result := 0;
    for K := 1 to Length(AStr) do
      Result := Result + Ord(AStr[K]) * K;
  end;

  function MTextChekSumA(const AStr: AnsiString): Double;
  var
    K: Integer;
  begin
    Result := 0;
    for K := 1 to Length(AStr) do
      Result := Result + ShortInt(Ord(AStr[K])) * K;
  end;

begin
  for I := FEntityDictionaries.Count - 1 downto 0 do
  begin
    vEntity := _getobj(FEntityDictionaries.List^[I].HashCode);
    vItem := TsgTableItem(FEntityDictionaries.List^[I].Data);
    vDictionaryReaded := nil;
    if Assigned(vItem.Item) then
      vDictionaryReaded := _getobj(vItem.Item.Handle);
    if (vDictionaryReaded <> nil) or ((vDictionaryReaded = nil) and (vItem.Item.Owner <> vEntity)) then
      vItem.Item := vDictionaryReaded;

    if UpdateDictItem(sAcadXRecRoundTrip, vXrecord, vData) then
    begin
      if vEntity is TsgDXFLayer then
      begin
        S := '';
        for J := 0 to vData.DataCount - 1 do
        begin
          case vData.DataType[J] of
            edtString:
              if vData.DataCode[J] = 102 then
                S := vData.DataString[J];
            edtInt:
              begin
                if (S = COLORTRUE) and (vData.DataCode[J] = 90) then
                begin
                  vColor.Active := acRGBColor;
                  vColor.Color := BGRToRGB(vData.DataInt[J]);
                  vEntity.ColorCAD := vColor;
                  S := '';
                end;
              end;
            edtInt16:
              begin
                if (S = COLORACI) and (vData.DataCode[J] = 70) then
                begin
                  vColor.Active := acIndexColor;
                  vColor.Color := vData.DataByte[J];
                  vEntity.ColorCAD := vColor;
                  S := '';
                end;
              end;
          end;
        end;
      end
      else
        if vEntity is TsgDXFDimensionStyle then
        begin
          J := 0;
          while (J < vData.DataCount) and (vData.DataCode[J] <> String_1000) do Inc(J);
          if J < vData.DataCount then
            if (vData.DataCode[J] = String_1000) and (vData.DataType[J] = edtString) and (vData.DataString[J] = cnstDStyle) then
              repeat
                if vData.GetCodeFor(J, vCode) and (vCode = Integer_278) then
                begin
                  TsgDXFDimensionStyle(vEntity).DIMDSEP := Char(vData.DataInt16[J]);
                  J := vData.DataCount;
                end
                else
                  Inc(J);
              until J >= vData.DataCount;
        end;
    end
    else
      if UpdateDictItem(sInternalData, vXrecord, vData) and
         (vData.DataCount > 1) and (vData.DataType[1] = edtString) then
      begin
        S := vData.DataString[1];
        if HasInternalDimensionBlockName(S) then
          S := cnstAsterisk + sInternalDimension + IntToStr(vEntity.Owner.IndexOfEntity(vEntity));
        vEntity.Name := S;
        ClearXRecord(I, vXrecord, vItem);
      end
      else
        if (UpdateDictItem(cnstAcadMText2008RT, vXrecord, vData) or
            UpdateDictItem(cnstAcadMTextRT, vXrecord, vData)) and
           (vData.DataCount > 1) and (vData.DataType[1] = edtString) then
        begin
          J := 0;
          //if (System.Pos('{',  TsgDXFMText(vItem.Entity).Text) > 0) or (System.Pos('\U+',  TsgDXFMText(vItem.Entity).Text) > 0) then
          if (vData.DataType[J] = edtDouble) and
            ((MTextChekSum(sgUnicodeStr(ParseUnicode(TsgDXFMText(vEntity).Text, [puU, puM]))) = vData.DataDouble[J]) or
             (MTextChekSumA(ConvertToAnsiString(AdsorbAccentSpaces(TsgDXFMText(vEntity).Text), CodePage)) = vData.DataDouble[J])) then
          begin
            Inc(J);
            S := '';
            while (J < vData.DataCount) and (vData.DataType[J] <> edtString) do Inc(J);
            while (J < vData.DataCount) and (vData.DataType[J] = edtString) do
            begin
              S := S + vData.DataString[J];
              Inc(J);
            end;
            TsgDXFMText(vEntity).Text := S;
          end;
          ClearXRecord(I, vXrecord, vItem);
        end
        else
          if vItem.Item = nil then
          begin
            TObject(FEntityDictionaries.List^[I].Data) := nil;
            FEntityDictionaries.Delete(I);
            vItem.Free;
          end;
  end;
end;

function TsgDXFConverter.ApplyCADHatchSettings(const AEntity: TsgDXFEntity): Boolean;
begin
  Result := False;
  if AEntity.EntType = ceHatch then
  begin
    case CADHatchSetting of
      hsConvertToSolid:
        begin
          if not TsgCADHatch(AEntity).SolidFill then
            Result := True;
        end;
      hsDrawAsSolid:
        TsgCADHatch(AEntity).DrawAsSolid := True;
      hsParserOnDraw:
        TsgCADHatch(AEntity).ParseLineOnDraw := True;
    end;
  end;
end;

procedure TsgDXFConverter.ApplyVariables;
var
  vVarDict: TsgDXFEntity;

  procedure ReleaseVar(AVariable: TsgDXFEntity; var AValue: Byte);
  var
    vVarItem: TsgOwneredItem;
  begin
    if Assigned(AVariable) then
    begin
      AValue := StrToIntDef(TsgDXFDictionaryVar(AVariable).Value, AValue);
      vVarItem := TsgOwneredItem(AVariable.GetNamedItem);
      if Assigned(vVarItem) then
      begin
        TsgDXFEntity(TsgOwneredItem(vVarItem.Owner).Ancestor).RemoveEntity(AVariable);
        if vVarItem.RefCount = 0 then
          AVariable.Free;
      end;
    end;
  end;

begin
  vVarDict := Sections[csObjects].FindEntByName(sAcDbVariableDictionary);
  if Assigned(vVarDict) then
  begin
    ReleaseVar(vVarDict.FindEntByName(sDictionaryVarOLEFRAME), FOleFrame);
    ReleaseVar(vVarDict.FindEntByName(sDictionaryVarXCLIPFRAME), GetPHeadVarStruct^.XClipFrame);
    // notify changes
  end;
end;

function TsgDXFConverter.BlockByName(const AName: string): TsgDXFBlock;
begin
  Result := TsgDXFBlock(FBlocksSection.FindEntByName(AName));
end;

procedure TsgDXFConverter.CADExtendedDataToXMLNode(const AAppID: UInt64;
  const AExtData: TsgCADExtendedData; const ANode: TsgNode);
var
  vNodeAppId, vNodeItem: TsgNode;
  vCountAttrib: TsgNodeSample;
begin
  vNodeAppId := ANode.AddChildNV(cnstXMLNames[xmlApplication].Name);
  if AAppID <> cnstBadHandle then
  begin
    vNodeAppId.AddAttribNV(cnstXMLNames[xmlName].Name).ValueAsStr := Sections[csAppID].FindEntByHandle(AAppID).Name;
    vNodeAppId.AddAttribNV(cnstXMLNames[xmlHandle].Name).ValueAsHandle := AAppID;
  end;
  AExtData.ToXMLNode(vNodeAppId);
  //
  // 0 items application name or handle - skip (code 1001)
  //
  if AAppID <> cnstBadHandle then
  begin
    vNodeItem := TsgNode(vNodeAppId.ChildNodes[0]);
    vNodeAppId.Childs.Delete(0);
    vNodeItem.Free;
    vCountAttrib := vNodeAppId.GetAttributeByName(cnstXMLNames[xmlCount].Name);
    vCountAttrib.ValueAsInt := vCountAttrib.ValueAsInt - 1;
  end;
end;

function TsgDXFConverter.CheckActiveVPort(const AbsHeight: Double): Boolean;
begin
  Result := False;
  if ActiveVPort <> nil then
  begin
    if ActiveVPort.ViewHeight <> 0 then
      Result :=  AbsHeight / ActiveVPort.ViewHeight < 1E-10
    else
      Result := True;
    if Result then
      ActiveVPort := nil;
  end;
end;

{$IFDEF SG_OPENING_IN_THEADS}
procedure TsgDXFConverter.PurgeCADIterateParams;
{$IFDEF MSWINDOWS}
const
  THREAD_QUERY_INFORMATION = $00000040;
  SYNCHRONIZE = $00100000;
var
  I: Integer;
  ThreadId: Cardinal;
  ThreadHandle: Cardinal;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
  I := FCADIterateThreadParams.Count - 1;
  while I >= 0 do
  begin
    ThreadId := FCADIterateThreadParams.List^[I].HashCode;
    ThreadHandle := OpenThread(THREAD_QUERY_INFORMATION or SYNCHRONIZE, False, ThreadId);
    if ThreadHandle <> 0 then
    begin
      if WaitForSingleObject(ThreadHandle, 0) = WAIT_FAILED then
        FCADIterateThreadParams.Delete(I);
      CloseHandle(ThreadHandle);
    end
    else
      FCADIterateThreadParams.Delete(I);
    Dec(I);
  end;
{$ENDIF}
{ TODO: PurgeCADIterateParams implementation for non win platforms }
end;
{$ENDIF}
{function TsgDXFConverter.CheckBlockByName(const ABlock: TsgDXFBlock;
  const AMaxHandle: UInt64): Integer;
var
  I: Integer;
  vBlockPrev: TsgDXFBlock;
  vEnt: TsgDXFEntity;
begin
  Result := 0;
  vBlockPrev := BlockByName(ABlock.Name);
  if Assigned(vBlockPrev) and (vBlockPrev.SpecPaperSpace or (vBlockPrev.Handle > AMaxHandle)) then
  begin
    if vBlockPrev.References <> nil then
    begin
      for I := vBlockPrev.References.Count - 1 downto 0 do
      begin
        vEnt := vBlockPrev.References[I];
        if vEnt is TsgDXFInsert then
          TsgDXFInsert(vEnt).Block := ABlock
        else
        begin
          if vEnt is TsgDXFDimensionStyle then
            TsgDXFDimensionStyle(vEnt).ReplaceBlock(vBlockPrev, ABlock);
        end;
      end;
    end;
    Result := 1;
    Sections[csBlocks].RemoveEntity(vBlockPrev);
    FreeAndNil(vBlockPrev);
  end;
  if Assigned(vBlockPrev) then
  begin
    Result := 2;
    ABlock.SetConverter(Self);
    ABlock.Name := ABlock.Name + '$' + IntToHex(NativeUInt(ABlock), 0);
  end;
end;}

function TsgDXFConverter.CheckEqualHandle(const AEntity: TsgDXFEntity;
  const AHandles: TsgInt64List; const ALog: TStrings = nil): Integer;
var
  I, vCount: Integer;
  vHandle: UInt64;
begin
  Result := 0;
  if Assigned(AEntity) then
  begin
    if AEntity.Handle = cnstBadHandle then
      SetHandle(AEntity)
    else
    begin
      vCount := AHandles.Count;
      vHandle := AEntity.Handle;
      AHandles.Add(vHandle);
      if AHandles.Count = vCount then
      begin
        Inc(Result);
        while AHandles.Count = vCount do
        begin
          AEntity.Handle := cnstBadHandle;
          SetHandle(AEntity);
          if AEntity.Handle <> cnstBadHandle then
            AHandles.Add(AEntity.Handle)
          else
            Break;
        end;
        if Assigned(ALog) then
          ALog.Add(AEntity.ClassName +'(' + AEntity.EntName + ')'  + ' $' +
            IntToHex(vHandle, 0) +  ' = $' +  IntToHex(AEntity.Handle, 0));
      end;
    end;
    for I := 0 to AEntity.Count - 1 do
      Inc(Result, CheckEqualHandle(AEntity[I], AHandles));
  end;
end;

function TsgDXFConverter.CheckEqualHandles(const ALog: TStrings = nil): Integer;
var
  vSection: TConvSection;
  vHandles: TsgInt64List;
  vEntity: TsgDXFEntity;
begin
  Result := 0;
  vHandles := TsgInt64List.Create;
  try
    vHandles.Sorted := True;
    vHandles.Duplicates := dupIgnore;
    for vSection := Low(TConvSection) to High(TConvSection) do
    begin
      vEntity := Sections[vSection];
      Inc(Result, CheckEqualHandle(vEntity, vHandles, ALog));
    end;
    Inc(Result, CheckEqualHandle(Sections[csObjects], vHandles, ALog));
  finally
    vHandles.Free;
  end;
end;

function TsgDXFConverter.CheckHandle(var AHandle: UInt64): Boolean;
begin
  Result := AHandle = cnstBadHandle;
  if Result then
  begin
    Inc(FMaxHandle);
    AHandle := FMaxHandle;
  end
  else
    if FMaxHandle < AHandle then
      FMaxHandle := AHandle;
end;

function TsgDXFConverter.CheckUnicode: Boolean;
begin
{$IFNDEF SG_NON_WIN_PLATFORM}
  Result := (Self.ImportMode = imImport) or (Win32Platform <> VER_PLATFORM_WIN32_NT);
{$ELSE}
  Result := Self.ImportMode = imImport;
{$ENDIF}
end;

procedure TsgDXFConverter.CleaningLayouts(ADeletePSpace: Boolean);
var
  I: Integer;
  vLayout: TsgDXFLayout;
begin
  I := 2;
  while I <= FLayouts.Count - 1 do
  begin
    vLayout := TsgDXFLayout(FLayouts[I]);
    if vLayout.IsEmpty  then
    begin
      if Assigned(vLayout.FPaperSpaceBlock) then
      begin
        FBlocksSection.RemoveEntity(vLayout.FPaperSpaceBlock);
        vLayout.FPaperSpaceBlock.Free;
      end;
      FLayouts.DeleteEntity(I).Free
    end
    else
      Inc(I);
  end;
  if ADeletePSpace then
    DeletePaperLayout;
end;

function TsgDXFConverter.GetCodePage: Integer;
begin
  Result := FHeadVarStruct.CodePage;
end;

function TsgDXFConverter.GetConvExtended: TsgConverterExtented;
begin
  if not Assigned(FConvExtended) then
    FConvExtended := TsgConverterExtented.Create(Self);
  Result := FConvExtended;
end;

function TsgDXFConverter.GetCircleZoomPercent: Integer;
begin
  Result := ActiveVPort.CircleZoomPercent;
end;

function TsgDXFConverter.GetDefaultLayoutIndex: Integer;
begin
  if FDefaultLayoutIndex = -1 then
  begin
    if (FHeadVarStruct.TileMode = 0) and (LayoutsCount > 1) then
      FDefaultLayoutIndex := 1
    else
      FDefaultLayoutIndex := 0;
  end;
  Result := FDefaultLayoutIndex;
end;

function TsgDXFConverter.GetLTScale: Double;
begin
  Result := FHeadVarStruct.LTScale;
end;

{$IFDEF SG_OPENING_IN_THEADS}
function TsgDXFConverter.GetParams: PsgCADIterate;
var
  I: Integer;
  CurrentThreadId: THandle;
begin
  Result := nil;
  if Assigned(FCADIterateThreadParams) then
  begin
{$IFDEF SG_FIREMONKEY}
    if Assigned(TThread.CurrentThread) then
      CurrentThreadId := TThread.CurrentThread.ThreadID
    else
      CurrentThreadId := MainThreadID;
{$ELSE}
    CurrentThreadId := GetCurrentThreadId;
{$ENDIF}
    I := FCADIterateThreadParams.IndexOf(CurrentThreadId);
    if I >= 0 then
      Result := PsgCADIterate(FCADIterateThreadParams.List^[I].Data);
  end;
end;
{$ENDIF}

function TsgDXFConverter.GetPHeadVarStruct: PsgHeadVarStruct;
begin
  Result := @FHeadVarStruct;
end;

{$IFDEF SG_VERSION_OLD}
function TsgDXFConverter.GetPaperSpace: Boolean;
begin
  Result := False;
end;
{$ENDIF}

function TsgDXFConverter.GetPointDisplayMode: Integer;
begin
  Result := FHeadVarStruct.PointDisplayMode;
end;

class function TsgDXFConverter.GetPropertyName: string;
begin
  Result := 'Converter';
end;

function TsgDXFConverter.GetReference(AClass: TsgObjectClass;
  AName: string): TsgListObject;
begin
  Result := nil;
  if AClass = TsgDXFLayer then
    Result := LayerByName(AName);
  if AClass = TsgDXFLineType then
    Result := LTypeByName(AName);
end;

function TsgDXFConverter.GetRegenerateArcs: Boolean;
begin
  Result := FQualityRegenerate and 1 <> 0;
end;

function TsgDXFConverter.GetHighQualityRegenerateArcs: Boolean;
begin
  Result := FQualityRegenerate and 2 <> 0;
end;

function TsgDXFConverter.GetTextPolylines(const AText: TsgDXFText; const AList: TList): Integer;
var
  I, J, K: Integer;
  vList: TList;
  vCollection: TsgTextLinesCollection;
begin
  vCollection := TsgTextLinesCollection.Create(TFPointList.Create, True);
  try
    Result := GetTextPolylines(AText, vCollection);
    if Result > 0 then
    begin
      K := 0;
      for I := 0 to vCollection.Counts.Count - 1 do
      begin
        vList := TList.Create;
        AList.Add(vList);
        for J := 0 to vCollection.Counts[I] - 1 do
          AddFPointInList(vList, TFPointList(vCollection.Poly)[K + J]);
        Inc(K, vCollection.Counts[I]);
      end;
    end;
  finally
    vCollection.Free;
  end;
end;

function TsgDXFConverter.GetTextPolylinesList(const AText: TsgDXFText;
  const AList: TsgObjectList): Integer;
var
  vCollection: TsgTextCurvesFPointListCollection;
begin
  vCollection := TsgTextCurvesFPointListCollection.Create(AList, False);
  try
    Result := GetTextPolylines(AText, vCollection);
  finally
    vCollection.Free;
  end;
end;

function TsgDXFConverter.GetTextPolylines(AText: TsgDXFText; ACollection: TsgCustomPolyItemsCollection): Integer;
var
  vText: TsgDXFTextAccess;
  vTextGlyph: TsgTextGlyph;
  vIndex: Integer;
  vMatrix: TFMatrix;
begin
  Result := 0;
  vText := TsgDXFTextAccess(AText);
  if UseSHXFonts and (not vText.WinFont) then
  begin
    vText.GetSHXLinesEx(SHXFonts, ACollection);
    ACollection.Normalize;
    if ACollection.Counts.Count > 0 then
    begin
      Result := 1;   // SHX
      Exit;
    end;
  end;
  vTextGlyph := TsgTextGlyph(TsgDXFStyleAccess(vText.Properties).FFontGlyphRef);
  if not (vTextGlyph is TsgTextGlyph) then
  begin
    vIndex := ContainerOfTextGlyphs.IndexOf(vText.Properties.FontName, vText.Properties.FontStyle, vText.Charset);
    if vIndex >= 0 then
      vTextGlyph := ContainerOfTextGlyphs.TextGlyph[vIndex]
    else
      vTextGlyph := nil;
  end;
  if Assigned(vTextGlyph) then
  begin
    vMatrix := FMatXMat(vText.GetMatrix, PFMatrix(ACollection.Transformation)^);
    ACollection.UpdateTransformation(cnstIdentityMat, {$IFDEF HAS_UNMANAGED_TYPEINFO}TypeInfo(TFMatrix){$ELSE}SizeOf(TFMatrix){$ENDIF});
    vTextGlyph.GetPolyPolyline(vText.Text, vText.UnicodeText, vMatrix, ACollection, vText.Tracking);
    ACollection.Normalize;
    Result := 2;// TTF
  end;
end;

function TsgDXFConverter.GetDictionary(AEntHandle: UInt64): TsgDXFEntity;
var
  I: Integer;
begin
  Result := nil;
  if AEntHandle <> cnstBadHandle then
  begin
    I := FEntityDictionaries.IndexOf(AEntHandle);
    if I >= 0 then
      Result := TsgTableItem(FEntityDictionaries[I].Data).Item;
  end;
end;

function TsgDXFConverter.GetDimStyle(Index: Integer): TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(FDimStyles[Index]);
end;

function TsgDXFConverter.GetDimStyleFromNode(const ANode: TsgNodeSample): TsgDXFDimensionStyle;
var
  vSection: TsgDXFGroup;
begin
  vSection := Sections[csDimStyles];
  if Assigned(vSection) then
  begin
    if IsHandleStr(ANode.Value)  then
      Result := TsgDXFDimensionStyle(vSection.FindEntByHandle(ANode.ValueAsHandle))
    else
      Result := TsgDXFDimensionStyle(vSection.FindEntByName(ANode.Value));
  end
  else
    Result := nil;
end;

function TsgDXFConverter.GetDisplayImageFrame: Boolean;
var
  vRasterVars: TsgCADRasterVariables;
begin
  vRasterVars := TsgCADRasterVariables(Sections[csObjects].FindEntByName(sRasterVariables));
  if vRasterVars <> nil then
    Result := vRasterVars.DisplayImageFrame
  else
    Result := cnstRasterVariablesDisplayImageFrame;
end;

function TsgDXFConverter.GetDrwHyperlinkBase: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropHyperlinkBase)];
end;

function TsgDXFConverter.GetDrwPropAuthor: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropAuthor)];
end;

function TsgDXFConverter.GetDrwPropComments: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropComments)];
end;

function TsgDXFConverter.GetDrwPropCustomSummaryInfo: TStringList;
begin
  if FDrwPropCustomSummaryInfo = nil then
  begin
    FDrwPropCustomSummaryInfo := TStringList.Create;
    CreateDefaultDrawingProp;
  end;
  Result := FDrwPropCustomSummaryInfo;
end;

function TsgDXFConverter.GetDrwPropInfo: TStringList;
begin
  if FDrwPropInfo = nil then
  begin
    FDrwPropInfo := TStringList.Create;
    CreateDefaultDrawingProp;
  end;
  Result := FDrwPropInfo;
end;

function TsgDXFConverter.GetDrwPropKeywords: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropKeywords)];
end;

function TsgDXFConverter.GetDrwPropSavedBy: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropLastSavedBy)];
end;

function TsgDXFConverter.GetDrwPropSubject: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropSubject)];
end;

function TsgDXFConverter.GetDrwPropTitle: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropTitle)];
end;

function TsgDXFConverter.GetDrwRevisionNumber: string;
begin
  Result := DrwPropInfo.Values[IntToStr(cntXCodeDrwPropRevisionNumber)];
end;

function TsgDXFConverter.GetDWGVersion(const S: AnsiString; var AVersion: TsgDWGVersion): Integer;
begin
  Result := sgConsts.GetDWGVersion(S, AVersion);
end;

procedure TsgDXFConverter.SetNumberOfPartsInCircle(const ACount: Integer);
begin
  if FNumberOfPartsInCircle = ACount then
    Exit;
  SetNumberOfPartsInCircleInternal(ACount);
  ReLoadEntities(1);
end;

procedure TsgDXFConverter.SetNumberOfPartsInCircleInternal(const ACount: Integer);
begin
  FNumberOfPartsInCircle := ACount;
  if FNumberOfPartsInCircle <= 1 then
    FNumberOfPartsInCircle := GetNumberOfCircleParts;
end;

procedure TsgDXFConverter.SetNumberOfPartsInSpline(const ACount: Integer);
begin
  if FNumberOfPartsInSpline = ACount then
    Exit;
  SetNumberOfPartsInSplineInternal(ACount);
  ReLoadEntities(2);
end;

procedure TsgDXFConverter.SetNumberOfPartsInSplineInternal(const ACount: Integer);
begin
  FNumberOfPartsInSpline := ACount;
  if FNumberOfPartsInSpline <= 1 then
    FNumberOfPartsInSpline := GetNumberOfSplineParts;
end;

function TsgDXFConverter.ViewTwistMatrix: TFMatrix;
begin
  Result := FViewTwistMatrix;
end;

function TsgDXFConverter.RemoveEntity(AEntity: TsgDXFEntity; DoFree: Boolean): Boolean;
begin
  Result := False;
  if (FEntities <> nil) and FEntities.RemoveEntity(AEntity) then
  begin
    if DoFree then
      AEntity.Free;
    Result := True;
  end;
end;

function TsgDXFConverter.RemoveFromEntitiesWithGeneratedHandles(const AEntity: TsgDXFEntity): Boolean;
begin
  Result := False;
  if FMapEntities.HasGeneratedList then
    Result := FMapEntities.RemoveEntityFromGeneratedList(AEntity);
end;

procedure TsgDXFConverter.DecompositeMLAtt;
var
  I: Integer;
begin
  for I := 0 to Counts[csBlocks] - 1 do
    DoDecompositeMLAtt(Sections[csBlocks][I]);
end;

function TsgDXFConverter.DeleteBlock(ABlock: TsgDXFBlock; DoFree: Boolean): Boolean;
begin
  Result := False;
  if Assigned(ExtractFromTable(FBlocksSection, ABlock)) then
  begin
    if DoFree then
      ABlock.Free;
    Result := True;
  end;
end;

function TsgDXFConverter.DeleteDimStyle(AStyle: TsgDXFDimensionStyle;
  DoFree: Boolean): Boolean;
begin
  Result := False;
  if Assigned(ExtractFromTable(FDimStyles, AStyle)) then
  begin
    if DoFree then
      AStyle.Free;
    Result := True;
  end;
end;

function TsgDXFConverter.GetSHXFont(const AStyle: TsgDXFStyle;
  const ABigFont: Boolean; ASHXFont: string = ''; const AResolve: Boolean = True): TsgSHXFont;
var
  vIsResolve: Boolean;

  function GetFontName(AFontFullName: string): string;
  begin
    Result := ChangeFileExt(ExtractFileName(AFontFullName), '');
  end;

  function IsValidFont(AFont: TsgSHXFont): Boolean;
  var
    vFontName: string;
  begin
    vFontName := GetFontName(AFont.Name);
    Result := sgSameText(vFontName, GetFontName(ASHXFont));
    if ABigFont and (not Result) then
      Result := sgSameText(vFontName, GetFontName(AStyle.FBigFont));
  end;

begin
//  if Length(ASHXFont) = 0 then
//    ASHXFont := AStyle.PrimaryFont;
  Result := nil;
  if (not ABigFont) or ((ABigFont) and (Length(AStyle.FBigFont) > 0)) then
  begin
    Result := SHX.GetSHXFont(FSHXFonts, AStyle.FSHXStyle, ASHXFont, ABigFont);
    if AResolve and ((Result = nil) or (not IsValidFont(Result))) then
    begin
      vIsResolve := False;
      ResolveNotFoundSHX(AStyle, ABigFont, FSHXFonts, ASHXFont, vIsResolve);
      if vIsResolve then
        Result := SHX.GetSHXFont(FSHXFonts, AStyle.FSHXStyle, ASHXFont,
          ABigFont);
    end;
  end;
end;

function TsgDXFConverter.GetSHXFonts: TsgSHXFontList;
begin
  Result := FSHXFonts;
end;

procedure TsgDXFConverter.SetCodePage(ACodePage: Integer);
begin
  FHeadVarStruct.CodePage := ACodePage;
  FCharset := CodepageToCharset(ACodePage);
end;

procedure TsgDXFConverter.SetDisplayImageFrame(const Value: Boolean);
var
  vRasterVars: TsgCADRasterVariables;
begin
  vRasterVars := Sections[csObjects].FindEntByName(sRasterVariables) as TsgCADRasterVariables;
  if vRasterVars = nil then
  begin
    vRasterVars := TsgCADRasterVariables.Create;
    Loads(vRasterVars);
    Sections[csObjects].AddEntity(vRasterVars);
  end;
  vRasterVars.DisplayImageFrame := Value;
end;

procedure TsgDXFConverter.SetDrwHyperlinkBase(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropHyperlinkBase)] := Value;
end;

procedure TsgDXFConverter.SetDrwPropAuthor(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropAuthor)] := Value;
end;

procedure TsgDXFConverter.SetDrwPropComments(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropComments)] := Value;
end;

procedure TsgDXFConverter.SetDrwPropKeywords(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropKeywords)] := Value;
end;

procedure TsgDXFConverter.SetDrwPropSavedBy(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropLastSavedBy)] := Value;
end;

procedure TsgDXFConverter.SetDrwPropSubject(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropSubject)] := Value;
end;

procedure TsgDXFConverter.SetDrwPropTitle(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropTitle)] := Value;
end;

procedure TsgDXFConverter.SetDrwRevisionNumber(const Value: string);
begin
  DrwPropInfo.Values[IntToStr(cntXCodeDrwPropRevisionNumber)] := Value;
end;

function TsgDXFConverter.SetEntDict(const AEnt, ADict: TsgDXFEntity): Integer;
var
  vItem: TsgTableItem;
begin
  Result := -1;
  if AEnt.Handle <> cnstBadHandle then
  begin
    Result := FEntityDictionaries.IndexOf(AEnt.Handle);
    if Result >= 0 then
    begin
      vItem := TsgTableItem(FEntityDictionaries.List^[Result].Data);
      vItem.Item := ADict;
      if ADict = nil then
      begin
        TObject(FEntityDictionaries.List^[Result].Data) := nil;
        FEntityDictionaries.Delete(Result);
        FreeAndNil(vItem);
      end;
    end
    else
      if ADict <> nil then
      begin
        vItem := TsgTableItem.Create;
        Result := FEntityDictionaries.Add(AEnt.Handle, vItem);
        vItem.Item := ADict;
        Pointer(vItem) := nil;
      end
      else
        vItem := nil;
  end;
end;


function TsgDXFConverter.GetEEDByHandle(const AAppID, AHandle: UInt64): TsgCADExtendedData;
var
  vIndex: Integer;
  vEEDList: TsgObjectCollection;
begin
  Result := nil;
  if (AAppID <> cnstBadHandle) and (AHandle <> cnstBadHandle) then
  begin
    vEEDList := EEDItems[AHandle];
    if Assigned(vEEDList) then
    begin
      vIndex := vEEDList.IndexOf(AAppID);
      if vIndex > -1 then
        Result := TsgCADExtendedData(vEEDList.Objects[vIndex]);
    end;
  end;
end;

function TsgDXFConverter.SetEntEED(const AEnt: TsgDXFEntity; AAppID: UInt64;
  AEEData: TsgCADExtendedData): Integer;
var
  I: Integer;
  vPrevData: TObject;
  vItem: TsgObjectCollection;
begin
  Result := -1;
  if (AEnt.Handle <> cnstBadHandle) and Assigned(FEntityEEDItems) then
  begin
    Result := FEntityEEDItems.IndexOf(AEnt.Handle);
    if Result >= 0 then
    begin
      vItem := TsgObjectCollection(FEntityEEDItems.Objects[Result]);
      I := vItem.IndexOf(AAppID);
      if I >= 0 then
      begin
        vPrevData := vItem.Objects[I];
        if AEEData = nil then
        begin
          vItem.Delete(I);
          if vItem.Count = 0 then
          begin
            FEntityEEDItems.Delete(Result);
            vItem.Free;
          end;
        end
        else
          vItem.Objects[I] := AEEData;
        if vPrevData <> AEEData then
          vPrevData.Free;
      end
      else
      begin
        vItem.Add(AAppID, AEEData);
      end;
    end
    else
      if AEEData <> nil then
      begin
        vItem := CreateObjectCollection;
        Result := FEntityEEDItems.Add(AEnt.Handle, vItem);
        vItem.Add(AAppID, AEEData);
      end;
  end;
end;

procedure TsgDXFConverter.SetExtents(const AValue: TFRect);
begin
  FHeadVarStruct.ExtMin := MakeFPoint(AValue.Left, AValue.Bottom, AValue.Z1);
  FHeadVarStruct.ExtMax := MakeFPoint(AValue.Right, AValue.Top, AValue.Z2);
end;

procedure TsgDXFConverter.SetHandleGroup(E: TsgDXFEntity);
var
  I: Integer;
  H: UInt64;
  vCheckHandle: Boolean;
begin
  if (Self = nil) or (E.Count = 0) then Exit;
  H := E.Entities[0].Handle;
  if (FStatus = stLoading) and FMapEntities.HasGeneratedList then
  begin
    if H = cnstBadHandle then
      FMapEntities.AddEntitiesToGeneratedList(E)
    else
    begin
      for I := 0 to E.Count - 1 do
      begin
        H := E.Entities[I].Handle;
        if FMaxHandle < H then
          FMaxHandle := H;
      end;
    end;
  end
  else
  begin
    for I := 0 to E.Count - 1 do
    begin
      H := E.Entities[I].Handle;
      vCheckHandle := CheckHandle(H);
      if vCheckHandle then
        E.Entities[I].Handle := H;
    end;
  end;
end;

procedure TsgDXFConverter.SetHandle(E: TsgDXFEntity);
var
  H: UInt64;
  vCheckHandle: Boolean;
begin
  if Self = nil then Exit;
  H := E.Handle;
  if (FStatus = stLoading) and FMapEntities.HasGeneratedList then
  begin
    if H = cnstBadHandle then
    begin
      if E.CanHaveHandle then
      begin
        E.SetConverter(Self);
        if Assigned(E.Converter) then
          FMapEntities.AddEntityToGeneratedList(E);
      end;
    end
    else
    begin
      if FMaxHandle < H then
        FMaxHandle := H;
    end;
  end
  else
  begin
    vCheckHandle := CheckHandle(H);
    if vCheckHandle then
      E.Handle := H;
  end;
end;

procedure TsgDXFConverter.SetHandSeed(const AMaxHandle: UInt64);
begin
  FMaxHandle := AMaxHandle;
end;

procedure TsgDXFConverter.SetHideWipeouts(const Value: Boolean);
var
  vWipeoutVars: TsgCADWipeoutVariables;
begin
  vWipeoutVars := TsgCADWipeoutVariables(Sections[csObjects].FindEntByName(cntClassDXFWIPEOUTVARIABLES));
  if vWipeoutVars = nil then
  begin
    vWipeoutVars := TsgCADWipeoutVariables.Create;
    Loads(vWipeoutVars);
    Sections[csObjects].AddEntity(vWipeoutVars);
  end;
  vWipeoutVars.DisplayImageFrame := not Value;
end;

procedure TsgDXFConverter.SetImportMode(const Value: TsgImportMode);
begin
  FImportMode := Value;
end;

procedure TsgDXFConverter.SetCrossoverMatrix(const AValue: Boolean);
begin
  FCrossoverMatrix := AValue;
end;

procedure TsgDXFConverter.SetCurversQuality(const AValue: Integer);
begin
  FQualityRegenerate := AValue;
end;

procedure TsgDXFConverter.SetRegenerateArcs(const AValue: Boolean);
begin
  FQualityRegenerate := Integer((FQualityRegenerate and $FFFFFFFE)) or Ord(AValue);
end;

procedure TsgDXFConverter.SetHighQualityRegenerateArcs(const AValue: Boolean);
begin
  FQualityRegenerate := Integer((FQualityRegenerate and $FFFFFFFD)) or (Ord(AValue) shl 1);
end;

procedure TsgDXFConverter.AddACADLayout(ALayout: TsgDXFLayout);
var
  vPaperIndex: Integer;
  vLayoutPrev: Integer;
begin
  ALayout.SetConverter(Self);
  vPaperIndex := GetPaperIndex(ALayout.PaperSpaceBlock.Name);
  case vPaperIndex of
    0: ReplaceLayout(0, ALayout);// setting Model Layout
    1:
      begin
        ALayout.CADSpace := csUndefined;
        ReplaceLayout(1, ALayout);// setting Paper Layout
      end;
  else
    if Assigned(FLayouts) then
      begin
        vLayoutPrev := FLayouts.IndexOfName(ALayout.Name);
        if vLayoutPrev > 1 then
          ReplaceLayout(vLayoutPrev, ALayout)
        else
          AddLayout(ALayout)
      end
      else
        AddLayout(ALayout)
  end; { case }
end;

function TsgDXFConverter.AddDrawingLayout(ACADImage: TObject;
  AName: string): TsgDXFLayout;
begin
  Result := TsgDXFLayout(NewNamedEntity(FLayouts, TsgDXFLayout, AName));
  Result.Loaded(Self);//by set converter
  AddXRef(ACADImage, AName, cnstFPointZero, cnstFPointSingle, 0, Result);
  Result.Loaded(Self);
end;

function TsgDXFConverter.GetAppIDHandle(const AAppIp: string): UInt64;
var
  vEnt: TsgDXFEntity;
begin
  Result := cnstBadHandle;
  if Assigned(FAppIDs) then
  begin
    vEnt := FAppIDs.FindEntByName(AAppIp);
    if Assigned(vEnt) then
      Result := vEnt.Handle;
  end;
end;

function TsgDXFConverter.AddEddNameValue(const AEnt: TsgDXFEntity; const AName,
  AValue: string): Boolean;
var
  vAppIDHandle: Int64;
  vData: TsgCADExtendedData;
  I: INteger;

  procedure AddNameValue;
  begin
    vData.AddInt16(Integer_1070, String_411);
    vData.AddString(String_1000, AName);

    vData.AddInt16(Integer_1070, String_412);
    vData.AddString(String_1000, AValue);
  end;

begin
  Result := False;
  vAppIDHandle := GetAppIdIntHandle(True);
  if vAppIDHandle <> cnstBadHandle then
  begin
    if AEnt.Handle = cnstBadHandle then
      SetHandle(AEnt);
    if AEnt.Handle = cnstBadHandle then
       Exit;
    vData := GetEEDByHandle(vAppIDHandle, AEnt.Handle);
    if Assigned(vData) then
    begin
      I := vData.DataCount - 1;
      if vData.DataCode[I] = String_1002 then
        vData.Delete(I);
      AddNameValue;
      vData.AddString(String_1002, '}');
      Result := True;
    end
    else
    begin
      vData := TsgCADExtendedData.Create(TsgDWGVersion(HeadVarStruct.Version));
      try
        vData.AddString(String_1001, GetAppIdInternal);
        vData.AddString(String_1000, cnstCstXNameValue);
        vData.AddString(String_1002, '{');
        AddNameValue;
        vData.AddString(String_1002, '}');
        SetEntEED(AEnt, vAppIdHandle, vData);
        Result := True;
        vData := nil;
      finally
        vData.Free;
      end;
    end;
  end;
end;

function TsgDXFConverter.GetAppIdIntHandle(const Add: Boolean = True): Int64;
var
  vEntAppID: TsgDXFAppID;
begin
  if FAppIdIntHandle = cnstBadHandle then
  begin
    FAppIdIntHandle := GetAppIDHandle(GetAppIdInternal);
    if Add and (FAppIdIntHandle = cnstBadHandle) then
    begin
      if not Assigned(FAppIDs) then
        CustomEntByName(GetAppID, csAppID, True);
      vEntAppID := TsgDXFAppID.Create;
      try
        vEntAppID.Name := GetAppIdInternal;
        Loads(vEntAppID);
        FAppIdIntHandle := vEntAppID.Handle;
      finally
        FAppIDs.AddEntity(vEntAppID);
      end;
    end;
  end;
  Result := FAppIdIntHandle;
end;

function TsgDXFConverter.GetEddNameValue(const AEnt: TsgDXFEntity;
  var AName, AValue: string; const AStrings: TStrings = nil): Boolean;
var
  I, vCode: Integer;
  vData: TsgCADExtendedData;
  vFindAppId: Boolean;
begin
  Result := False;
  AName := '';
  AValue := '';
  vData := GetEEDByHandle(GetAppIdIntHandle(False), AEnt.Handle);
  if Assigned(vData) then
  begin
    vFindAppId := False;
    vCode := -1;
    I := 0;
    while I < vData.DataCount do
    begin
      case vData.DataCode[I] of
        String_1000:
          begin
            case vCode of
              String_411:  AName := vData.DataString[I];
              String_412:
                begin
                  AValue := vData.DataString[I];
                  if Assigned(AStrings) then
                    AStrings.Add(AName + AStrings.NameValueSeparator + AValue)
                  else
                    Break;
                end;
            else
              if vFindAppId and SameText(vData.DataString[I], cnstCstXNameValue) then
                Result := True;
            end;
            vCode := -1;
          end;
        String_1001:
          begin
            if SameText(vData.DataString[I], GetAppID) then
              vFindAppId := True
            else
              Break;
          end;
        Integer_1070:
          begin
            if vCode > -1 then
            begin
              vCode := -1;
            end
            else
              vCode := vData.DataInt16[I];
          end;
      end;
      Inc(I);
    end;
  end;
end;

procedure TsgDXFConverter.AddEntitiesWithGeneratedHandles(const AEntity: TsgDXFEntity);
begin
  if FMapEntities.HasGeneratedList then
    FMapEntities.AddEntityToGeneratedList(AEntity);
end;

function TsgDXFConverter.AddLayout(ALayout: TsgDXFLayout): Integer;
begin
  ALayout.SetConverter(Self);
  Result := FLayouts.AddEntity(ALayout);
end;

function TsgDXFConverter.ToXMLWithParams(const AParentNode: TsgNode;
  const AParams: TsgXMLParams): TsgNode;
var
  I, J: Integer;
  vList: TList;
  vSection: TsgDXFSection;
  vXMLName: TsgStringList;
begin
  Result := ToXMLWithParamsBase(AParentNode, AParams);
  vXMLName := TsgStringList.Create;
  vList := TList.Create;
  try
    GetSubEntities(vList);
    if Assigned(vList) then
    begin
      GetXmlSectionNames(vXMLName, AParams);
      vXMLName.CaseSensitive := False;
      vXMLName.Sorted := True;
      for I := 0 to vList.Count - 1 do
      begin
        vSection := TsgDXFSection(vList[I]);
        if Assigned(vSection) then
        begin
          J := vXMLName.IndexOf(vSection.Name);
          if J > -1 then
            vSection.ToXMLWithParams(Result, AParams);
        end;
      end;
    end;
  finally
    vList.Free;
    vXMLName.Free;
  end;
end;

function TsgDXFConverter.ToXMLWithParamsBase(const AParentNode: TsgNode;
  const AParams: TsgXMLParams): TsgNode;
begin
  Result := inherited ToXMLWithParams(AParentNode, AParams);
end;

function TsgDXFConverter.AddLineType(const ALTypeName: string;
  const AUniform: Integer; const ADashes: array of Double): TsgDXFEntity;
begin
  Result := nil;
  if Sections[csLTypes] <> nil then
    Result := Sections[csLTypes].FindEntByName(ALTypeName);
  if Result = nil then
  begin
    Result := CustomEntByName(ALTypeName, csLTypes);
    if Result <> nil then
    begin
      Result.Lines.Initialize(ADashes);
      Result.Lines.Uniform := AUniform;
      Loads(Result);
    end;
  end;
end;

procedure TsgDXFConverter.FillMainSection;
begin
  if FMain <> nil then
  begin
    if Main.IndexOfEntity(Sections[csTables]) < 0 then
      Main.AddEntity(Sections[csTables]);
    if Main.IndexOfEntity(Sections[csBlocks]) < 0 then
      Main.AddEntity(Sections[csBlocks]);
    if Main.IndexOfEntity(Sections[csObjects]) < 0 then
      Main.AddEntity(Sections[csObjects]);

    if Assigned(FBlockRecords) and (Sections[csTables].IndexOfEntity(FBlockRecords) < 0) then
      Sections[csTables].AddEntity(FBlockRecords);
    if Assigned(FImageDefs) and (Sections[csObjects].IndexOfEntity(FImageDefs) < 0) then
      Sections[csObjects].AddEntity(FImageDefs);
    if Assigned(FMStyles) and (Sections[csObjects].IndexOfEntity(FMStyles) < 0) then
      Sections[csObjects].AddEntity(FMStyles);
    if Assigned(FLayouts) and (Sections[csObjects].IndexOfEntity(FLayouts) < 0) then
      Sections[csObjects].AddEntity(FLayouts);
    if Assigned(FTableStyles) and (Sections[csObjects].IndexOfEntity(FTableStyles) < 0) then
      Sections[csObjects].AddEntity(FTableStyles);
    if Assigned(FFieldList) and (Sections[csObjects].IndexOfEntity(FFieldList) < 0) then
      Sections[csObjects].AddEntity(FFieldList);
  end;
end;

function TsgDXFConverter.DeleteLayout(ALayout: TsgDXFLayout): Boolean;
begin
  Result := ALayout <> GetModelLayout;
  if Result then
    FLayouts.RemoveEntity(ALayout);
end;

function TsgDXFConverter.GetTransform3d: TFMatrix;
begin
  Result := FTransform3D;
end;

procedure TsgDXFConverter.SetTransform3d(AMatrix: TFMatrix);
begin
  FTransform3D := AMatrix;
end;

function TsgDXFConverter.GetUCS(ALayout: TsgDXFLayout): TFMatrix;
var
  Matr: TFMatrix;
  XDir, YDir, ZDir, vShift: TFPoint;

  function BuildZVector(X, Y: TFPoint): TFPoint;
  begin
    Result := MakeFPoint(X.Y * Y.Z - X.Z * Y.Y,
                         Y.X * X.Z - X.X * Y.Z,
                         X.X * Y.Y - Y.X * X.Y);
  end;

  function PtXMat(const P: TFPoint; const M: TFMatrix): TFPoint;
    function Part(I: Integer): Extended;
    begin
      Result := P.X * M.M[I,0] + P.Y * M.M[I,1] + P.Z * M.M[I,2];
    end;
  begin
    Result.X := Part(0);
    Result.Y := Part(1);
    Result.Z := Part(2);
  end;

  procedure BuildMatr;
  var
    I: Integer;
  begin
    ZDir := BuildZVector(XDir, YDir);
    for I := 0 to 2 do
    begin
      Matr.M[0, I] := XDir.V[I];
      Matr.M[1, I] := YDir.V[I];
      Matr.M[2, I] := ZDir.V[I];
      Matr.M[3, I] := 0;
    end;
    vShift := PtXMat(vShift, Matr);
    for I := 0 to 2 do
      Matr.M[3, I] := - vShift.V[I];
  end;

begin
  if ALayout.IsModel then
  begin
    if not ActiveVPort.UCSVP then
    begin
      vShift := GetHeadVarAsFPt('$UCSORG');
      XDir := GetHeadVarAsFPt('$UCSXDIR');
      YDir := GetHeadVarAsFPt('$UCSYDIR');
    end
    else
    begin
      vShift := ActiveVPort.UCSOrigin;
      XDir := ActiveVPort.UCSXDir;
      YDir := ActiveVPort.UCSYDir;
    end;
  end
  else
  // if ALayout.PaperSpace = 1 then
  begin
    vShift := MakeFPoint(0,0,0);
    XDir := MakeFPoint(1,0,0);
    YDir := MakeFPoint(0,1,0);
  end;
  {else
  brgin
    vShift := ALayout.UCSOrigin;
    XDir := ALayout.UCSXDir;
    YDir := ALayout.UCSYDir;
  end;}
  BuildMatr;
  Result := Matr;
end;

function TsgDXFConverter.QueryCorrectBlockName(const AName, ABaseName: string; const ABlock: TsgDXFBlock): string;
var
  vName: string;
var
  vBlocks: TsgDXFTable;
  vIndex: Integer;
begin
  vName := GetNameCorrect(AName);
  if vName = '' then
    vName := ABaseName + '_' + IntToStr(TsgNativeUINT(ABlock));
  // generate unique block name
  vBlocks := TsgDXFTable(Sections[csBlocks]);
  vIndex := vBlocks.Count;
  Result := vName;
  while Assigned(vBlocks.FindEntByName(Result)) do
  begin
    Result := vName + '_' + IntToStr(vIndex);
    Inc(vIndex);
  end;
end;

function TsgDXFConverter.GetUniqueBlockName(const ABaseName: string;
  AIndex: PInteger = nil): string;
var
  vBlocks: TsgDXFTable;
  vIndex: Integer;
begin
  vBlocks := TsgDXFTable(Sections[csBlocks]);
  if AIndex = nil then
  begin
    vIndex := vBlocks.Count - 1;
    AIndex := @vIndex;
  end;
  // generate unique block name
  repeat
    Inc(AIndex^);
    Result := ABaseName + IntToStr(AIndex^);
  until not Assigned(vBlocks.FindEntByName(Result));
end;

function TsgDXFConverter.GetHeaderSection: TsgDXFSection;
begin
  if not Assigned(FHeaderSection) then
    FHeaderSection := TsgDXFSectionHeader.CreateByConverter(Self);
  Result := FHeaderSection;
end;

function TsgDXFConverter.GetHeadVarAsFPt(AName: string): TFPoint;
begin
  if AName = '$UCSORG' then
    Result := FHeadVarStruct.UCSORG
  else
    if AName = '$UCSXDIR' then
      Result := FHeadVarStruct.UCSXDir
    else
      if AName = '$UCSYDIR' then
        Result := FHeadVarStruct.UCSYDir
      else
        Result := cnstFPointSingle;
end;

function TsgDXFConverter.GetHideWipeouts: Boolean;
var
  vWipeoutVars: TsgCADWipeoutVariables;
begin
  vWipeoutVars := TsgCADWipeoutVariables(Sections[csObjects].FindEntByName(cntClassDXFWIPEOUTVARIABLES));
  if vWipeoutVars <> nil then
    Result := not vWipeoutVars.DisplayImageFrame
  else
    Result := not cnstWipeoutVariablesDisplayImageFrame;
end;

procedure TsgDXFConverter.InitializeSections;
begin
  InitializeSectionsBegin;
end;

procedure TsgDXFConverter.InitializeSectionsBegin;
var
  I: TConvSection;
begin
  for I := csLTypes to csVPorts do
    if I <> csEntities then
      Sections[I] := NewTable(I);
  FillMainSection;
end;

procedure TsgDXFConverter.InitXRefConverter(const AXRefConv: TsgDXFConverter;
  const AXRef: TsgDXFXref);
begin
  if Assigned(AXRefConv) then
  begin
    AXRefConv.FContainerXref := AXRef;
    AXRefConv.FOwnerConverter := Self;
  end;
end;

function TsgDXFConverter.CheckEntName(var AName: string;
  const ASection: TConvSection; const AAfterLoad: Boolean): Boolean;
const
  sDefaultName: string = sStandardName;
var
  vIndex: Integer;
begin
  Result := False;
  if AAfterLoad then
  begin
    vIndex := GetSectionInt(ASection).IndexOfName(AName);
    if vIndex < 0 then
    begin
      AName := sDefaultName;
      Result := True;
    end;
  end;
  if (not Result) and (not IsNameCorrect(AName)) then
  begin
    AName := sDefaultName;
    Result := True;
  end;
end;

procedure TsgDXFConverter.InitializeSectionsEnd(const AFinalizationLoading: Boolean = False);
var
  I: TConvSection;
  J: Integer;
  vLayers: TsgDXFGroup;
  vLineType: TsgDXFLineType;
  vDimStyle: TsgDXFDimensionStyle;
begin
  if Self.Sections[csLTypes] = nil then
    Sections[csLTypes] := NewNamedTable(cnstSectionNames[csLTypes].Name,
      cnstSectionNames[csLTypes].ClassType);
  CustomEntByName(sByLayer, csLTypes);
  CustomEntByName(sByBlock, csLTypes);
  CustomEntByName(sContinuous, csLTypes);
  CheckEntName(FHeadVarStruct.TextStyle, csStyles, AFinalizationLoading);
  CustomEntByName(HeadVarStruct.TextStyle, csStyles);
  CheckEntName(FHeadVarStruct.DimStyle, csDimStyles, AFinalizationLoading);
  vDimStyle := TsgDXFDimensionStyle(CustomEntByName(HeadVarStruct.DimStyle, csDimStyles));
  if not Assigned(vDimStyle.DIMTXSTY) then
  begin
    CheckEntName(FHeadVarStruct.DimTextStyle, csStyles, AFinalizationLoading);
    vDimStyle.DIMTXSTY := TsgDXFStyle(CustomEntByName(HeadVarStruct.DimTextStyle, csStyles));
  end;
  if Self.StyleByName(sStandardName) = nil then
  begin
  end;
  if Self.DimensionStyleByName(sStandardName) = nil then
  begin
  end;
  for I := csTables to csVPorts do
    if I <> csEntities then
    begin
      if Sections[I] = nil then
        Sections[I] := NewTable(I);
      TsgDXFTable(Sections[I]).Loaded(Self);
    end;
  CustomEntByName(GetAppID, csAppID);
  vLineType := LTypeByName(sContinuous);
  vLayers := Sections[csLayers];
  for J := 0 to vLayers.Count - 1 do
    if (vLayers.Entities[J].LineType = nil) then
      vLayers.Entities[J].LineType := vLineType;
  if (LayoutsCount > 1) and (Layouts[1] <> nil) then
    CleaningLayouts(Layouts[1].IsEmpty);
  FreeEntitiesWithGeneratedHandles;
end;

function TsgDXFConverter.FindEntityByHandle(const AHandle: UInt64): TsgDXFEntity;
begin
  Result := Sections[csEntities].FindEntByHandle(AHandle);
end;

function TsgDXFConverter.FindObjByHandle(const AHandle: UInt64): TsgDXFEntity;
begin
  FMapEntities.ActivateRegister;
  Result := FMapEntities.GetEntityByHandle(AHandle);
end;

function TsgDXFConverter.FindObjByHandles(const AHandles: TsgInt64List;
  const AEntities: TList; const AGroup: TsgDXFEntity = nil): Integer;

  procedure FindInHandles(const ASection: TsgDXFEntity;
    const AHandlesCur: TsgInt64List; const AEntities: TList);
  var
    J, vIndex: Integer;
    vHandle: UInt64;
    vEntity: TsgDXFEntity;
  begin
    for J := 0 to ASection.Count - 1 do
    begin
      vIndex := -1;
      vEntity := ASection.Entities[J];
      vHandle := vEntity.Handle;
      if vHandle > AHandlesCur.First then
      begin
        if vHandle < AHandlesCur.Last then
          vIndex := AHandlesCur.IndexOf(vHandle)
        else
          if vHandle = AHandlesCur.Last then
            vIndex := AHandlesCur.Count - 1;
      end
      else
      begin
        if vHandle = AHandlesCur.First then
          vIndex := 0;
      end;
      if vIndex > -1 then
      begin
        AEntities.Add(vEntity);
        AHandlesCur.Delete(vIndex);
        if AHandlesCur.Count < 1 then
          Break;
      end
      else
      begin
        if vEntity.Count > 0 then
        begin
          FindInHandles(vEntity, AHandlesCur, AEntities);
          if AHandlesCur.Count < 1 then
            Break;
        end;
      end;
    end;
  end;

var
  I: Integer;
  vSection: TsgDXFGroup;
  vHandles: TsgInt64List;
begin
  Result := AEntities.Count;
  vHandles := TsgInt64List.Create;
  try
    vHandles.AppendDynArray(AHandles);
    vHandles.ProcCompare := sgComparer.TsgPointerTypeComparer.CmpUInt64;
    if not AHandles.Sorted then
      vHandles.Sorted := True;
    if Assigned(AGroup) then
      FindInHandles(AGroup, vHandles, AEntities)
    else
    begin
      for I := Low(cnstSectionsByFindObject) to High(cnstSectionsByFindObject) do
      begin
        vSection := Sections[cnstSectionsByFindObject[I]];
        if not Assigned(vSection) then
          Continue;
        FindInHandles(vSection, vHandles, AEntities);
        if vHandles.Count = 0 then
          Break;
      end;
    end;
  finally
    Result := AEntities.Count - Result;
    vHandles.Free;
  end;
end;

function TsgDXFConverter.FindObjByHandles(const AHandles: TList;
  const AEntities: TList; const AGroup: TsgDXFEntity = nil): Integer;
var
  I: Integer;
  vHandles: TsgInt64List;
begin
  vHandles := TsgInt64List.Create;
  try
    vHandles.Capacity := AHandles.Count;
    for I := 0 to AHandles.Count - 1 do
      vHandles.Add(PInt64(AHandles[I])^);
    vHandles.ProcCompare := sgComparer.TsgPointerTypeComparer.CmpUInt64;
    vHandles.Sorted := True;
    Result := FindObjByHandles(vHandles, AEntities, AGroup);
  finally
    vHandles.Free;
  end;
end;

function TsgDXFConverter.ForwardToModeler(const AHandle: string;
  const APathKey: string = ''): TsgObjEntity3D;
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  vModeller: TsgModeller;
  vCompound: TsgModPartCompound;
  vEntity: TsgModEntity;
{$ENDIF}
begin
  Result := nil;
{$IFNDEF SG_NO_USE_KERNEL3D}
  vModeller := GetModeller;
  if not Assigned(vModeller) then
    Exit;
  if Length(AHandle) > 0 then
  begin
    vCompound := vModeller.Root[False];
    vEntity := vCompound.FindEntity(StrToInt(AHandle));
    if Assigned(vEntity) then
    begin
      Result := GetEntityProxy(vEntity, APathKey);
    end;
  end;
{$ENDIF}
end;

procedure TsgDXFConverter.HeadVarStructInit;
begin
  FHeadVarStruct := cnstDefHeadVarStruct;
end;

{$IFDEF SG_VERSION_OLD}
procedure TsgDXFConverter.SetPaperSpace(const AValue: Boolean);
begin
end;
{$ENDIF}

{$IFDEF SG_OPENING_IN_THEADS}
procedure TsgDXFConverter.SetParams(const Value: PsgCADIterate);
begin
  ExchangeParams(Value);
end;
{$ENDIF}

procedure TsgDXFConverter.SetPointDisplayMode(const Value: Integer);
begin
  FHeadVarStruct.PointDisplayMode := Value;
end;

procedure TsgDXFConverter.SetLTScale(const Value: Double);
begin
  FHeadVarStruct.LTScale := Value;
end;

procedure TsgDXFConverter.SetModellerLinker(const ALinker: TsgModellerLinker);
begin
  FreeAndNil(FModellerLinker);
  FModellerLinker := ALinker;
end;

function TsgDXFConverter.GetIs3D: Boolean;
begin
  Result := (VPort.X <> 0) or (VPort.Y <> 0);
end;

function TsgDXFConverter.QueryModeller(const ATryCreate: Boolean): TsgModeller;
begin
{$IFNDEF SG_NO_USE_KERNEL3D}
  if (not Assigned(FModellerLinker)) and ATryCreate then
    FModellerLinker := TsgModellerLinker.Create(TsgModeller.Create, True);
  if Assigned(FModellerLinker) then
    Result := FModellerLinker.Modeller
  else
{$ENDIF}  
    Result := nil;
end;

function TsgDXFConverter.QueryXInfo(var AAppFileVer: string; var AVerified: Boolean): Boolean;
var
  I: Integer;
  vAppID, vDictionary, vXInfo: TsgDXFEntity;
  vExtData: TsgCADExtendedDataAccess;
  vVer: UInt64;
  vVerW: array[0..3] of Word absolute vVer;
  vRead, vCalc: UInt64;
  vData: TsgExtData;
begin
  Result := False;
  vAppID := Sections[csAppID].FindEntByName(GetAppID);
  if Assigned(vAppID) then
  begin
    vDictionary := vAppID.Dictionary;
    if Assigned(vDictionary) then
    begin
      vXInfo := vDictionary.FindEntByName('XINFO');
      if Assigned(vXInfo) then
      begin
        vVer := 0;
        vRead := 0;
        vCalc := 0;
        vExtData := TsgCADExtendedDataAccess(TsgDXFXRecord(vXInfo).Data);
        for I := 0 to vExtData.DataCount - 1 do
        begin
          vData := vExtData.Data[I];
          case vData.ECode of
            310: vVer := PUInt64(vData.EData)^;
            311: vRead := PUInt64(vData.EData)^;
            312: vCalc := PUInt64(vData.EData)^;
          end;
        end;
        AVerified := vRead = vCalc;
        AAppFileVer := Format('%d.%d.%d.%d', [vVerW[3], vVerW[2], vVerW[1], vVerW[0]]);
        Result := True;
      end;
    end;
  end;
end;

{ TsgDXFEntity }

procedure TsgDXFEntity.Clear(const ADoFree: Boolean = True);
begin
end;

procedure TsgDXFEntity.ClearEED;
var
  vConv: TsgDXFConverter;
begin
  vConv := Converter;
  if Assigned(vConv) then
    vConv.ClearEntEED(Self);
end;

procedure TsgDXFEntity.ClearReferences;
begin
  ExcludeFromGroups;
  ClearEED;
  GroupClear;         // clear group (after export)
  Dictionary := nil;
  LineType := nil;
  Layer := nil;
  SetConverter(nil);
end;

procedure TsgDXFEntity.GroupClear;
begin
end;

procedure TsgDXFEntity.Clone(const Source: TsgDXFEntity);
begin
  AssignEntity(Source);
  SetHandleFromBase(Self, Source);
end;

constructor TsgDXFEntity.Create;
begin
  inherited Create;
  {$IFDEF SG_GLOBALHANDLE}
  Inc(GlobalIndex);
  GlobalHandle := GlobalIndex;
  GlobalList.Add(Self);
  {$ENDIF}
{$IFDEF SG_MODULE_LOG}
  Log.Add('$' + IntToHex(TsgNativeUInt(Self), 0) + ' := '+ ClassName + '.Create;');
{$ENDIF}
  LineWeight := fLineWeightByLayer;
end;

function TsgDXFEntity.GroupCreate(AConverter: TsgDXFConverter = nil): Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.AddEntUseInsert(const AEntity: TsgDXFEntity): Integer;
begin
  Result := Count;
  if not InsertEntity(Result, AEntity) then
    Result := -1;
end;

function TsgDXFEntity.AddHandleItem(const AItem: TsgDXFEntity): Integer;
begin
  Result := -1;
end;

function TsgDXFEntity.AddItem(const AItem: TObject): Integer;
begin
  Result := -1;
end;

function TsgDXFEntity.GetAnnotative: Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.ToXMLWithParams(const AParentNode: TsgNode;
  const AParams: TsgXMLParams): TsgNode;
begin
  Result := inherited ToXMLWithParams(AParentNode, AParams);
  ToXMLSubEntities(Result, AParams);
end;

function TsgDXFEntity.AddDestroyNotification(
  const ANotify: TNotifyEvent): Integer;
var
  vList: TsgNotifyEventsList;
begin
  Result := -1;
  if GetDestroyNotifications(vList, Assigned(ANotify)) then
    Result := vList.Add(ANotify);
end;

function TsgDXFEntity.AddEntity(const AEntity: TsgDXFEntity): Integer; // overridden in BLOCK, POLYLINE etc.
begin
  Result := AddEntUseInsert(AEntity);
end;

function TsgDXFEntity.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := nil;
end;

function TsgDXFEntity.DeleteHandleItem(const AItem: TsgDXFEntity): Integer;
begin
  Result := -1;
end;

function TsgDXFEntity.DeleteItem(const AItem: TObject): Integer;
begin
  Result := -1;
end;

destructor TsgDXFEntity.Destroy;
begin
  {$IFDEF SG_GLOBALHANDLE}
  GlobalHandle := -GlobalHandle;
  GlobalList.Remove(Self);
  {$ENDIF}
{$IFDEF SG_READER_DEBUG}
  if Assigned(GlobalEntityDestroyNotification) then
    GlobalEntityDestroyNotification(Self);
{$ENDIF}
  // clear subentities
  Clear;
  // clear references to layer, linetype, blockrecord...
  ClearReferences;
  inherited Destroy;
end;

function TsgDXFEntity.EEDItemsToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vAppID: UInt64;
  vNodeEEDItems: TsgNode;
  vEEDItems: TsgObjectCollection;
  vExtData: TsgCADExtendedData;
begin
  Result := 0;
  vEEDItems := EEDItems;
  if Assigned(vEEDItems) then
  begin
    Result := vEEDItems.Count;
    vNodeEEDItems := ANode.AddChildNV(cnstXMLNames[xmlEedList].Name);
    vNodeEEDItems.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := Result;
    for I := 0 to vEEDItems.Count - 1 do
    begin
      vAppID := vEEDItems[I].HashCode;
      vExtData := TsgCADExtendedData(vEEDItems.Objects[I]);
      Converter.CADExtendedDataToXMLNode(vAppID, vExtData, vNodeEEDItems);
    end;
  end;
end;

procedure TsgDXFEntity.EndExtData(const AData: TsgCADExtendedData);
begin
end;

function TsgDXFEntity.Is3dObject: Integer;
begin
  Result := 0;
end;

class function TsgDXFEntity.IsConverterClearing(const AConv: TsgDXFConverter): Boolean;
begin
  Result := False;
  if Assigned(AConv) then
    Result := (AConv.Status in [stClearing, stDestroying]){$IFDEF SG_BTI}or AConv.FPreclean{$ENDIF};
end;

function TsgDXFEntity.IsEqualExtDataName(const AData: TsgCADExtendedData;
  const AName: string): Boolean;
begin
  Result := AData.IsEqualName(AName);
end;

function TsgDXFEntity.EntName: string;
begin
  Result := GetClassEntName(Self);
end;

procedure TsgDXFEntity.ExchangeEntity(AIndex1, AIndex2: Integer);
var
  vTmp: TsgDXFEntity;
begin
  vTmp := Entities[AIndex1];
  SetEntity(AIndex1, Entities[AIndex2]);
  SetEntity(AIndex2, vTmp);
end;

procedure TsgDXFEntity.ExcludeFromGroups;
var
  vConverter: TsgDXFConverter;
begin
  vConverter := Converter;
  if Assigned(vConverter) then
    vConverter.ExcludeFromGroups(Self);
end;

function TsgDXFEntity.FindChildByHandle(const AHandle: UInt64; ADeep: Integer = 0): TsgDXFEntity;
var
  I: Integer;
begin
  Result := nil;
  I := IndexOfHandle(AHandle);
  if I >= 0 then
    Result := Entities[I]
  else
    if ADeep <> 0 then
    begin
      Dec(ADeep);
      I := 0;
      while (I < Count) and not Assigned(Result) do
      begin
        Result := Entities[I].FindChildByHandle(AHandle, ADeep);
        Inc(I);
      end;
    end;
end;

function TsgDXFEntity.FindEntByDescription(const ADescription: string): TsgDXFEntity;
var
  I: Integer;
begin
  Result := nil;
  I := Count - 1;
  while (I >= 0) and not Assigned(Result) do
    if Entities[I].Description = ADescription then
      Result := Entities[I]
    else
      Dec(I);
end;

function TsgDXFEntity.FindEntByHandle(const AHandle: UInt64; ADeep: Integer = 0;
  const AIterateInsert: Boolean = False): TsgDXFEntity;
begin
  Result := FindChildByHandle(AHandle, ADeep);
  if not Assigned(Result) and AIterateInsert and IsInsert then
  begin
    if Assigned(TsgDXFInsert(Self).Block) then
      Result := TsgDXFInsert(Self).Block.FindEntByHandle(AHandle, ADeep, AIterateInsert);
  end;
end;

function TsgDXFEntity.FindEntByName(const AName: string): TsgDXFEntity;
var
  vIndex: Integer;
begin
  Result := nil;
  vIndex := IndexOfName(AName);
  if vIndex > -1 then
    Result := Entities[vIndex];
end;

procedure TsgDXFEntity.FreeInstance;
begin
  // free object-fields created by this entity
  FreeReferences;
{$IFDEF SG_CALC_INSTANCE_SIZES}
  Dec(TotalAllocated, InstanceSize);
{$ENDIF}
  inherited FreeInstance;
end;

procedure TsgDXFEntity.FreeReferences;
begin
end;

procedure TsgDXFEntity.SetAnnotative(AValue: Boolean);
begin
end;

function TsgDXFEntity.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vLineWeight: Double;
  I: Integer;
  vNodeApp, vNodeAppName: TsgNodeSample;
  vItemZero: TsgNode;
  vData: TsgNodeSample;
  vXMLType: TsgXMLType;
  vAppID: UInt64;
  vExtData: TsgCADExtendedData;
  vListBits: TsgStringList;
  vBit: Byte;
  vNumBit, vFlags: Integer;
  vBitsStr, S: string;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlEedList:
      begin
        if Assigned(Converter) then
        begin
          if ANode.ChildNodesCount > 0 then
          begin
            for I := 0 to ANode.ChildNodesCount - 1 do
            begin
              vNodeApp := ANode.ChildNodes[I];
              vXMLType := GetXMLType(vNodeApp.Name);
              if vXMLType.Id = xmlApplication then
              begin
                vNodeAppName := vNodeApp.GetAttributeByName(cnstXMLNames[xmlName].Name);
                if Assigned(vNodeAppName) then
                begin
                  vAppID := Converter.CustomEntByName(vNodeAppName.ValueAsStr, csAppID).Handle;
                  vExtData := nil;
                  if vNodeApp.ChildNodesCount > 0 then
                  begin
                    vExtData := TsgCADExtendedData.Create(Converter.Version);
                    // Check for a required element of EED
                    // 0 items application name or handle - add(code 1001)
                    vItemZero :=TsgNode(vNodeApp.ChildNodes[0]);
                    vData := vItemZero.GetAttributeByName(cnstXMLNames[xmlEedCode].Name);
                    if vData.ValueAsInt <> String_1001 then
                    begin
                      vItemZero := TsgNode.Create;
                      vItemZero.AddAttribNV(cnstXMLNames[xmlEedCode].Name).ValueAsInt := String_1001;
                      vItemZero.AddAttribNV(cnstXMLNames[xmlEedType].Name).ValueAsStr := cnstExtDataTypeString[edtInt];
                      vItemZero.AddAttribNV(cnstXMLNames[xmlEedData].Name).ValueAsInt64 := vAppID;
                      TsgNode(vNodeApp).Childs.Insert(0, vItemZero);
                    end
                    else
                    begin
                      vData := vItemZero.GetAttributeByName(cnstXMLNames[xmlEedData].Name);
                      vData.ValueAsInt64 := vAppID;
                    end;
                    vExtData.FromXMLNode(vXMLType, vNodeApp, AIsChild, AResult);
                  end;
                  Converter.SetEntEED(Self, vAppID, vExtData);
                end;
              end;
            end;
          end
          else // <EedList/> - remove EED
            Converter.ClearEntEED(Self);
        end;
      end;
    xmlHandle: SetHandle(ANode.ValueAsHandle);
    xmlHandleSave:
      begin
        if Assigned(Converter) then
         Converter.SaveHandle(ANode.ValueAsStr, Self);
      end;
    xmlLineWeight:
      begin
        vLineWeight := ANode.ValueAsDouble;
        if vLineWeight < 0 then
        begin
          if (vLineWeight = fLineWeightByBlock) or
             (vLineWeight = fLineWeightByLayer) or
             (vLineWeight = fLineWeightDefault) then
            LineWeight := vLineWeight
          else
            begin
              Result := cnstXML_ERROR;
              DoErrorXMLNode(AResult.Errors, False, ANode, xmlLineWeight);
            end;
        end
        else
        begin
          LineWeight := ConvertLineWeightToDXF(vLineWeight)/100;
        end;
      end;
    xmlFlags:
      begin
        if Pos('[', ANode.ValueAsStr) <> 0 then
        begin
          vBitsStr := ANode.ValueAsStr;
          StringReplace(vBitsStr, '[', '');
          StringReplace(vBitsStr, ']', '');
          vListBits := TsgStringList.Create;
          try
            vListBits.LineBreak := cnstXMLValuesSeparator;
            vListBits.Text := vBitsStr;
            vFlags := GetFlags;
            for I := 0 to vListBits.Count - 1 do
            begin
              S := Trim(vListBits[I]);
              if Length(S) > 0 then
              begin
                vBit := Ord(S[1] <> '-');
                vNumBit := Abs(StrToInt(vListBits[I]));
                SetFlagsXml(vNumBit, vBit, @vFlags);
              end;
            end;
            SetFlags(vFlags);
          finally
            vListBits.Free;
          end;
        end
        else
          SetFlags(ANode.ValueAsInt);
      end;
    xmlLineTypeName:
      begin
        if Assigned(Converter) then
          LineType := Converter.GetLineTypeByNode(ANode);
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFEntity.FromXMLSubEntities(const ANode: TsgNodeSample;
  const AResult: IsgResultNode = nil): Integer;
var
  I: Integer;
  vChild, vHandle, vName: TsgNodeSample;
  vEntity: TsgDXFEntity;
  vEntityClass: TsgDXFEntityClass;
  vLTypeName: string;
  vAttribMode: TsgNodeSample;
  vEntLayer: TsgDXFLayer;
  vEntLineType: TsgDXFLineType;


  procedure AddHandleToResult(const AOutput: TsgNode;
    AName: string; AHandle: UInt64; ANodeChild: TsgNodeSample);
  var
    vNodeOutput: TsgNode;
    vNodeAttrib: TsgNodeSample;
  begin
    if AHandle <> cnstBadHandle then
    begin
      vNodeOutput := AOutput.AddChildNV(AName);
      vNodeAttrib := vNodeOutput.AddAttribNV(cnstXMLNames[xmlHandle].Name);
      vNodeAttrib.ValueAsHandle :=AHandle;
      if vChild.HasPosition then
        vNodeOutput.AddAttribNV(cnstXMLPosition).ValueData.ValueAsPoint :=
          Point(ANodeChild.Position.X, ANodeChild.Position.Y);
    end;
  end;

begin
  Result := inherited FromXMLSubEntities(ANode, AResult);

  vAttribMode := ANode.GetAttributeByName(cnstXMLNames[xmlMode].Name);
  if Assigned(vAttribMode) then
  begin
    if vAttribMode.ValueAsInt <> 0 then
      Clear;
  end;

  if ANode.ChildNodesCount > 0 then
  begin
    Result := cnstXML_OK;
    vEntLayer := nil;
    vEntLineType := nil;
    for I := 0 to ANode.ChildNodesCount - 1 do
    begin
      vEntity := nil;
      vChild := ANode.ChildNodes[I];
      vHandle := vChild.GetAttributeByName(sgConsts.cnstXMLNames[xmlHandle].Name);
      if Assigned(vHandle) then
      begin
        if vHandle.ValueAsHandle <> cnstBadHandle then
          vEntity := FindEntByHandle(vHandle.ValueAsHandle);
      end
      else
      begin
        vName := vChild.GetAttributeByName(sgConsts.cnstXMLNames[xmlName].Name);
        if Assigned(vName) then
        begin
          if Length(vName.ValueAsStr) > 0 then
            vEntity := FindEntByName(vName.ValueAsStr);
        end;
      end;
      if Assigned(vEntity) then//set
      begin
        vEntity.SetConverter(Converter);
        if vEntity is TsgDXFBlock then
          TsgDXFBlock(vEntity).IsLoaded := False;
        vEntity.FromXML(vChild, AResult);
        if AResult <> nil then
          AddHandleToResult(AResult.Output, cnstXMLUpdated, vEntity.Handle,
          vChild);
      end
      else//added
      begin
        vEntityClass := TsgDXFEntityClass(GetClassByXMLName(vChild.Name));
        if Assigned(vEntityClass) then
        begin
          if not Assigned(vEntLayer) then
          begin
            vEntLayer := Converter.LayerByName(Converter.HeadVarStruct.CLayer);
            vLTypeName := Converter.HeadVarStruct.CELType;
            if Length(vLTypeName) < 0 then
              vLTypeName := sContinuous;
            vEntLineType := Converter.LTypeByName(vLTypeName);
          end;
          vEntity := vEntityClass.Create;
          vEntity.SetConverter(Converter);
          vEntity.Layer := vEntLayer;
          vEntity.LineType := vEntLineType;
          AddEntity(vEntity);
          if vEntity.FromXML(vChild, AResult) <> cnstXML_OK then
            RemoveEntity(vEntity)
          else
          begin
             if AResult <> nil then
                AddHandleToResult(AResult.Output, cnstXMLCreated,
                  vEntity.Handle, vChild);
          end;
        end
        else
          if AResult <> nil then
            DoErrorXMLNode(AResult.Errors, True, vChild, xmlUndefined);
      end;
    end;
  end;
end;

function TsgDXFEntity.GetColor: TColor;
begin
  Result := ConvertColorCADToRGB(ColorCAD);
end;

function TsgDXFEntity.GetColorCAD: TsgColorCAD;
begin
  Result := cnstDefHeadVarStruct.CEColor;
end;

function TsgDXFEntity.GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean;
var
  R: TFRect;
begin
  Result := False;
  R := GetBox;
  EnumBoxPoints(R, Proc, Full);
end;

function TsgDXFEntity.GetVisible: Boolean; //is on visible layer
begin
  Result := ((Layer = nil) or (not Layer.Frozen and Layer.Visible)) and Visibility;
end;

function TsgDXFEntity.GetBox: TFRect;   // overridden in all visible descendants
begin
  Result := BadRect;
end;

function TsgDXFEntity.BoxForLayout(ALayout: TsgDXFLayout; AConv: TsgDXFConverter): TFRect;
begin
  Result := GetBox;
end;

function TsgDXFEntity.GetCount: Integer;
begin
  Result := 0;
end;

function TsgDXFEntity.GetDescription: string;
begin
  Result := '';
end;

function TsgDXFEntity.GetDestroyNotifications(out AList: TsgNotifyEventsList;
  ACreateNew: Boolean; AAttributesIntfPtr: Pointer): Boolean;
var
  vAttributes: IsgGlobalPropProvider;
  V: Variant;
begin
  Result := False;
  if GetGlobalPropProvider(Self, False, vAttributes) then
  begin
    if vAttributes.TryGetValue(cnstDestroyNotification, V) and (VarType(V) = varUnknown) then
      Result := VarCastToObj(V, AList)
    else
      if ACreateNew then
      begin
        AList := TsgNotifyEventsList.Create;
        vAttributes[cnstDestroyNotification] := AList as IUnknown;
        Result := True;
      end;
    if Assigned(AAttributesIntfPtr) then
      IInterface(AAttributesIntfPtr^) := vAttributes;
  end;
end;

function TsgDXFEntity.GetDictionary: TsgDXFEntity;
var
  vConverter: TsgDXFConverter;
begin
  Result := nil;
  vConverter := Converter;
  if Assigned(vConverter) then
    Result := vConverter.Dictionary[Handle];
end;

function TsgDXFEntity.GetDimStyleInternal: Pointer;
begin
  Result := cnstObjectReserve;
end;

function TsgDXFEntity.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := nil;
end;

function TsgDXFEntity.IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := Count - 1;
  while (Result >= 0) and (Entities[Result] <> AEntity) do
    Dec(Result);
end;

function TsgDXFEntity.IndexOfHandle(const AHandle: UInt64): Integer;
begin
  Result := Count - 1;
  while (Result >= 0) and (Entities[Result].Handle <> AHandle) do
    Dec(Result);
end;

function TsgDXFEntity.IndexOfName(const AName: string): Integer;
begin
  Result := Count - 1;
  while (Result >= 0) and (AnsiCompareText(Entities[Result].Name, AName) <> 0) do
    Dec(Result);
end;

function TsgDXFEntity.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := False;
end;

procedure TsgDXFEntity.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
begin
  if IsInvoke(AConverter) then
    Proc(Self);
end;

function TsgDXFEntity.IsInvoke(AConverter: TsgDXFConverter): Boolean;
var
  vParams: PsgCADIterate;
begin
  vParams := AConverter.Params;
  if vParams <> nil then
  begin
    if vParams^.Stopped then
      Result := False
    else
    begin
      Result := True;
      if  (AConverter.ImportMode = imImport) and Assigned(vParams^.Viewport) then
        Result := (IntersectRects(GetBox, vParams^.ViewPortRect, vParams^.Matrix) <> -1);
    end;
  end
  else
    Result := True;
end;

function TsgDXFEntity.GetTextStyleInternal: Pointer;
begin
  Result := cnstObjectReserve;
end;

function TsgDXFEntity.GetThickness: Double;
begin
  Result := GetThicknessInt;
end;

function TsgDXFEntity.GetThicknessInt: Double;
begin
  Result := cnstThicknessDefault;
end;

function TsgDXFEntity.GroupHasAddedEntities: Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.HasDimesionStyle(const AStyle: Pointer): Boolean;
begin
  Result := HasObject(AStyle, GetDimStyleInternal);
end;

function TsgDXFEntity.HasTextStyle(const AStyle: Pointer): Boolean;
begin
  Result := HasObject(AStyle, GetTextStyleInternal);
end;

function TsgDXFEntity.HasLineWeight: Boolean;
begin
  Result := True;
end;

function TsgDXFEntity.GroupExists: Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.IsInsert: Boolean; //evg
begin
  Result := False;
end;

function TsgDXFEntity.IsOnePixelOptimisationValid: Boolean; //evg
begin
  Result := True;
end;

function TsgDXFEntity.GetComplex: Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.GetLayer: TsgDXFLayer;
begin
  Result := nil;
end;

function TsgDXFEntity.GetLayerInsp: TsgDXFlayer;
begin
  Result := GetLayerInspInternal;
end;

function TsgDXFEntity.GetLayerInspInternal: TsgDXFlayer;
begin
  Result := GetLayer;
end;

function TsgDXFEntity.GetLineType: TsgDXFLineType;
begin
  Result := nil;
end;

function TsgDXFEntity.GetLineTypeScale: Double;
begin
  Result := 1;
end;

function TsgDXFEntity.GetLineWeight: Double;
begin
  Result := fLineWeightByLayer;
end;

function TsgDXFEntity.GetLineWeightScaled: Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgOwneredItem;
end;

function TsgDXFEntity.GetMaterial: TsgDXFMaterial;
begin
  Result := nil;
end;

function TsgDXFEntity.GetName: string;
begin
  Result := EntName;
end;

function TsgDXFEntity.GetNamedItem: TObject;
begin
  Result := nil;
end;

function TsgDXFEntity.GetConverter: TsgDXFConverter;
var
  vOwner: TsgDXFEntity;
begin
  vOwner := GetOwner;
  if Assigned(vOwner) then
    Result := vOwner.GetConverter()
  else
    Result := nil;
end;

function TsgDXFEntity.GetEntType: TsgCADEntities;
begin
  Result := ceEntity;
end;

function TsgDXFEntity.GetEntTypeEx: Integer;
begin
  Result := cnstUndefined;
end;

function TsgDXFEntity.GetEED(const AAppID: UInt64): TsgCADExtendedData;
var
  vIndex: Integer;
  vEEDList: TsgObjectCollection;
begin
  Result := nil;
  if Handle <> cnstBadHandle then
  begin
    vEEDList := GetEEDItems;
    if Assigned(vEEDList) then
    begin
      vIndex := vEEDList.IndexOf(AAppID);
      if vIndex > -1 then
        Result := TsgCADExtendedData(vEEDList.Objects[vIndex]);
    end;
  end;
end;

function TsgDXFEntity.GetEEDItems: TsgObjectCollection;
var
  vConv: TsgDXFConverter;
begin
  Result := nil;
  vConv := Converter;
  if Assigned(vConv) then
    Result := vConv.EEDItems[Handle];
end;

function TsgDXFEntity.GetEntClassEx: TsgEntClass;
begin
  Result.EG := gtCAD;
  Result.ET.CAD := GetEntType;
end;

procedure TsgDXFEntity.ToSubEntities(const AParentNode: TsgNode;
  const AParams: TsgXMLParams);
begin
  ToXMLSubEntities(AParentNode, AParams);
end;

function TsgDXFEntity.IsUsedInKeyConstruction: Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vFlags: Integer;
  vHandle: UInt64;
  vLineTypeName: string;
  I: Integer;
  vBox: TFRect;
  vDictionary: TsgDXFEntity;
  vIrd: TsgCADIrdObjRecord;
  vIrdNode: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);

  if not (xmlForViewing in AParams.Mode) then
    EEDItemsToXMLNode(ANode, AParams);

  if IsFullPropsOrXMLHelp(AParams.Mode) or (LineWeight <> fLineWeightByLayer) then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLineWeight].Name).ValueData,
      LineWeight, xmlForViewing in AParams.Mode);
  vHandle := Handle;
  if (vHandle <> cnstBadHandle) or IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlHandle].Name).ValueAsHandle := vHandle;
  vFlags := GetFlags;
  if IsFullPropsOrXMLHelp(AParams.Mode) or (vFlags <> 0) then
    ANode.AddAttribNV(cnstXMLNames[xmlFlags].Name).ValueAsInt := vFlags;
  if IsXMLHelp(AParams.Mode) then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlLineTypeName].Name);
  end
  else
  begin
    vLineTypeName := sContinuous;
    if Assigned(LineType) then
      vLineTypeName := LineType.Name;
    if IsFullProps(AParams.Mode) or (vLineTypeName <> sByLayer) then
      ANode.AddAttribNV(cnstXMLNames[xmlLineTypeName].Name).Value := vLineTypeName;
  end;

  // IRD attributes
  vDictionary := Dictionary;
  if Assigned(vDictionary) then
    for I := 0 to vDictionary.Count - 1 do
      if (vDictionary[I].GetLinkClass = TsgIrdDescriptedNamedItem) and (vDictionary[I] is TsgCADIrdObjRecord) then
      begin
        vIrd := TsgCADIrdObjRecord(vDictionary[I]);
        vIrdNode := ANode.AddChildNV(vIrd.IrdDscRecord.TableName);
        if vIrd.IrdDscRecord.Description <> '' then
          vIrdNode.AddAttribNV(cnstXMLNames[sgConsts.xmlDescription].Name, vIrd.IrdDscRecord.Description);
        vIrd.AddAttributes(vIrdNode, AParams);
      end;

  if IsFullPropsOrXMLHelp(AParams.Mode) then
  begin
    vBox := Box;
    {$IFNDEF DEBUG}if not IsBadRect(vBox) then{$ENDIF}
      ANode.AddAttribNV(cnstXMLNames[xmlBox].Name).ValueAsFRect := vBox;
  end;
end;

procedure TsgDXFEntity.ToXMLSubEntities(const AParentNode: TsgNode;
  const AParams: TsgXMLParams);
var
  I: Integer;
  vSubEntities: TsgNode;
  vParams: TsgXMLParams;
begin
  vParams := AParams;
  vSubEntities := GetSubEntitiesNode(AParentNode, vParams);
  if Assigned(vSubEntities) then
    for I := 0 to Count - 1 do
      Entities[I].ToXMLWithParams(vSubEntities, vParams);
end;

function TsgDXFEntity.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = sURLXDataName then
    Result := GetExtDataHyperLink(AData);
end;

function TsgDXFEntity.GetExtDataHyperLink(const AData: TsgCADExtendedData): Boolean;
var
  vName, vValue: string;
begin
  Result := Length(HyperLink) > 0;
  if Result then
  begin
    vName := GetHyperLinkName;
    vValue := GetHyperLinkValue;
    AData.AddString(String_1001, sURLXDataName);
    AData.AddString(String_1000, vValue);
    AData.AddString(String_1002, '{');
    AData.AddString(String_1000, vName);
    AData.AddString(String_1002, '{');
    AData.AddInt(Integer_1071, 1);
    AData.AddString(String_1002, '}');
    AData.AddString(String_1002, '}');
  end;
end;

function TsgDXFEntity.GetExtrusion: TFPoint;
begin
  Result := cnstExtrusion;
end;

function TsgDXFEntity.GetExtensionDictionary(const Index: Variant): TsgDXFEntity;
var
  vDictionary: TsgDXFEntity;
begin
  Result := nil;
  vDictionary := Dictionary;
  if Assigned(vDictionary) then
    Result := TsgDXFDictionary(vDictionary).Item(Index);
end;

function TsgDXFEntity.GetFlags: Integer;
begin
  Result := 0;
end;

function TsgDXFEntity.GroupGet: TsgDXFGroup;
begin
  Result := nil;
end;

function TsgDXFEntity.GetHandle: UInt64;
begin
  Result := cnstBadHandle;
end;

function TsgDXFEntity.GetHLink: string;
var
  vAppID: TsgDXFEntity;
  vURLData: TsgCADExtendedData;
  vHyperLinkValue, vHyperLinkName: string;
begin
  Result := '';
  if Assigned(Converter) and Assigned(Converter.Sections[csAppID]) then
  begin
    vAppID := Converter.Sections[csAppID].FindEntByName(sURLXDataName);
    if Assigned(vAppID) then
    begin
      vURLData := EED[vAppID.Handle];
      if Assigned(vURLData) and ParseURLData(vURLData, vHyperLinkName, vHyperLinkValue) then
        Result := MakeHyperLink(vHyperLinkName, vHyperLinkValue);
    end;
  end;
end;

function TsgDXFEntity.GetHyperLink: string;
begin
  Result := GetHLink;
end;

function TsgDXFEntity.GetHyperLinkName: string;
var
  I: Integer;
begin
  Result := HyperLink;
  if Length(Result) > 0 then
  begin
    I := StringPos(cnstHyperLinkDelimiter, Result, 1);
    if I > 0 then
      SetLength(Result, I - 1);
  end;
end;

function TsgDXFEntity.GetHyperLinkValue: string;
var
  I: Integer;
begin
  Result := HyperLink;
  if Length(Result) > 0 then
  begin
    I := StringPos(cnstHyperLinkDelimiter, Result, 1);
    if I > 0 then
      Delete(Result, 1, I);
  end;
end;

function TsgDXFEntity.GetInternalFlags: Word;
begin
  Result := 0;
end;

function TsgDXFEntity.GetObjectType: Integer;
begin
  Result := Integer(GetEntType);
end;

function TsgDXFEntity.GetOnDraw: TNotifyEvent;
begin
  Result := nil;
end;

function TsgDXFEntity.GetOwner: TsgDXFEntity;
begin
  Result := nil;
end;

function TsgDXFEntity.GetPaperSpace: Integer;
begin
  Result := 0;
end;

procedure TsgDXFEntity.GetXMLIdsChangingHiding(const AChangeList, AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AChangeList) then
    begin
      AChangeList.Add(Integer(xmlLineWeight));
      AChangeList.Add(Integer(xmlLineTypeName));
    end;
    if Assigned(AHideList) then
    begin
//      AHideList.Add(Integer(xmlHandle));
      AHideList.Add(Integer(xmlFlags));
      AHideList.Add(Integer(xmlExtrusion));
      AHideList.Add(Integer(xmlHyperLink));
    end;
  end;
end;

function TsgDXFEntity.GetSrcEnd: PAnsiChar;
begin
  Result := nil;
end;

function TsgDXFEntity.GetSrcStart: PAnsiChar;
begin
  Result := nil;
end;

function TsgDXFEntity.GetSubEntitiesNode(const AParentNode: TsgNode; var AParams: TsgXMLParams;
  const AHasSubEntities: Boolean = False): TsgNode;
begin
  Result := nil;
  if (xmAddSubEntities in AParams.Mode) and (AHasSubEntities or (Count > 0)) then
  begin
    if not (xmNoSubEntitiesNode in AParams.Mode) then
      Result := AParentNode.AddChildNV(cnstXMLNames[xmlSubEntities].Name)
    else
      Result := AParentNode;
    if xmOnlyChildNodes in AParams.Mode then
      Exclude(AParams.Mode, xmAddSubEntities);
  end;
end;

function TsgDXFEntity.GetVisibility: Boolean;
begin
  Result := True;
end;

procedure TsgDXFEntity.AssignEntity(Source: TsgDXFEntity);
begin
  if Assigned(Source) then
  begin
    HyperLink := Source.HyperLink;
    LineWeight := Source.LineWeight;
    LineTypeScale := Source.LineTypeScale;
  end;
end;

procedure TsgDXFEntity.AssignExtendedData(const ASource: TsgDXFEntity);

  procedure AssignCollections(const ACollectionD, ACollectionS: TsgObjectCollection);
  var
    I: Integer;
    vS, vD: TsgHashItemObject;
  begin
    for I := 0 to ACollectionS.Count - 1 do
    begin
      vS := ACollectionS.Items[I];
      vD.HashCode := vS.HashCode;
      vD.Data := TsgCADExtendedData.Create(TsgCADExtendedData(vS.Data).Version);
      TsgCADExtendedData(vD.Data).AssignData(TsgCADExtendedData(vS.Data));
      ACollectionD.Add(vD);
    end;
  end;

var
  vDest, vSource: TsgObjectCollection;
  vConv: TsgDXFConverter;
  vIndex: Integer;
begin
  if not Assigned(ASource) then
    Exit;
  vSource := ASource.GetEEDItems;
  if Assigned(vSource) then
  begin
    vConv := ASource.Converter;
    if Handle = cnstBadHandle then
    begin
      SetConverter(vConv);
      vConv.SetHandle(Self);
    end;
    vIndex := vConv.EntityEEDItems.IndexOf(Handle);
    if vIndex < 0 then
    begin
      vDest := TsgObjectCollection(TsgBaseListClass(vSource.ClassType).Create);
      vConv.EntityEEDItems.Add(Handle, vDest);
      AssignCollections(vDest, vSource);
    end
    else
    begin
      vDest := TsgObjectCollection(vConv.EntityEEDItems.Items[vIndex].Data);
      TsgObjectCollection.ClearList(vDest);
      AssignCollections(vDest, vSource);
    end;
  end
  else
  begin      
    vConv := Converter;
    if Assigned(vConv) then
    begin
      vIndex := vConv.EntityEEDItems.IndexOf(Handle);
      if vIndex > -1 then
      begin
        vDest := TsgObjectCollection(vConv.EntityEEDItems.Items[vIndex].Data);
        vConv.EntityEEDItems.Delete(vIndex);
        TsgObjectCollection.FreeList(vDest);//neet test
      end;
    end;
  end;
end;

function TsgDXFEntity.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.RemoveDestroyNotification(
  const ANotify: TNotifyEvent): Integer;
var
  vList: TsgNotifyEventsList;
  vAttributes: IsgGlobalPropProvider;
begin
  Result := -1;
  if GetDestroyNotifications(vList, False, @vAttributes) then
  begin
    Result := vList.Remove(ANotify);
    if vList.Count = 0 then
    begin
      vAttributes.RemoveItem(cnstDestroyNotification);
      vList.Free; // because TsgNotifyEventsList do not implements refcount!
    end;
  end;
end;

function TsgDXFEntity.RemoveEntity(const AEntity: TsgDXFEntity): Boolean;
var
  vIndex: Integer;
begin
  Result := False;
  vIndex := IndexOfEntity(AEntity);
  while vIndex > -1 do//Removes some times added primitives. Error correction is added.
  begin
    DeleteEntity(vIndex);
    Result := True;
    vIndex := IndexOfEntity(AEntity);
  end;
end;

procedure TsgDXFEntity.RemoveReferenceNotification(const ARefObj: TsgDXFEntity);
begin
end;

procedure TsgDXFEntity.Draw;
begin// do nothing
end;

procedure TsgDXFEntity.Link(AConverter: TsgDXFConverter);
begin
end;

procedure TsgDXFEntity.ListNotify(const Obj: TObject; Action: TListNotification);
var
  vConverter: TsgDXFConverter;
begin
  vConverter := GetConverter;
  if Assigned(vConverter) then
    vConverter.EntityListNotify(Obj, Action);
end;

procedure TsgDXFEntity.Loaded(AConverter: TsgDXFConverter);
begin
  ChangeHandle(AConverter);
  SetConverter(AConverter);
  LoadedInternal(AConverter);
end;

procedure TsgDXFEntity.EntityLoaded;
begin
  inherited EntityLoaded;
  if Assigned(Converter) then
    Loaded(Converter);
end;

procedure TsgDXFEntity.LoadedInternal(AConverter: TsgDXFConverter);
begin
{$IFDEF SG_MODULE_LOG}
  Log.Add(ClassName + '($' + IntToHex(TsgNativeUInt(Self), 0)+ ').Loaded');
{$ENDIF}
end;

procedure TsgDXFEntity.NameChanging(var NewName: string; var AAllow: Boolean);
begin
end;

procedure TsgDXFEntity.NotifyDestroing;
var
  vList: TsgNotifyEventsList;
  vAttributes: IsgGlobalPropProvider;
begin
  if GetDestroyNotifications(vList, False, @vAttributes) then
  begin
    while vList.Count > 0 do
    try
      if Assigned(vList.List^[vList.Count - 1]) then
        vList.List^[vList.Count - 1](Self);
    finally
      vList.Delete(vList.Count - 1);
    end;
    vAttributes.RemoveItem(cnstDestroyNotification);
    vList.Free; // because TsgNotifyEventsList do not implements refcount!
  end;
end;

function TsgDXFEntity.GetAnnotationScales: TsgDXFEntity;
var
  vObjectContextManager: TsgDXFEntity;
begin
  Result := nil;
  vObjectContextManager := GetExtensionDictionary(sAcDbContextDataManager);
  if Assigned(vObjectContextManager) then
    Result := vObjectContextManager.FindEntByName(cnstAcDbAnnotationScales)
end;

class function TsgDXFEntity.ExtractEEDTypeEx(AExtData: TObject;
  var AGroupName: string; var AEntTypeNum: Integer;
  const AMaxDataIndex: Integer = 4): Integer;
begin
  Result := -1;
  AGroupName := '';
  AEntTypeNum := cnstUndefined;
  if AExtData is TsgCADExtendedData then
  begin
    Result := TsgCADExtendedData(AExtData).ExtractEEDType(AGroupName,
      AEntTypeNum, AMaxDataIndex);
  end;
end;

{$IFDEF SG_CALC_INSTANCE_SIZES}
class function TsgDXFEntity.NewInstance: TObject;
begin
  Result := inherited NewInstance;
  Inc(TotalAllocated, InstanceSize);
end;
{$ENDIF}

function TsgDXFEntity.CanAddedToXMLParams: Boolean;
begin
  Result := GetEntType > ceEntity;
end;

function TsgDXFEntity.CanDraw: Boolean;
begin
  Result := False;
end;

function TsgDXFEntity.CanHaveHandle: Boolean;
begin
  Result := False;
end;

procedure TsgDXFEntity.ChangeHandle(AConverter: TsgDXFConverter);
begin
  AConverter.SetHandle(Self);
end;

procedure TsgDXFEntity.SetColor(Value: TColor);
begin
  SetColor__(Value);
end;

procedure TsgDXFEntity.SetColorCAD(const Value: TsgColorCAD);
begin // do nothing
end;

procedure TsgDXFEntity.SetColor__(const Value: TColor);
begin
  ColorCAD :=  ConvertColortoColorCAD(Value);
end;

procedure TsgDXFEntity.SetConverter(const AConverter: TsgDXFConverter);
begin// do nothing
end;

procedure TsgDXFEntity.SetDescription(const AValue: string);
begin
end;

procedure TsgDXFEntity.SetDictionary(const AValue: TsgDXFEntity);
var
  vConv: TsgDXFConverter;
begin
  vConv := Converter;
  if not Assigned(vConv) and Assigned(AValue) then
    vConv := AValue.Converter;
  if Assigned(vConv) then
    vConv.SetEntDict(Self, AValue);
end;

procedure TsgDXFEntity.SetEED(const AAppID: UInt64;
  const AValue: TsgCADExtendedData);
var
  vConv: TsgDXFConverter;
begin
  vConv := Converter;
  if Assigned(vConv) then
    vConv.SetEntEED(Self, AAppID, AValue);
end;

procedure TsgDXFEntity.SetEntity(const AIndex: Integer; const AEntity: TsgDXFEntity);
begin// do nothing
end;

procedure TsgDXFEntity.SetExtData(const AData: TsgCADExtendedData);
begin// do nothing
end;

procedure TsgDXFEntity.SetExtDataHyperLink(const AData: TsgCADExtendedData);
var
  vHyperLinkValue, vHyperLinkName: string;
begin
  if IsEqualExtDataName(AData, sURLXDataName) then
    if ParseURLData(AData, vHyperLinkName, vHyperLinkValue) then
      HyperLink := MakeHyperLink(vHyperLinkName, vHyperLinkValue);
end;

procedure TsgDXFEntity.SetExtrusion(const Value: TFPoint);
begin// do nothing
end;

procedure TsgDXFEntity.SetFlags(const Value: Integer);
begin
end;

procedure TsgDXFEntity.SetFlagsXml(const ANum: Integer; const ABit: Byte; AFlags: PInteger);
var
  vFlags: Integer;
  vPFlags: PInteger;
begin
  vPFlags := AFlags;
  if vPFlags = nil then
  begin
    vFlags := GetFlags;
    vPFlags := @vFlags;
  end;
  vPFlags^ := (vPFlags^ and (($1 shl ANum) -1) ) or (ABit  shl ANum);
  if AFlags = nil then
    SetFlags(vFlags);
end;

procedure TsgDXFEntity.SetHandle(const Value: UInt64);
begin// do nothing
{$IFDEF SG_MODULE_LOG}
  Log.Add(ClassName + '($' + IntToHex(TsgNativeUInt(Self), 0)+ ').Handle := $' + IntToHex(Value, 0) + ';');
{$ENDIF}
end;

procedure TsgDXFEntity.SetHLink(const AValue: string);
begin// do nothing
end;

procedure TsgDXFEntity.SetHyperLink(const AValue: string);
begin
  SetHLink(AValue);
end;

procedure TsgDXFEntity.SetInternalFlags(const Value: Word);
begin// do nothing
end;

procedure TsgDXFEntity.SetLayer(const Value: TsgDXFLayer);
begin// do nothing
end;

procedure TsgDXFEntity.SetLayerInsp(const ALayer: TsgDXFlayer);
begin
  SetLayerInspInternal(ALayer);
end;

procedure TsgDXFEntity.SetLayerInspInternal(const ALayer: TsgDXFlayer);
begin
  SetLayer(ALayer);
end;

procedure TsgDXFEntity.SetLineType(const AValue: TsgDXFLineType);
begin// do nothing
end;

procedure TsgDXFEntity.SetLineTypeScale(Value: Double);
begin// do nothing
end;

procedure TsgDXFEntity.SetLineWeight(Value: Double);
begin// do nothing
end;

procedure TsgDXFEntity.SetLineWeightScaled(Value: Boolean);
begin// do nothing
end;

procedure TsgDXFEntity.SetLType(Value: TsgDXFEntity);
begin// for compatibility with previous versions
  if Value is TsgDXFLineType then
    LineType := TsgDXFLineType(Value)
  else
    LineType := nil;
end;

procedure TsgDXFEntity.SetLWeight(Value: Integer);
begin// do nothing
end;

procedure TsgDXFEntity.SetMaterial(const Value: TsgDXFMaterial);
begin// do nothing
end;

procedure TsgDXFEntity.SetName(const AName: string);
begin// do nothing
end;

procedure TsgDXFEntity.SetOnDraw(const Value: TNotifyEvent);
begin// do nothing
end;

procedure TsgDXFEntity.SetOwner(const Value: TsgDXFEntity);
begin// do nothing
end;

procedure TsgDXFEntity.SetPaperSpace(const Value: Integer);
begin// do nothing
end;

procedure TsgDXFEntity.SetSrcEnd(const Value: PAnsiChar);
begin// do nothing
end;

procedure TsgDXFEntity.SetSrcStart(const Value: PAnsiChar);
begin// do nothing
end;

procedure TsgDXFEntity.SetThickness(const AValue: Double);
begin
  SetThicknessInt(AValue);
end;

procedure TsgDXFEntity.SetThicknessInt(const AValue: Double);
begin// do nothing
end;

procedure TsgDXFEntity.SetVisibility(const Value: Boolean);
begin// do nothing
end;

procedure TsgDXFEntity.SetVisible(Value: Boolean);
begin// do nothing
end;

procedure TsgDXFEntity.StyleChanged(Sender: TObject);
begin
end;

function TsgDXFEntity.GetLineCap: Word;
begin// do nothing
  Result := PS_ENDCAP_ROUND;
end;

function TsgDXFEntity.GetLineJoin: Word;
begin
  Result := PS_JOIN_ROUND;
end;

function TsgDXFEntity.GetLines: TsgLines;
begin
  Result := StdLines;
end;

procedure TsgDXFEntity.SetLineCap(const Value: Word);
begin// do nothing
end;

procedure TsgDXFEntity.SetLineJoin(const Value: Word);
begin// do nothing
end;

{TsgDXFEntitySample}

constructor TsgDXFEntitySample.Create;
begin
  inherited Create;
end;

function TsgDXFEntitySample.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlLineTypeScale: LineTypeScale := ANode.ValueAsDouble;
    xmlLayerName:
      begin
        if Assigned(Converter) then
          Layer := Converter.GetLayerByNode(ANode);
        if not Assigned(Layer) then
          Result := cnstXML_UNSUPPORTED;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure TsgDXFEntitySample.CheckArroyType(const AValue: TsgDimArrowType);
var
  vBlock: TsgDXFBlock;
begin
  if FConverter <> nil then
  begin
    vBlock := FConverter.BlockByName(sgDimensionArrowTypeNames[AValue]);
    if vBlock = nil then
    begin
      vBlock := TsgDXFBlock.Create;
      vBlock.Layer := GetLayer;
      GenerateArrow(FConverter, vBlock, AValue);
      vBlock.Name := sgDimensionArrowTypeNames[AValue];
      vBlock.Loaded(FConverter);
      FConverter.FBlocksSection.AddEntity(vBlock);
    end;
  end;
end;

procedure TsgDXFEntitySample.AssignEntity(Source: TsgDXFEntity);
var
  vEntitySample: TsgDXFEntitySample absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFEntitySample then
  begin
    FTextRotation := vEntitySample.FTextRotation;
    FBackGroundImage := vEntitySample.FBackGroundImage;
  end;
end;

function TsgDXFEntitySample.GetBackGroundImage: TsgDXFImageEnt;
begin
  Result := FBackGroundImage;
end;

function TsgDXFEntitySample.GetColorCAD: TsgColorCAD;
begin
  Result := GetActiveHeadVar^.CEColor;
end;

function TsgDXFEntitySample.GetDimTextOffset: Double;
begin
  Result := GetActiveHeadVar^.DimProps.Gap;
end;

function TsgDXFEntitySample.GetDimTextPosVert: TsgDimTextPosVert;
begin
  Result := TsgDimTextPosVert(GetActiveHeadVar^.DimProps.Tad);
end;

function TsgDXFEntitySample.GetFilletRadius: Double;
begin
  Result := GetActiveHeadVar^.FilletRadius;
end;

function TsgDXFEntitySample.GetFontHeight: TsgFloat;
begin
  Result := GetActiveHeadVar^.TextSize;
end;

function TsgDXFEntitySample.GetFontName: string;
var
  vTextStyle: TsgDXFStyle;
  vExt: string;
begin
  Result := '';
  vTextStyle := TextStyle;
  if vTextStyle <> nil then
  begin
    Result := vTextStyle.FontName;
    if Length(Result) = 0 then
    begin
      Result := vTextStyle.GetPrimaryFontName;
      if Length(Result) > 0 then
      begin
        vExt := ExtractFileExt(Result);
        if Length(vExt) > 0 then
          SetLength(Result, Length(Result) - Length(vExt));
      end;
    end;
  end;
  if Length(Result) = 0 then
  begin
    Result := sDefaultSHXFont;
    if Length(Result) <= 0 then
      Result := cnstDefaultTTFFont;
  end;
end;

function TsgDXFEntitySample.GetDimArrowType(const ADimProps: TsgDimStyle;
  const ANameValue: TsgDimNameVal): TsgDimArrowType;
begin
  Result := datClosedfilled;
  case ANameValue of
    vnDIMBLK1:   Result := GetDimArrowTypeByDimSah(ADimProps.Sah, ADimProps.Arrows.Blk, ADimProps.Arrows.Blk1);
    vnDIMBLK2:   Result := GetDimArrowTypeByDimSah(ADimProps.Sah, ADimProps.Arrows.Blk, ADimProps.Arrows.Blk2);
    vnDIMLRBLK:  Result :=  ADimProps.Arrows.LrBlk;
  end;
end;

function TsgDXFEntitySample.GetDimBlk1: Byte;
begin
  Result := GetArrowByte(GetDimArrowType(GetActiveHeadVar^.DimProps, vnDIMBLK1));
end;

function TsgDXFEntitySample.GetDimBlk2: Byte;
begin
  Result := GetArrowByte(GetDimArrowType(GetActiveHeadVar^.DimProps, vnDIMBLK2));
end;

function TsgDXFEntitySample.GetDimLrBlk: Byte;
begin
  Result := GetArrowByte(GetDimArrowType(GetActiveHeadVar^.DimProps, vnDIMLRBLK));
end;

function TsgDXFEntitySample.GetDimExtLineExt: TsgFloat;
begin
  Result := GetActiveHeadVar^.DimProps.Exe;
end;

function TsgDXFEntitySample.GetDimExtLineOffset: TsgFloat;
begin
  Result := GetActiveHeadVar^.DimProps.Exo;
end;

function TsgDXFEntitySample.GetDimTextHeight: TsgFloat;
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  Result := GetActiveHeadVar^.DimProps.Txt;
  vDimStyle := GetDimStyle;
  if Assigned(vDimStyle) then
    vDimStyle.GetTextHeightReal(Result);
end;

function TsgDXFEntitySample.GetDimForceText: Integer;
begin
  Result := GetActiveHeadVar^.DimProps.TIX;
end;

function TsgDXFEntitySample.GetDimLFac: Double;
begin
  Result := GetActiveHeadVar^.DimProps.LFac;
end;

function TsgDXFEntitySample.GetDimPrecision: Integer;
begin
  Result := GetActiveHeadVar^.DimProps.Dec;
end;

function TsgDXFEntitySample.GetDimScale: Double;
begin
  Result := GetActiveHeadVar^.DimProps.Scale;
end;

function TsgDXFEntitySample.GetDimStyle: TsgDXFDimensionStyle;
begin
  if (FConverter <> nil) and (FConverter.FDimStyles <> nil) then
    Result := TsgDXFDimensionStyle(FConverter.FDimStyles.FindEntByName(
      FConverter.HeadVarStruct.DimStyle))
  else
    Result := nil;
end;

function TsgDXFEntitySample.GetLayer: TsgDXFLayer;
begin
  if (FConverter <> nil) and (FConverter.FLayers <> nil) then
    Result := TsgDXFLayer(FConverter.FLayers.FindEntByName(
      FConverter.FHeadVarStruct.CLayer))
  else
    Result := nil;
end;

function TsgDXFEntitySample.GetLineType: TsgDXFLineType;
begin
  if FConverter <> nil then
    Result := TsgDXFLineType(FConverter.LTypeByName(FConverter.FHeadVarStruct.CELType))
  else
    Result := nil;
end;

function TsgDXFEntitySample.GetLineTypeScale: Double;
begin
  Result := GetActiveHeadVar^.CELTScale;
end;

function TsgDXFEntitySample.GetLineWeight: Double;
begin
  Result := GetActiveHeadVar^.CELWeight;
end;

function TsgDXFEntitySample.GetPointDisplayMode: Integer;
begin
  Result := GetActiveHeadVar^.PointDisplayMode;
end;

function TsgDXFEntitySample.GetPointDisplaySize: Double;
begin
  Result := GetActiveHeadVar^.PointDisplaySize;
end;

function TsgDXFEntitySample.GetDimTextAlign: Integer;

  function GetTexAlign(const AHeadVar: PsgHeadVarStruct): Integer;
  begin
    if AHeadVar^.DimProps.Tih then
      Result := 0//gorizontal - default
    else
    begin
      if AHeadVar^.DimProps.Toh then
        Result := 2//ISO
      else
        Result := 1;//align
    end;
  end;

begin
  Result := GetTexAlign(GetActiveHeadVar);
end;

function TsgDXFEntitySample.GetDimTextColor: TsgColorCAD;
begin
  Result := GetActiveHeadVar^.DimProps.ClrT;
end;

function TsgDXFEntitySample.GetTextStyle: TsgDXFStyle;
begin
  if (FConverter <> nil) and (FConverter.FStyles <> nil) then
    Result := TsgDXFStyle(FConverter.FStyles.FindEntByName(
      FConverter.HeadVarStruct.TextStyle))
  else
    Result := nil;
end;

function TsgDXFEntitySample.GetTextRotation: TsgFloat;
begin
  Result := FTextRotation;
end;

procedure TsgDXFEntitySample.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  if FConverter = nil then
    FBackGroundImage := nil;
end;

procedure TsgDXFEntitySample.SetAnalogyDistance(const Value: Double);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtAnalogyDistance);
    FConverter.FHeadVarStruct.AnalogyDistance := Value;
    AfterChange(prtAnalogyDistance);
  end;
end;

procedure TsgDXFEntitySample.SetArrowSize(const Value: Double);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if (FConverter <> nil) and (Value >= 0) then
  begin
    BeforeChange(prtArrowSize);
    FConverter.FHeadVarStruct.DimProps.Asz := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Asz := FConverter.FHeadVarStruct.DimProps.Asz;
    AfterChange(prtArrowSize);
  end;
end;

procedure TsgDXFEntitySample.SetBackGroundImage(const Value: TsgDXFImageEnt);
begin
  BeforeChange(prtBackGroundImage);
  FBackGroundImage := Value;
  AfterChange(prtBackGroundImage);
end;

procedure TsgDXFEntitySample.SetColorCAD(const Value: TsgColorCAD);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtColor);
    FConverter.FHeadVarStruct.CEColor := Value;
    AfterChange(prtColor);
  end;
end;

procedure TsgDXFEntitySample.SetDimTextAlign(const Value: Integer);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimTextAlign);
    case Value of
      1://align
        begin
          FConverter.FHeadVarStruct.DimProps.Tih := False;
          FConverter.FHeadVarStruct.DimProps.Toh := False;
        end;
      2://ISO
        begin
          FConverter.FHeadVarStruct.DimProps.Tih := False;
          FConverter.FHeadVarStruct.DimProps.Toh := True;
        end;
    else//gorizontal - default
      FConverter.FHeadVarStruct.DimProps.Tih := True;
      FConverter.FHeadVarStruct.DimProps.Toh := True;
    end;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
    begin
      vDimStyle.FDimProps.Tih := FConverter.FHeadVarStruct.DimProps.Tih;
      vDimStyle.FDimProps.Toh := FConverter.FHeadVarStruct.DimProps.Toh;
    end;
    AfterChange(prtDimTextAlign);
  end;
end;

procedure TsgDXFEntitySample.SetDimTextColor(const Value: TsgColorCAD);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimTextColor);
    FConverter.FHeadVarStruct.DimProps.ClrT := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
     vDimStyle.FDimProps.ClrT := FConverter.FHeadVarStruct.DimProps.ClrT;
    AfterChange(prtDimTextColor);
  end;
end;

procedure TsgDXFEntitySample.SetDimTextOffset(const Value: Double);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimTextOffset);
    FConverter.FHeadVarStruct.DimProps.Gap := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Gap := FConverter.FHeadVarStruct.DimProps.Gap;
    AfterChange(prtDimTextOffset);
  end
end;

procedure TsgDXFEntitySample.SetDimTextPosVert(const Value: TsgDimTextPosVert);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimTextPosVert);
    FConverter.FHeadVarStruct.DimProps.Tad := Integer(Value);
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Tad  := FConverter.FHeadVarStruct.DimProps.Tad ;
    AfterChange(prtDimTextPosVert);
  end
end;

procedure TsgDXFEntitySample.SetFilletRadius(const Value: Double);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtFilletRadius);
    FConverter.FHeadVarStruct.FilletRadius := Value;
    AfterChange(prtFilletRadius);
  end;
end;

procedure TsgDXFEntitySample.SetFontHeight(const Value: TsgFloat);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtTextSize);
    FConverter.FHeadVarStruct.TextSize := Abs(Value);
    AfterChange(prtTextSize);
  end;
end;

procedure TsgDXFEntitySample.SetDimArrowType(var ADimProps: TsgDimStyle;
  const ANameValue: TsgDimNameVal; const AType: TsgDimArrowType);
const
  cnstPropertyTypeArrow: array [vnDIMBLK .. vnDIMLRBLK] of TsgPropertyType =
    (prtArrowType, prtArrowType1, prtArrowType2, prtArrowTypeL);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    CheckArroyType(AType);
    BeforeChange(cnstPropertyTypeArrow[ANameValue]);
    vDimStyle := DimStyle;
    case ANameValue of
      vnDIMBLK1:
        begin
          SetDimArrowType1BySah(AType, FConverter.FHeadVarStruct.DimProps);
          if vDimStyle <> nil then
              vDimStyle.DimArrowType1 := AType;
        end;
      vnDIMBLK2:
        begin
          SetDimArrowType2BySah(AType, FConverter.FHeadVarStruct.DimProps);
          if vDimStyle <> nil then
              vDimStyle.DimArrowType2 := AType;
        end;
      vnDIMLRBLK:
        begin
          ADimProps.Arrows.LrBlk := AType;
          if vDimStyle <> nil then
              vDimStyle.DIMLDRBLKT := AType;
        end;
    end;
    AfterChange(cnstPropertyTypeArrow[ANameValue]);
  end;
end;

procedure TsgDXFEntitySample.SetDimBlk1(const Value: Byte);
begin
  SetDimArrowType(FConverter.FHeadVarStruct.DimProps, vnDIMBLK1, GetArrowType(Value));
end;

procedure TsgDXFEntitySample.SetDimBlk2(const Value: Byte);
begin
  SetDimArrowType(FConverter.FHeadVarStruct.DimProps, vnDIMBLK2, GetArrowType(Value));
end;

procedure TsgDXFEntitySample.SetDimLrBlk(const Value: Byte);
begin
  SetDimArrowType(FConverter.FHeadVarStruct.DimProps, vnDIMLRBLK, GetArrowType(Value));
end;

procedure TsgDXFEntitySample.SetDimExtLineExt(const Value: TsgFloat);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimExtLineExt);
    FConverter.FHeadVarStruct.DimProps.Exe := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Exe := FConverter.FHeadVarStruct.DimProps.Exe;
    AfterChange(prtDimExtLineExt);
  end;
end;

procedure TsgDXFEntitySample.SetDimExtLineOffset(const Value: TsgFloat);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimExtLineExo);
    FConverter.FHeadVarStruct.DimProps.Exo := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Exo := FConverter.FHeadVarStruct.DimProps.Exo;
    AfterChange(prtDimExtLineExo);
  end;
end;

procedure TsgDXFEntitySample.SetDimTextHeight(const Value: TsgFloat);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimTextSize);
    FConverter.FHeadVarStruct.DimProps.Txt := Abs(Value);
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Txt := FConverter.FHeadVarStruct.DimProps.Txt;
    AfterChange(prtDimTextSize);
  end;
end;

procedure TsgDXFEntitySample.SetDimForceText(const Value: Integer);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimTextForce);
    FConverter.FHeadVarStruct.DimProps.TIX := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.TIX := FConverter.FHeadVarStruct.DimProps.TIX;
    AfterChange(prtDimTextForce);
  end;
end;

procedure TsgDXFEntitySample.SetDimLFac(const Value: Double);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimMeasurementsScale);
    FConverter.FHeadVarStruct.DimProps.LFac := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.LFac := FConverter.FHeadVarStruct.DimProps.LFac;
    AfterChange(prtDimMeasurementsScale);
  end;
end;

procedure TsgDXFEntitySample.SetDimPrecision(const Value: Integer);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimPrecision);
    FConverter.FHeadVarStruct.DimProps.Dec := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Dec := FConverter.FHeadVarStruct.DimProps.Dec;
    AfterChange(prtDimPrecision);
  end;
end;

procedure TsgDXFEntitySample.SetDimScale(const Value: Double);
var
  vDimStyle: TsgDXFDimensionStyle;
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtDimScale);
    FConverter.FHeadVarStruct.DimProps.Scale := Value;
    vDimStyle := DimStyle;
    if vDimStyle <> nil then
      vDimStyle.FDimProps.Scale := FConverter.FHeadVarStruct.DimProps.Scale;
    AfterChange(prtDimScale);
  end;
end;

procedure TsgDXFEntitySample.SetDimStyle(const Value: TsgDXFDimensionStyle);
begin
  if (Value = nil) or (FConverter = nil) then Exit;
  BeforeChange(prtDimStyle);
  FConverter.FHeadVarStruct.DimStyle := Value.Name;
  if DimStyle.TextStyle <> nil then
    FConverter.FHeadVarStruct.DimTextStyle := Value.TextStyle.Name
  else
    FConverter.FHeadVarStruct.DimTextStyle := cnstSGHeadVarStruct.DimTextStyle;
  FConverter.FHeadVarStruct.DimProps := Value.FDimProps;
  AfterChange(prtDimStyle);
end;

procedure TsgDXFEntitySample.SetLayer(const Value: TsgDXFLayer);
begin
  if (FConverter <> nil) and (Value <> nil) and (not Value.Frozen) then
  begin
    BeforeChange(prtLayer);
    if Value <> nil then
      FConverter.FHeadVarStruct.CLayer := Value.Name
    else
      FConverter.FHeadVarStruct.CLayer := '';
    AfterChange(prtLayer);
  end;
end;

procedure TsgDXFEntitySample.SetLineType(const AValue: TsgDXFLineType);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtLineType);
    if AValue <> nil then
      FConverter.FHeadVarStruct.CELType := AValue.Name
    else
      FConverter.FHeadVarStruct.CELType := '';
    AfterChange(prtLineType);
  end;
end;

procedure TsgDXFEntitySample.SetLineTypeScale(Value: Double);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtLineTypeScale);
    FConverter.FHeadVarStruct.CELTScale := CorrectScale(Value, FConverter.FHeadVarStruct.CELTScale, True);
    AfterChange(prtLineTypeScale);
  end;
end;

procedure TsgDXFEntitySample.SetLineWeight(Value: Double);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtLineWeight);
    FConverter.FHeadVarStruct.CELWeight := Value;
    AfterChange(prtLineWeight);
  end;
end;

procedure TsgDXFEntitySample.SetPointDisplayMode(const Value: Integer);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtPointDisplayMode);
    FConverter.FHeadVarStruct.PointDisplayMode := Value;
    AfterChange(prtPointDisplayMode);
  end;
end;

procedure TsgDXFEntitySample.SetPointDisplaySize(const Value: Double);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtPointDisplaySize);
    FConverter.FHeadVarStruct.PointDisplaySize := Value;
    AfterChange(prtPointDisplaySize);
  end;
end;

procedure TsgDXFEntitySample.SetTextStyle(const Value: TsgDXFStyle);
begin
  if (Value = nil) or (FConverter = nil) then Exit;
  BeforeChange(prtTextStyle);
  FConverter.FHeadVarStruct.TextStyle := Value.Name;
  AfterChange(prtTextStyle);
end;

procedure TsgDXFEntitySample.SetTextRotation(const AValue: TsgFloat);
begin
  if FConverter <> nil then
  begin
    BeforeChange(prtTextRotation);
    try
      FTextRotation := AValue;
    finally
      AfterChange(prtTextRotation);
    end;
  end;
end;

function TsgDXFEntitySample.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (LineTypeScale <> 1) then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLineTypeScale].Name).ValueData,
      LineTypeScale, xmlForViewing in AParams.Mode);
  if IsXMLHelp(AParams.Mode) then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlLayerName].Name);
  end
  else
  begin
    if Assigned(Layer) and (IsFullProps(AParams.Mode) or (Layer.NameID <> slrnZero)) then
      ANode.AddAttribNV(cnstXMLNames[xmlLayerName].Name).ValueAsStr := Layer.Name;
  end;
end;

function TsgDXFEntitySample.UseTextStyleFixedHeight: Boolean;
var
  vHeight: Double;
  vDimStyle: TsgDXFDimensionStyle;
begin
  Result := False;
  vDimStyle := GetDimStyle;
  if Assigned(vDimStyle) then
    Result := not vDimStyle.GetTextHeightReal(vHeight);
end;

function TsgDXFEntitySample.GetAnalogyDistance: Double;
begin
  Result := GetActiveHeadVar^.AnalogyDistance;
end;

function TsgDXFEntitySample.GetArrowSize: Double;
begin
  Result := GetActiveHeadVar^.DimProps.Asz;
end;

{ TsgDXFPenEntity }

function TsgDXFPenEntity.IsOnePixelOptimisationValid: Boolean;//evg
begin
  Result := (Lines = nil) or Lines.IsSolid;
end;

constructor TsgDXFPenEntity.Create;
begin
  inherited Create;
  FLineTypeScale := 1;
end;

function TsgDXFPenEntity.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlLineTypeScale: LineTypeScale := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFPenEntity.GetLineTypeScale: Double;
begin
  Result := FLineTypeScale;
end;

procedure TsgDXFPenEntity.SetLineTypeScale(Value: Double);
begin
  FLineTypeScale := CorrectScale(Value, FLineTypeScale);
end;

function TsgDXFPenEntity.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (LineTypeScale <> 1) then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLineTypeScale].Name).ValueData,
      LineTypeScale, xmlForViewing in AParams.Mode);
end;

{ TsgDXFPenTableItem }

procedure TsgDXFPenTableItem.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFPenTableItem then
    FFlags := TsgDXFPenTableItem(Source).Flags;
end;

function TsgDXFPenTableItem.GetFlags: Integer;
begin
  Result := FFlags;
end;

procedure TsgDXFPenTableItem.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFPenTableItem.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcName].Name] := Name;
end;
{$ENDIF}

{ TsgDXFObjectEntityLineType }

procedure TsgDXFObjectEntityLineType.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFObjectEntityLineType then
    LineType := TsgDXFObjectEntityLineType(Source).LineType;
end;

procedure TsgDXFObjectEntityLineType.ClearReferences;
begin
  inherited ClearReferences;
  FLineTypeItem.Item := nil;
end;

constructor TsgDXFObjectEntityLineType.Create;
begin
  inherited Create;
  FLineTypeItem := TsgTableItem.Create;
end;

procedure TsgDXFObjectEntityLineType.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FLineTypeItem);
end;

function TsgDXFObjectEntityLineType.GetLines: TsgLines;
begin
  if (LineType = nil) or (LineType.NameID = sltnByLayer) then
  begin
    if Layer <> nil then
      Result := Layer.Lines
    else
      Result := StdLines;
  end
  else
    Result := LineType.Lines;
end;

function TsgDXFObjectEntityLineType.GetLineType: TsgDXFLineType;
begin
  Result := TsgDXFLineType(FLineTypeItem.Item);
end;

procedure TsgDXFObjectEntityLineType.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFObjectEntityLineType.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  if LineType = nil then
    LineType := AConverter.LTypeByName(sByLayer);
end;

procedure TsgDXFObjectEntityLineType.SetLineType(const AValue: TsgDXFLineType);
begin
  FLineTypeItem.Item := AValue;
end;

{TsgDXFLineType}

procedure TsgDXFLineType.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFLineType then
  begin
    Lines.Assign(TsgDXFLineType(Source).Lines);
    FNameID := TsgDXFLineType(Source).NameID;
  end;
end;

constructor TsgDXFLineType.Create;
begin
  inherited Create;
  FLines := TsgLines.Create;
end;

procedure TsgDXFLineType.AddComplexElement(const AComplexType: Byte;
  const ADash, ARotation, AScale, AXOffset, AYOffset: Double;
  AStyle: TsgDXFStyle; const AShapeNumber: Byte; const AText: string = '';
  AScaleFactor: Double = cnstLTScale);
var
  vElement: TsgLTypeElement;
begin
  vElement.ComplexType := AComplexType;        // 74
  vElement.Dash := ADash * AScaleFactor;       // 49
  vElement.Rotation := ARotation;              // 50
  vElement.Scale := AScale * AScaleFactor;     // 46
  vElement.XOffset := AXOffset * AScaleFactor; // 44
  vElement.YOffset := AYOffset * AScaleFactor; // 45
  vElement.Style := AStyle;                    // 340
  vElement.Text := AText;                      // 9
  vElement.ShapeNumber := AShapeNumber;        // 75
  FLines.Add(vElement);
end;

procedure TsgDXFLineType.AddDashElement(const ADash: Double;
  AScaleFactor: Double = cnstLTScale);
var
  vElement: TsgLTypeElement;
begin
  FillChar(vElement, SizeOf(vElement), 0);
  vElement.Dash := ADash * AScaleFactor;
  vElement.Scale := 1.0;
  vElement.Text := '';
  FLines.Add(vElement);
end;

procedure TsgDXFLineType.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FLines);
end;

function TsgDXFLineType.GetLines: TsgLines;
begin
  Result := FLines;
end;

procedure TsgDXFLineType.SetLineTypeScale(Value: Double);
begin
  inherited SetLineTypeScale(Value);
  if FLines <> nil then
    FLines.Scale := CorrectScale(Value, FLines.Scale);
end;

procedure TsgDXFLineType.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
  Lines.Link(AConverter);
end;

procedure TsgDXFLineType.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  FLines.Loaded(AConverter);
  // "CONTINUOUS" linetype always as continuous line
  if FNameID = sltnContinious then
    FLines.Clear;
end;

procedure TsgDXFLineType.NameChanging(var NewName: string; var AAllow: Boolean);
begin
  FNameID := CheckStandartNames(NewName);
end;

function TsgDXFLineType.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vPatterns, vPattern: TsgNode;
  vElement: TsgLTypeElement;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddChildNV(cnstXMLNames[xmlPatterns].Name)
  else
  begin
    if Assigned(FLines) and (FLines.ElementsCount > 0) then
    begin
      vPatterns := ANode.AddChildNV(cnstXMLNames[xmlPatterns].Name);
      vPatterns.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := FLines.ElementsCount;
      if IsFullProps(AParams.Mode) then
      begin
        for I := 0 to FLines.ElementsCount - 1 do
        begin
          vPattern := vPatterns.AddChildNV(cnstXMLNames[xmlPattern].Name);
          vElement := FLines.Elements[I];
          vPattern.AddAttribNV(cnstXMLNames[xmlComplexType].Name).ValueAsInt := vElement.ComplexType and $07;
          vPattern.AddAttribNV(cnstXMLNames[xmlDash].Name).ValueAsDouble := vElement.Dash;
          if vElement.ComplexType > 0 then
          begin
            vPattern.AddAttribNV(cnstXMLNames[xmlScale].Name).ValueAsDouble := vElement.Scale;
            vPattern.AddAttribNV(cnstXMLNames[xmlRotation].Name).ValueAsDouble := vElement.Rotation;
            vPattern.AddAttribNV(cnstXMLNames[xmlOffset].Name).ValueAsF2DPoint := MakeF2DPoint(vElement.XOffset, vElement.YOffset);
            vPattern.AddAttribNV(cnstXMLNames[xmlIndex].Name).ValueAsDouble := vElement.ShapeNumber;
            if vElement.ComplexType and 2 <> 0 then
              vPattern.AddAttribNV(cnstXMLNames[xmlText].Name).ValueAsStr := vElement.Text;
            if Assigned(vElement.Style) and (vElement.Style is TsgDXFStyle) then
              vPattern.AddAttribNV(cnstXMLNames[xmlStyleName].Name).ValueAsStr := TsgDXFStyle(vElement.Style).Name;
          end;
        end;
      end;
    end;
  end;
end;

function TsgDXFLineType.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  I, J: Integer;
  vConv: TsgDXFConverter;
  vStyleDefault: TsgDXFStyle;
  vPatterns, vPattern, vAttrib: TsgNodeSample;
  vOffset: TF2DPoint;
  vElement: TsgLTypeElement;

  function GetStyleDefault: TsgDXFStyle;
  begin
    if not Assigned(vStyleDefault) then
    begin
      vStyleDefault := vConv.StyleByPrimaryFont(cnstFileNameOfShapes);
      if vStyleDefault = nil then
      begin
        vStyleDefault := TsgDXFStyle.Create;
        vStyleDefault.Name := '';
        vStyleDefault.Flags := 1;
        vStyleDefault.PrimaryFont := cnstFileNameOfShapes;
        vConv.Loads(vStyleDefault);
        vConv.Sections[csStyles].AddEntity(vStyleDefault);
      end;
    end;
    Result := vStyleDefault;
  end;

  procedure SetElementStyle(const AName: string);
  var
    vStyle: TsgDXFStyle;
  begin
    if not Assigned(vConv) then Exit;
    if Length(AName) = 0 then
      vElement.Style := GetStyleDefault
    else
    begin
      vStyle := TsgDXFStyle(vConv.CustomEntByName(UpperCase(AName), csStyles, False));
      if not Assigned(vStyle) then
        vStyle := GetStyleDefault;
      vElement.Style := vStyle;
    end;
  end;

begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPatterns:
      begin
        vPatterns := nil;
        if AIsChild then
          vPatterns := ANode;
        if Assigned(vPatterns) then
        begin
          vConv := Converter;
          vStyleDefault := nil;
          if Assigned(FLines) then
            FLines.Clear
          else
            FLines := TsgLines.Create;
          try
            for I := 0 to vPatterns.ChildNodesCount - 1 do
            begin
              vPattern := vPatterns.ChildNodes[I];
              if SameText(vPattern.Name, cnstXMLNames[xmlPattern].Name) then
              begin
                vElement.Text := '';
                FillChar(vElement, SizeOf(vElement), 0);
                try
                  for J := 0 to vPattern.AttributeNodesCount - 1 do
                  begin
                    vAttrib := vPattern.AttributeNodes[J];
                    case GetXMLId(vAttrib.Name) of
                      xmlComplexType:  vElement.ComplexType := vAttrib.ValueAsInt and $07;
                      xmlDash:  vElement.Dash := vAttrib.ValueAsDouble;
                      xmlScale: vElement.Scale := vAttrib.ValueAsDouble;
                      xmlText:  vElement.Text := vAttrib.ValueAsStr;
                      xmlRotation: vElement.Rotation := vAttrib.ValueAsDouble;
                      xmlOffset:
                        begin
                          vOffset := vAttrib.ValueAsF2DPoint;
                          vElement.XOffset := vOffset.X;
                          vElement.YOffset := vOffset.Y;
                        end;
                      xmlIndex:     vElement.ShapeNumber := vAttrib.ValueAsInt;
                      xmlStyleName: SetElementStyle(vAttrib.ValueAsStr);
                    end;
                  end;
                finally
                  if vElement.ComplexType > 0 then
                    SetElementStyle('');
                  FLines.Add(vElement);
                end;
              end;
            end;
          finally
            if Assigned(vConv) then
              FLines.Loaded(vConv);
          end;
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{TsgDXFLayer}

procedure TsgDXFLayer.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFLayer then
  begin
    LineType := TsgDXFLayer(Source).LineType;
    FVisible := TsgDXFLayer(Source).FVisible;
    FIsPlotting := TsgDXFLayer(Source).IsPlotting;
    FMaterialItem.Item := TsgDXFLayer(Source).FMaterialItem.Item;
    FNameID := TsgDXFLayer(Source).NameID;
  end;
end;

constructor TsgDXFLayer.Create;
begin
  inherited Create;
  FLineTypeItem := TsgTableItem.Create;
  FMaterialItem := TsgTableItem.Create;
  FVisible := True;
  FIsPlotting := True;
  FLineWeight := fLineWeightDefault;
  FColor := cnstColorCADByBlackWhite;
  FIsCheckName := GlobalCheckNameLayer;
  FAnnoScaleItem := TsgTableItem.Create;
end;

procedure TsgDXFLayer.ClearReferences;
begin
  inherited ClearReferences;
  FLineTypeItem.Item := nil;
  FAnnoScaleItem.Item := nil;
  FMaterialItem.Item := nil;
end;

procedure TsgDXFLayer.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FLineTypeItem);
  FreeAndNil(FAnnoScaleItem);
  FreeAndNil(FMaterialItem);
end;

function TsgDXFLayer.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);

  case AType.Id of
    xmlName: begin
      if not IsNameCorrect(Name) then
      begin
        Result := cnstXML_ERROR;
        if Assigned(AResult) then
        begin
          DoErrorXMLNode(AResult.Errors, False, ANode, xmlName);
        end;
        Exit;
      end;
    end;
  end;

  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlVisible: Visible := ANode.ValueAsBool;
    xmlLocked: Locked := ANode.ValueAsBool;
    xmlFrozen: Frozen := ANode.ValueAsBool;
    xmlFrozenByNewViewPort: IsFrozenByNewViewPort := ANode.ValueAsBool;
    xmlXrefLink: XrefLink := ANode.ValueAsBool;
    xmlIsPlotting: IsPlotting := ANode.ValueAsBool;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFLayer.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcFrozen].Name] := Frozen;
  ANode.ChildValues[sPlcKeyWords[plcPlotting].Name] := IsPlotting;
  ANode.ChildValues[sPlcKeyWords[plcThickness].Name] := GetThickness;
end;

function TsgDXFLayer.SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
  const AType: TsgPlcType; const AValue: Variant): Integer;
begin
  Result := cnstExportToXML_OK;
  case AType.Id of
    plcFrozen: Frozen := AValue;
    plcPlotting: IsPlotting := AValue;
    plcThickness: LineWeight := AValue;
  else
    Result := inherited SetPropertyFromPluginsInternal(ANode, AType, AValue);
  end;
end;
{$ENDIF}

function TsgDXFLayer.GetVisible: Boolean;
begin
  Result := FVisible;
end;

procedure TsgDXFLayer.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AChangeList) then
    begin
      AChangeList.Add(Integer(xmlFrozen));
      AChangeList.Add(Integer(xmlVisible));
      AChangeList.Add(Integer(xmlLocked));
      AChangeList.Add(Integer(xmlIsPlotting));
    end;
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlFrozenByNewViewPort));
      AHideList.Add(Integer(xmlXrefLink));
    end;
  end;
end;

function TsgDXFLayer.GetXrefLink: Boolean;
begin
  Result := FFlags and 16 <> 0;
end;

function TsgDXFLayer.GetContainerLayer: TsgDXFLayer;
var
  vLayerName, vBlockName: string;
  vMainConv: TsgDXFConverter;
begin
  Result := nil;
  if Assigned(Converter) and Assigned(Converter.FContainerXref) then
  begin
    vMainConv := Converter.GetMainConverter;
    vLayerName := Name;
    if NameID <> slrnZero then
    begin
      vBlockName := Converter.FContainerXref.Block.Name;
      vLayerName := vBlockName + cnstXRefNameDelimiter + vLayerName;
    end;
    if not Assigned(FContainerLayer) or (FContainerLayer.Name <> vLayerName) then
      FContainerLayer := TsgDXFLayer(vMainConv.FLayers.FindEntByName(vLayerName));
    Result := FContainerLayer;
  end;
end;

function TsgDXFLayer.GetFrozen: Boolean;
begin
  Result := FFlags and 1 <> 0;
end;

function TsgDXFLayer.GetFrozenByNewViewPort: Boolean;
begin
  Result := FFlags and 2 <> 0;
end;

function TsgDXFLayer.GetIsPlotting: Boolean;
begin
  Result := (AnsiUpperCase(Name) <> sLayerDefPoints) and FIsPlotting;
end;

function TsgDXFLayer.GetLines: TsgLines;
begin
  if LineType = nil then
    Result := inherited GetLines
  else
    Result := LineType.Lines;
end;

function TsgDXFLayer.GetLineType: TsgDXFLineType;
begin
  Result := TsgDXFLineType(FLineTypeItem.Item);
end;

function TsgDXFLayer.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgDXFLayer.GetLocked: Boolean;
begin
  Result := FFlags and 4 <> 0;
end;

function TsgDXFLayer.GetMaterial: TsgDXFMaterial;
begin
  Result := TsgDXFMaterial(FMaterialItem.Item);
end;

function TsgDXFLayer.GetUsed: Boolean;
begin
  Result := FLinkID.RefCount > 0;
end;

procedure TsgDXFLayer.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFLayer.UpdateAnnoScale(AConverter: TsgDXFConverter);
var
  I: Integer;
  D: TsgDXFDictionary;
  E: TsgDXFEntity;
  Data: TsgCADExtendedData;
begin
  Annotative := False;
  D := TsgDXFDictionary(Dictionary);
  if Assigned(D) then
  begin
    E := D.FindEntByName(cnstASDK_XREC_ANNO_SCALE_INFO);
    if E = nil then
      E := D.FindEntByName(cnstASDK_XREC_ANNOTATION_SCALE_INFO);
    if E is TsgDXFXRecord then
    begin
      Data := TsgDXFXRecord(E).Data;
      I := 0;
      while (I < Data.DataCount) and (Data.DataType[I] <> edtInt64) and (Data.DataCode[I] <> 340) do Inc(I);
      if (I < Data.DataCount) and Assigned(AConverter.ScaleList) then
      begin
        E := AConverter.ScaleList.FindEntByHandle(Data.DataInt64[I]);
        FAnnoScaleItem.Item := E;
        Annotative := Assigned(E);
        if Annotative and (TsgDXFScale(E).Description = AConverter.AnnoDesc) then
          AConverter.AnnoScale := TsgDXFScale(E);
      end;
    end;
  end;
end;

function TsgDXFLayer.GetAnnoScale: TsgDXFScale;
begin
  Result := TsgDXFScale(FAnnoScaleItem.Item);
end;

procedure TsgDXFLayer.LoadedInternal(AConverter: TsgDXFConverter);
var
  vColorCAD: TsgColorCAD;
begin
  inherited LoadedInternal(AConverter);
  if Annotative then
    UpdateAnnoScale(AConverter);
  vColorCAD := ColorCAD;
  if Integer(vColorCAD.Color) < 0 then // invisible
  begin
    vColorCAD.Color := -Integer(vColorCAD.Color);
    ColorCAD := vColorCAD;
    FVisible := False;
  end;
  if Assigned(LineType) then//layer has not line type by layer or by block
    if LineType.NameID in [sltnByBlock, sltnByLayer] then
      LineType := AConverter.LTypeByName(sContinuous);
  if (FNameID = slrnHasAsterisk) and (Name = cnstAdskConstraints) then
    Frozen := True;
end;

procedure TsgDXFLayer.NameChanging(var NewName: string; var AAllow: Boolean);
begin
  if IsCheckName then
  begin
    if not IsNameCorrect(NewName, [cnstVertSlash, cnstStar]) then
    begin
      AAllow := False;
      raise EsgIncorrectNameLayer.Create(sIncorrectNameLayer);
    end;
  end;
  if NewName <> '' then
  begin
    if NewName = '0' then
      FNameID := slrnZero
    else
      if NewName[1] = cnstAsterisk then
        FNameID := slrnHasAsterisk
      else
        if sgSameText(NewName, sLayerDefPoints) then
          FNameID := slrnDefpoints
        else
          FNameID := slrnAny;
  end
  else
    FNameID := slrnEmpty;
  if (FNameID = slrnHasAsterisk) and (NewName = cnstAdskConstraints) then
    Frozen := True;
end;

procedure TsgDXFLayer.SetFrozen(AFrozen: Boolean);
begin
  FFlags := (FFlags and not 1) or Ord(AFrozen);
end;

procedure TsgDXFLayer.SetFrozenByNewViewPort(const Value: Boolean);
begin
  FFlags := (FFlags and not 2) or (Ord(Value) shl 1);
end;

procedure TsgDXFLayer.SetLineType(const AValue: TsgDXFLineType);
begin
  FLineTypeItem.Item := AValue;
end;

procedure TsgDXFLayer.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgDXFLayer.SetLocked(const Value: Boolean);
begin
  FFlags := (FFlags and not 4) or (Ord(Value) shl 2);
end;

procedure TsgDXFLayer.SetMaterial(const Value: TsgDXFMaterial);
begin
  FMaterialItem.Item := Value;
end;

procedure TsgDXFLayer.SetVisible(Value: Boolean);
begin
  FVisible := Value;
end;

procedure TsgDXFLayer.SetXrefLink(const Value: Boolean);
begin
  FFlags := (FFlags and ($FF and not $30)) or // mask = 00110000b
    (Ord(Value) shl 4) or
    (Ord(Value) shl 5); // set this bit when xref file resolved
end;

function TsgDXFLayer.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlVisible].Name).ValueAsBool := Visible;
  ANode.AddAttribNV(cnstXMLNames[xmlLocked].Name).ValueAsBool := Locked;
  ANode.AddAttribNV(cnstXMLNames[xmlFrozen].Name).ValueAsBool := Frozen;
  ANode.AddAttribNV(cnstXMLNames[xmlFrozenByNewViewPort].Name).ValueAsBool := IsFrozenByNewViewPort;
  ANode.AddAttribNV(cnstXMLNames[xmlXrefLink].Name).ValueAsBool := XrefLink;
  ANode.AddAttribNV(cnstXMLNames[xmlIsPlotting].Name).ValueAsBool := IsPlotting;
  ANode.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := FLinkID.RefCount;
end;

{TsgDXFGroup}

procedure TsgDXFGroup.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  FEntities[AIndex] := AEntity;
end;

procedure TsgDXFGroup.SetUseEntityInvisible(AValue: Boolean);
begin
  FInternalFlags :=  (FInternalFlags and $FEFF) or (Integer(AValue) shl 8);
end;

//function TsgDXFGroup.AddHandleItem(const AItem: TsgDXFEntity): Integer;
//begin
//  Result := -1;
//  if AItem.Handle <> cnstBadHandle then
//    Result := FSortHandles.Add(AItem.Handle, AItem);
//end;

procedure TsgDXFGroup.UpdateBox;
begin
end;

function TsgDXFGroup.CanAddedToXMLParams: Boolean;
begin
  Result := True;
end;

procedure TsgDXFGroup.Clear(const ADoFree: Boolean);
begin
//  FSortHandles.Clear(True);
  inherited Clear(ADoFree);
  if InternalFlags and 2 = 0 then
    ClearEntCollection(FEntities, ADoFree)
  else
    ClearItemsCollection(FEntities, ADoFree);
end;

procedure TsgDXFGroup.AddEntities(const ASource: TsgDXFEntity;
  AConverter: TsgDXFConverter = nil);
var
  I: Integer;
  vEntNew, vEntSource: TsgDXFEntity;
begin
  if not Assigned(AConverter) then
    AConverter := Converter;
  for I := 0 to ASource.Count - 1 do
  begin
    vEntSource := TsgDXFEntity(ASource.Entities[I]);
    vEntNew := TsgDXFEntityClass(vEntSource.ClassType).Create;
    vEntNew.AssignEntity(vEntSource);
    AddEntity(vEntNew);
    if Assigned(AConverter) then
      AConverter.Loads(vEntNew);
  end;
end;

constructor TsgDXFGroup.Create;
begin
  inherited Create;
  FEntities := TsgEntitiesList(TsgEntitiesList.CreateList(ListNotify));
//  FSortHandles := CreateCollection;
end;

function TsgDXFGroup.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FEntities[AIndex];
  FEntities.Delete(AIndex);
end;

procedure TsgDXFGroup.DoListNotify(Ptr: Pointer; Action: TListNotification);
begin
  if Assigned(FOnListNotify) then
    FOnListNotify(Ptr, Action);
end;

//function TsgDXFGroup.DeleteHandleItem(const AItem: TsgDXFEntity): Integer;
//begin
//  Result := FSortHandles.IndexOf(AItem.Handle);
//  if Result >= 0 then
//    FSortHandles.Delete(Result);
//end;

procedure TsgDXFGroup.ExchangeEntity(AIndex1, AIndex2: Integer);
begin
  if AIndex1 <> AIndex2 then
    FEntities.Exchange(AIndex1, AIndex2);
end;

procedure TsgDXFGroup.FreeReferences;
begin
  inherited FreeReferences;
//  FreeAndNil(FSortHandles);
  FreeAndNil(FEntities);
end;

function TsgDXFGroup.IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := FEntities.IndexOf(AEntity);
end;

function TsgDXFGroup.IndexOfName(const AName: string): Integer;
begin
  if not FindChildByEntName(Self, AName, False, Result) then
    Result := -1;
end;

function TsgDXFGroup.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := AEntity.EntType <> ceSeqEnd;
  if Result then
    FEntities.Insert(AIndex, AEntity);
end;

procedure TsgDXFGroup.Iterate(AConverter: TsgDXFConverter;  Proc, FinishProc: TsgCADEntityProc);
var
  vStopped: PBoolean;
  I: Integer;
begin
  vStopped := @AConverter.Params^.Stopped;
  I := 0;
  while (I < Count) and not vStopped^ do
  begin
    Entities[I].Invoke(AConverter, Proc, FinishProc);
    Inc(I);
  end;
end;

function TsgDXFGroup.GetCount: Integer;
begin
  Result := FEntities.Count;
end;

function TsgDXFGroup.GetUseEntityInvisible: Boolean;
begin
  Result := (FInternalFlags and $100) <> 0;
end;

procedure TsgDXFGroup.SortEntByHandle;
begin
  if FEntities.Count > 1 then
    QSortArrayBounds(FEntities.List, CompareHandleEntities, 0, FEntities.Count - 1);
end;

function TsgDXFGroup.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FEntities[AIndex];
end;

{$IFDEF SGDEL_2005}
//function TsgDXFGroup.GetEnumerator: TListEnumerator;
//begin
//  Result := FEntities.GetEnumerator;
//end;
{$ENDIF}

function TsgDXFGroup.GetStrValue: string;
begin
  Result := EntName;
end;

procedure TsgDXFGroup.ListNotify(const Obj: TObject; Action: TListNotification);
begin
  case Action of
    lnAdded:
      begin
        inherited ListNotify(Obj, Action);
        TsgDXFEntity(Obj).SetOwner(Self);
        DoListNotify(Obj, Action);
      end;
    lnExtracted, lnDeleted:
      begin
        DoListNotify(Obj, Action);
        TsgDXFEntity(Obj).SetOwner(nil);
        inherited ListNotify(Obj, Action);
      end;
  end;
end;

procedure TsgDXFGroup.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  UpdateBox;
end;

{ TsgDXFGroupEntity }

procedure TsgDXFGroupEntity.UpdateBox;
var
  I: Integer;
begin
  FBox := BadRect;
  for I := 0 to Count - 1 do        // FBox is union of all entities
    if Entities[I].Visibility then
      UnionFRect(FBox, Entities[I].Box);
end;

constructor TsgDXFGroupEntity.Create;
begin
  inherited Create;
  FBox := cnstBadRect;
end;

function TsgDXFGroupEntity.FindEntity(
  const AProc: TsgObjProc; const AList: TList): TsgDXFEntity;
var
  I: Integer;
  vEnt: TsgDXFEntity;
begin
  Result := nil;
  if Assigned(AProc) then
  begin
    for I := 0 to Count - 1 do
    begin
      vEnt := Entities[I];
      if AProc(vEnt) <> nil then
      begin
        Result := vEnt;
        if Assigned(AList) then
          AList.Add(vEnt)
        else
          Break;
      end;
    end;
  end;
end;

function TsgDXFGroupEntity.GetBox: TFRect;
begin
  Result := FBox;
end;

class function TsgDXFGroupEntity.IsAttdef(const AEntity: Pointer): Pointer;
begin
  Result := nil;
  if TsgDXFEntity(AEntity).EntType = ceAttdef then
    Result := AEntity;
end;

procedure TsgDXFGroupEntity.LoadIntities(const AConverter: TsgDXFConverter;
  ALoadSelf: Boolean);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    AConverter.Loads(Entities[I]);
  if ALoadSelf then
    AConverter.Loads(Self);
end;

{TsgDXFPenLine}

function TsgDXFPenLine.GetBox: TFRect;
begin
  Result.TopLeft := Point;
  Result.BottomRight := Point;
end;

procedure TsgDXFPenLine.AddThickness(var R: TFRect);
var
  T: Double;
begin
  if GetThickness <= 0 then
    Exit;
  T := GetThickness / 2;
  R.Left := R.Left - T;
  R.Top := R.Top + T;
  R.Right := R.Right + T;
  R.Bottom := R.Bottom - T;
end;

procedure TsgDXFPenLine.ApplyExtrusionByPoint;
begin
  if IsExtruded then
    DoExtrusion(FPoint, FExtrusion^);
end;

function TsgDXFPenLine.IsExtruded: Boolean;
begin
  Result := FExtrusion <> nil;
end;

function TsgDXFPenLine.GetExtrusion: TFPoint;
begin
  if IsExtruded then
    Result := FExtrusion^
  else
    Result := cnstExtrusion;
end;

function TsgDXFPenLine.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgDXFPenLine.GetThicknessInt: Double;
begin
  Result := GetZThick;
end;

function TsgDXFPenLine.GetZThick: Double;
begin
  Result := FZThick;
end;

procedure TsgDXFPenLine.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgDXFPenLine.SetZThick(const Value: Double);
begin
  FZThick := Value;
end;

function TsgDXFPenLine.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (FZThick <> 0) then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlZThick].Name).ValueData,
      FZThick, xmlForViewing in AParams.Mode);
  if IsFullPropsOrXMLHelp(AParams.Mode) or IsExtruded then
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlExtrusion].Name).ValueData,
      Extrusion, xmlForViewing in AParams.Mode);
end;

procedure TsgDXFPenLine.FreeReferences;
begin
  inherited FreeReferences;
  DisposeAndNil(FExtrusion);
end;

function TsgDXFPenLine.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlZThick: FZThick := ANode.ValueAsDouble;
    xmlExtrusion: Extrusion := ANode.ValueAsFPoint;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFPenLine.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcLineType].Name] := itoId(LineType);//why ???
  if Assigned(LineType) then
    ANode.ChildValues[sPlcKeyWords[plcLineTypeName].Name] := LineType.Name;
  if ZThick <> 0 then//hide default value
     ANode.ChildValues[sPlcKeyWords[plcZThick].Name] := ZThick;
  if IsExtruded then//hide default value
    SetPointToNode(ANode, Extrusion, sPlcKeyWords[plcExtrusion].Name);
end;
{$ENDIF}

procedure TsgDXFPenLine.SetLWeight(Value: Integer);
begin
  if FLineWeight = fLineWeightByLayer then
    FLineWeight := Value / 100;
end;

procedure TsgDXFPenLine.SetThicknessInt(const AValue: Double);
begin
  SetZThick(AValue);
end;

procedure TsgDXFPenLine.AssignEntity(Source: TsgDXFEntity);
var
  vPenLine: TsgDXFPenLine absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFPenLine then
  begin
    FZThick := vPenLine.FZThick;
    if vPenLine.FExtrusion <> nil then
      Extrusion := vPenLine.FExtrusion^
    else
      DisposeAndNil(FExtrusion);
  end;
end;

procedure TsgDXFPenLine.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  ApplyExtrusionByPoint;
end;

procedure TsgDXFPenLine.SetExtrusion(const Value: TFPoint);
begin
  if IsEqualFPoints(Value, cnstExtrusion) then
    DisposeAndNil(FExtrusion)
  else
  begin
    if FExtrusion = nil then
      New(FExtrusion);
    FExtrusion^ := Value;
  end;
end;

{ TsgDXFSection }

procedure TsgDXFSection.ChangeHandle(AConverter: TsgDXFConverter);
begin
  // don't set Handle for SECTIONs
end;

function TsgDXFSection.GetHandle: UInt64;
begin
  Result := cnstBadHandle;
end;

function TsgDXFSection.IsTablesBelongSection(ATable: TConvSection): Boolean;
begin
  Result := False;
end;

procedure TsgDXFSection.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  if Name = cnstSectionHEADER then
    AConverter.FHeadEnd := SrcEnd;
end;

procedure TsgDXFSection.SetHandle(const Value: UInt64);
begin
  // do nothing
end;

{ TsgDXFVertex }

function TsgDXFVertex.CanHaveHandle: Boolean;
begin
  Result := True;//but does not have a converter
end;

procedure TsgDXFVertex.FreeReferences;
begin
  inherited FreeReferences;
  DisposeAndNil(FPolyFaceIndexes);
end;

function TsgDXFVertex.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPoint: FPoint := ANode.ValueAsFPoint;
    xmlBulge: Bulge := ANode.ValueAsDouble;
    xmlStartWidth: StartWidth := ANode.ValueAsDouble;
    xmlEndWidth: EndWidth := ANode.ValueAsDouble;
    xmlX:  FPoint.X := ANode.ValueAsDouble;
    xmlY:  FPoint.Y := ANode.ValueAsDouble;
    xmlZ:  FPoint.Z := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFVertex.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  SetPointToNode(ANode, Point, sPlcKeyWords[plcPoint].Name);
  if Bulge <> 0 then
    ANode.ChildValues[sPlcKeyWords[plcBulge].Name] := Bulge;
end;
{$ENDIF}

procedure TsgDXFVertex.AssignEntity(Source: TsgDXFEntity);
var
  vVertex: TsgDXFVertex absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFVertex then
  begin
    FPoint := vVertex.FPoint;
    if (FPolyFaceIndexes <> nil) then
    begin
      Dispose(FPolyFaceIndexes);
      FPolyFaceIndexes := nil;
    end;
    if vVertex.FPolyFaceIndexes <> nil then
    begin
      New(FPolyFaceIndexes);
      FPolyFaceIndexes^ := vVertex.FPolyFaceIndexes^;
    end;
    FBulge := vVertex.FBulge;
    FEndWidth := vVertex.FEndWidth;
    FFlags := vVertex.FFlags;
    FStartWidth := vVertex.FStartWidth;
  end;
end;

procedure TsgDXFCustomVertex.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFCustomVertex then
    FPoint := TsgDXFCustomVertex(Source).Point
end;

function TsgDXFCustomVertex.CanDraw: Boolean;
begin
  Result := True;
end;

function TsgDXFCustomVertex.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPoint:
      begin
        if HasPoint then
          FPoint := ANode.ValueAsFPoint;
      end
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFCustomVertex.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  SetPointToNode(ANode, Point, sPlcKeyWords[plcPoint].Name);
end;
{$ENDIF}

function TsgDXFCustomVertex.GetBox: TFRect;
begin
  Result.TopLeft := Point;
  Result.BottomRight := Point;
end;

function TsgDXFCustomVertex.GetPoint: TFPoint;
begin
  Result := FPoint;
end;

function TsgDXFCustomVertex.HasPoint: Boolean;
begin
  Result := True;
end;

procedure TsgDXFCustomVertex.SetPoint(AValue: TFPoint);
begin
  FPoint := AValue;
end;

function TsgDXFCustomVertex.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if HasPoint then
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPoint].Name).ValueData,
      FPoint, xmlForViewing in AParams.Mode);
end;

function TsgDXFVertex.GetBox: TFRect;
begin
  Result.TopLeft := Point;
  Result.BottomRight := Point;
end;

function TsgDXFVertex.GetBulge: Double;
begin
  Result := FBulge;
end;

function TsgDXFVertex.GetEndWidth: Double;
begin
  Result := FEndWidth;
end;

function TsgDXFVertex.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgDXFVertex.GetHandle: UInt64;
begin
  Result := FHandle;
end;

function TsgDXFVertex.GetInternalFlags: Word;
begin
  Result := 1;
end;

function TsgDXFVertex.GetIs3DVertex: Boolean;
begin
  Result := not (FFlags and 32 = 0);
end;

function TsgDXFVertex.GetPolyFaceIndex1: Integer;
begin
  if FPolyFaceIndexes = nil then
    Result := 0
  else
    Result := FPolyFaceIndexes^[1];
end;

function TsgDXFVertex.GetPolyFaceIndex2: Integer;
begin
  if FPolyFaceIndexes = nil then
    Result := 0
  else
    Result := FPolyFaceIndexes^[2];
end;

function TsgDXFVertex.GetPolyFaceIndex3: Integer;
begin
  if FPolyFaceIndexes = nil then
    Result := 0
  else
    Result := FPolyFaceIndexes^[3];
end;

function TsgDXFVertex.GetPolyFaceIndex4: Integer;
begin
  if FPolyFaceIndexes = nil then
    Result := 0
  else
    Result := FPolyFaceIndexes^[4];
end;

function TsgDXFVertex.GetStartWidth: Double;
begin
  Result := FStartWidth;
end;

function TsgDXFVertex.HasBulge: Boolean;
begin
  Result := FBulge <> 0;
end;

function TsgDXFVertex.IsEqualPointBulge(const AVertex: TsgDXFVertex): Boolean;
begin
  Result := IsEqualFPoints(Point, AVertex.Point) and
    IsEqual(Bulge, AVertex.Bulge);
end;

function TsgDXFVertex.IsPolyfaceMeshVertex: Boolean;
begin
  // Vertex is polyface mesh vertex
  Result := FFlags = 128;
end;

function TsgDXFVertex.IsSplineFrameControlPoint: Boolean;
begin
  // Vertex is spline frame control point
  Result := (FFlags and 16) <> 0;
end;

procedure TsgDXFVertex.NewPolyFaceIndexes;
begin
  if FPolyFaceIndexes = nil then
  begin
    New(FPolyFaceIndexes);
    FillChar(FPolyFaceIndexes^, SizeOf(TsgPolyFaceVertexIndexes), 0);
  end;
end;

procedure TsgDXFVertex.SetPolyFaceIndex1(const Value: Integer);
begin
  NewPolyFaceIndexes;
  FPolyFaceIndexes^[1] := Value;
end;

procedure TsgDXFVertex.SetPolyFaceIndex2(const Value: Integer);
begin
  NewPolyFaceIndexes;
  FPolyFaceIndexes^[2] := Value;
end;

procedure TsgDXFVertex.SetPolyFaceIndex3(const Value: Integer);
begin
  NewPolyFaceIndexes;
  FPolyFaceIndexes^[3] := Value;
end;

procedure TsgDXFVertex.SetPolyFaceIndex4(const Value: Integer);
begin
  NewPolyFaceIndexes;
  FPolyFaceIndexes^[4] := Value;
end;

procedure TsgDXFVertex.SetStartWidth(const Value: Double);
begin
  if not Is3DVertex then
    FStartWidth := Value;
end;

function TsgDXFVertex.GetPolyFaceIndex(Index: Integer): Integer;
begin
  if FPolyFaceIndexes = nil then
    Result := -1
  else
    Result := FPolyFaceIndexes^[Index];
end;

procedure TsgDXFVertex.SetPolyFaceIndex(Index: Integer; const Value: Integer);
begin
  if (Index <= High(TsgPolyFaceVertexIndexes)) and
    (Index >= Low(TsgPolyFaceVertexIndexes)) then
  begin
    NewPolyFaceIndexes;
    FPolyFaceIndexes^[Index] := Value;
  end;
end;

function TsgDXFVertex.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlLineWeight].Name);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPoint].Name).ValueData,
    FPoint, xmlForViewing in AParams.Mode);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (FBulge <> 0) then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlBulge].Name).ValueData,
      FBulge, xmlForViewing in AParams.Mode);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (FStartWidth <> 0) or (FEndWidth <> 0) then
  begin
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlStartWidth].Name).ValueData,
      FStartWidth, xmlForViewing in AParams.Mode);
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlEndWidth].Name).ValueData,
      FEndWidth, xmlForViewing in AParams.Mode);
  end;
end;

function TsgDXFVertex.GetPoint: TFPoint;
begin
  Result := FPoint;
end;

procedure TsgDXFVertex.SetBulge(const Value: Double);
begin
  if not Is3DVertex then
    FBulge := Value;
end;

procedure TsgDXFVertex.SetEndWidth(const Value: Double);
begin
  if not Is3DVertex then
    FEndWidth := Value;
end;

procedure TsgDXFVertex.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

procedure TsgDXFVertex.SetHandle(const AValue: UInt64);
begin
{$IFDEF SG_MODULE_LOG}
  inherited SetHandle(AValue);
{$ENDIF}
  FHandle := AValue;
end;

procedure TsgDXFVertex.SetIs3DVertex(const Value: Boolean);
begin
  FFlags := (FFlags and $DF) or (Byte(Value) shl 5);
  if Value then
  begin
    FBulge := 0;
    FEndWidth := 0;
    FStartWidth := 0;
  end;
end;

procedure TsgDXFVertex.SetPoint(const AValue: TFPoint);
begin
  FPoint := AValue;
end;

{ TsgDXFLine }

procedure TsgDXFLine.ApplyExtrusionByPoint;
begin
end;

function TsgDXFLine.GetAngle: TsgFloat;
begin
  Result := GetAngleByPoints(FPoint, FPoint1, False);
end;

function TsgDXFLine.GetBox: TFRect;
begin
  Result := inherited GetBox;
  ExpandFRect(Result, Point1);
  AddZThick(Result);
//  AddThickness(Result);
end;

function TsgDXFLine.GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean;
begin
  if FZThick = 0 then
  begin
    Proc(Point);
    Proc(Point1);
    Result := True;
  end
  else
    Result := inherited GetBoxPoints(Proc, Full);
end;

procedure TsgDXFLine.LoadedInternal(AConverter: TsgDXFConverter);
begin
  if Layer = nil then
    Layer := AConverter.LayerByName('0');
end;

constructor TsgDXFLine.Create;
begin
  inherited Create;
//  FDottedSingPts := TList.Create;
end;

destructor TsgDXFLine.Destroy;
begin
 { if Assigned(FDottedSingPts) then
  begin
    for I := 0 to FDottedSingPts.Count - 1 do
      Dispose(FDottedSingPts[I]);
    FDottedSingPts.Free;
  end;   }
  inherited Destroy;
end;

procedure TsgDXFLine.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFLine then
    FPoint1 := TsgDXFLine(Source).FPoint1;
end;

procedure TsgDXFLine.AddZThick(var R: TFRect);
begin
  if FZThick = 0 then
    Exit;
  ExpandFRect(R, MakeFPoint(Point.X, Point.Y, Point.Z + FZThick));
  ExpandFRect(R, MakeFPoint(Point1.X, Point1.Y, Point1.Z + FZThick));
end;

function TsgDXFLine.GetEntType: TsgCADEntities;
begin
  Result := ceLine;
end;

function TsgDXFLine.GetLength: TsgFloat;
begin
  Result := DistanceFPoint(FPoint, FPoint1);
end;

function TsgDXFLine.GetLine: TsgLine;
begin
  Result.Point1 := Point;
  Result.Point2 := Point1;
end;

function TsgDXFLine.GetPoint1: TFPoint;
begin
  Result := FPoint1;
end;

function TsgDXFLine.GetPoints(const AIndex: Integer): TFPoint;
begin
  case AIndex of
    0:  Result := Point;
    1:  Result := Point1;
  else
    Result := cnstFPointZero;
  end;
end;

procedure TsgDXFLine.SetAngle(const Value: TsgFloat);
var
  vDistance, vValue: Double;
  S, C: Extended;
begin
  if sgModAngle(Value, vValue) then
  begin
    vDistance := DistanceFPoint2D(FPoint, FPoint1);
    if vDistance > fAccuracy then
    begin
      SinCos(vValue * fPiDividedBy180, S, C);
      FPoint1.X := FPoint.X + C * vDistance;
      FPoint1.Y := FPoint.Y + S * vDistance;
    end;
  end;
end;

procedure TsgDXFLine.SetLength(const Value: TsgFloat);
var
  vDelta: TFPoint;
  vDistance: Double;
begin
  if IsEqualFPoints(FPoint, FPoint1) then Exit;
  if IsEqual(Value, 0) then
    FPoint1 := FPoint
  else
  begin
    vDistance := DistanceFPointSqr(FPoint1, FPoint);
    if vDistance > fAccuracy then
    begin
      vDistance := Sqrt(vDistance);
      vDelta := SubFPoint(FPoint1, FPoint);
      FPoint1.X := FPoint.X + Value * vDelta.X / vDistance;
      FPoint1.Y := FPoint.Y + Value * vDelta.Y / vDistance;
      FPoint1.Z := FPoint.Z + Value * vDelta.Z / vDistance;
    end
    else
      FPoint1 := FPoint;
  end;
end;

procedure TsgDXFLine.SetLine(const AValue: TsgLine);
begin
  Point := AValue.Point1;
  Point1 := AValue.Point2;
end;

procedure TsgDXFLine.SetPoint1(AValue: TFPoint);
begin
  FPoint1 := AValue;
end;

procedure TsgDXFLine.SetPoints(const AIndex: Integer; const AValue: TFPoint);
begin
  case AIndex of
    0:  Point := AValue;
    1:  Point1 := AValue;
  end;
end;

function TsgDXFLine.ToXMLOverloadedData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLength].Name).ValueData,
    Length, xmlForViewing in AParams.Mode);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (Angle <> 0) then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlAngle].Name).ValueData,
      Angle, xmlForViewing in AParams.Mode);
  Result := cnstXML_OK;
end;

function TsgDXFLine.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPoint1].Name).ValueData,
    Point1, xmlForViewing in AParams.Mode);
  ToXMLOverloadedData(ANode, AParams);
end;

function TsgDXFLine.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPoint1: Point1 := ANode.ValueAsFPoint;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFLine.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  SetPointToNode(ANode, Point1, sPlcKeyWords[plcPoint1].Name);
end;
{$ENDIF}

{ TsgDXFPoint }

constructor TsgDXFPoint.Create;
begin
  inherited Create;
end;

procedure TsgDXFPoint.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FPoints);
end;

procedure TsgDXFPoint.AssignEntity(Source: TsgDXFEntity);
var
  vPoint: TsgDXFPoint absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFPoint then
  begin
    FPoint := vPoint.Point;
    if FPoints <> nil then
    begin
      ClearPoints;
      FPoints.Free;
      FPoints := nil;
    end;
  end;
end;

procedure TsgDXFPoint.ClearPoints;
var
  I, J, Cnt: Integer;
begin
  if FPoints <> nil then
  begin
    Dispose(FPoints[0]);
    Dispose(FPoints[1]);
    I := 2;
    while I < FPoints.Count do
    begin
      Cnt := Integer(FPoints[I]);
      Inc(I);
      J := I;
      Inc(I, Cnt);
      while J < I do
      begin
        Dispose(FPoints[J]);
        Inc(J);
      end;
    end;
    FPoints.Count := 0;
  end;
end;

procedure TsgDXFPoint.ApplyExtrusionByPoint;
begin
end;

procedure TsgDXFPoint.ClearReferences;
begin
  inherited ClearReferences;
  ClearPoints;
end;

function TsgDXFPoint.GetBox: TFRect;
begin
  if FPoints = nil then
  begin
    Result := inherited GetBox;
    ExpandFRect(Result, MakeFPoint(FPoint.X, FPoint.Y, FPoint.Z + FZThick));
  end
  else
  begin
    Result := cnstBadRect;
    Result.TopLeft := PFPoint(FPoints[0])^;
    Result.BottomRight := PFPoint(FPoints[1])^;
  end;
end;

function TsgDXFPoint.GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean;
var
  vPt: TFPoint;
begin
  if FPoints = nil then
  begin
    vPt := MakeFPoint(0, 0,FZThick);
    if Extruded(Extrusion) then
      DoExtrusion(vPt, FExtrusion^);
    vPt.X := vPt.X + FPoint.X;
    vPt.Y := vPt.Y + FPoint.Y;
    vPt.Z := vPt.Z + FPoint.Z;
    Proc(FPoint);
    Proc(vPt);
  end
  else
  begin
    Proc(PFPoint(FPoints[0])^);
    Proc(PFPoint(FPoints[1])^);
  end;
  Result := True;
end;

function TsgDXFPoint.GetEntType: TsgCADEntities;
begin
  Result := cePoint;
end;

function TsgDXFPoint.GetPoints(const AList: TsgObjectList): Integer;
var
  I, J, Cnt, vCount: Integer;
  vPoints: TFPointList;
begin
  Result := 1;
  if Assigned(FPoints) then
  begin
    I := 2;
    vCount := FPoints.Count;
    while I < vCount do
    begin
      Cnt := Integer(FPoints[I]);
      Inc(I);
      J := I;
      Inc(I, Cnt);
      vPoints := TFPointList.Create;
      AList.Add(vPoints);
      vPoints.Capacity := I - J + 1;
      while J < I do
      begin
        vPoints.Add(PFPoint(FPoints[J])^);
        Inc(J);
      end;
    end;
  end
  else
  begin
    vPoints := TFPointList.Create;
    AList.Add(vPoints);
    vPoints.Add(Point);
  end;
end;

procedure TsgDXFPoint.LoadedInternal(AConverter: TsgDXFConverter);
const
  cnstPi: Double = 3.1415926535897932384626433832795;
  cnst1DivSqrt2: Double = 1 / 1.4142135623730950488016887242097;
var
  vPDMode: Byte;
  vPDSize: Double;
  vBox: TFRect;
  vHasExtrusion: Boolean;
  P: PFPoint;

  procedure AddPt(const AX, AY, AZ: Double);
  begin
    New(P);
    FPoints.Add(P);
    P^.X := AX;
    P^.Y := AY;
    P^.Z := AZ;
    if vHasExtrusion then
      DoExtrusion(P^, FExtrusion^);
    P^.X := P^.X + FPoint.X;
    P^.Y := P^.Y + FPoint.Y;
    P^.Z := P^.Z + FPoint.Z;
    ExpandFRect(vBox, P^);
  end;

  procedure AddCircle;
  var
    I, Cnt: Integer;
    S, C: Extended;
    vStart, vDelta, vRadius: Double;
  begin
    vRadius := vPDSize * 0.5;
    Cnt := AConverter.NumberOfPartsInCircle;
    if Cnt = 0 then
      Cnt := GetNumberOfCircleParts;
    vStart := 0;
    vDelta := cnstPi * 2 / Cnt;
    FPoints.Add(Pointer(Cnt + 1));
    for I := 0 to Cnt do
    begin
      SinCos(vStart, S, C);
      AddPt(vRadius * C, vRadius * S, 0);
      vStart := vStart + vDelta;      
    end;
  end;

  procedure AddCross;
  begin
    FPoints.Add(Pointer(2));
    AddPt(0, vPDSize, 0);
    AddPt(0, -vPDSize, 0);
    FPoints.Add(Pointer(2));
    AddPt(vPDSize, 0, 0);
    AddPt(-vPDSize, 0, 0);
  end;

  procedure AddCrossDiagonal;
  var
    vSize: Double;
  begin
    vSize := vPDSize * cnst1DivSqrt2;
    FPoints.Add(Pointer(2));
    AddPt(vSize, vSize, 0);
    AddPt(-vSize, -vSize, 0);
    FPoints.Add(Pointer(2));
    AddPt(vSize, -vSize, 0);
    AddPt(-vSize, vSize, 0);
  end;

  procedure AddLine;
  begin
    FPoints.Add(Pointer(2));
    New(P);
    FPoints.Add(P);
    P^ := FPoint;
    ExpandFRect(vBox, P^);
    AddPt(0, vPDSize * 0.5, 0);
  end;

  procedure AddPoint;
  begin
    FPoints.Add(Pointer(1));
    New(P);
    FPoints.Add(P);
    P^ := FPoint;
    ExpandFRect(vBox, P^);
  end;

  procedure AddSquare;
  var
    vSize: Double;
  begin
    vSize := vPDSize * 0.5;
    FPoints.Add(Pointer(5));
    AddPt(-vSize, vSize, 0);
    AddPt(vSize, vSize, 0);
    AddPt(vSize, -vSize, 0);
    AddPt(-vSize, -vSize, 0);
    AddPt(-vSize, vSize, 0);
  end;

  procedure DoZTick;
  var
    vPzTick: TFPoint;
    I, J, vCount, Cnt: Integer;
    P0: PFPoint;
  begin
    vPzTick := MakeFPoint(0, 0, FZThick);
    if vHasExtrusion then
      DoExtrusion(vPzTick, Extrusion);
    I := 2;
    vCount := FPoints.Count;
    while I < vCount do
    begin
      Cnt := Integer(FPoints[I]);
      Inc(I);
      J := I;
      Inc(I, Cnt);
      FPoints.Add(Pointer(Cnt));
      while J < I do
      begin
        P0 := FPoints[J];
        Inc(J);
        New(P);
        FPoints.Add(P);
        P^.X := P0^.X + vPzTick.X;
        P^.Y := P0^.Y + vPzTick.Y;
        P^.Z := P0^.Z + vPzTick.Z;
        ExpandFRect(vBox, P^);
      end;
    end;
  end;

begin
  inherited LoadedInternal(AConverter);
  vPDMode := Byte(AConverter.HeadVarStruct.PointDisplayMode);
  vPDSize := AConverter.HeadVarStruct.PointDisplaySize;
  if (Layer <> nil) and (Layer.Name = sLayerDefPoints) then
    vPDMode := 0;
  if Abs(vPDSize) < fAccuracy then
    vPDSize := 1;
  if vPDMode > 1 then
  begin
    vHasExtrusion := IsExtruded;
    vBox := cnstBadRect;
    if FPoints = nil then
      FPoints := TList.Create
    else
      ClearPoints;
    New(P);
    FPoints.Add(P);
    New(P);
    FPoints.Add(P);
    case vPDMode and 7 of
      0:  AddPoint;
      2:  AddCross;
      3:  AddCrossDiagonal;
      4:  AddLine;
    end;
    if (vPDMode and 32) <> 0 then
      AddCircle;
    if (vPDMode and 64) <> 0 then
      AddSquare;
    if Abs(FZThick) > fAccuracy then
      DoZTick;
    PFPoint(FPoints[0])^ := vBox.TopLeft;
    PFPoint(FPoints[1])^ := vBox.BottomRight;
  end
  else
  begin
    if FPoints <> nil then
    begin
      ClearPoints;
      FPoints.Free;
      FPoints := nil;
    end;
  end;
end;

procedure TsgDXFPoint.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
  vPDMode: Integer;
begin
  if (AConverter.Params.Insert <> nil)
    and (AConverter.Params.Insert.EntType = ceDimension) then
  begin
    vPDMode := AConverter.FHeadVarStruct.PointDisplayMode;
    try
      AConverter.FHeadVarStruct.PointDisplayMode := 1;
      LoadedInternal(AConverter);
    finally
      AConverter.FHeadVarStruct.PointDisplayMode := vPDMode;
    end;
  end;
  inherited Invoke(AConverter, Proc, FinishProc);
end;

{ TsgDXFSolid }

function TsgDXFSolid.GetBox: TFRect;
var
  I: Integer;
  vPts: TsgPoints4;
  vCount: Integer;
begin
  vCount := GetPoints(vPts, False, IsExtruded);
  Result.TopLeft := vPts[0];
  Result.BottomRight := Result.TopLeft;
  for I := 1 to vCount - 1 do
    ExpandFRect(Result, vPts[I]);
  if Abs(FZThick) > 0 then
  begin
    GetPoints(vPts, True, IsExtruded);
    for I := 0 to vCount - 1 do
      ExpandFRect(Result, vPts[I]);
  end;
end;

function TsgDXFSolid.GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean;
var
  R: TFRect;
  E: PFPoint;
begin
  Result := True;
  E := FExtrusion;
  FExtrusion := nil;
  R := GetBox;
  FExtrusion := E;
  EnumBoxPoints(R, Proc, Full);
end;

function TsgDXFSolid.GetDrawPoints(const APoints: TFPointList): Boolean;
var
  vPts: TsgPoints4;
begin
  Result := False;
  GetPoints(vPts);
//  if APoints.Capacity - APoints.Count < 6 then
//    APoints.Capacity := APoints.Capacity + 6;
  if Self.InternalFlags and $40 = 0 then
  begin
    Result := True;
    APoints.Add(vPts[0]);
    if Self.InternalFlags and $10 <> 0 then
    begin
      APoints.Add(vPts[2]);
      APoints.Add(vPts[1]);
    end
    else
    begin
      APoints.Add(vPts[1]);
      APoints.Add(vPts[2]);
    end;
  end;
  if Self.InternalFlags and $80 = 0 then
  begin
    Result := True;
    APoints.Add(vPts[0]);
    if Self.InternalFlags and $20 <> 0 then
    begin
      APoints.Add(vPts[3]);
      APoints.Add(vPts[2]);
    end
    else
    begin
      APoints.Add(vPts[2]);
      APoints.Add(vPts[3]);
    end;
  end;
end;

procedure TsgDXFSolid.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFSolid then
  begin
    FPoint2 := TsgDXFSolid(Source).FPoint2;
    FPoint3 := TsgDXFSolid(Source).FPoint3;
    DisposeAndNil(FMatrix);
  end;
end;

function TsgDXFSolid.GetEntType: TsgCADEntities;
begin
  Result := ceSolid;
end;

function TsgDXFSolid.GetMatrix: TFMatrix;
begin
  if Assigned(FMatrix) then
    Result := FMatrix^
  else
  begin
    if IsExtruded then
    begin
      New(FMatrix);
      FMatrix^ := ExtrusionToMatrix(Extrusion);
      Result := FMatrix^;
    end
    else
      Result := cnstIdentityMat;
  end;
end;

function TsgDXFSolid.GetPoint2: TFPoint;
begin
  Result := FPoint2;
end;

function TsgDXFSolid.GetPoint3: TFPoint;
begin
  Result := FPoint3;
end;

function TsgDXFSolid.GetPoints(var APoints4: TsgPoints4;
  const AAddZThick: Boolean = False; const AExtruding: Boolean = False): Integer;
var
  I: Integer;
begin
  Result := 4;

  APoints4[0] := FPoint;
  APoints4[1] := FPoint1;
  APoints4[2] := FPoint2;
  APoints4[3] := FPoint3;

  if IsEqualFPoints(APoints4[1], APoints4[2]) then
  begin
    SwapFPoints(APoints4[2], APoints4[3]);
    Dec(Result);
  end;
  if IsEqualFPoints(APoints4[0], APoints4[3]) then
    Dec(Result);
  if IsEqualFPoints(APoints4[0], APoints4[2]) then
  begin
    SwapFPoints(APoints4[2], APoints4[3]);
    Dec(Result);
  end;
  if AAddZThick and (Abs(FZThick) > 0) then
    for I := 0 to 3 do
      APoints4[I].Z := APoints4[I].Z + FZThick;
  if AExtruding and IsExtruded then
    for I := 0 to 3 do
      APoints4[I] := AffineTransformPoint(APoints4[I], GetMatrix);
end;

procedure TsgDXFSolid.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlLength));
    end;
  end;
end;

procedure TsgDXFSolid.Invoke(AConverter: TsgDXFConverter; Proc,
  FinishProc: TsgCADEntityProc);
var
  vMatrix: TFMatrix;
begin
  if IsInvoke(AConverter) then
  begin
    if IsExtruded then
    begin
      vMatrix := AConverter.Params^.Matrix;
      AConverter.Params^.Matrix := FMatXMat(GetMatrix, AConverter.Params^.Matrix);
    end;
    Proc(Self);
    if IsExtruded then
    begin
      AConverter.Params^.Matrix := vMatrix;
    end;
  end;
end;

procedure TsgDXFSolid.LoadedInternal(AConverter: TsgDXFConverter);
begin
  CalcState;
end;

procedure TsgDXFSolid.SetExtrusion(const Value: TFPoint);
begin
  inherited SetExtrusion(Value);
  DisposeAndNil(FMatrix);
end;

procedure TsgDXFSolid.SetPoint2(AValue: TFPoint);
begin
  FPoint2 := AValue;
end;

procedure TsgDXFSolid.SetPoint3(AValue: TFPoint);
begin
  FPoint3 := AValue;
end;

function TsgDXFSolid.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPoint2].Name).ValueData,
    Point2, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPoint3].Name).ValueData,
    Point3, xmlForViewing in AParams.Mode);
end;

procedure TsgDXFSolid.CalcState;
const
  cnstSqrRes = MinSingle;
var
  vPts: TsgPoints4;
  vN1X, vN1Y, vN1Z, vN2X, vN2Y, vN2Z, vLen1, vLen2: Extended;

  procedure NormalExt(const X1, Y1, Z1, X2, Y2, Z2: Extended; var X, Y, Z: Extended);
  begin
    X := Y1 * Z2 - Z1 * Y2;
    Y := Z1 * X2 - X1 * Z2;
    Z := X1 * Y2 - Y1 * X2;
  end;

  procedure SubPointExt(const X1, Y1, Z1, X2, Y2, Z2: Extended; var X, Y, Z: Extended);
  begin
    X := X1 - X2;
    Y := Y1 - Y2;
    Z := Z1 - Z2;
  end;

  function CalcNormalExt(const AP1, AP2, AP3: TFPoint; var X, Y, Z: Extended): Extended;
  var
    VX1, VY1, VZ1, VX2, VY2, VZ2: Extended;
  begin
    SubPointExt(AP2.X, AP2.Y, AP2.Z, AP1.X, AP1.Y, AP1.Z, VX1, VY1, VZ1);
    SubPointExt(AP3.X, AP3.Y, AP3.Z, AP1.X, AP1.Y, AP1.Z, VX2, VY2, VZ2);
    NormalExt(VX1, VY1, VZ1, VX2, VY2, VZ2, X, Y, Z);
    Result := Sqrt(Sqr(X) + Sqr(Y) + Sqr(Z));
  end;

begin
  GetPoints(vPts);
  vLen1 := CalcNormalExt(vPts[0], vPts[1], vPts[2], vN1X, vN1Y, vN1Z);
  vLen2 := CalcNormalExt(vPts[0], vPts[2], vPts[3], vN2X, vN2Y, vN2Z);
  FInternalFlags := FInternalFlags and $02;
  if IsZero(vLen1, cnstSqrRes) then
    FInternalFlags := FInternalFlags or $40
  else
    if Abs(ArcCos(-vN1Z/vLen1)) < cnstPiDiv2 then
      FInternalFlags := FInternalFlags or $10;
  if IsZero(vLen2, cnstSqrRes) then
    FInternalFlags := FInternalFlags or $80
  else
    if Abs(ArcCos(-vN2Z/vLen2)) < cnstPiDiv2 then
      FInternalFlags := FInternalFlags or $20;
end;

procedure TsgDXFSolid.FreeReferences;
begin
  inherited FreeReferences;
  DisposeAndNil(FMatrix);
end;

function TsgDXFSolid.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPoint2: Point2 := ANode.ValueAsFPoint;
    xmlPoint3: Point3 := ANode.ValueAsFPoint;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFSolid.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  SetPointToNode(ANode, Point2, sPlcKeyWords[plcPoint2].Name);
  SetPointToNode(ANode, Point3, sPlcKeyWords[plcPoint3].Name);
end;
{$ENDIF}

{ TsgDXFTrace }

function TsgDXFTrace.GetEntType: TsgCADEntities;
begin
  Result := ceTrace;
end;

procedure TsgDXFTrace.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlAngle));
    end;
  end;
end;

{ TsgDXF3dFace }

function TsgDXF3dFace.GetBox: TFRect;
begin
  if IsHidden then
    Result := cnstBadRect
  else
    Result := inherited GetBox;
end;

function TsgDXF3dFace.GetEntType: TsgCADEntities;
begin
  Result := ce3dFace;
end;

function TsgDXF3dFace.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgDXF3dFace.IsHidden: Boolean;
begin
  Result := FFlags = $F;
end;

procedure TsgDXF3dFace.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

function TsgDXF3dFace.ToXMLOverloadedData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  // do nothing
  Result := cnstXML_OK;
end;

{ TsgDXFSortEntsTable }

procedure TsgDXFSortEntsTable.ClearReferences;
begin
  inherited ClearReferences;
  FHandlesNew.Clear;
  FHandlesOld.Clear;
end;

constructor TsgDXFSortEntsTable.Create;
begin
  inherited Create;
  FHandlesOld := TsgInt64List.Create;
  FHandlesNew := TsgInt64List.Create;
end;

procedure TsgDXFSortEntsTable.FindMinMaxHandles(const AEntities: TsgObjectList;
  var AHandleMin, AHandleMax: UInt64);
var
  I: Integer;
  vHandle: UInt64;
  vEnt: TsgDXFEntity;
begin
  AHandleMin := TsgDXFEntity(AEntities[0]).Handle;
  AHandleMax := AHandleMin;
  for I := 0 to FHandlesOld.Count - 1 do
  begin
    vHandle := FHandlesOld[I];//this copy variable because GetItem inline function
    SetMinMaxUInt64(vHandle, AHandleMin, AHandleMax);
    vHandle := FHandlesNew[I];//this copy variable because GetItem inline function
    SetMinMaxUInt64(vHandle, AHandleMin, AHandleMax);
  end;
  for I := 0 to AEntities.Count - 1 do
  begin
    vEnt := TsgDXFEntity(AEntities.List[I]);
    SetMinMaxUInt64(vEnt.Handle, AHandleMin, AHandleMax);
    if vEnt.EntType = ceViewport then
    begin
      TsgDXFViewport(vEnt).OrdIndex := -1;
    end;
  end;
end;

procedure TsgDXFSortEntsTable.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FHandlesNew);
  FreeAndNil(FHandlesOld);
end;

procedure TsgDXFSortEntsTable.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFSortEntsTable.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
end;

function TsgDXFSortEntsTable.ReplaceHandle(AEntity: TsgDXFEntity): Boolean;
var
  vIndexOld: Integer;
begin
  vIndexOld := FHandlesOld.IndexOf(AEntity.Handle);
  Result := vIndexOld > -1;
  if Result then
    AEntity.Handle := FHandlesNew[vIndexOld];
end;

procedure TsgDXFSortEntsTable.ReplaceHandles(const AEntities: TsgObjectList;
  const ACurrent, ANew: TsgInt64List);
var
  I, J, vMin, vMax: Integer;
  vHandles: TsgInt64List;
begin
  vHandles := TsgInt64List.Create;
  try
    vHandles.Count := AEntities.Count;
    for I := 0 to AEntities.Count - 1 do
      vHandles[I] := TsgDXFEntity(AEntities.List[I]).Handle;
    for I := 0 to ACurrent.Count - 1 do
    begin
      vMin := 0;
      vMax := AEntities.Count - 1;
      while (vMin <= vMax) do
      begin
        J := (vMax + vMin) shr 1;
        case CompareHandles(ACurrent[I], vHandles[J]) of
          +1:  vMin := J + 1;
          -1:  vMax := J - 1
        else
          TsgDXFEntity(AEntities.List[J]).Handle := ANew[I];
          Break;
        end;
      end;
    end;
  finally
    vHandles.Free;
  end;
end;

procedure TsgDXFSortEntsTable.SortByQwickMetod(const AEntities: TsgObjectList);
begin
  QSortArrayBounds(AEntities.List, CompareHandleEntities, 0, AEntities.Count - 1);
  ReplaceHandles(AEntities, FHandlesOld, FHandlesNew);
  QSortArrayBounds(AEntities.List, CompareHandleEntities, 0, AEntities.Count - 1);
  ReplaceHandles(AEntities, FHandlesNew, FHandlesOld);
end;

function TsgDXFSortEntsTable.SortEntities(const AGroup: TsgDXFEntity): Boolean;
begin
  Result := False;
  if AGroup is TsgDXFGroup then
  begin
    if AGroup is TsgDXFBlock then
    begin
      TsgDXFBlock(AGroup).FViewPortOrdIndex := -1;
      TsgDXFBlock(AGroup).FViewPortWithMinIndex := nil;
    end;
    SortEntitiesList(TsgDXFGroup(AGroup).FEntities);
    Result := True;
  end;
end;

procedure TsgDXFSortEntsTable.SortEntitiesList(const AEntities: TsgObjectList);
var
  vHandleMin, vHandleMax, vHandleSize: UInt64;
begin
  if (AEntities.Count < 2) or (FHandlesOld.Count < 1) then Exit;
  FindMinMaxHandles(AEntities, vHandleMin, vHandleMax);
  vHandleSize := vHandleMax - vHandleMin;
  if (vHandleSize > 0) and (vHandleSize < 5000000) then// maximum size of memory in byte
    SortSmallList(AEntities, vHandleMin, vHandleMax)
  else
    SortByQwickMetod(AEntities);
end;

procedure TsgDXFSortEntsTable.SortSmallList(const AEntities: TsgObjectList;
  const AHandleMin, AHandleMax: UInt64);
var
  I, J, K: Integer;
  vListOfHandle, vListOfHandleNew, vEntList: TsgObjectList;
  vHandlesOld, vHandlesNew: UInt64;
begin
  vListOfHandle := TsgObjectList.Create;
  vListOfHandle.Count := AHandleMax - AHandleMin + 1;
  vListOfHandleNew := TsgObjectList.Create;
  vListOfHandleNew.Count :=  vListOfHandle.Count;
  try
    for I := 0 to AEntities.Count - 1 do
    begin
      J := TsgDXFEntity(AEntities.List^[I]).Handle - AHandleMin;
      vListOfHandle.List^[J] := AEntities.List^[I];
      vListOfHandleNew.List^[J] := AEntities.List^[I];
    end;
    for I := 0 to FHandlesOld.Count - 1 do
    begin
      if FHandlesOld[I] = 0 then
        Continue;
      vHandlesOld := FHandlesOld[I];
      vHandlesNew := FHandlesNew[I];
      J := vHandlesOld - AHandleMin;
      K := vHandlesNew - AHandleMin;
      if vListOfHandleNew.List^[K] = vListOfHandle.List^[J] then
        Continue;
      if vListOfHandleNew.List^[K] = nil then
        vListOfHandleNew.List^[K] := vListOfHandle.List^[J]
      else
      begin
        if not (TObject(vListOfHandleNew.List^[K]) is TsgObjectList) then
        begin
          vEntList := TsgObjectList.Create;
          vEntList.Add(vListOfHandleNew.List^[K]);
          vListOfHandleNew.List^[K] := vEntList;
        end;
        TsgObjectList(vListOfHandleNew.List^[K]).Add(vListOfHandle.List^[J]);
      end;
      if not (TObject(vListOfHandleNew.List^[J]) is TsgObjectList) then
      begin
        if vListOfHandle.List^[J] = vListOfHandleNew.List^[J] then
          vListOfHandleNew.List^[J] := nil;
      end
      else
      begin
        if vListOfHandle.List^[J] = TsgObjectList(vListOfHandleNew.List^[J]).First then
          TsgObjectList(vListOfHandleNew.List^[J])[0] := nil;
      end;
    end;
    AEntities.Count := 0;
    for I := 0 to vListOfHandleNew.Count - 1 do
    begin
      if vListOfHandleNew.List^[I] <> nil then
      begin
        if not (TObject(vListOfHandleNew.List^[I]) is TsgObjectList) then
          AEntities.Add(vListOfHandleNew.List^[I])
        else
        begin
          vEntList := TsgObjectList(vListOfHandleNew.List^[I]);
          K := vEntList.Count - 1;
          for J := 0 to K do
            if vEntList.List^[J] <> nil then
              AEntities.Add(vEntList.List^[J]);
          vEntList.Free;
        end;
      end;
    end;
  finally
    vListOfHandle.Free;
    vListOfHandleNew.Free;
  end;
end;

{ TsgCADBasePolyline }

procedure TsgCADBasePolyline.ClearReferences;
begin
  inherited ClearReferences;
  if Assigned(FPolyPoints) then
    FPolyPoints.Clear;
end;

procedure TsgCADBasePolyline.CheckDispersionFactor;
var
  I, J: Integer;
  vFactor, vAngle: Double;
  vDelete: Boolean;
begin
  if not (Assigned(FPolyPoints) and (FPolyPoints.Count > 2)) then
    Exit;
  vFactor := 180 - GetDispersionFactor;
  I := 1;
  while I < FPolyPoints.Count - 2 do
  begin
    J := I + 1;
    repeat
      vAngle := GetAngleOfLinesEx(FPolyPoints[I], FPolyPoints[I - 1], FPolyPoints[J]);
      vDelete := vAngle > vFactor;
      if vDelete then
      begin
        Inc(J);
        if J >= FPolyPoints.Count then
          vDelete := False;
      end;
    until not vDelete;
    while J - I > 2 do
    begin
      FPolyPoints.Delete(I + 1);
      Dec(J);
    end;
    Inc(I);
  end;
end;

constructor TsgCADBasePolyline.Create;
begin
  inherited Create;
  FPolyPoints := TFPointList.Create;
end;

function TsgCADBasePolyline.GetBox: TFRect;
begin
  Result := FBox;
end;

function TsgCADBasePolyline.GetIsMeshMClosed: Boolean;
begin
  Result := Closed;
end;

function TsgCADBasePolyline.GetIsMeshNClosed: Boolean;
begin
  Result := FFlags and 32 <> 0;
end;

function TsgCADBasePolyline.GetIsPLinegen: Boolean;
begin
  Result := FFlags and 128 <> 0;
end;

function TsgCADBasePolyline.GetIsPolygonMesh: Boolean;
begin
  Result := False;
end;

function TsgCADBasePolyline.PointCount: Integer;
begin
  Result := FPolyPoints.Count;
end;

procedure TsgCADBasePolyline.AddZTicks(AList: TFPointList);
var
  I, vCount: Integer;
  vPzTick, vElevation: TFPoint;
  vHasElevation, vHasZTick: Boolean;
begin
  vCount := AList.Count - 1;
  vPzTick := MakeFPoint(0, 0, FZThick);
  vHasZTick := not IsZero(vPzTick.Z);// <> 0;
  vElevation := MakeFPoint(0, 0, GetElevation);
  vHasElevation := not IsZero(vElevation.Z);// <> 0;
  if IsExtruded then
  begin
    DoExtrusion(vPzTick, Extrusion);
    DoExtrusion(vElevation, Extrusion);
  end;
  for I := 0 to vCount do
  begin
    if vHasElevation then
      AList[I] := AddFPoint(AList[I], vElevation);
    if vHasZTick then
      AList.Add(AddFPoint(AList[I], vPzTick));
  end;
end;

procedure TsgCADBasePolyline.UpdateBox;
var
  I: Integer;
begin
  FBox := BadRect;
  for I := 0 to PointCount - 1 do
    ExpandFRect(FBox, Points[I]);
end;

procedure TsgCADBasePolyline.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADBasePolyline then
    FFlags := TsgCADBasePolyline(Source).FFlags;
end;

function TsgCADBasePolyline.HasWidth(const AFull: Boolean = True): Boolean;
begin
  Result := False;
end;

procedure TsgCADBasePolyline.DoExtrusions;
var
  I: Integer;
  vExtrusion: TFPoint;
begin
  if IsExtruded then
  begin
    vExtrusion := Extrusion;
    for I := 0 to FPolyPoints.Count - 1 do
      DoExtrusion(FPolyPoints.List^[I], vExtrusion);
  end;
end;

procedure TsgCADBasePolyline.DoZThickAndElevation;
// Converts to polygon mesh if thickness (code 39) is present
begin
  if (not (IsPolyZThickness or (GetElevation <> 0)) ) or IsPolygonMesh then
    Exit;
  AddZTicks(FPolyPoints);
end;

procedure TsgCADBasePolyline.DoZThickness(const APointsCounts: TsgIntegerList);
var
  vList: TFPointList;
  vMaxNumDottedLines: Integer;
  vPLineGen, vOldAutocadMetod: Boolean;
  vOldUniform: Integer;
begin
  if IsPolyZThickness and not Lines.IsSolid then
  begin
    vList := TFPointList.Create;
    vMaxNumDottedLines := iMaxNumDottedLines;
    try
      iMaxNumDottedLines := vMaxNumDottedLines div 8;

      vOldUniform := Lines.Uniform;
      vOldAutocadMetod := Lines.IsAutocadMetod;
      try
        vPLineGen := IsPLinegen and (not HasWidth);//change in future version
        if vPLineGen then
        begin
          Lines.Uniform := 1;
          Lines.IsAutocadMetod := True;
          //Lines.Loaded(Self.Converter);
        end;

        if Assigned(APointsCounts) then
          Lines.Vertexes(PolyPoints, APointsCounts, vList, Closed or IsMeshNClosed)
        else
          Lines.Curve(PolyPoints, vList, Closed or IsMeshNClosed);
      finally
        Lines.Uniform := vOldUniform;
        Lines.IsAutocadMetod := vOldAutocadMetod;
      end;
      PolyPoints.Assign(vList);
      FFlags := FFlags or cnstPolyPointsNotSolid;
    finally
      iMaxNumDottedLines := vMaxNumDottedLines;
      vList.Free;
    end;
  end;
end;

procedure TsgCADBasePolyline.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FPolyPoints);
end;

function TsgCADBasePolyline.GetBoxPoints(Proc: TFPointProc;  Full: Boolean): Boolean;
var
  I: Integer;
  vPoints: TFPointList;
begin
  vPoints := PolyPoints;
  Result := Full and (FBox.Right >= FBox.Left) and (vPoints.Count <= cIPointsCnt);
  if not Result then
    inherited GetBoxPoints(Proc, Full)
  else
  begin
    for I := 0 to vPoints.Count - 1 do
      Proc(vPoints[I]);
    Result := False;
  end;
end;

function TsgCADBasePolyline.GetClosed: Boolean;
begin
  Result := not (FFlags and 1 = 0);
end;

function TsgCADBasePolyline.GetElevation: Double;
begin
  Result := 0;
end;

function TsgCADBasePolyline.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgCADBasePolyline.GetPolySign: Integer;
begin
  if FFlags and cnstPolySignPlus <> 0 then
    Result := +1
  else if FFlags and cnstPolySignMinus <> 0 then
    Result := -1
  else
    Result := 0;
end;

function TsgCADBasePolyline.GetPolyPoint(Index: Integer): TFPoint;
begin
  Result := PolyPoints[Index];
end;

function TsgCADBasePolyline.IsPathEvacuation: Boolean;
begin
  Result := Flags and cnstPathEvacuationFlag <> 0;
end;

function TsgCADBasePolyline.IsPolyPointsSolid: Boolean;
begin
  Result := (FFlags and cnstPolyPointsNotSolid) = 0;
end;

function TsgCADBasePolyline.GetIsPolyZThickness: Boolean;
begin
  Result := FZThick <> 0;
end;

function TsgCADBasePolyline.GetArea: Double;
begin
  Result := 0;//change in future version
end;

function TsgCADBasePolyline.GetLength: Double;
begin
  Result := 0;//change in future version
end;

function TsgCADBasePolyline.GetLinkEntity: TsgDXFEntity;
begin
  Result := nil;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgCADBasePolyline.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  if EntType in [ceLWPolyline, cePolyline, ceSpline] then
    ANode.ChildValues[sPlcKeyWords[plcClosed].Name] := Closed;
end;
{$ENDIF}

procedure TsgCADBasePolyline.LoadedInternal(AConverter: TsgDXFConverter);
var
  vLTScale: Double;
begin
  FBox := BadRect;
  if Layer = nil then
    Layer := AConverter.LayerByName('0');
  if not Assigned(LineType) then
    LineType := AConverter.LTypeByName(sByLayer);
  FFlags :=  FFlags and (not cnstPolyPointsNotSolid);//clear flag by IsPolyPointsSolid
  vLTScale := Lines.Scale;
  Lines.Scale := vLTScale * AConverter.GetLTScale * LineTypeScale;
  try
    ReloadPolyPoints(AConverter);
    if HasDispersionFactor then
      CheckDispersionFactor;
    DoZThickAndElevation;
    UpdateBox;
  finally
    Lines.Scale := vLTScale;
  end;
end;

procedure TsgCADBasePolyline.ReloadPolyPoints(const AConverter: TsgDXFConverter);
begin
  FPolyPoints.Clear(False);
end;

procedure TsgCADBasePolyline.SetClosed(const AClosed: Boolean);
begin
  FFlags := (FFlags and -2) or Byte(AClosed);
end;

procedure TsgCADBasePolyline.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

procedure TsgCADBasePolyline.SetPolySign(const AValue: Integer);
var
  vSign: Integer;
begin
  if AValue > 0 then
    vSign := cnstPolySignPlus
  else if AValue < 0 then
    vSign := cnstPolySignMinus
  else
    vSign := 0;
  FFlags := FFlags and not(cnstPolySignPlus or cnstPolySignMinus);
  FFlags := (FFlags and 127) or vSign;
end;

function TsgCADBasePolyline.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  vNode: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsFullPropsOrXMLHelp(AParams.Mode) then
  begin
    if Assigned(FPolyPoints) then
    begin
      ANode.AddAttribNV(cnstXMLNames[xmlPointsCount].Name).ValueAsInt := FPolyPoints.Count;
      if (not (xmlForViewing in AParams.Mode)) and (FPolyPoints.Count > 0) then
      begin
        vNode := ANode.AddChildNV(cnstXMLNames[xmlPolypoints].Name);
        FPolyPoints.ToXML(vNode, cnstXMLNames[xmlPoint].Name);
      end;
    end;
  end;
end;

procedure TsgCADBasePolyline.SetPLineGen(const APLineGen: Boolean);
begin
  FFlags := (FFlags and (not 128)) or (Ord(APLineGen) shl 7);
end;

{ TsgDXFPolyline }

procedure TsgDXFPolyline.SetStartIndexPoint(const AIndex: Integer; const AGcode: Boolean);
begin
  SetNewIndexPoint(AIndex, AGcode, True);
end;

procedure TsgDXFPolyline.SetEndIndexPoint(const AIndex: Integer);
begin
  SetNewIndexPoint(AIndex, False, False);
end;

procedure TsgDXFPolyline.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  ClearEntCollection(FEntities, ADoFree);
end;

procedure TsgDXFPolyline.ClearReferences;
begin
  inherited ClearReferences;
  if Assigned(FArrows) then
    FArrows.Clear;
  if Assigned(FPolyLineEntities) then
    TsgObjectList.ClearList(FPolyLineEntities, True);
  if Assigned(FPolyFaceVertexIndexes) then
    FPolyFaceVertexIndexes.Clear(True);
  if Assigned(FPointsCounts) then
    FPointsCounts.Clear;
end;

function TsgDXFPolyline.CopyVertexes(const APoly: TsgDXFPolyline;
  const ASaveHandles: Boolean = False): Integer;
var
  I: Integer;
  V: TsgDXFVertex;
begin
  Result := APoly.FEntities.Count;
  FEntities.Capacity := FEntities.Capacity + Result;
  for I := 0 to Result - 1 do
  begin
    V := TsgDXFVertex.Create;
    FEntities.Add(V);
    if ASaveHandles then
      V.Clone(APoly.FEntities[I])
    else
      V.AssignEntity(APoly.FEntities[I]);
  end;
end;

function TsgDXFPolyline.AddVertextEx(const AVertex: TsgDXFVertex;
 const AForce: Boolean = False): Boolean;
var
  V: TsgDXFVertex;
begin
  Result := False;
  if AForce or (Count = 0) or (not AVertex.IsEqualPointBulge(Vertexes[Count - 1])) then
  begin
    V := TsgDXFVertex.Create;
    FEntities.Add(V);
    V.AssignEntity(AVertex);
    Result := True;
  end;
end;

function TsgDXFPolyline.InsVertexEx(const AVertex: TsgDXFVertex;
  const AForce: Boolean = False): Boolean;
var
  V: TsgDXFVertex;
begin
  Result := False;
  if AForce or (Count = 0) or (not AVertex.IsEqualPointBulge(Vertexes[0])) then
  begin
    V := TsgDXFVertex.Create;
    FEntities.Insert(0, V);
    V.AssignEntity(AVertex);
    Result := True;
  end;
end;

function TsgDXFPolyline.CopyVertexesExt(const APoly: TsgDXFPolyline;
  const Adding, AForward: Boolean): Integer;

  procedure FixDirection(const AStart, AEnd: Integer; const ACheckFirstVertex, AFixBulges: Boolean);
  var
    I: Integer;
    V, vNext: TsgDXFVertex;
  begin
    if AFixBulges then
    begin
      for I := AStart to AEnd - 1 do
      begin
        V := Vertexes[I];
        vNext := Vertexes[I + 1];
        V.Bulge := -vNext.Bulge;
      end;
      V := Vertexes[AEnd];
      V.Bulge := 0;
    end
    else
      V := Vertexes[AEnd];
    if ACheckFirstVertex then
    begin
      V := Vertexes[AStart];
      if AStart > 0 then
      begin
        if IsEqualFPoints(V.Point, Vertexes[AStart - 1].Point) then
        begin
          Vertexes[AStart - 1].Bulge := V.Bulge;
          Self.DeleteEntity(AStart).Free;
        end;
      end;
    end
    else
    begin
      if AEnd + 1 < Count then
      begin
        if IsEqualFPoints(V.Point, Vertexes[AEnd + 1].Point) then
          Self.DeleteEntity(AEnd).Free;
      end;
    end;
  end;

var
  I, vCnt: Integer;
begin
  Result := 0;
  if AForward then
  begin
    if Adding then
    begin
      for I := 0 to APoly.Count - 1 do
        Inc(Result, Integer(AddVertextEx(APoly.Vertexes[I])));
    end
    else
    begin
      if APoly.Count > 0 then
        Inc(Result, Integer(InsVertexEx(APoly.Vertexes[0], True)));
      for I := 1 to APoly.Count - 1 do
        Inc(Result, Integer(InsVertexEx(APoly.Vertexes[I])));
      FixDirection(0, Result - 1, False, True);
    end;
  end
  else
  begin
    if Adding then
    begin
      vCnt := Self.Count;
      if APoly.Count > 0 then
        Inc(Result, Integer(AddVertextEx(APoly.Vertexes[APoly.Count - 1], True)));
      for I := APoly.Count - 2 downto 0 do
        Inc(Result, Integer(AddVertextEx(APoly.Vertexes[I])));
      FixDirection(vCnt, vCnt + Result - 1, True, True);
    end
    else
    begin
      if APoly.Count > 0 then
        Inc(Result, Integer(InsVertexEx(APoly.Vertexes[APoly.Count - 1], True)));
      for I := APoly.Count - 2 downto 0 do
        Inc(Result, Integer(InsVertexEx(APoly.Vertexes[I])));
      FixDirection(0, Result - 1, False, False);
//      FixDirection(0, Result - 1, False, False);
    end;
  end;
end;

function TsgDXFPolyline.DeleteDuplicateVertexes(ADuplicateVertexesAccuracy: Double): Boolean;
var
  I, J: Integer;
  vVertex1, vVertex2: TsgDXFVertex;
begin
  Result := False;
  if ADuplicateVertexesAccuracy < 0 then
    ADuplicateVertexesAccuracy := fExtendedResolution;
  I := 0;
  while I < Count do
  begin
    vVertex1 := Vertexes[I];
    J := I + 1;
    while J < Count do
    begin
      vVertex2 := Vertexes[J];
      if IsEqualFPoints(vVertex1.Point, vVertex2.Point, ADuplicateVertexesAccuracy) then
      begin
        Result := True;
        DeleteEntity(J);
        DeleteEntity(I);
        InsertEntity(I, vVertex2);
        vVertex1.Free;
        vVertex1 := vVertex2;
      end
      else
        Break;
    end;
    Inc(I);
  end;
  if (Count > 1) and Closed then
  begin
    vVertex1 := Vertexes[0];
    while Count > 1 do
    begin
      vVertex2 := Vertexes[Count - 1];
      if IsEqualFPoints(vVertex1.Point, vVertex2.Point, ADuplicateVertexesAccuracy) then
      begin
        Result := True;
        DeleteEntity(Count - 1);
        vVertex2.Free;
      end
      else
        Break;
    end;
  end;
end;

constructor TsgDXFPolyline.Create;
begin
  inherited Create;
  FEntities := TsgEntitiesList(TsgEntitiesList.CreateList(ListNotify));
  FPointsCounts := TsgIntegerList.Create;
end;

function TsgDXFPolyline.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FEntities[AIndex];
  FEntities.Delete(AIndex);
end;

{$IFDEF SG_CLIENTSVG}
class function TsgDXFPolyline.GetCopyExtData: Boolean;
begin
  Result := not PolylinesNoCopyExtData;
end;

class procedure TsgDXFPolyline.SetCopyExtData(const AValue: Boolean);
begin
  PolylinesNoCopyExtData := not AValue;
end;
{$ENDIF}

function TsgDXFPolyline.GetCount: Integer;
var
  vEntities: TsgEntitiesList;
begin
  vEntities := GetEntities;
  if Assigned(vEntities) then
    Result := vEntities.Count
  else
    Result := 0;
end;

function TsgDXFPolyline.GetElevation: Double;
begin
  Result := FPoint.Z;
end;

function TsgDXFPolyline.GetEntities: TsgEntitiesList;
begin
  if Assigned(Converter) and (not Converter.AllArcsAsCurves) then
    Result := FPolyLineEntities
  else
    Result := FEntities;
end;

function TsgDXFPolyline.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := TsgDXFEntity(GetEntities[AIndex]);
end;

function TsgDXFPolyline.GetIsPolygonMesh: Boolean;
begin
  Result := (FMeshM  > 1) and (FMeshN > 1);
  if FPolyPoints <> nil then
    Result := Result and (FMeshM * FMeshN = FPolyPoints.Count);
end;

function TsgDXFPolyline.GetBulgeHeight(const AIndex: Integer): Double;

  function GetHeight(const V1, V2: TsgDXFVertex): Double;
  begin
    Result := 0.5 * V1.Bulge * DistanceFPoint(V1.Point, V2.Point);
  end;

begin
  Result := 0;
  if AIndex <= FEntities.Count - 2 then
    Result := GetHeight(TsgDXFVertex(FEntities.List[AIndex]), TsgDXFVertex(FEntities.List[AIndex + 1]))
  else
    if Closed then
      Result := GetHeight(TsgDXFVertex(FEntities.List[AIndex]), TsgDXFVertex(FEntities.List[0]));
end;

function TsgDXFPolyline.GetIsPolyFaceMesh: Boolean;
begin
  Result := (FFlags = 64) and IsPolyFaceParamsValid;
end;

procedure TsgDXFPolyline.AssignEntity(Source: TsgDXFEntity);
var
  vPoly: TsgDXFPolyline absolute Source;
  I: Integer;
  V, vVertexSource: TsgDXFVertex;
  vReCreatevertexes: Boolean;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFPolyline then
  begin
    FreeAndNil(FArrows);
    vReCreatevertexes := (ClassType <> Source.ClassType) or
      (Flags <> vPoly.Flags) or (vPoly.FEntities.Count = 0) or
      (FEntities.Count <> vPoly.FEntities.Count);
    if (not vReCreatevertexes) then
    begin
      for I := 0 to vPoly.FEntities.Count - 1 do
      begin
        vVertexSource := TsgDXFVertex(vPoly.FEntities[I]);
        V := TsgDXFVertex(FEntities[I]);
        if V.Flags = vVertexSource.Flags then
          V.AssignEntity(vVertexSource)
        else
        begin
          vReCreatevertexes := True;
          Break;
        end;
      end;
    end;
    if vReCreatevertexes then
    begin
      Clear;
      CopyVertexes(vPoly);
    end;
    FMeshM := vPoly.FMeshM;
    FMeshN := vPoly.FMeshN;
    FStartW := vPoly.FStartW;
    FEndW := vPoly.FEndW;
    FGlobalW := vPoly.FGlobalW;
{$IFDEF SG_CLIENTSVG}
    if GetCopyExtData then
      AssignExtendedData(Source);
{$ENDIF}
  end;
end;

function TsgDXFPolyline.GetVertex(Index: Integer): TsgDXFVertex;
begin
  Result := TsgDXFVertex(FEntities[Index]);
end;

procedure TsgDXFPolyline.GetVertexListForPolyFaceMesh(AVertexList: TFPointList);
var
  I, K, vIndex, vFirstIndex, vAbsIndex: Integer;
  vPts: array[0..3] of PFPoint;
  vNext: Boolean;
begin
  if Assigned(AVertexList) then
  begin
    if PolyFaceVertexIndexes.Count = 0 then
      Exit;
    I := 0;
    repeat
      FillChar(vPts, SizeOf(vPts), 0);
      K := 0;
      vNext := False;
      vFirstIndex := Integer(PolyFaceVertexIndexes[I]);
      repeat
        vIndex := Integer(PolyFaceVertexIndexes[I]);
        vAbsIndex := Abs(vIndex) - 1;
        if (vAbsIndex >= 0) and (vAbsIndex < PolyPoints.Count) then
        begin
          vPts[K] := @PolyPoints.List[vAbsIndex];
          Inc(K);
        end
        else vNext := True;
        Inc(I);
        if (K = 4) and (vIndex = -vFirstIndex) then
          vNext := True;
      until vNext or (I >= PolyFaceVertexIndexes.Count) or (K = 4);
      if (vPts[0] <> nil) and (vPts[1] <> nil) and (vPts[2] <> nil) then
      begin
        AVertexList.Add(vPts[0]^);
        AVertexList.Add(vPts[1]^);
        AVertexList.Add(vPts[2]^);
        if vPts[3] <> nil then
        begin
          AVertexList.Add(vPts[0]^);
          AVertexList.Add(vPts[2]^);
          AVertexList.Add(vPts[3]^);
        end;
      end;
    until (I >= PolyFaceVertexIndexes.Count);
  end;
end;

procedure TsgDXFPolyline.GetVertexListForPolygonMesh(MeshM,
  MeshN: Integer; AVertexList: TFPointList; AVertexIndexList: TsgIntegerList);
var
  I, J, K: Integer;
  vVector1, vVector2: TFPoint;
  vNClosed, vMClosed: Boolean;

//  procedure SolidMeshIndex(M, N: Integer; MeshNClosed,
//    MeshMClosed: Boolean; AVertexIndexList: TsgIntegerList);
//  var
//    I, J, K: Integer;
//  begin
//    for J := 0 to M - 2 do
//    begin
//      K := J * N;
//      for I := 0 to N - 2 do
//      begin
//        AVertexIndexList.AppendArray([K, K + 1, K + 1 + N]);
//        AVertexIndexList.AppendArray([K, K + 1 + N, K + N]);
//        Inc(K);
//      end;
//      if MeshNClosed then
//      begin
//        AVertexIndexList.AppendArray([K, J * N, (J + 1) * N]);
//        AVertexIndexList.AppendArray([K, (J + 1) * N, (J + 2) * N - 1]);
//      end;
//    end;
//    if MeshMClosed then
//      for J := 0 to N - 2 do
//      begin
//        AVertexIndexList.AppendArray([J, (M - 1) * N + J, (M - 1) * N + J + 1]);
//        AVertexIndexList.AppendArray([J, (M - 1) * N + J + 1, J + 1]);
//      end;
//  end;

  procedure SolidMeshIndex(M, N: Integer; MeshNClosed,
    MeshMClosed: Boolean; AVertexIndexList: TsgIntegerList);
  var
    I, J, K: Integer;
  begin
    for J := 0 to M - 2 do
    begin
      K := J * N;
      for I := 0 to N - 2 do
      begin
        AVertexIndexList.AppendArray([K + 1, K + 1 + N, K + N]);
        AVertexIndexList.AppendArray([K + N, K, K + 1]);
        Inc(K);
      end;
      if MeshNClosed then
      begin
        K := K - N;
        AVertexIndexList.AppendArray([K + 1, K + 1 + N, K + 2 * N]);
        AVertexIndexList.AppendArray([K + 2 * N, K + N, K + 1]);
      end;
    end;
    if MeshMClosed then
    begin
      J := M - 1;
      if J > 1 then
        for I := 0 to N - 2 do
        begin
          AVertexIndexList.AppendArray([I + 1, I + J * N, I + 1 + J * N]);
          AVertexIndexList.AppendArray([I + J * N, I + 1, I]);
        end;
      if MeshNClosed or (not MeshNClosed and (J <= 1)) then
      begin
        AVertexIndexList.AppendArray([0, (M - 1) * N, N - 1]);
        AVertexIndexList.AppendArray([N - 1, M * N - 1, (M - 1) * N]);
      end;
    end;
  end;

begin
  if Assigned(AVertexList) and Assigned(AVertexIndexList) then
  begin
    //Add Vertex
    for I := 0 to PolyPoints.Count - 1 do
      AVertexList.Add(PolyPoints[I]);

    if Lines.IsSolid or (IsPolygonMesh and (not IsPolyZThickness)) then
    begin
      if EntType = ceCircle then
      begin
        vMClosed := False;
        vNClosed := False;
      end
      else
      begin
        vMClosed := IsMeshMClosed;
        vNClosed := IsMeshNClosed;
      end;
      SolidMeshIndex(MeshM, MeshN, vNClosed, vMClosed, AVertexIndexList)
    end
    else
    begin
      for I := 0 to MeshM - 2 do
      begin
        K := I * MeshN;
        J := 0;
        while J < MeshN - 1 do
        begin
          vVector1 := AVertexList[K + J];
          vVector2 := AVertexList[K + J + 1];
          if (vVector1.X <> vVector2.X) or (vVector1.Y <> vVector2.Y) or
             (vVector1.Z <> vVector2.Z) then
          begin
            AVertexIndexList.AppendArray([K + J, K + J + 1, K + MeshN + J + 1]);
            AVertexIndexList.AppendArray([K + J, K + MeshN + J + 1, K + MeshN + J]);
          end;
          Inc(J, 2);
        end;
      end;
    end;
  end;
end;

procedure TsgDXFPolyline.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlGlobalWidth));
    end;
  end;
end;

function TsgDXFPolyline.HasPoint: Boolean;
begin
  Result := False;
end;

function TsgDXFPolyline.HasWidth(const AFull: Boolean = True): Boolean;
var
  I: Integer;
  V: TsgDXFVertex;
begin
  Result := (GlobalWidth <> 0) or (StartWidth <> 0) or (EndWidth <> 0);
  if (not Result) and AFull then
  begin
    for I := 0 to Count - 1 do
    begin
      V := Vertexes[I];
      Result := (V.StartWidth <> 0) or (V.EndWidth <> 0);
      if Result then
        Break;
    end;
  end;
end;

procedure TsgDXFPolyline.DoVertexes;
var
  I, J: Integer;
  vPolyPoints, vDottedSingPts: TFPointList;
  Pt1, Pt2: TFPoint;
  vBulge: Double;
  vIsTransformed: Boolean;
  vTransformation: TFMatrix;

  procedure CreateLineByimImport;
  var
    vLine: TsgDXFLine;
  begin
    vLine := TsgDXFLine.Create;
    Converter.DoCreate(vLine);
    vLine.AssignEntity(Self);
    vLine.Visibility := Visibility;
    if vIsTransformed then
    begin
      vLine.Point := AffineTransformPoint(Pt1, vTransformation); // Point must be extruded
      vLine.Point1 := AffineTransformPoint(Pt2, vTransformation); // Point1 must be extruded
    end
    else
    begin
      vLine.Point := Pt1;
      vLine.Point1 := Pt2;
    end;
    vLine.Loaded(Converter);
    if FPolyLineEntities = nil then
      FPolyLineEntities := TsgEntitiesList.Create;
    FPolyLineEntities.Add(vLine);
  end;
       {evg
  procedure CopyData(ASource, AReceiver: TList);
  var
    J: Integer;
  begin
    for J := 0 to ASource.Count - 1 do
      AReceiver.Add(ASource[J]);
  end;}

  procedure AddPolyFaceVertex(AIndex: Integer);
  begin
    if Assigned(Vertexes[AIndex].FPolyFaceIndexes) then
      FPolyFaceVertexIndexes.AppendArray(Vertexes[AIndex].FPolyFaceIndexes^)
    else
      FPolyFaceVertexIndexes.AppendArray([0, 0, 0, 0]);
    FPointsCounts.Add(4);
  end;

  // Aplies extrusion for the point
  procedure ApplyExtrusion(var APoint: TFPoint);
  begin
    if (GetEntType <> ceLWPolyline) and (Elevation <> 0) then
    begin
      if Is3dPolyline then
        APoint.Z := APoint.Z - Elevation
      else
        APoint.Z := 0;
    end;
    if vIsTransformed then
      APoint := AffineTransformPoint(APoint, vTransformation);
  end;
var
  vNumberOfCircleParts: Integer;
  vVerticesNeeded: Integer;
begin
  FPointsCounts.Count := 0;
  vIsTransformed := IsExtruded;
  if vIsTransformed then
    vTransformation := ExtrusionToMatrix(Extrusion)
  else
    vTransformation := cnstIdentityMat;
  if FPolyFaceVertexIndexes = nil then
    FPolyFaceVertexIndexes := TsgIntegerList.Create
  else
    FPolyFaceVertexIndexes.Clear;
  try
  if Is3dPolygonMesh then
  begin
    if Flags = $50 then //16 = This is a 3D polygon mesh; 64 = The polyline is a polyface mesh
      vVerticesNeeded := FMeshM + FMeshN
    else
      vVerticesNeeded := FMeshM * FMeshN;
    if not ((vVerticesNeeded > FEntities.Count) or (FMeshM * FMeshN = 0)) then
      for I := 0 to FEntities.Count - 1 do
        if Vertexes[I].IsSplineFrameControlPoint then
        begin
          FPointsCounts.Add(-1);
        end
        else
          if not Vertexes[I].IsPolyfaceMeshVertex then
          begin
            FPolyPoints.Add(Vertexes[I].Point);
            FPointsCounts.Add(1);
          end
          else
            AddPolyFaceVertex(I);
  end
  else
  begin
    if Converter <> nil then
      vNumberOfCircleParts := Converter.NumberOfPartsInCircle
    else
      vNumberOfCircleParts := GetNumberOfCircleParts;
    vDottedSingPts := TFPointList.Create;
    vPolyPoints := TFPointList.Create;
    try
      if FPointsCounts.Capacity < FEntities.Count then
        FPointsCounts.Capacity := FEntities.Count;
      for I := 0 to FEntities.Count - 1 do
      begin
        if Vertexes[I].IsSplineFrameControlPoint then
        begin
          FPointsCounts.Add(-1);
          Continue;
        end;
        if not Vertexes[I].IsPolyfaceMeshVertex then
        begin
          Pt1 := Vertexes[I].Point;
          vBulge := Vertexes[I].Bulge;
          if I = FEntities.Count - 1 then
          begin
            if IsMeshNClosed or Closed then
              Pt2 := Vertexes[0].Point
            else
            begin
              ApplyExtrusion(Pt1);
              FPolyPoints.Add(Pt1);
              FPointsCounts.Add(1);
              Continue;
            end
          end
          else
            Pt2 := Vertexes[I + 1].Point;

          if ComparePoint(@Pt1, @Pt2) then
          begin
            if vBulge = 0 then
            begin
              if (Converter.ImportMode = imImport) then
                CreateLineByimImport;
              ApplyExtrusion(Pt1);
              FPolyPoints.Add(Pt1);
              FPointsCounts.Add(1);
            end
            else// Adds points for arc segments (with 42 code)
            begin
              ApplyBulgeByPoint(Pt1, Pt2, vBulge, vPolyPoints, vNumberOfCircleParts);

              //delete dublicated point
              //if (vPolyPoints.Count > 0) and (I < FEntities.Count - 1) and  IsEqualFPoints(vPolyPoints.Last, Pt2) then
              //  vPolyPoints.Count := vPolyPoints.Count - 1;

              for J := 0 to vPolyPoints.Count - 1 do
                ApplyExtrusion(vPolyPoints.List^[J]);
              FPolyPoints.AppendDynArray(vPolyPoints);
              FPointsCounts.Add(vPolyPoints.Count);
              vPolyPoints.Clear(False);
            end;
          end
          else
          begin
            ApplyExtrusion(Pt1);
            FPolyPoints.Add(Pt1);
            FPointsCounts.Add(1);
          end
        end
        else
          AddPolyFaceVertex(I);
      end;
    finally
      vPolyPoints.Free;
      vDottedSingPts.Free;
    end;
  end;
  finally
    if FPolyFaceVertexIndexes.Count = 0 then
      FreeAndNil(FPolyFaceVertexIndexes);
  end;
end;

procedure TsgDXFPolyline.DoZThickAndElevation;
begin
  inherited DoZThickAndElevation;
  if (not (IsPolyZThickness or (GetElevation <> 0)) ) or IsPolygonMesh then
    Exit;
  if Assigned(FArrows) then
    AddZTicks(FArrows);
end;

procedure TsgDXFPolyline.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FEntities);
  FreeAndNil(FArrows);
  FreeAndNil(FPolyFaceVertexIndexes);
  FreeAndNil(FPointsCounts); //evg
end;

function TsgDXFPolyline.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vGlobalWidth: Double;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlGlobalWidth:
      begin
        vGlobalWidth := ANode.ValueAsDouble;
        if vGlobalWidth < 0 then
        begin
          Result := cnstXML_ERROR;
          DoErrorXMLNode(AResult.Errors, False, ANode, xmlGlobalWidth);
        end
        else
          if not Polyline3D  then
            GlobalWidth := vGlobalWidth;
      end;
    xmlElevation:
      begin
        FPoint := MakeFPoint(0, 0, ANode.ValueAsFPoint.Z);//see SetElevation
      end
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure TsgDXFPolyline.ApplyBulgeByPoint(P1, P2: TFPoint; Bulge: Double;
   AList: TFPointList; ANumberOfCircleParts: Integer);
// Adds points for arc segments (with 42 code)
var
  vArc: TsgDXFArc;
  vArcR: TsgArcR;
  vGenerator: TsgGeneratorShapeEdge;
begin
  vGenerator := TsgGeneratorShapeEdge.Create;
  try
    vGenerator.SetBaseList(AList);
    vGenerator.NumberCirclePart := NumberOfCirclePartsByBulge(Converter,
      P1, P2, Bulge);
    vGenerator.IsImportMode := (Converter.ImportMode = imImport) or Converter.HighQualityRegenerateArcs;
    vArcR := vGenerator.CreateBulgesArc(P1, P2, Bulge);
  finally
    vGenerator.Free;
  end;
  if Converter.ImportMode = imImport then
  begin
    vArc := TsgDXFArc.Create;
    Converter.DoCreate(vArc);
    vArc.AssignEntity(Self);
    vArc.Layer := Layer;
    vArc.Visibility := Visibility;
    vArc.Point := vArcR.Center;
    vArc.FRadius := vArcR.Radius;
    vArc.FStartAngle := vArcR.AngleS;
    vArc.FEndAngle := vArcR.AngleE;
    vArc.Loaded(Converter);
    if FPolyLineEntities = nil then
      FPolyLineEntities := TsgEntitiesList.Create;
    FPolyLineEntities.Add(vArc);
  end;
end;

procedure TsgDXFPolyline.DoArrows(const ALines: TsgLines;
  const AMatrix: PFMatrix);
var
  vCreatorSegments: TsgCreatorSegments;
begin
  FreeAndNil(FArrows);
  if HasWidth and (not (Is3dPolygonMesh or IsPolyFaceMesh)) then
  begin
    vCreatorSegments := TsgCreatorSegments.Create(TsgDXFLWPolyline(Self), ALines, AMatrix);
    try
      vCreatorSegments.LoadSegments;
    finally
      vCreatorSegments.Free;
    end;
  end;
end;

procedure TsgDXFPolyline.DoLoadVertexes(AConverter: TsgDXFConverter);
var
  I: Integer;
begin
  if not Assigned(AConverter) then
    AConverter := Converter;
  if Assigned(AConverter) then
  begin
    for I := 0 to FEntities.Count - 1 do
      AConverter.Loads(TsgDXFEntity(FEntities.List[I]));
  end;
end;

function TsgDXFPolyline.GetGlobalWidth: Double;
begin
  Result := FGlobalW;
end;

procedure TsgDXFPolyline.SetBulgeHeight(const AIndex: Integer; const AHeight: Double);

  procedure SetHeight(const V1, V2: TsgDXFVertex; const H: Double);
  var
    vD: Double;
  begin
    vD := DistanceFPoint(V1.Point, V2.Point);
    if vD > fDoubleResolution then
      V1.Bulge := 2 * H / vD;
  end;

begin
  if AIndex <= FEntities.Count - 2 then
    SetHeight(TsgDXFVertex(FEntities.List[AIndex]), TsgDXFVertex(FEntities.List[AIndex + 1]), AHeight)
  else
    if Closed then
      SetHeight(TsgDXFVertex(FEntities.List[AIndex]), TsgDXFVertex(FEntities.List[0]), AHeight);
end;

procedure TsgDXFPolyline.SetElevation(const AValue: Double);
begin
  FPoint.Z := AValue;
end;

procedure TsgDXFPolyline.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  GetEntities[AIndex] := AEntity;
end;

procedure TsgDXFPolyline.SetGlobalWidth(AValue: Double);
begin
  FGlobalW := AValue;
end;

procedure TsgDXFPolyline.SetNewIndexPoint(const AIndex: Integer; const AGCode,
  AIsStart: Boolean);
var
  I, vIndex: Integer;
  vVertex: TsgDXFVertex;
begin
  if AIsStart then
  begin
    if AGCode then
    begin
      //vVertex := Vertexes[Count - 1];
      DeleteEntity(Count - 1).Free;
    end;
    for I := 0 to AIndex  - 1 do
    begin
      vVertex := TsgDXFVertex(FEntities[0]);
      FEntities.Delete(0);
      FEntities.Add(vVertex);
    end;
    if AGCode then
    begin
      vVertex := TsgDXFVertex.Create;
      vVertex.AssignEntity(Vertexes[0]);
      AddEntity(vVertex);
    end;
  end
  else
  begin
    for I := Count - 1 downto AIndex + 1 do
    begin
      vIndex := Count - 1;
      vVertex := TsgDXFVertex(FEntities[vIndex]);
      FEntities.Delete(vIndex);
      FEntities.Insert(0, vVertex);
      //Dec(vIndex);
    end;
  end;
end;

procedure TsgDXFPolyline.SetPointsCounts(const Value: TsgIntegerList);
begin
  FPointsCounts := Value;
end;

procedure TsgDXFPolyline.SetPolyline3D(const Value: Boolean);
begin
  FFlags := (FFlags and (not 8)) or (Ord(Value) shl 3);
end;

function TsgDXFPolyline.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (GetElevation <> 0) then
    ANode.AddAttribNV(cnstXMLNames[xmlElevation].Name).ValueAsFPoint := MakeFPoint(0, 0, GetElevation);
  if IsFullPropsOrXMLHelp(AParams.Mode) or ((not Polyline3D) and (GlobalWidth <> 0)) then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlGlobalWidth].Name).ValueData,
      GlobalWidth, xmlForViewing in AParams.Mode);
  if IsFullPropsOrXMLHelp(AParams.Mode) then
  begin
    if Assigned(PolyPoints) then
    begin
      ANode.AddAttribNV(cnstXMLNames[xmlLength].Name).ValueAsDouble := GetLength;
      if not Polyline3D then
        ANode.AddAttribNV(cnstXMLNames[xmlArea].Name).ValueAsDouble := GetArea;
    end;
  end;
end;

procedure TsgDXFPolyline.UpdateBox;
var
  I: Integer;
begin
  inherited UpdateBox;
  if FArrows <> nil then
    for I := FArrows.Count - 1 downto 0 do
      ExpandFRect(FBox, FArrows[I]);
//  AddThickness(FBox);
end;

function TsgDXFPolyline.GetArea: Double;
var
  vCount: Integer;
begin
  vCount := -1;
  if ZThick <> 0 then
    vCount := PolyPoints.Count div 2;
  Result := GetAreaOfList(PolyPoints, vCount);
end;

function TsgDXFPolyline.GetLength: Double;
var
  vCount: Integer;
begin
  vCount := -1;
  if ZThick <> 0 then
    vCount := PolyPoints.Count div 2;
  Result := GetPerimeterOfList(PolyPoints, Closed, vCount);
end;

procedure TsgDXFPolyline.ReloadPolyPoints(const AConverter: TsgDXFConverter);
var
  vLines: TsgLines;
begin
  inherited ReloadPolyPoints(AConverter);
  FPolyFaceVertexIndexes.Free;
  FPolyFaceVertexIndexes := nil;
  if Assigned(FPolyLineEntities) then
    TsgObjectList.ClearList(FPolyLineEntities, True);
  FreeAndNil(FPolyLineEntities);
  if FEntities.Count = 0 then
    Exit;
  DoLoadVertexes(AConverter);
  DoVertexes;
  FreeAndNil(FArrows);
  vLines := nil;
  if IsPolyZThickness and Assigned(Lines) and not Lines.IsSolid then
    vLines := Lines;
  DoArrows(vLines, nil);//calc by box
  DoZThickness(PointsCounts);
end;

function TsgDXFPolyline.IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := FEntities.IndexOf(AEntity);
end;

function TsgDXFPolyline.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := AEntity.ClassType = TsgDXFVertex;
  if Result then
  begin
    if Is3dPolyline then
      TsgDXFVertex(AEntity).Is3DVertex := True;
    FEntities.Insert(AIndex, AEntity);
  end;
end;

function TsgDXFPolyline.Is3dPolygonMesh: Boolean;
begin
  Result := (Flags and 16 <> 0) and (EntType <> ceLWPolyline);
end;

function TsgDXFPolyline.Is3dPolyline: Boolean;
begin
  Result := (Flags and 8 <> 0) and (EntType <> ceLWPolyline);
end;

function TsgDXFPolyline.IsExtruded: Boolean;
begin
  if Is3dPolygonMesh or Is3dPolyline then
    Result := False
  else
    Result := inherited IsExtruded;
end;

function TsgDXFPolyline.IsPolyFaceParamsValid: Boolean;
begin
  Result := (FPolyFaceVertexIndexes <> nil) and
    (((FMeshM > 1) and (FMeshN >= 1)) or (FPolyFaceVertexIndexes.Count >= 2));
end;

procedure TsgDXFPolyline.Iterate(AConverter: TsgDXFConverter;  Proc, FinishProc: TsgCADEntityProc);
var
  I: Integer;
begin
  if not AConverter.AllArcsAsCurves then
    for I := 0 to PolyLineEntities.Count - 1 do
      TsgDXFEntity(PolyLineEntities[I]).Invoke(AConverter, Proc, FinishProc);
end;

function TsgDXFPolyline.GetEntType: TsgCADEntities;
begin
  Result := cePolyline;
end;

{ TsgDXFLWPolyline }

function TsgDXFLWPolyline.GetEntType: TsgCADEntities;
begin
  Result := ceLWPolyline;
end;

procedure TsgDXFLWPolyline.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      if AHideList.IndexOf(Integer(xmlGlobalWidth)) > 0 then
        AHideList.Delete(AHideList.IndexOf(Integer(xmlGlobalWidth)));
    end;
  end;
end;

function TsgDXFLWPolyline.HasLineWeight: Boolean;
begin
  Result := not HasWidth(False);
end;

{ TsgDXFSpline }

constructor TsgDXFSpline.Create;
begin
  inherited Create;
  FFit := TFPointList.Create;
  FControls := TFPointList.Create;
  FDegree := 3;
  FKnots := TsgDoubleList.Create;
  FWeights := TsgDoubleList.Create;
  FKnotTol := cnstKnotTol;
  FCtrlTol := cnstCtrlTol;
  FFitTol := cnstFitTol;
end;

procedure TsgDXFSpline.EndExtData(const AData: TsgCADExtendedData);
begin
  AData.AddString(String_1002, '}');
end;

procedure TsgDXFSpline.AssignEntity(Source: TsgDXFEntity);
var
  vSpline: TsgDXFSpline absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFSpline then
  begin
    FFlagsExtented := vSpline.FFlagsExtented;
    FDegree := vSpline.FDegree;
    FBeginningTangent := vSpline.FBeginningTangent;
    FEndingTangent := vSpline.FEndingTangent;
    FControls.Assign(vSpline.FControls);
    FFit.Assign(vSpline.FFit);
    FKnots.Assign(vSpline.FKnots);
    FWeights.Assign(vSpline.FWeights);
    FKnotTol := vSpline.FKnotTol;
    FCtrlTol := vSpline.FCtrlTol;
    FFitTol := vSpline.FFitTol;
  end;
end;

procedure TsgDXFSpline.ClearReferences;
begin
  inherited ClearReferences;
  FFit.Clear;
  FControls.Clear;
  FKnots.Clear;
  FWeights.Clear;
end;

function TsgDXFSpline.ControlCount: Integer;
begin
  Result := FControls.Count;
end;

function TsgDXFSpline.FitCount: Integer;
begin
  Result := FFit.Count;
end;

function TsgDXFSpline.KnotCount: Integer;
begin
  Result := FKnots.Count;
end;

function TsgDXFSpline.WeightCount: Integer;
begin
  Result := FWeights.Count;
end;

function TsgDXFSpline.GetFitPoint(Index: Integer): TFPoint;
var
  C: Integer;
  P: TFPoint;
begin
  C := FitCount;
  if Index > C + Ord(Closed) then
    Exit;
  if Index < FFit.Count + Ord(Closed) then
  begin
    if Index = FFit.Count then
      Index := 0;
    Result := FFit[Index];
    Exit;
  end;
  if not Closed and (Index > 0) then
    Inc(Index);
  if Index >= Count then
    Dec(Index);
  Result := Controls[Index];
  if not Closed and ((Index = 0) or (Index = Count - 1)) then
    Exit;
  if Closed and (Index = Count - 1) then
    Index := 0
  else
    Dec(Index);
  P := Controls[Index];
  Result.X := (Result.X + P.X) / 2;
  Result.Y := (Result.Y + P.Y) / 2;
  Result.Z := (Result.Z + P.Z) / 2;
end;

procedure TsgDXFSpline.ReloadPolyPoints;
var
  I: Integer;
  P: TFPoint;
begin
  if (FFit <> nil) and (FFit.Count > FControls.Count) and (FPolyPoints.Count = 0) then
  begin
    FPolyPoints.Clear(False);
    for I := 0 to FFit.Count - 1 do
    begin
      P := FFit[I];
      P.Z := 0;
      FPolyPoints.Add(P);
    end;
    DoExtrusions;
  end;
end;

procedure TsgDXFSpline.AddKnot(const X: Extended);
var
  V: Single;
begin
  V := X;
  FKnots.Add(V);
end;

procedure TsgDXFSpline.AddWeight(const W: Extended);
var
  V: Single;
begin
  V := W;
  FWeights.Add(V);
end;

function TsgDXFSpline.GetIsByAngles: Boolean;
begin
  Result := FFit.Count > FControls.Count;
end;

function TsgDXFSpline.GetKnot(const AIndex: Integer): Double;
begin
  if AIndex < FKnots.Count then
    Result := FKnots[AIndex]
  else
    Result := 0;
end;

procedure TsgDXFSpline.BuildSplineByAngles(const ANumberOfParts: Integer);
var
  Cnt, PtsCount, N: Integer;
  vSegm: Double;
  vFreeBegin, vFreeEnd: Boolean;
  tau, m, ksi, eta: TsgDoubleList;
  vBeginningTangent, vEndingTangent: TFPoint;

  procedure CreateParameters;
  var
    I: Integer;
  begin
    vFreeBegin := (vBeginningTangent.X=0) and (vBeginningTangent.Y=0) and (vBeginningTangent.Z=0);
    vFreeEnd := (vEndingTangent.X=0) and (vEndingTangent.Y=0) and (vEndingTangent.Z=0);
    // Parameter tau[I] returns parameter value by nonregular cell
    tau := TsgDoubleList.Create(Cnt);
    m := TsgDoubleList.Create(Cnt+1);
    ksi := TsgDoubleList.Create(Cnt+1);
    eta := TsgDoubleList.Create(Cnt+1);
    tau[0] := 0;
    for I := 1 to Cnt-2 do
      tau[I] := tau[I-1]+DistanceFPoint(FFit[I], FFit[I-1], 0)/FLen;
    tau[Cnt-1] := 1;
  end;

  procedure DestroyParameters;
  begin
    tau.Free;
    m.Free;
    ksi.Free;
    eta.Free;
  end;

  { Cubic splines in mi-terms
    Axis - must be equal 1,2,3 for X,Y,Z values of TFPoint.    }
  procedure DoSpline(Axis: Byte);
  var
    lambda, mu, coef, t: Double;
    I, J: Integer;

    // Returns function value in fit points (X, Y or Z coords of Index-fitpoint)
    // Index= 0..Cnt-1
    function Fi(Index: Integer): TsgFloat;
    begin
      Result := FFit[Index].V[Axis];
    end;
    // Returns value of Tau-parameter for which it is necessary to find value
    // of function, Index= 1..Cnt-1, J=0..cnstPointsInSegment-1
    function XTau(Index, J: Integer): Double;
    begin
      Result := (DistanceFPoint(FFit[Index+1], FFit[Index], 0)/FLen)*J/ANumberOfParts;
    end;
    // h[i]=tau[i+1]-tau[i], Index= 0..Cnt-1
    function Step(Index: Integer): Double;
    begin
      Result := tau[Index+1] - tau[Index];
    end;
  begin
    // The solution of the equations set with a three-diagonal
    // matrix by traversing method
    ksi[0] := 0.0;  eta[0] := 0.0;
    ksi[1] := -0.5 * Ord(vFreeBegin);
    if vFreeBegin then // coef := 3*(Fi(1)-Fi(0))/Step(0)// mu=1, lambda=0
      eta[1] := 1.5*(Fi(1)-Fi(0))/Step(0)
    else     // coef := 2*vBeginningTangent.V[Axis]*FLen;// mu=0, lambda=0
      eta[1] := vBeginningTangent.V[Axis]*FLen;
    for I := 1 to Cnt-1 do
    begin
      if I <> Cnt-1 then
      begin
        lambda := Step(I) / (tau[I+1] - tau[I-1]);
        mu := Step(I-1) / (tau[I+1] - tau[I-1]);
        coef := 3*(mu*(Fi(I+1)-Fi(I))/Step(I) + lambda*(Fi(I)-Fi(I-1))/Step(I-1));
      end
      else
      begin
        mu := 0;
        lambda := Ord(vFreeEnd);
        if vFreeEnd then
          coef := 3*(Fi(Cnt-1)-Fi(Cnt-2))/Step(Cnt-2)// mu=0, lambda=1
        else
          coef := 2*vEndingTangent.V[Axis]*FLen;// mu=0, lambda=0
      end;
      ksi[I+1] := mu / (-2-lambda*ksi[I]);
      eta[I+1] := (lambda*eta[I]-coef) / (-2-lambda*ksi[I]);
    end;
    ksi[Cnt] := 0;
    m[Cnt] := 0.0;
    for I := Cnt-1 downto 0 do
      m[I] := ksi[I+1]*m[I+1] + eta[I+1];
    for I := 0 to Cnt-2 do
      for J := 0 to ANumberOfParts-1 do
      begin
        t := XTau(I, J)/Step(I);
          FPolyPoints.List^[I*ANumberOfParts+J].V[Axis] :=
          Fi(I)*Sqr(1-t)*(1+2*t) + Fi(I+1)*Sqr(t)*(3-2*t) +
          m[I]*Step(I)*t*Sqr(1-t) - m[I+1]*Step(I)*Sqr(t)*(1-t);
      end;
    FPolyPoints.List^[PtsCount-1].V[Axis] := Fi(Cnt-1);
    m.Clear(False);
    ksi.Clear(False);
    eta.Clear(False);
  end;

begin
  vBeginningTangent := FBeginningTangent;
  vEndingTangent := FEndingTangent;
  if (vBeginningTangent.X > 1)  or  (vBeginningTangent.X < -1)  then
    vBeginningTangent.X := 0;
  if (vBeginningTangent.Y > 1) or (vBeginningTangent.Y < -1) then
    vBeginningTangent.Y := 0;
  if (vEndingTangent.X > 1) or (vEndingTangent.X < -1) then
    vEndingTangent.X := 0;
  if (vEndingTangent.Y > 1) or (vEndingTangent.Y < -1) then
    vEndingTangent.Y := 0;

  Cnt := FFit.Count;
  FLen := 0;
  N := 1;
  while N < Cnt {Ord(not Closed)} do
  begin
    vSegm := DistanceFPoint(FFit[N], FFit[N-1], 0);
    if vSegm > FitTol then
    begin
      FLen := FLen + vSegm;
      Inc(N);
    end
    else
    begin// delete bad fits
      FFit.Delete(N);
      Dec(Cnt);
    end;
  end;
  if Cnt < 2 then Exit;
  CreateParameters;
  try
    PtsCount := (Cnt-1)*ANumberOfParts;
    FPolyPoints.Capacity := PtsCount;
    for N := 0 to PtsCount-1 do
      FPolyPoints.Add(cnstFPointZero);
    for N := 0 to 2 do DoSpline(N);
  finally
    DestroyParameters;
  end;
end;

function TsgDXFSpline.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = GetAppID then
  begin
    AData.AddString(String_1001, AAppID);
    AData.AddString(String_1002, '{');
    Result := True;
  end;
end;

procedure TsgDXFSpline.BuildSplineAsPoly;
var
  I: Integer;
begin
  if Assigned(FFit) then
    for I := 0 to FFit.Count - 1 do
    begin
      if (I = 0) or (not IsEqualFPoints(FPolyPoints.Last, FFit[I])) then
        FPolyPoints.Add(FFit[I]);
    end;
end;

procedure TsgDXFSpline.LoadedInternal(AConverter: TsgDXFConverter);
begin
  FPolyPoints.Clear(False);
  DisposeAndNil(FExtrusion);
  if IsPolyline then
    BuildSplineAsPoly
  else
  begin
    if IsByAngles then
      BuildSplineByAngles(AConverter.NumberOfPartsInSpline)
    else
      GetSpline(AConverter.NumberOfPartsInSpline);
  end;
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFSpline.GetPoints(Proc: TsgDXFSplineProc;
  XScale, YScale: Extended);
var
  I: Integer;
  P0: TFPoint;
begin
  if FitCount < 2 then
    for I := 0 to ControlCount - 1 do
    begin
      P0 := ControlPoints[I];
      Proc(MakeFPoint(P0.X, P0.Y, P0.Z));
    end;
end;

function TsgDXFSpline.GetControlPoint(Index: Integer): TFPoint;
begin
  Result := FControls[Index];
end;

function TsgDXFSpline.GetDegree: Byte;
begin
  Result := FDegree;
end;

procedure TsgDXFSpline.GetSpline(const ANumberOfParts: Integer);
var
  IncT: Double;
  vControlCount: Integer;
  vGenerator: TsgGeneratorShapeEdge;
  vWeights: TsgDoubleList;
begin
  vControlCount := ControlCount;
  if FitCount > vControlCount then
    Exit;
  if Knots.Count <> 0  then
  begin
    vGenerator := TsgGeneratorShapeEdge.Create;
    try
      vGenerator.SetBaseList(FPolyPoints);
      vGenerator.NumberSplinePart := ANumberOfParts;
      if vGenerator.IsBSpline(Degree) then
      begin
        vWeights := nil;
        if IsRational then
          vWeights := FWeights;
        vGenerator.CreateBSpline(FControls, FKnots, vWeights, Degree);
      end
      else
      begin
        IncT := 1 / ANumberOfParts;  // := 0.1;
        if (FitCount < 2) and (vControlCount > 4) then
        begin
          if IsEqualFPoints2D(ControlPoints[3], ControlPoints[4], fDoubleResolution) then// ????
            IncT := fFixToleranceInc;
        end;
        vGenerator.CreateSplineByKnots(FControls, FKnots, IncT);
      end;
    finally
      vGenerator.Free;
    end;
  end
  else
  begin
    FPolyPoints.AppendDynArray(FControls);
    DoExtrusions;
  end;
end;

function TsgDXFSpline.GetWeight(const AIndex: Integer): Double;
begin
  if AIndex < FWeights.Count then
    Result := FWeights[AIndex]
  else
    Result := 0;
end;

procedure TsgDXFSpline.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlPoint));
    end;
  end;
end;

function TsgDXFSpline.HasPoint: Boolean;
begin
  Result := False;
end;

function TsgDXFSpline.IsPeriodic: Boolean;
begin
  Result := Flags and 2 <> 0;
end;

function TsgDXFSpline.IsPolyline: Boolean;
begin
  Result := FlagsExtented and 1 <> 0;
end;

function TsgDXFSpline.IsRational: Boolean;
begin
  Result := Flags and 4 <> 0;
end;

function TsgDXFSpline.GetBeginningTangent: TFPoint;
begin
  Result := FBeginningTangent;
end;

procedure TsgDXFSpline.SetBeginningTangent(AValue: TFPoint);
begin
  FBeginningTangent := AValue;
end;

procedure TsgDXFSpline.SetDegree(const Value: Byte);
begin
  FDegree := Value;
end;

function TsgDXFSpline.GetEndingTangent: TFPoint;
begin
  Result := FEndingTangent;
end;

procedure TsgDXFSpline.SetEndingTangent(AValue: TFPoint);
begin
  FEndingTangent := AValue;
end;

procedure TsgDXFSpline.SetKnot(const AIndex: Integer; const Value: Double);
begin
  if AIndex < FKnots.Count then
    FKnots[AIndex] := Value;
end;

procedure TsgDXFSpline.SetWeight(const AIndex: Integer; const Value: Double);
begin
  if AIndex < FWeights.Count then
    FWeights[AIndex] := Value;
end;

function TsgDXFSpline.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vNode: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
//  RemoveProperty(Result, TsgBasePoint);
  ANode.AddAttribNV(cnstXMLNames[xmlDegree].Name).ValueAsInt := FDegree;
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlStartTangentVector].Name).ValueData,
    FBeginningTangent, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlEndTangentVector].Name).ValueData,
    FEndingTangent, xmlForViewing in AParams.Mode);
  if IsXMLHelp(AParams.Mode) then
  begin
    ANode.AddChildNV(cnstXMLNames[xmlControlPoints].Name);
    ANode.AddChildNV(cnstXMLNames[xmlFitPoints].Name);
    ANode.AddChildNV(cnstXMLNames[xmlKnotsPoints].Name);
    ANode.AddChildNV(cnstXMLNames[xmlWeights].Name);
  end
  else
  begin
    if Assigned(FControls) and (FControls.Count > 0) then
    begin
      vNode := ANode.AddChildNV(cnstXMLNames[xmlControlPoints].Name);
      FControls.ToXML(vNode, cnstXMLNames[xmlPoint].Name);
    end;
    if Assigned(FFit) and (Fit.Count > 0) then
    begin
      vNode := ANode.AddChildNV(cnstXMLNames[xmlFitPoints].Name);
      FFit.ToXML(vNode, cnstXMLNames[xmlPoint].Name);
    end;
    if Assigned(FKnots) and (FKnots.Count > 0) then
    begin
      vNode := ANode.AddChildNV(cnstXMLNames[xmlKnotsPoints].Name);
      FKnots.ToXML(vNode, cnstXMLNames[xmlKnot].Name);
    end;
    if Assigned(FWeights) and (FWeights.Count > 0) then
    begin
      vNode := ANode.AddChildNV(cnstXMLNames[xmlWeights].Name);
      FWeights.ToXML(vNode, cnstXMLNames[xmlWeight].Name);
    end;
  end;
end;

procedure TsgDXFSpline.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FFit);
  FreeAndNil(FControls);
  FreeAndNil(FKnots);
  FreeAndNil(FWeights);
end;

function TsgDXFSpline.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlDegree:             FDegree := ANode.ValueAsInt;
    xmlStartTangentVector: FBeginningTangent :=  ANode.ValueAsFPoint;
    xmlEndTangentVector:   FEndingTangent := ANode.ValueAsFPoint;
    xmlControlPoints:      FControls.FromXML(ANode{, AResult});
    xmlFitPoints:          FFit.FromXML(ANode{, AResult});
    xmlWeights:            FWeights.FromXML(ANode{, AResult});
    xmlKnotsPoints:        FKnots.FromXML(ANode{, AResult});
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFSpline.GetEntType: TsgCADEntities;
begin
  Result := ceSpline;
end;

function TsgDXFSpline.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  if (FlagsExtented <> 0) and BeginExtData(AData, AAppID) then
  begin
    AData.AddInt16(Integer_1070, Integer_70);
    AData.AddInt(Integer_1071, FlagsExtented);
    EndExtData(AData);
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

{ TsgDXFCircle }

procedure TsgDXFCircle.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFCircle then
    FRadius := TsgDXFCircle(Source).FRadius;
end;

procedure TsgDXFCircle.ReloadPolyPoints;
begin
  DoZThickness(nil);
  DoExtrusions;
end;

procedure TsgDXFCircle.Params(var A, B, AStart, AEnd, ASin, ACos: Double);
begin
  A := Radius;
  B := Radius;
  AStart := 0;
  AEnd := 360;
  ASin := 0;
  ACos := 1;
end;

function TsgDXFCircle.GetRadius: TsgFloat;
begin
  Result := FRadius;
end;

procedure TsgDXFCircle.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
end;

procedure TsgDXFCircle.SetClosed(const AClosed: Boolean);
begin
end;

procedure TsgDXFCircle.SetRadius(AValue: TsgFloat);
begin
  if AValue > fDoubleResolution then
    FRadius := AValue;
end;

function TsgDXFCircle.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  CircleParamsToXMLNode(ANode, AParams);
end;

function TsgDXFCircle.CircleParamsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := cnstXML_OK;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlRadius].Name).ValueData,
    Radius, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLength].Name).ValueData,
    Length, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlArea].Name).ValueData,
    Area, xmlForViewing in AParams.Mode);
end;

function TsgDXFCircle.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlRadius: Radius := ANode.ValueAsDouble;
  else
     Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFCircle.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  if EntType <> ceEllipse then
    ANode.ChildValues[sPlcKeyWords[plcRadius].Name] := Radius;
end;
{$ENDIF}

function TsgDXFCircle.GetArea: Double;
begin
  Result := GetAreaOfCircle(Radius);
end;

function TsgDXFCircle.GetLength: Double;
begin
  Result := GetLengthCircle(Radius);
end;

procedure TsgDXFCircle.LoadedInternal(AConverter: TsgDXFConverter);
begin
  if not (Self is TsgDXFArc) then
  begin
    Closed := True;
    //FFlags := FFlags or 128;
  end;
  FFlags := FFlags or 128;
  GeneratePoints(AConverter);
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFCircle.GeneratePoints(AConverter: TsgDXFConverter);
// Converts CIRCLE (ARC, ELLIPSE) to polyline
var
  A, B, AStart, AEnd, ASin, ACos: Double;
  vNumberPartsInCircle: Integer;
  vGenerator: TsgGeneratorShapeEdge;
begin
  FPolyPoints.Clear(False);
  Params(A, B, AStart, AEnd, ASin, ACos);
  vNumberPartsInCircle := NumberOfCirclePartsByRadius(AConverter, Radius);
  vGenerator := TsgGeneratorShapeEdge.Create;
  try
    vGenerator.SetBaseList(FPolyPoints);
    vGenerator.NumberCirclePart := vNumberPartsInCircle;
    vGenerator.IsImportMode := Converter.ImportMode = imImport;
    vGenerator.CreateEllipticArcByRadiuses(Point, A, B, AStart, AEnd, ASin, ACos);
  finally
    vGenerator.Free;
  end;
end;

function TsgDXFCircle.GetClosed: Boolean;
begin
  Result := True;
end;

function TsgDXFCircle.GetEntType: TsgCADEntities;
begin
  Result := ceCircle;
end;

{ TsgDXFArc }

constructor TsgDXFArc.Create;
begin
  inherited Create;
  FEndAngle := 360;
end;

procedure TsgDXFArc.AssignEntity(Source: TsgDXFEntity);
var
  vArc: TsgDXFArc absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFArc then
  begin
    FEndAngle := vArc.FEndAngle;
    FStartAngle := vArc.FStartAngle;
  end;
end;

function TsgDXFArc.GetHeight: Double;
var
  vP1, vP2, vP3: TFPoint;
  vA: Double;
begin
  vA := GetMiddleAngle(StartAngle, EndAngle);
  vP1 := GetPointOnCircle(Point, Radius, StartAngle);
  vP2 := GetPointOnCircle(Point, Radius, EndAngle);
  vP3 := GetPointOnCircle(Point, Radius, vA);
  Result := DistanceFPoint(MiddleFPoint(vP1, vP2), vP3);
end;

function TsgDXFArc.GetArc: TsgArcR;
begin
  Result.Center := Point;
  Result.Radius := Radius;
  Result.AngleS := StartAngle;
  Result.AngleE := EndAngle;
end;

function TsgDXFArc.GetClosed: Boolean;
begin
  Result := IsEqualAngle(FStartAngle, FEndAngle);
end;

function TsgDXFArc.GetEndAngle: TsgFloat;
begin
  Result := FEndAngle;
end;

procedure TsgDXFArc.SetHeight(const AValue: Double);
var
  vP1, vP2, vP3, vCenter: TFPoint;
  vAS, vAE, vAM, vR: Double;
begin
  if Abs(AValue) <= fAccuracy then Exit;
  vP1 := GetPointOnCircle(Point, Radius, StartAngle);
  vP2 := GetPointOnCircle(Point, Radius, EndAngle);
  vP3 := GetNormalPt(vP1, vP2, MiddleFPoint(vP1, vP2), AValue);
  if GetCircleParams(vP1, vP2, vP3, vCenter, vR) and (vR < MaxSingle) then
  begin
    Point := vCenter;
    Radius  := vR;
    vAS := GetAngleByPoints(vCenter, vP1, False);
    vAE := GetAngleByPoints(vCenter, vP2, False);
    vAM := GetAngleByPoints(vCenter, vP3, False);
    if vAS > vAE then
      SwapSGFloats(vAS, vAE);
    if (vAM < vAS) or (vAM > vAE) then
      SwapSGFloats(vAS, vAE);
    StartAngle := vAS;
    EndAngle := vAE;
  end;
end;

procedure TsgDXFArc.SetArc(const AValue: TsgArcR);
begin
  Point := AValue.Center;
  Radius := AValue.Radius;
  StartAngle := AValue.AngleS;
  EndAngle := AValue.AngleE;
end;

procedure TsgDXFArc.SetEndAngle(AValue: TsgFloat);
begin
  FEndAngle := AValue;
end;

function TsgDXFArc.GetStartAngle: TsgFloat;
begin
  Result := FStartAngle;
end;

procedure TsgDXFArc.SetStartAngle(AValue: TsgFloat);
begin
  FStartAngle := AValue;
end;

function  TsgDXFArc.CircleParamsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited CircleParamsToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlHeight].Name).ValueAsDouble := GetHeight;
end;

function TsgDXFArc.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlEndAngle].Name).ValueData,
    FEndAngle, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlStartAngle].Name).ValueData,
    FStartAngle, xmlForViewing in AParams.Mode);
end;

function TsgDXFArc.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vNode: TsgNodeSample;
  vStartPoint, vEndPoint, vMiddlePoint, vCenter: TFPoint;
  vMode: Integer;
  vCorrertAmountParams: Integer;
  vRadius, vAS, vAE, vAB: Double;

  procedure ReadPointParam(const ANode: TsgNodeSample; AId: TsgXMLId;
    var APoint: TFPoint; var ACorrertAmountParams: Integer);
  var
    vNodeParam: TsgNodeSample;
  begin
    vNodeParam := ANode.GetAttributeByName(cnstXMLNames[AId].Name);
    if Assigned(vNodeParam) then
    begin
      APoint := vNodeParam.ValueAsFPoint;
      Inc(ACorrertAmountParams);
    end;
  end;

begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlEndAngle:   FEndAngle := ANode.ValueAsDouble;
    xmlStartAngle: FStartAngle := ANode.ValueAsDouble;
    xmlCalc:
      begin
        vNode := ANode.GetAttributeByName(cnstXMLNames[xmlMode].Name);
        if Assigned(vNode) then
        begin
          vMode := vNode.ValueAsInt;
          case vMode of
            0:
            begin
              vCorrertAmountParams := 0;
              ReadPointParam(ANode, xmlStartPoint, vStartPoint, vCorrertAmountParams);
              ReadPointParam(ANode, xmlEndPoint, vEndPoint, vCorrertAmountParams);
              ReadPointParam(ANode, xmlMiddlePoint, vMiddlePoint, vCorrertAmountParams);
              if vCorrertAmountParams = 3 then
              begin
                  if GetCircleParams(vStartPoint, vEndPoint, vMiddlePoint, vCenter, vRadius) then
                  begin
                    Point := vCenter;
                    Radius := vRadius;
                    vAS := GetAngleByPoints(vCenter, vStartPoint, False);
                    vAE := GetAngleByPoints(vCenter, vEndPoint, False);
                    vAB := GetAngleByPoints(vCenter, vMiddlePoint, False);
                    if vAS > vAE then
                      SwapSGFloats(vAS, vAE);
                    if (vAB < vAS) or (vAB > vAE) then
                      SwapSGFloats(vAS, vAE);
                    StartAngle := vAS;
                    EndAngle := vAE;
                  end;
              end;
            end;
          end;
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFArc.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcEndAngle].Name] := EndAngle;
  ANode.ChildValues[sPlcKeyWords[plcStartAngle].Name] := StartAngle;
  SetPointToNode(ANode, EndPoint, sPlcKeyWords[plcEndPoint].Name);
  SetPointToNode(ANode, StartPoint, sPlcKeyWords[plcStartPoint].Name);
end;
{$ENDIF}

function TsgDXFArc.GetEndingPoint: TFPoint;
begin
  Result := RotPt(FEndAngle);
  DoExtrusion(Result, Extrusion);
end;

function TsgDXFArc.GetStartingPoint: TFPoint;
begin
  Result := RotPt(FStartAngle);
  DoExtrusion(Result, Extrusion);
end;

function TsgDXFArc.GetArea: Double;
var
  vArc: TsgArcR;
begin
  vArc.Center := Point;
  vArc.Radius := Radius;
  vArc.AngleS := StartAngle;
  vArc.AngleE := EndAngle;
  Result := GetAreaOfArc(vArc);
end;

function TsgDXFArc.GetLength: Double;
begin
  Result := GetLengthArc(FRadius, FStartAngle, FEndAngle);
end;

function TsgDXFArc.RotPt(Angle: Extended): TFPoint;
begin
  Angle := Radian(Angle);
  Result.X := Point.X + Radius*Cos(Angle);
  Result.Y := Point.Y + Radius*Sin(Angle);
  Result.Z := Point.Z;
end;

procedure TsgDXFArc.Params(var A, B, AStart, AEnd, ASin, ACos: Double);
begin
  inherited Params(A, B, AStart, AEnd, ASin, ACos);
  AStart := StartAngle;
  AEnd := EndAngle;
  if StartAngle > EndAngle then
    AStart := AStart - Round(StartAngle / 360) * 360;
  if AEnd < AStart then
    AEnd := AEnd + 360;
end;

procedure TsgDXFArc.LoadedInternal(AConverter: TsgDXFConverter);
begin
  Closed := False;
  inherited LoadedInternal(AConverter);
end;

function TsgDXFArc.GetEntType: TsgCADEntities;
begin
  Result := ceArc;
end;

{ TsgDXFEllipse }

constructor TsgDXFEllipse.Create;
begin
  inherited Create;
  FIsExtruded := True;
end;

procedure TsgDXFEllipse.AssignEntity(Source: TsgDXFEntity);
var
  vEllipse: TsgDXFEllipse absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFEllipse then
  begin
    FIsExtruded := vEllipse.FIsExtruded;
    FRadPt := vEllipse.FRadPt;
    FRatio := vEllipse.FRatio;
  end;
end;

procedure TsgDXFEllipse.LoadedInternal(AConverter: TsgDXFConverter);
begin
  // Only for single call in Loaded
  if FIsExtruded and IsExtruded then
  begin
    FIsExtruded := False;
    DoPreExtrusion(FPoint, Extrusion);
    DoPreExtrusion(FRadPt, Extrusion);
  end;
  FRadius := Sqrt(FRadPt.X * FRadPt.X + FRadPt.Y * FRadPt.Y);
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFEllipse.Params(var A, B, AStart, AEnd, ASin, ACos: Double);
begin
  inherited Params(A, B, AStart, AEnd, ASin, ACos);
  if (EndAngle > StartAngle) and (EndAngle >= 360) then
  begin
    AStart := StartAngle;
    AEnd := EndAngle;
    if AEnd > AStart + 360 then
      AEnd := AStart + 360;
  end;
  B := A * FRatio;
  if Abs(FRadius) > 1E-10 then
  begin
    ASin := FRadPt.Y / FRadius;
    ACos := FRadPt.X / FRadius;
  end
  else
  begin
    ASin := 1.0;
    ACos := 0.0;
  end;
end;

function TsgDXFEllipse.GetAxisAngle: Double;
begin
  if FRadPt.X <> 0 then
    Result := f180DividedByPi * ArcTan2(FRadPt.Y, FRadPt.X)
  else
  begin
    if FRadPt.Y >= 0 then
      Result := 90
    else
      Result := 270;
  end;
end;

function TsgDXFEllipse.GetAxisAngleRad: Double;
begin
  Result := fPiDividedBy180 * GetAxisAngle;
end;

function TsgDXFEllipse.GetRadiuses(var AR1, AR2: Double): Boolean;
begin
  Result := GetClosed;
  AR1 := sgFunction.GetLengthVector(RadPt);
  AR2 := AR1 * Ratio;
end;

function TsgDXFEllipse.GetRadPt: TFPoint;
begin
  Result := FRadPt;
end;

procedure TsgDXFEllipse.SetRadPt(AValue: TFPoint);
begin
  FRadPt := AValue;
end;

function TsgDXFEllipse.GetRatio: TsgFloat;
begin
  Result := FRatio;
end;

procedure TsgDXFEllipse.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlStartAngle));
      AHideList.Add(Integer(xmlEndAngle));
    end;
  end;
end;

procedure TsgDXFEllipse.SetAxisAngle(const AAngle: Double);
var
  vAngle, vLength: Double;
  vSin, vCos: Extended;
begin
  if sgModAngle(AAngle, vAngle) then
  begin
    vLength := DistanceFVector(FRadPt);
    if vLength > 0 then
    begin
      SinCos(vAngle * fPiDividedBy180, vSin, vCos);
      FRadPt := MakeFPoint(vCos * vLength, vSin * vLength);
    end;
  end;
end;

procedure TsgDXFEllipse.SetAxisAngleRad(const AAngle: Double);
begin
  SetAxisAngle(AAngle * f180DividedByPi);
end;

procedure TsgDXFEllipse.SetExtrusion(const Value: TFPoint);
begin
  inherited SetExtrusion(Value);
  FIsExtruded := True;
end;

procedure TsgDXFEllipse.SetRatio(AValue: TsgFloat);
begin
  FRatio := AValue;
end;

function  TsgDXFEllipse.CircleParamsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := cnstXML_OK;
end;

function TsgDXFEllipse.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlLineWeight].Name);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlRadPt].Name).ValueData,
    RadPt, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlRatio].Name).ValueData,
    Ratio, xmlForViewing in AParams.Mode);
end;

function TsgDXFEllipse.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlRadPt: RadPt := ANode.ValueAsFPoint;
    xmlRatio: Ratio := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFEllipse.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcAngle].Name] := Angle;
  ANode.ChildValues[sPlcKeyWords[plcRatio].Name] := Ratio;
//  SetPointToNode(ANode, EndPoint, 'EndPoint');
  SetPointToNode(ANode, EndPoint, sPlcKeyWords[plcRadPt].Name);
end;
{$ENDIF}

function TsgDXFEllipse.GetEntType: TsgCADEntities;
begin
  Result := ceEllipse;
end;

function TsgDXFEllipse.GetArea: Double;
var
  vR1, vR2: Double;
begin
  Result := 0;
  if GetRadiuses(vR1, vR2) then
    Result := cnstPi * vR1 * vR2;
end;

function TsgDXFEllipse.GetLength: Double;
var
  vR1, vR2: Double;
begin
   Result := 0;
   if GetRadiuses(vR1, vR2) then
     Result := cnstPi * (vR1 + vR2);
end;

{ TsgDXFTable }

function TsgDXFTable.AddItem(const AItem: TObject): Integer;
begin
  Result := FLinkID.AddItem(AItem);
end;

procedure TsgDXFTable.UpdateBox;
begin
  // don't need in Box
end;

procedure TsgDXFTable.AssignEntity(Source: TsgDXFEntity);
//var
//  I: Integer;
//  vTable: TsgDXFTable absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFTable then
    Name := TsgDXFTable(Source).Name;
//  if Source is TsgDXFTable then
//  begin
//    for future version
//    if vTable._FSortList = nil then
//    begin
//      FreeAndNil(_FSortList);
//      for I := 0 to vTable.Count - 1 do
//        AddEntity(vTable[I]);
//    end
//    else
//    begin
//      if _FSortList = nil then
//        _FSortList := TsgStringList.Create;
//      _FSortList.Assign(vTable._FSortList);
//      CopyLists(FEntities, vTable.FEntities);
//    end;
//  end;
end;

procedure TsgDXFTable.Clear(const ADoFree: Boolean);
begin
  TsgSortedItem(FLinkID).SortList.Clear;
  inherited Clear(ADoFree);
end;

procedure TsgDXFTable.ClearReferences;
begin
  inherited ClearReferences;
  TsgSortedItem(FLinkID).SortList.Clear;
end;

constructor TsgDXFTable.Create;
begin
  inherited Create;
end;

function TsgDXFTable.DeleteItem(const AItem: TObject): Integer;
begin
  Result := FLinkID.RemoveItem(AItem);
end;

function TsgDXFTable.EntName: string;
begin
  Result := FLinkID.Name;
  if Result = '' then
    Result := inherited EntName;
end;

function TsgDXFTable.FindChildByHandle(const AHandle: UInt64; ADeep: Integer = 0): TsgDXFEntity;
var
  I: Integer;
 Item: TsgOwneredItem;
begin
  Result := nil;
  Item := TsgSortedItem(FLinkID).SortList.ByHandle[AHandle];
  if Assigned(Item) then
    Result := Item.Ancestor
  else
    if ADeep <> 0 then
    begin
      Dec(ADeep);
      I := 0;
      while (I < Count) and not Assigned(Result) do
      begin
        Result := Entities[I].FindChildByHandle(AHandle, ADeep);
        Inc(I);
      end;
    end;
end;

function TsgDXFTable.FindEntByDescription(
  const ADescription: string): TsgDXFEntity;
var
  Item: TsgOwneredItem;
begin
  Result := nil;
  Item := TsgSortedItem(FLinkID).SortList.ByDescription[ADescription];
  if Assigned(Item) then
    Result := Item.Ancestor;
end;

function TsgDXFTable.FindEntByName(const AName: string): TsgDXFEntity;
var
  Item: TsgOwneredItem;
begin
  Result := nil;
  Item := TsgSortedItem(FLinkID).SortList.ByName[AName];
  if Assigned(Item) then
    Result := Item.Ancestor;
end;

procedure TsgDXFTable.FreeReferences;
begin
  inherited FreeReferences;
end;

function TsgDXFTable.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlName: Name := ANode.ValueAsStr;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFTable.GetComplex: Boolean;
begin
  Result := True;
end;

function TsgDXFTable.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgSortedItem;
end;

function TsgDXFTable.GetName: string;
begin
  Result := TsgNamedItem(FLinkID).Name;
end;

function TsgDXFTable.GetNamedItem: TObject;
begin
  Result := FLinkID;
end;

function TsgDXFTable.GetOwner: TsgDXFEntity;
begin
  if Assigned(FLinkID.Owner) then
    Result := TsgDXFEntity(TsgOwneredItem(FLinkID.Owner).Ancestor)
  else
    Result := nil;
end;

procedure TsgDXFTable.Link(AConverter: TsgDXFConverter);
var
  I: Integer;
  Item: TObject;
begin
  inherited Link(AConverter);
  if TsgSortedItem(FLinkID).SortList.Count <> Count then
  begin
    TsgSortedItem(FLinkID).SortList.Sorted := False;
    TsgSortedItem(FLinkID).SortList.Clear;
    for I := 0 to Count - 1 do
    begin
      Item := Entities[I].GetNamedItem;
      if Assigned(Item) then
        TsgSortedItem(FLinkID).SortList.Add(Item);
    end;
  end;
end;

procedure TsgDXFTable.ListNotify(const Obj: TObject; Action: TListNotification);
begin
  case Action of
    lnAdded:
      begin
        inherited ListNotify(Obj, Action);
        AddItem(TsgDXFEntity(Obj).GetNamedItem);
      end;
    lnDeleted, lnExtracted:
      begin
        DeleteItem(TsgDXFEntity(Obj).GetNamedItem);
        inherited ListNotify(Obj, Action);
      end;
  end;
end;

procedure TsgDXFTable.SetName(const AName: string);
begin
  TsgNamedItem(FLinkID).Name := AName;
end;

procedure TsgDXFTable.SetOwner(const Value: TsgDXFEntity);
begin
  if Assigned(Value) then
    FLinkID.Owner := Value.GetNamedItem
  else
    FLinkID.Owner := nil;
end;

function TsgDXFTable.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlLayerName].Name);
  ANode.AddAttribNV(cnstXMLNames[xmlName].Name).Value := Name;
end;

{ TsgDXFBlock }

constructor TsgDXFBlock.Create;
begin
  inherited Create;
  FXrefPath := '';
  if FBlockRecord = nil then
  begin
    FBlockRecord := TsgDXFBlockRecord(TsgDXFBlockRecord.NewInstance);
    FBlockRecord.Block := Self;
    FBlockRecord.Create;
  end;
  FViewPortOrdIndex := -1;
  TsgBlockItem(FLinkID).FBlockRecordLinkID := FBlockRecord.FLinkID;
end;

function TsgDXFBlock.EntName: string;
begin
  Result := FBlockRecord.FLinkID.Name;
  if Result = '' then
    Result := inherited EntName;
end;

procedure TsgDXFBlock.CheckAttdefFlag;
var
  I: Integer;
  vHasConstantAttdef, vHasAnyAttdef: Boolean;
begin
  // bit "0x02" is not set if the block has any attribute definitions
  // that are constant, or has no attribute definitions at all
  vHasConstantAttdef := False;
  vHasAnyAttdef := False;
  I := 0;
  while (I < Count) and not vHasConstantAttdef do
    if Entities[I].EntType = ceAttdef then //if Entities[I] is TsgDXFAttdef then
    begin
      vHasAnyAttdef := True;
      if TsgDXFAttdef(Entities[I]).Constant then
        Inc(vHasConstantAttdef)
      else
        Inc(I);
    end
    else
      Inc(I);
  if vHasConstantAttdef or not vHasAnyAttdef then
    SetFlags(GetFlags and not $02)
  else
    SetFlags(GetFlags or $02);
end;

{procedure TsgDXFBlock.CheckSpecPaperSpaceName;
//fix export empty block SpecPaperSpace
var
  vName: string;
begin
  vName := AnsiUpperCase(FName);
  if (Length(vName) > 0) and (vName[1] = '$') then
    vName[1] := '*';
  if (sModelSpace = vName) or (sPaperSpace = vName) then
    SetSpecPaperSpace(True);
end;}

procedure TsgDXFBlock.Clear(const ADoFree: Boolean = True);
begin
  inherited Clear(ADoFree);
  IsLoaded := False;
  FBox := cnstBadRect;
  FXref := nil;
  SetFlags(GetFlags and not $02);
end;

procedure TsgDXFBlock.ClearReferences;
var
  I: Integer;
begin
  inherited ClearReferences;
  if Assigned(Layout) then
  begin
    TsgDXFLayout(Layout).FPaperSpaceBlock := nil;
    Layout := nil;
  end;
  if FReferences <> nil then
    for I := FReferences.Count - 1 downto 0 do
      TsgDXFEntity(FReferences[I]).RemoveReferenceNotification(Self);
  SetOwner(nil);
end;

procedure TsgDXFBlock.FreeReferences;
begin
  if Assigned(FBlockRecord) then
    FBlockRecord.NotifyDestroing;
  inherited FreeReferences;
  FreeAndNil(FReferences);
  if Assigned(FBlockRecord) then
  begin
    FBlockRecord.FBlock := nil;
    FreeAndNil(FBlockRecord);
  end;
end;

procedure TsgDXFBlock.ListNotify(const Obj: TObject; Action: TListNotification);
begin
  case Action of
    lnAdded:
      begin
        inherited ListNotify(Obj, Action);
        case TsgDXFEntity(Obj).EntType of
          ceViewport: SetViewPortProperty(TsgDXFViewPort(Obj), True);
          ceAttdef:
            if TsgDXFAttdef(Obj).Constant then
              SetFlags(GetFlags and not $02)
            else
              SetFlags(GetFlags or $02);
          ceXRef:
            begin
              FXref := TsgDXFXref(Obj);
              if Assigned(Converter) then
                Converter.GetMainConverter.XRefs.Add(FXref);
            end;
        end;
      end;
    lnExtracted, lnDeleted:
      begin
        case TsgDXFEntity(Obj).EntType of
          ceAttdef: CheckAttdefFlag;
          ceViewport:
            begin
              //FViewPortOrdIndex := -1;
              if Obj = FViewPortWithMinIndex then
                FViewPortWithMinIndex := nil;
              TsgDXFViewport(Obj).OrdIndex := -1;
            end;
          ceXRef:
            begin
              if FXref = Obj then
              begin
                if Assigned(Converter) then
                  Converter.GetMainConverter.XRefs.Remove(FXref);
                FXref := nil;
              end;
            end;
        end;
        inherited ListNotify(Obj, Action);
      end;
  end;
end;

procedure TsgDXFBlock.LoadedInternal(AConverter: TsgDXFConverter);
var
  I: Integer;
  vXRef: TsgDXFXref;
  vConv: TsgDXFConverter;
  vFind: Boolean;

  function FindXref(AList: TList; var Index: Integer): Boolean;
  begin
    Index := 0;
    Result := False;
    while (Index < AList.Count) and not Result do
      if ExtractFileName(TsgDXFXref(AList[Index]).Path) = ExtractFileName(FXrefPath) then
        Inc(Result)
      else
        Inc(Index);
  end;

  procedure InitXref(const ASrc: TsgDXFXref);
  begin
    AddEntity(TsgDXFXref.Create);
    if Assigned(ASrc.CADImage) then
    begin
      FXref.FCADImage := TGraphic(TGraphicClass(ASrc.CADImage.ClassType).Create);
      FXref.FCADImage.Assign(ASrc.CADImage);
    end;
    FXref.FPath := ASrc.Path;
    FXref.FBox := ASrc.Box;
    FXref.Name := ASrc.Name;
  end;

begin
  if IsLoaded then
    Exit;
  if (FXrefPath <> '') and IsBlockByXRef and
    not (IsBlockXrefOverlay and Assigned(AConverter.FContainerXref))// internal Xref-XRef overlay
    and (CompareText(ExtractFileName(AConverter.FileName), ExtractFileName(FXrefPath)) <> 0) then
  begin
{$IFDEF SG_OPENING_IN_THEADS}
    MonitorEnter(GlobalLoadingXRefsStack);
    try
{$ENDIF}
      I := 0;
      vXRef := nil;
      if FindXref(GlobalLoadingXRefsStack, I) then
        vXRef := GlobalLoadingXrefsStack[I];
      if Assigned(vXRef) then
      begin
        vFind := True;
        InitXref(vXRef);
      end
      else
      begin
        vConv := AConverter;
        repeat
          vFind := FindXref(vConv.XRefs, I);
          if not vFind then
            vConv := vConv.FOwnerConverter;
        until vFind or (vConv = nil);
        if vFind then
          InitXref(TsgDXFXref(vConv.XRefs[I]));
      end;
{$IFDEF SG_OPENING_IN_THEADS}
    finally
      MonitorExit(GlobalLoadingXRefsStack);
    end;
{$ENDIF}

    if not vFind then
      if ExtractFileName(AConverter.GetMainConverter.FileName) <> ExtractFileName(FXrefPath) then
        AddFromXrefPath(AConverter)
      else
      begin
        // breaking circular reference from FXrefPath to AConverter.GetMainConverter.FileName
      end;
  end;
  CheckAttdefFlag;
{ if (Pos(sPaperSpace, UpperCase(FName)) <> 0) and (Count > 0) then
  begin
    FSpecPaperSpace := True;
    inherited Loaded(AConverter);
    FLoaded := True;
    Exit;
  end; }
  inherited LoadedInternal(AConverter);//UpdateBox; previous version, in the current version see inherited Loaded(AConverter);
  IsLoaded := True;
  FBlockRecord.Loaded(AConverter);
end;

procedure TsgDXFBlock.SetBoxInternal(const ABox: TFRect);
begin
  FBox := ABox;
end;

procedure TsgDXFBlock.SetDescription(const AValue: string);
begin
  FBlockRecord.Description := AValue;
end;

procedure TsgDXFBlock.SetLayout(const Value: TsgDXFEntity);
begin
  FLayout := Value;
end;

procedure TsgDXFBlock.SetLoaded(const Value: Boolean);
begin
  FInternalFlags := (FInternalFlags and $FFFE) or Word(Value);
end;

procedure TsgDXFBlock.SetName(const AName: string);
begin
  FBlockRecord.Name := AName;
end;

procedure TsgDXFBlock.SetOwner(const AValue: TsgDXFEntity);
var
  vConverter: TsgDXFConverter;
begin
  if Assigned(AValue) then
    FLinkID.Owner := AValue.GetNamedItem
  else
    FLinkID.Owner := nil;
  if Assigned(FBlockRecord) then
  begin
    vConverter := Converter;
    if Assigned(vConverter) and Assigned(FLinkID.Owner) then
      FBlockRecord.SetOwner(vConverter.Sections[csBlockRecords])
    else
      FBlockRecord.SetOwner(nil);
  end;
end;

procedure TsgDXFBlock.SetViewPortProperty(const AViewPort: TsgDXFViewPort;
  const APaperSpaceBlock: Boolean);
var
  vTmp: Integer;
begin
  Inc(FViewPortOrdIndex);
  AViewPort.OrdIndex := FViewPortOrdIndex;
//  if APaperSpaceBlock then
//    AViewPort.FPaperSpaceBlock := TsgDXFBlock(Self);//by TgsDXFBlock
  if (FViewPortOrdIndex = 0) or not Assigned(FViewPortWithMinIndex) then
    FViewPortWithMinIndex := AViewPort;
  if AViewPort.Handle < FViewPortWithMinIndex.Handle then
  begin
    vTmp := AViewPort.OrdIndex;
    AViewPort.OrdIndex := FViewPortWithMinIndex.OrdIndex;
    FViewPortWithMinIndex.OrdIndex := vTmp;
    FViewPortWithMinIndex := AViewPort;
  end;
end;

procedure TsgDXFBlock.SetXrefPath(const Value: string);
begin
  FXrefPath := Value;
end;

function TsgDXFBlock.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlName].Name).ValueAsStr := Name;
  if IsFullPropsOrXMLHelp(AParams.Mode) or (not IsEqualFPoints(Offset, cnstFPointZero)) then
    ANode.AddAttribNV(cnstXMLNames[xmlBasePoint].Name).ValueAsFPoint := Offset;
end;

function TsgDXFBlock.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlName: Name := ANode.ValueAsStr;
    xmlBasePoint: Offset := ANode.ValueAsFPoint;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{procedure TsgDXFBlock.SetSpecPaperSpace(const Value: Boolean);
begin
  FInternalFlags := (FInternalFlags and 253) or (Byte(Value) shl 1);
end;}

{$IFDEF SG_BTI}
function TsgDXFBlock.GetExtendedData: TObject;
begin
  Result := nil;
end;

function TsgDXFBlock.GetExtendedLayer: string;
begin
  Result := '';
end;
{$ENDIF}

function TsgDXFBlock.AddEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := AddEntUseInsert(AEntity);
end;

procedure TsgDXFBlock.AddFromXrefPath(AConverter: TsgDXFConverter);
var
  vObj: TObject;
begin
  Clear(True);
  if not Assigned(FXref) then
    AddEntity(TsgDXFXref.Create)
  else
  begin
    FXRef.FPath := '';
    FXRef.FBox := cnstBadRect;
  end;
  // Clear entities and base point of the block (only for Xref-block)
  FOffset := cnstFPointZero;
  //{For future versions, see DWG12 xrefs} Clear;
  if bLoadEmptyXRef or FXRef.AddCADImage(AConverter, FXrefPath, AConverter.FXRefSearchPaths) then
    FXRef.LoadedInternal(AConverter)
  else
  begin
    vObj := FXRef;
    RemoveEntity(FXRef);
    vObj.Free;
  end;
end;

procedure TsgDXFBlock.UpdateBox;
var
  I: Integer;
  vEnt: TsgDXFEntity;
  vAttdef: TsgDXFAttdef absolute vEnt;
  vIns: TsgDXFInsert absolute vEnt;
begin
  FBox := BadRect;
  I := 0;
  while I < Count do// FBox is union of all entities
  begin
    vEnt := Entities[I];
    if vEnt.Visibility or UseEntityInvisible then
    begin
      case vEnt.EntType of
        ceAttdef:
          begin
            if not ((vAttdef.Flags = 0) or vAttdef.NotAppear or (vAttdef.Value = '')) then
              UnionFRect(FBox, vEnt.Box);
          end;
      else
        if vEnt.IsInsert then
        begin
          if Assigned(vIns.Block) then
            vIns.Link(Converter);
          if Assigned(vIns.Block) and not vIns.Block.IsLoaded then
            vIns.Resolve(Converter);
          vIns.CheckBlock(Converter);
        end;
        UnionFRect(FBox, vEnt.Box);
      end;
    end;
    Inc(I);
  end;
end;

procedure TsgDXFBlock.AssignEntity(Source: TsgDXFEntity);
var
  vXRef: TsgDXFXref;
  vBlock: TsgDXFBlock absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFBlock then
  begin
    vXRef := FXRef;
    if Assigned(vXRef) then
    try
      RemoveEntity(vXRef);
    finally
      FreeAndNil(vXRef);
    end;
    FInternalFlags := vBlock.FInternalFlags;
    IsLoaded := False;
    FOffset := vBlock.FOffset;
    FXrefPath := vBlock.FXrefPath;
    FBlockRecord.AssignEntity(vBlock.BlockRecord);
  end;
end;

function TsgDXFBlock.GetBlockRecord: TsgDXFBlockRecord;
begin
  Result := FBlockRecord;
end;

function TsgDXFBlock.GetComplex: Boolean;
begin
  Result := True;
end;

function TsgDXFBlock.GetDescription: string;
begin
  Result := FBlockRecord.Description;
end;

function TsgDXFBlock.GetLayout: TsgDXFEntity;
begin
  Result := FLayout;
end;

function TsgDXFBlock.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgBlockItem;
end;

function TsgDXFBlock.GetLoaded: Boolean;
begin
  Result := FInternalFlags and 1 <> 0;
end;

function TsgDXFBlock.GetName: string;
begin
  Result := FBlockRecord.Name;
end;

function TsgDXFBlock.GetNamedItem: TObject;
begin
  Result := FLinkID;
end;

function TsgDXFBlock.GetOwner: TsgDXFEntity;
begin
  if Assigned(FLinkID.Owner) then
    Result := TsgDXFEntity(TsgOwneredItem(FLinkID.Owner).Ancestor)
  else
    Result := nil;
end;

function TsgDXFBlock.GetReferences: TsgList;
begin
  if FReferences = nil then
  begin
    FReferences := TsgList.Create;
    FReferences.Sorted := True;
    FReferences.Duplicates := dupIgnore;
  end;
  Result := FReferences;
end;

{$IFDEF SG_VERSION_OLD}
function TsgDXFBlock.GetSpecPaperSpace: Boolean;
begin
  Result := Assigned(FLayout); //Result := FInternalFlags and 2 <> 0;
end;
{$ENDIF}

function TsgDXFBlock.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := False;
  if Assigned(FLayout) or (not IsLoaded) then
  begin
{$IFDEF sgProt}
    if (Count + 1) and 3 <> 0 then
{$ENDIF}
      Result := inherited InsertEntity(AIndex, AEntity);
  end;
end;

function TsgDXFBlock.GetXrefPath: string;
begin
  Result := FXrefPath;
  if (Length(Result) = 0) and Assigned(FXref) then
    Result := FXref.Path;
end;

function TsgDXFBlock.IsAcadTableBlock: Boolean;
begin
  Result := IsBlockIntetnal;
  if Result then
    Result := (Length(Name) > 2) and (UpCase(Name[2]) = 'T') and
      (IsDigit(Name[3]) or (Pos(sInternalACADTable, Name) = 1));
end;

function TsgDXFBlock.IsBlockByXRef: Boolean;
begin
  Result := (Flags and 36 <> 0);
end;

function TsgDXFBlock.IsBlockIntetnal: Boolean;
begin
  Result := (Flags and 1 <> 0);
  if (not Result) and (Length(Name) > 0) and
    (Name[1] = cnstInternalBlockPrefix) then
    Result := True;
end;

function TsgDXFBlock.IsBlockXrefOverlay: Boolean;
begin
  Result := (Flags and 8 <> 0);
end;

function TsgDXFBlock.IsModalSpaceBlock: Boolean;
var
  vConverter: TsgDXFConverter;
begin
  vConverter := Converter;
  Result := Assigned(vConverter) and (vConverter.LayoutsCount > 0) and
    (Layout = vConverter.Layouts[0]);
end;

function TsgDXFBlock.IterateEx(AConverter: TsgDXFConverter; Proc,
  FinishProc: TsgCADEntityProc): TList;
var
  vParams: PsgCADIterate;
  I: Integer;
  vEnt: TsgDXFEntity;
begin
  Result := nil;
  vParams := AConverter.Params;
  if Assigned(vParams^.BlockStack) then
  begin
    I := vParams^.BlockStack.Count;
    vParams^.BlockStack.Add(Self);
    if vParams^.BlockStack.Count = I then//this dublicate
    begin
      if vParams^.Insert <> nil then
        vParams^.Insert.Block := nil;
      Exit;
    end;
  end;
  try
    I := 0;
    while (I < Count) and not vParams^.Stopped do
    begin
      vEnt := Entities[I];
      if not (vEnt.ClassType = TsgDXFAttdef) then
        vEnt.Invoke(AConverter, Proc, FinishProc)
      else
      begin
        if Result = nil then
          Result := TList.Create;
        Result.Add(vEnt);
      end;
      Inc(I);
    end;
    if vParams^.Stopped then
      FreeAndNil(Result);
  finally
    if Assigned(vParams^.BlockStack) then
      vParams^.BlockStack.Remove(Self);
  end;
end;

{ TsgDXFInsert }

procedure TsgDXFInsert.CalculateMatrix;
var
  vBlkRefObjectContextData: TsgCADBlkRefObjectContextData;

  function DoGetAnnotationScale(AConverter: TsgDXFConverter; out ObjectContextData): Boolean;
  var
    vContextDataList: TsgDXFEntity;
  begin
    Pointer(ObjectContextData) := nil;
    if EntType = ceInsert then
    begin
      vContextDataList := GetAnnotationScales;
      if Assigned(vContextDataList) then
        TObject(ObjectContextData) := vContextDataList.FindEntByDescription(AConverter.AnnoDesc);
    end;
    Result := Assigned(TObject(ObjectContextData));
  end;

begin
  InitializeMatrix;
  if not DoGetAnnotationScale(Converter, vBlkRefObjectContextData) then
    FMatrix := BuildMatrix(Point, Scale,
      Extrusion, Reverse(GetBlockOffset), Angle, FMatrix)
  else
    FMatrix := BuildMatrix(vBlkRefObjectContextData.Point, vBlkRefObjectContextData.ScaleFactor,
      Extrusion, Reverse(GetBlockOffset), vBlkRefObjectContextData.Angle, FMatrix);
end;

function TsgDXFInsert.CanAddedToXMLParams: Boolean;
begin
   Result := EntType = ceInsert;
end;

function TsgDXFInsert.CanShow: Boolean;
begin
  Result := True;
end;

function TsgDXFInsert.CheckBlock(AConverter: TsgDXFConverter): Boolean;
begin
  LinkBlockRecord(AConverter);
  if Assigned(Block) and not Block.IsLoaded then
    DoBlockLoad(AConverter, Block);
  Result := not ((Block = nil) or ((Block.Count = 0) and (FAttribs.Count = 0)));
end;

procedure TsgDXFInsert.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  ClearAttribs(ADoFree);
end;

procedure TsgDXFInsert.ClearAttribs(const ADoFree: Boolean = True);
begin
  ClearEntCollection(FAttribs, ADoFree);
end;

procedure TsgDXFInsert.ClearReferences;
begin
  inherited ClearReferences;
  ReferenceBlockRecord(nil);
  SetOwnerInsert(nil);
end;

procedure TsgDXFInsert.CopyItems(const ASource: TsgDXFEntity);
var
  vSrc, vDst: TsgDXFEntity;
  I: Integer;
begin
  for I := 0 to TsgDXFInsert(ASource).Attribs.Count - 1 do
  begin
    vSrc := TsgDXFInsert(ASource).Attribs[I];
    vDst := TsgDXFEntityClass(vSrc.ClassType).Create;
    AssignAttrib(vDst, vSrc);
    Attribs.Add(vDst);
  end;
  DelayedLoadAttribs := Attribs.Count > 0;
end;

constructor TsgDXFInsert.Create;
begin
  inherited Create;
  FScale := cnstFPointSingle;
  FExtrusion := cnstExtrusion;
  FAttribs := TsgEntitiesList(TsgEntitiesList.CreateList(ListNotify));
  FMatrix := cnstIdentityMat;
end;

procedure TsgDXFInsert.DoDelayedLoad(AConverter: TsgDXFConverter);
begin
  ReloadAttribs(AConverter);
end;

procedure TsgDXFInsert.DoBlockLoad(const AConverter: TsgDXFConverter; const ABlock: TsgDXFBlock);
begin
  if Assigned(AConverter) then
  begin
    if Assigned(AConverter.OnLoad) then
      AConverter.OnLoad(ABlock)
    else
      AConverter.Loads(ABlock);
  end
  else
    ABlock.Loaded(AConverter);
end;

function TsgDXFInsert.DoSetBlockAfter(const ASetBlock: TsgDXFBlock): Integer;
begin
  Result := 1;
end;

function TsgDXFInsert.DoSetBlockBefore(const ASetBlock: TsgDXFBlock): Integer;
begin
  Result := 1;
end;

function TsgDXFInsert.IndexAttribOfName(const AName: string;
  const AMode: Integer = 0): Integer;
var
  I: Integer;
  vAttrib: TsgDXFAttrib;
  vAttribName, vNameUppder: string;
begin
  Result := -1;
  vNameUppder := AnsiUpperCase(AName);
  if Assigned(FAttribs) and (FAttribs.Count > 0) then
  begin
    for I := 0 to FAttribs.Count - 1 do
    begin
      vAttrib := TsgDXFAttrib(FAttribs[I]);
      vAttribName := vAttrib.Tag;
      case AMode of
        1:
          begin
            if vNameUppder <> AnsiUpperCase(vAttribName) then
              vAttrib := nil;
          end;
      else//0
        if AName <> vAttribName then
          vAttrib := nil;
      end;
      if Assigned(vAttrib) then
      begin
        Result := I;
        Break;
      end;
    end;
  end;
end;

procedure TsgDXFInsert.AssignAttrib(Dest, Source: TsgDXFEntity);
begin
  Dest.AssignEntity(Source);
end;

procedure TsgDXFInsert.AssignEntity(Source: TsgDXFEntity);
var
  vInsert: TsgDXFInsert absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFInsert then
  begin
    FSceneElement :=  vInsert.FSceneElement;
    // clear attributes
    Clear;
    // copy attributes/items/...
    CopyItems(vInsert);
    // copy block reference/block entities...
    ReferenceBlockRecord(vInsert.BlockRecord);
    // copy single-type properties
    FAngle := vInsert.FAngle;
    FExtrusion := vInsert.FExtrusion;
    FMatrix := vInsert.FMatrix;
    SetOwnerInsert(vInsert.OwnerInsert);
    FScale := vInsert.FScale;
  end;
end;

function TsgDXFInsert.GetCount: Integer;
begin
  Result := FAttribs.Count;
end;

function TsgDXFInsert.GetDelayedLoadAttribs: Boolean;
begin
  Result := FInternalFlags and 1 <> 0;
end;

function TsgDXFInsert.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := TsgDXFEntity(FAttribs[AIndex]);
end;

function TsgDXFInsert.EntName: string;
begin
  if FSceneElement > 0 then
    Result := cnstSceneElement
  else
  begin
    Result := inherited EntName;
    if Block <> nil then
      Result := Result + ' ' + Block.Name;
  end;
end;

function TsgDXFInsert.RealLayer: TsgDXFLayer;
var
  vContainerLayer: TsgDXFLayer;
begin
  Result := Layer;
  if Result <> nil then
  begin
    vContainerLayer := Result.GetContainerLayer;
    if vContainerLayer <> nil then
      Result := vContainerLayer;
  end;
  if ((Result = nil) or (Result.NameID = slrnZero)) and (OwnerInsert <> nil) then
  begin
    if OwnerInsert <> Self then
      Result := OwnerInsert.RealLayer;
  end;
end;


{ Procedure TsgDXFInsert.ReferenceBlockRecord

  Called from the "AssignEntity".
  Do not call directly }

procedure TsgDXFInsert.ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord);
begin
  BlockRecord := ABlockRecord;
end;

function TsgDXFInsert.FindBlock(AConverter: TsgDXFConverter; const AName: string): TsgDXFBlock;
begin
  Result := AConverter.BlockByName(AName);
end;

procedure TsgDXFInsert.Resolve(AConverter: TsgDXFConverter);
// For forward references
begin
  if Assigned(BlockRecord) then
    DoBlockLoad(AConverter, BlockRecord.Block);
  LoadedInternal(AConverter);
end;

function TsgDXFInsert.GetActualBlockRecord: TsgDXFBlockRecord;
begin
  Result := BlockRecord.GetAcAuthEnvironBlockRecord;
end;

function TsgDXFInsert.GetAngle: Double;
begin
  Result := FAngle;
end;

function TsgDXFInsert.GetAttribs: TsgEntitiesList;
begin
  Result := FAttribs;
end;

function TsgDXFInsert.GetBlock: TsgDXFBlock;
begin
  Result := nil;
  if Assigned(FBlockRecord) then
    Result := FBlockRecord.Block;
end;

function TsgDXFInsert.GetBlockOffset: TFPoint;
var
  vRefBlockRec: TsgDXFBlockRecord;
begin
  vRefBlockRec := BlockRecord.GetAcAuthEnvironBlockRecord;
  Result := vRefBlockRec.Block.Offset;
  if vRefBlockRec.Block.IsBlockByXRef and (vRefBlockRec.Block.Xref <> nil) and (vRefBlockRec.Block.Xref.CADImage <> nil) then
    Result := AddFPoint(Result,
      TsgCADImage(vRefBlockRec.Block.Xref.CADImage).Converter.HeadVarStruct.InsBase);
end;

function TsgDXFInsert.GetBox: TFRect;
begin
  if Assigned(Converter) and Assigned(BlockRecord) and not BlockRecord.Block.IsLoaded then
    Resolve(Converter);
  Result := FBox;
end;

function TsgDXFInsert.BoxForLayout(ALayout: TsgDXFLayout; AConv: TsgDXFConverter): TFRect;
var
  I: Integer;
  E: TsgDXFEntity;
begin
  Result := GetBox;
  if not Annotative or (EntType <> ceInsert) then
    Exit;
  Result := cnstBadRect;
  for I := 0 to Block.Count-1 do
  begin
    E := Block[I];
    if not ALayout.IsLayerInVisible(E.Layer, AConv) then
      UnionFRect(Result, E.Box);
  end;
end;

function TsgDXFInsert.Attrib(const S: string; var P: TFPoint): TsgDXFAttrib;
var
  I: Integer;
begin
  for I := 0 to FAttribs.Count - 1 do
  begin
    Result := TsgDXFAttrib(FAttribs[I]);
    if Result.Tag <> S then
      Continue;
    P := Result.FStartPoint;
    Exit;
  end;
  Result := nil;
end;

function TsgDXFInsert.RealColor(AColor: TColor): TColor;
begin
  Result := AColor;
  if (Result <> clByLayer) or (Self = nil) then
    Exit;
  Result := Color;
  if Result = clByLayer then
    Result := OwnerInsert.RealColor(Result);
end;

procedure TsgDXFInsert.ReloadAttribs(AConverter: TsgDXFConverter);
var
  I: Integer;
begin
  for I := 0 to FAttribs.Count - 1 do
    TsgDXFAttrib(FAttribs[I]).Loaded(AConverter);
end;

procedure TsgDXFInsert.RemoveReferenceNotification(const ARefObj: TsgDXFEntity);
begin
  inherited RemoveReferenceNotification(ARefObj);
  if ARefObj = Block then
    Block := nil;
end;

procedure TsgDXFInsert.SetAngle(const Value: Double);
var
  vAttrib: TsgDXFAttrib;
  Delta, vValue: Double;
  I: Integer;
begin
  if sgModAngle(Value, vValue) then
  begin
    Delta := vValue - FAngle;
    FAngle := vValue;
    for I := 0 to FAttribs.Count - 1 do
    begin
      vAttrib := TsgDXFAttrib(Attribs[I]);
      vAttrib.Point := OffsetFPoint(vAttrib.Point, Point, False);
      vAttrib.Point := RotateFPoint(vAttrib.Point, Delta);
      vAttrib.Point := OffsetFPoint(vAttrib.Point, Point, True);
      if vAttrib.HasSecond then
      begin
        vAttrib.Point1 := OffsetFPoint(vAttrib.Point1, Point, False);
        vAttrib.Point1 := RotateFPoint(vAttrib.Point1, Delta);
        vAttrib.Point1 := OffsetFPoint(vAttrib.Point1, Point, True);
      end;
      vAttrib.Rotation := vAttrib.Rotation + Delta;
    end;
  end;
end;

procedure TsgDXFInsert.SetBlock(const Value: TsgDXFBlock);
begin
  if DoSetBlockBefore(Value) > 0 then
  begin
    try
      if Assigned(Value) and Value.InheritsFrom(TsgDXFBlock) then
        BlockRecord := Value.BlockRecord
      else
        BlockRecord := TsgDXFBlockRecord(TObject(Value));
    finally
      DoSetBlockAfter(Value);
    end;
  end;
end;

procedure TsgDXFInsert.SetBlockRecord(const Value: TsgDXFBlockRecord);
begin
  if FBlockRecord <> Value then
  begin
    if Assigned(FBlockRecord) and FBlockRecord.InheritsFrom(TsgDXFBlockRecord) then
      FBlockRecord.Block.References.Remove(Self);
    FBlockRecord := Value;
    if Assigned(FBlockRecord) and FBlockRecord.InheritsFrom(TsgDXFBlockRecord) then
      FBlockRecord.Block.References.Add(Self);
  end;
end;

procedure TsgDXFInsert.SetDelayedLoadAttribs(const Value: Boolean);
begin
  FInternalFlags := (FInternalFlags and $FE) or Byte(Value);
end;

procedure TsgDXFInsert.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  FAttribs[AIndex] := AEntity;
end;

procedure TsgDXFInsert.SetExtrusion(const Value: TFPoint);
begin
  FExtrusion := Value;
  if (FExtrusion.X = 0) and (FExtrusion.Y = 0) and (FExtrusion.Z = 0) then
    FExtrusion.Z := 1;
end;

procedure TsgDXFInsert.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgDXFInsert.SetOwnerInsert(const AValue: TsgDXFInsert);
begin
  FOwnerInsert := AValue;
end;

procedure TsgDXFInsert.SetPoint(AValue: TFPoint);
begin
  SetPointAndMoveAttribs(AValue, True);
end;

procedure TsgDXFInsert.SetPointAndMoveAttribs(const AValue: TFPoint;
  const AMoveAttribs: Boolean);
begin
  if AMoveAttribs then
    OffsetAttribs(OffsetFPoint(AValue, Point, False));
  inherited SetPoint(AValue);
end;

procedure TsgDXFInsert.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
  LinkBlockRecord(AConverter);
end;

procedure TsgDXFInsert.LinkBlockRecord(AConverter: TsgDXFConverter);
begin
end;

procedure TsgDXFInsert.ListNotify(const Obj: TObject;
  Action: TListNotification);
begin
  case Action of
    lnAdded:
      begin
        inherited ListNotify(Obj, Action);
        if TsgDXFEntity(Obj).EntType = ceAttrib then
          TsgDXFEntity(Obj).SetOwner(Self);
      end;
    lnExtracted, lnDeleted:
      begin
        if TsgDXFEntity(Obj).EntType = ceAttrib then
          TsgDXFEntity(Obj).SetOwner(nil);
        inherited ListNotify(Obj, Action);
      end;
  end;
end;

procedure TsgDXFInsert.LoadedInternal(AConverter: TsgDXFConverter);
var
  I: Integer;
  vBounds: array of TFPoint;
  vSpatialFilter: TsgCADSpatialFilter;
  vSelfBox, vClipBox: TFRect;
  vIntersect: TF2DRect;
  vRefBlockRec: TsgDXFBlockRecord;
  vBoundsBox: TFRect;
  vT: TFMatrix;

  procedure DoAttribsBox;
  var
    I: Integer;
    vAttrib: TsgDXFAttrib;
  begin
    for I := 0 to FAttribs.Count - 1 do
    begin
      vAttrib := TsgDXFAttrib(FAttribs.List[I]);
      if not vAttrib.NotAppear then
        UnionFRect(FBox, vAttrib.FBox);
    end;
  end;

begin
  inherited LoadedInternal(AConverter);
  FBox := BadRect;
  if not CheckBlock(AConverter) then
    Exit;
  vRefBlockRec := GetActualBlockRecord;
  FBox := vRefBlockRec.Block.FBox;
  CalculateMatrix;
  if GetSpatialFilter(Self, TsgDXFEntity(vSpatialFilter)) and (vSpatialFilter.Bounds.Count >= 2) then
  begin
    vBounds := nil;
    try
      if vSpatialFilter.Bounds.Count = 2 then
      begin
        SetLength(vBounds, 4);
        vBoundsBox := PFRect(vSpatialFilter.Bounds.List)^;
        SwapDoubles(vBoundsBox.Top, vBoundsBox.Bottom);
        GetPts4ByBox(vBoundsBox, PsgPoints4(vBounds)^);
      end
      else
      begin
        SetLength(vBounds, vSpatialFilter.Bounds.Count);
        System.Move(vSpatialFilter.Bounds.List^, vBounds[0], Length(vBounds) * SizeOf(vBounds[0]));
      end;
      vT := vSpatialFilter.GetBoundTransformation(FMatrix);
      for I := 0 to High(vBounds) do
        vBounds[I] := FPointXMat(vBounds[I], vT);
      vClipBox := GetBoxOfArray(vBounds);
      vSelfBox := GetRealBox(Block.FBox, FMatrix);
      if not IntersectRectF2D(MakeF2dRectFromFRect(vSelfBox), MakeF2dRectFromFRect(vClipBox), @vIntersect) then
      begin
        if vSpatialFilter.DisplayBounds and (Converter.HeadVarStruct.XClipFrame <> 0) then
          FBox := vClipBox
        else
          FBox := cnstBadRect
      end
      else
        FBox := vClipBox;
    finally
      Finalize(vBounds);
    end;
  end
  else
    if (Block.Count <> 0) and not IsBadRect(FBox) then
      TransRectCorners(FBox, FMatrix);// don't TransRectCorners for attribs
  if DelayedLoadAttribs then
  begin
    DelayedLoadAttribs := False;
    DoDelayedLoad(AConverter);
  end;
  DoAttribsBox;
  if Layer = nil then
    Layer := AConverter.LayerByName('0');
end;

procedure TsgDXFInsert.OffsetAttribs(const ADelta: TFPoint);
var
  I: Integer;
  vAttrib: TsgDXFAttrib;
begin  
  for I := 0 to FAttribs.Count - 1 do
  begin
    vAttrib := TsgDXFAttrib(FAttribs.List[I]);
    vAttrib.Point := OffsetFPoint(vAttrib.Point, ADelta, True);
    if vAttrib.HasSecond then
      vAttrib.Point1 := OffsetFPoint(vAttrib.Point1, ADelta, True);
  end;
end;

function TsgDXFInsert.GetName: string;
begin
  Result := '';
  if Assigned(BlockRecord) then
    Result := BlockRecord.Name;
end;

function TsgDXFInsert.GetNodeName: string;
begin
  if FSceneElement > 0 then
    Result := GetXMLNameOfSceneElement
  else
    Result := inherited GetNodeName;
end;

procedure TsgDXFInsert.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
    end;
  end;
end;

class function TsgDXFInsert.GetXMLNameOfSceneElement: string;
begin
  Result := cnstXMLPrefix + cnstSceneElement;
end;

procedure TsgDXFInsert.InitializeMatrix;
begin
  FMatrix := cnstIdentityMat;
end;

function TsgDXFInsert.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := AEntity.EntType = ceAttrib;
  if Result then
    FAttribs.Insert(AIndex, AEntity);
end;

procedure TsgDXFInsert.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
  P: PsgCADIterate;
  Saved, SavedBlock: TsgCADIterate;
  SavedMatrix: TFMatrix;
  vConv: TsgDXFConverter;
  vConvsMatrix: TFMatrix;
  vEnt: TsgDXFEntity;
  vEnters, I: Integer;
  vAttdefs: TList;

  procedure ApplyAttribs(AAttdefs: TList);
  var
    I, J: Integer;
    vIsHaveAttdef: Boolean;
    vAttdef: TsgDXFAttdef absolute vEnt;
    vAttrib: TsgDXFAttrib;
  begin
    for I := 0 to FAttribs.Count - 1 do
    begin
      vAttrib := TsgDXFAttrib(FAttribs.List[I]);
      vIsHaveAttdef := False;
      if AAttdefs <> nil then
      begin
        for J := 0 to AAttdefs.Count - 1 do
        begin
          vEnt := TsgDXFEntity(AAttdefs[J]);
          if vAttrib.Tag = vAttdef.Tag then
          begin
            vIsHaveAttdef := True;
            if not vAttdef.Constant then
              vAttdef.FHasChanging := True;
            vAttrib.Invoke(AConverter, Proc, FinishProc);
            Break;
          end;
        end;
      end;
      if not vIsHaveAttdef and (not vAttrib.NotAppear) then
        vAttrib.Invoke(AConverter, Proc, FinishProc);
    end;
  end;

  procedure InitDefParams(APCADIterate: PsgCADIterate);
  begin
    APCADIterate^.Insert := Self;
    APCADIterate^.Color := Color;
    APCADIterate^.XScale := 0.0;
    APCADIterate^.YScale := 0.0;
    if (LineType = nil) or (LineType.NameID <> sltnByBlock) then
      APCADIterate^.LType := Lines;
  end;

var
  vRefBlockRec: TsgDXFBlockRecord;
begin
  vEnters := Integer(AConverter.AutoInsert and (Block <> nil));

  if vEnters = 0 then
    vEnters := Proc(Self);
  if vEnters = 0 then
    Exit;

  if Assigned(Converter) then
  begin
    vConv := Converter.GetMainConverter(@vConvsMatrix);
    SavedMatrix := vConv{FConverter}.FTransform3D;
    vConv.FTransform3D := FMatXMat(FMatrix, vConvsMatrix);
  end
  else
    vConv := nil;
  P := AConverter.Params;
  Saved := P^;
  SetOwnerInsert(P.Insert);
  vAttdefs := nil;
  try
    if vEnters = 1 then
    begin
      // Could be changed by attribs
      FillChar(SavedBlock, SizeOf(SavedBlock), 0);
      SavedBlock.BlockStack := P.BlockStack;
      SavedBlock.DrawMatrix := P.DrawMatrix;
      SavedBlock.RegenScale := P.RegenScale;
      SavedBlock.Viewport := P.Viewport;
      SavedBlock.Matrix := FMatXMat(FMatrix, P.Matrix);// only after calling ApplyAttribs
      SavedBlock.Additional := Integer(IsRotatedFMat(SavedBlock.Matrix));
      SavedBlock.ConvertMatrixCurrentInsertToWCS :=
        FMatXMat(P.ConvertMatrixCurrentInsertToWCS, GetMatrix);
      SavedBlock.LType := Saved.LType;
      InitDefParams(@SavedBlock);
      P^ := SavedBlock;
      vRefBlockRec := BlockRecord.GetAcAuthEnvironBlockRecord;
      vAttdefs := vRefBlockRec.Block.IterateEx(AConverter, Proc, FinishProc);
      Saved.Stopped := P^.Stopped;
    end;
    if FAttribs.Count > 0 then
    begin
      P^ := Saved;
      InitDefParams(P);
      ApplyAttribs(vAttdefs);
      if (vAttdefs <> nil) and not P^.Stopped then
      begin
        P^ := SavedBlock;
        for I := 0 to vAttdefs.Count - 1 do
          TsgDXFEntity(vAttdefs[I]).Invoke(AConverter, Proc, FinishProc);
        Saved.Stopped := P^.Stopped;
      end;
    end;
  finally
    vAttdefs.Free;
  end;
  P^ := Saved;
  SetOwnerInsert(P.Insert);
  if Assigned(vConv) then
    vConv.FTransform3D := SavedMatrix;
  if Assigned(FinishProc) then
    FinishProc(Self);
end;

function TsgDXFInsert.GetMatrix: TFMatrix;
begin
  Result := FMatrix;
end;

function TsgDXFInsert.GetEntType: TsgCADEntities;
begin
  Result := ceInsert;
end;

function TsgDXFInsert.ExtractParamsFromMatrix2D(var P, S: TFPoint; var A: Double): Boolean;
begin
  Result := FMatExtractParams2D(FMatrix, P, S, A);
end;

function TsgDXFInsert.Is3dObject: Integer;
begin
  Result := inherited Is3dObject;
  if SceneElement > 0 then
    Result := 1;
end;

function TsgDXFInsert.IsInsert: Boolean; //evg
begin
  Result := True;
end;

function TsgDXFInsert.IsOnePixelOptimisationValid: Boolean;  //evg
begin
  Result := False;
end;

function TsgDXFInsert.GetNameOfBlockPattern: string;
begin
  Result := EntName;
end;

{$IFDEF SG_BTI}
function TsgDXFInsert.GetArcOfCenter: TsgArcR;
begin
  FillChar(Result, SizeOf(Result), 0);
end;

function TsgDXFInsert.GetExtendedBlockData: TsgExtendedBlockData;
begin
  Result := nil;
end;

function TsgDXFInsert.GetOwnerConstruction: TsgDXFEntity;
begin
  Result := nil;
end;

procedure TsgDXFInsert.GetArcsParams(var Arcs: TsgArcsParams);
begin
  FillChar(Arcs, SizeOf(Arcs), 0);
end;

function TsgDXFInsert.GetBoundariesPoints(const AList: TsgObjectList;
  AConverter: TsgDXFConverter = nil): Integer;
begin
  if Assigned(AList) then
    Result := __GetBoundariesPointsInternal(AList, AConverter)
  else
    Result := 0;
end;

function TsgDXFInsert.__GetBoundariesPointsInternal(const AList: TsgObjectList;
  AConverter: TsgDXFConverter = nil): Integer;
begin
  Result := 0;
end;

procedure TsgDXFInsert.GetPts(var APts: TsgPoints4);
begin
  FillChar(APts, SizeOf(APts), 0);
end;

procedure TsgDXFInsert.GetPtsEx(const AList: TFPointList);
begin
end;

function TsgDXFInsert.GetSelectedIndex: Integer;
begin
  Result := -1;
end;

function TsgDXFInsert.GetMarkControlPoints: Integer;
begin
  Result := 0;
end;

function TsgDXFInsert.GetVertexModeInsp: Boolean;
begin
  Result := False;
end;

function TsgDXFInsert.IsDraw: Boolean;
begin
  Result := True;
end;

function TsgDXFInsert.IsRealCircular: Boolean;
begin
  Result := False;
end;

function TsgDXFInsert.BlockIsPattern(const ABlock: TsgDXFBlock): Boolean;
begin
  Result := False;
end;

procedure TsgDXFInsert.SetSelectedIndex(const AIndex: Integer);
begin
end;

function TsgDXFInsert.SetBtiProps(const AID: Integer;
  const AValue: Pointer): Integer;
begin
  Result := 0;
end;
{$ENDIF}

function TsgDXFInsert.BTIDataFromXMLNode(const ANode: TsgNode;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := cnstXML_OK;
end;

function TsgDXFInsert.BTIDataToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := cnstXML_OK;
end;

function TsgDXFInsert.GetExtrusion: TFPoint;
begin
  Result := FExtrusion;
end;

function TsgDXFInsert.GetHasAttribs: Boolean;
begin
  Result := (FAttribs <> nil) and (FAttribs.Count > 0);
end;

function TsgDXFInsert.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgDXFInsert.GetScale: TFPoint;
begin
  Result := FScale;
end;

function TsgDXFInsert.GetBox3D(const AKey: UInt64): TFRect;
{$IFNDEF SG_FIREMONKEY}
var
  vNode: IsgVisibleObject;
{$ENDIF}
begin
  Result := cnstBadRect;
{$IFNDEF SG_FIREMONKEY}
  GetInterfaceForData(AKey, FVisualization, IsgVisibleObject, vNode);
  if Assigned(vNode) then
    Result := vNode.GetBox;
{$ENDIF}
end;

function TsgDXFInsert.GetAlphaBlend(const AKey: UInt64): Integer;
{$IFNDEF SG_FIREMONKEY}
var
  vNode: IsgVisibleObject;
{$ENDIF}
begin
  Result := -1;
{$IFNDEF SG_FIREMONKEY}
  GetInterfaceForData(AKey, FVisualization, IsgVisibleObject, vNode);
  if Assigned(vNode) then
    Result := vNode.GetAlphaBlend;
{$ENDIF}
end;

function TsgDXFInsert.GetAlphaBlendRepresentation(const AKey: UInt64): Integer;
begin
  Result := GetAlphaBlend(AKey);
end;

procedure TsgDXFInsert.SetAlphaBlend(const AKey: UInt64; const AValue: Integer);
{$IFNDEF SG_FIREMONKEY}
var
  vNode: IsgVisibleObject;
{$ENDIF}
begin
{$IFNDEF SG_FIREMONKEY}
  GetInterfaceForData(AKey, FVisualization, IsgVisibleObject, vNode);
  if Assigned(vNode) then
    vNode.SetAlphaBlend(AValue);
{$ENDIF}
end;

function TsgDXFInsert.GetCustomColor(const AKey: UInt64): Cardinal;
{$IFNDEF SG_FIREMONKEY}
var
  vNode: IsgVisibleObject;
{$ENDIF}
begin
  Result := clByBlock;
{$IFNDEF SG_FIREMONKEY}
  GetInterfaceForData(AKey, FVisualization, IsgVisibleObject, vNode);
  if Assigned(vNode) then
    Result := vNode.GetCustomColor;
{$ENDIF}
end;

procedure TsgDXFInsert.SetCustomColor(const AKey: UInt64; const AValue: Cardinal);
{$IFNDEF SG_FIREMONKEY}
var
  vNode: IsgVisibleObject;
{$ENDIF}
begin
{$IFNDEF SG_FIREMONKEY}
  GetInterfaceForData(AKey, FVisualization, IsgVisibleObject, vNode);
  if Assigned(vNode) then
    vNode.SetCustomColor(AValue);
{$ENDIF}
end;

procedure TsgDXFInsert.SetAlphaBlendRepresentation(const AKey: UInt64;
  const AValue: Integer);
begin
  SetAlphaBlend(AKey, AValue);
end;

function TsgDXFInsert.GetCustomColorRepresentation(const AKey: UInt64): Cardinal;
begin
  Result := GetCustomColor(AKey);
end;

procedure TsgDXFInsert.SetCustomColorRepresentation(const AKey: UInt64;
  const AValue: Cardinal);
begin
  SetCustomColor(AKey, AValue);
end;

function TsgDXFInsert.GetArea(const AKey: UInt64): Double;
{$IFNDEF SG_FIREMONKEY}
var
  vNode: IsgVisibleObject;
{$ENDIF}
begin
  Result := -1;
{$IFNDEF SG_FIREMONKEY}
  GetInterfaceForData(AKey, FVisualization, IsgVisibleObject, vNode);
  if Assigned(vNode) then
    Result := vNode.GetArea;
{$ENDIF}
end;

procedure TsgDXFInsert.NormalizeVisibilityTree;
var
  vHashItem: TsgHashItem;
  vColl: TsgCollection;
{$IFNDEF SG_FIREMONKEY}
  vNode: IsgVisibleObject;
{$ENDIF}
begin
  if not Assigned(FVisualization) then
    Exit;
  vColl := TsgCollection(FVisualization);
  if vColl.Count > 0 then
  begin
    vHashItem := vColl[0];
{$IFNDEF SG_FIREMONKEY}
     if Assigned(vHashItem.Data) and
      Supports(TObject(vHashItem.Data), IsgVisibleObject, vNode) then
    begin
      vNode.NormalizeVisibilityTree;
    end;
{$ENDIF}
  end;
end;

procedure TsgDXFInsert.GetSetVisibleRepresentation(const AKey: UInt64;
  var AValue: Boolean; const AIsGet: Boolean);
var
  I: Integer;
  vHashItem: TsgHashItem;
  vColl: TsgCollection;
{$IFDEF SG_FIREMONKEY}
  vMesh: IControl;
{$ELSE}
  vNode: IsgVisibleObject;
{$ENDIF}
begin
  if not Assigned(FVisualization) then
    Exit;

  vColl := TsgCollection(FVisualization);
  I := vColl.IndexOf(AKey);
  if I >= 0 then
  begin
    vHashItem := vColl[I];
{$IFDEF SG_FIREMONKEY}
    if Assigned(vHashItem.Data) and
      Supports(vHashItem.Data, IControl, vMesh) then
    begin
      if AIsGet then
        AValue := vMesh.Visible
      else
        vMesh.Visible := AValue;
    end;
{$ELSE}
     if Assigned(vHashItem.Data) and
      Supports(TObject(vHashItem.Data), IsgVisibleObject, vNode) then
    begin
      if AIsGet then
        AValue := vNode.GetVisibleElement
      else
        vNode.SetVisibleElement(AValue);
    end;
{$ENDIF}
  end
end;

function TsgDXFInsert.GetVisibleRepresentation(const AKey: UInt64): Boolean;
begin
  Result := False;
  GetSetVisibleRepresentation(AKey, Result);
end;

procedure TsgDXFInsert.SetScale(const Value: TFPoint);
var
  vAttrib: TsgDXFAttrib;
  vScaleKoef: TFPoint;
  vHeightKoef: Double;
  I: Integer;

  procedure ApplyAttribPoint(var AAttribPoint: TFPoint);
  begin
    AAttribPoint.X := FPoint.X + (AAttribPoint.X - FPoint.X) * vScaleKoef.X;
    AAttribPoint.Y := FPoint.Y + (AAttribPoint.Y - FPoint.Y) * vScaleKoef.Y;
    AAttribPoint.Z := FPoint.Z + (AAttribPoint.Z - FPoint.Z) * vScaleKoef.Z;
  end;
begin
  if FAttribs.Count > 0 then
  begin
    try
      vScaleKoef.X := Value.X / FScale.X;
      vScaleKoef.Y := Value.Y / FScale.Y;
      vScaleKoef.Z := Value.Z / FScale.Z;
    except
      vScaleKoef := cnstFPointSingle;
    end;
    for I := FAttribs.Count - 1 downto 0 do
    begin
      vAttrib := TsgDXFAttrib(Attribs[I]);
      // Scale Attrib width/height
      vHeightKoef := vAttrib.Height;
      vAttrib.Height := vAttrib.Height * vScaleKoef.Y;
      if vAttrib.Height <> 0 then
        vHeightKoef := vHeightKoef / vAttrib.Height;
      vAttrib.Scale := vAttrib.Scale * vHeightKoef * vScaleKoef.X;
      // Scale Attrib position
      ApplyAttribPoint(vAttrib.FPoint);
      if vAttrib.HasSecond then
        ApplyAttribPoint(vAttrib.FPoint1);
    end;
  end;
  FScale := Value;
end;

procedure TsgDXFInsert.SetVisibleRepresentation(const AKey: UInt64;
  const AValue: Boolean);
var
  vValue: Boolean;
begin
  vValue := AValue;
  GetSetVisibleRepresentation(AKey, vValue, False);
end;

function TsgDXFInsert.ToXMLGeoData(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := cnstXML_OK;
  if IsFullPropsOrXMLHelp(AParams.Mode) then
  begin
    ANode.AddAttribNV(
      cnstXMLNames[xmlInsertMatrix].Name
      ).ValueData.ValueAsMatrix := FMatrix;
  end;
  ANode.AddAttribNV(cnstXMLNames[xmlExtrusion].Name).ValueAsFPoint := Extrusion;
  ANode.AddAttribNV(cnstXMLNames[xmlAngle].Name).ValueAsDouble := Angle;
  ANode.AddAttribNV(cnstXMLNames[xmlFPointScale].Name).ValueAsFPoint := Scale;
end;

function TsgDXFInsert.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vParams: TsgXMLParams;
{$IFNDEF SG_NO_USE_KERNEL3D}
  vArea: Double;
  vBox3d: TFRect;
  vPathKey: UInt64;
  vIconIndex: TsgIconIndex;
{$ENDIF}
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlBlockName].Name)
  else
  begin
    if Assigned(Block) and (xmPathGenSup in AParams.Mode) then
    begin
      vParams := AParams;
      Block.ToXMLWithParams(ANode, vParams);
    end;
    if (xmlForViewing in AParams.Mode) or IsFullPropsOrXMLHelp(AParams.Mode) then
    begin
       {$IFNDEF SG_NO_USE_KERNEL3D}
      if Assigned(Block) and (Block.Count > 0) then
      begin
        vIconIndex := icnPartInstance;
        ANode.AddAttribNV(cnstXMLIconIndex).ValueAsInt := Integer(vIconIndex);
      end;
      if Assigned(AParams.NodeData) and (AParams.NodeData is TsgNode) then
      begin
        vPathKey := GetAttributeHandle(TsgNode(AParams.NodeData),
          sgConsts.cnstXMLNames[xmlPathKey].Name);
        if vPathKey <> 0 then
        begin
          vArea := GetArea(vPathKey);
          if vArea >= 0 then
          begin
            ANode.AddAttribNV(sgConsts.cnstXMLNames[xmlArea].Name).ValueAsDouble :=
              vArea;
          end;
          vBox3d := GetBox3D(vPathKey);
          if not IsBadRect(vBox3d) then
          begin
            ANode.AddAttribNV(sgConsts.cnstXMLNames[xmlBox3d].Name).ValueAsFRect :=
              vBox3d;
          end;
        end;
      end;
      {$ENDIF}
    end;
    if Assigned(Block) then
      ANode.AddAttribNV(cnstXMLNames[xmlBlockName].Name).ValueAsStr := Block.Name;
  end;
  ToXMLGeoData(ANode, AParams);
end;

procedure TsgDXFInsert.FreeReferences;
var
  vBlock: TsgDXFBlock;
begin
  inherited FreeReferences;
  vBlock := Block;
  if Assigned(vBlock) then
  begin
    if (vBlock.Owner = nil) or (vBlock.Owner = Self) then
      vBlock.Free
    else
      SetBlockRecord(nil); // release ref only
  end;
  FreeAndNil(FAttribs);
end;

function TsgDXFInsert.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FAttribs[AIndex];
  FAttribs.Delete(AIndex);
end;

function TsgDXFInsert.DoClearReferences(var AConv: TsgDXFConverter;
  var ABlock: TsgDXFBlock): Boolean;
begin
  Result := IsConverterClearing(Converter);
  if Result then
  begin
    ABlock := nil;
    AConv := nil;
  end
  else
  begin
    ABlock := Block;
{$IFDEF SG_BTI}
    if Assigned(ABlock)and BlockIsPattern(ABlock) then
      ABlock := nil;
{$ENDIF}
    AConv := Converter;
  end;
end;

class function TsgDXFInsert.FreeBlockInternal(const AConv: TsgDXFConverter;
  const ABlock: TsgDXFBlock): Boolean;
begin
  Result := False;
  if Assigned(ABlock) and Assigned(AConv) and (not IsConverterClearing(AConv)) then
  begin
    if AConv.Sections[csBlocks].RemoveEntity(ABlock) then
    begin
      ABlock.Free;
      Result := True;
    end;
  end;
end;

function TsgDXFInsert.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlBlockName:
      begin
        if IsHandleStr(ANode.Value)  then
          Block := TsgDXFBlock(Converter.Sections[csBlocks].FindEntByHandle(ANode.ValueAsHandle))
        else
          Block := Converter.BlockByName(ANode.Value);
      end;
    xmlExtrusion: Extrusion := ANode.ValueAsFPoint;
    xmlAngle: Angle := ANode.ValueAsDouble;
    xmlFPointScale: Scale := ANode.ValueAsFPoint;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFInsert.IsUsedInKeyConstruction: Boolean;
begin
  Result := True;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFInsert.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
//  SetPointToNode(ANode, Scale, 'Scale');
//  ANode.ChildValues['Block'] := itoId(Block);
//  ANode.ChildValues['Owner'] := itoId(Owner);
  ANode.ChildValues[sPlcKeyWords[plcAngle].Name] := Angle;
//  SetPointToNode(ANode, Extrusion, 'Extrusion');
end;

function TsgDXFInsert.SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
  const AType: TsgPlcType; const AValue: Variant): Integer;
begin
  Result := cnstExportToXML_OK;
  case AType.Id of
    plcAngle: Angle := AValue;
  else
    Result := inherited SetPropertyFromPluginsInternal(ANode, AType, AValue);
  end;
end;
{$ENDIF}

{ TsgCADClipInsert }

constructor TsgCADClipInsert.Create;
begin
  inherited Create;
  FClipBox := BadRect;
end;

procedure TsgCADClipInsert.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADClipInsert then
    FClipBox := TsgCADClipInsert(Source).FClipBox;
end;

function TsgCADClipInsert.GetBox: TFRect;
begin
  Result := inherited GetBox;
  if Result.Left < FClipBox.Left       then Result.Left := FClipBox.Left;
  if Result.Right > FClipBox.Right     then Result.Right := FClipBox.Right;
  if Result.Top > FClipBox.Top         then Result.Top := FClipBox.Top;
  if Result.Bottom < FClipBox.Bottom   then Result.Bottom := FClipBox.Bottom;
//  if Result.Left > Result.Right        then Result.Left := Result.Right;
//  if Result.Bottom > Result.Top        then Result.Bottom := Result.Top;
end;

function TsgCADClipInsert.GetClipBox: TFRect;
begin
  Result := FClipBox;
end;

procedure TsgCADClipInsert.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlFPointScale));
      AHideList.Add(Integer(xmlAngle));
      AHideList.Add(Integer(xmlBlockName));
    end;
  end;
end;

procedure TsgCADClipInsert.SetClipBox(const Value: TFRect);
begin
  FClipBox := Value;
end;

procedure TsgCADClipInsert.SetPoint(AValue: TFPoint);
var
  Delta: TFPoint;
begin
  Delta := OffsetFPoint(AValue, Point, False);
  inherited SetPoint(AValue);
  FClipBox.TopLeft := OffsetFPoint(FClipBox.TopLeft, Delta, True);
  FClipBox.BottomRight := OffsetFPoint(FClipBox.BottomRight, Delta, True);
end;

function TsgCADClipInsert.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlClipRect].Name)
  else
    if not IsBadRect(FClipBox) then
      ANode.AddAttribNV(cnstXMLNames[xmlClipRect].Name).ValueAsFRect := FClipBox;
end;

{ TsgCADMInsert }

procedure TsgCADMInsert.AssignEntity(Source: TsgDXFEntity);
var
  M: TsgCADMInsert absolute Source;
begin
  inherited AssignEntity(Source);
  if not (Source is TsgCADMInsert) then
    Exit;
  NumCols := M.NumCols;
  NumRows := M.NumRows;
  ColSpacing := M.ColSpacing;
  RowSpacing := M.RowSpacing;
end;

constructor TsgCADMInsert.Create;
begin
  inherited Create;
  FNumCols := 1;
  FNumRows := 1;
end;

function TsgCADMInsert.GetBox: TFRect;
var
  vPoint1, vPoint2, vPointColRow: TFPoint;
begin
  Result := inherited GetBox;
  if not IsBadRect(Result) then
  begin
    vPointColRow := MakeFPoint(ColSpacing * (NumCols-1), RowSpacing * (NumRows-1), 0);
    vPoint1 := AddFPoint(Result.TopLeft, vPointColRow);
    vPoint2 := AddFPoint(Result.BottomRight, vPointColRow);
    ExpandFRect(Result, vPoint1);
    ExpandFRect(Result, vPoint2);
  end;
end;

function TsgCADMInsert.GetColSpacing: Double;
begin
  Result := FColSpacing;
end;

function TsgCADMInsert.GetNumCols: Integer;
begin
  Result := FNumCols;
end;

function TsgCADMInsert.GetNumRows: Integer;
begin
  Result := FNumRows;
end;

function TsgCADMInsert.GetRowSpacing: Double;
begin
  Result := FRowSpacing;
end;

procedure TsgCADMInsert.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
  I, J: Integer;
  P, P0: TFPoint;
begin
  P0 := Point;
  P := P0;
  try
    for I := 0 to NumRows - 1 do
    begin
      P.X := P0.X;
      for J := 0 to NumCols - 1 do
      begin
        Point := P;
        CalculateMatrix;
        inherited Invoke(AConverter, Proc, FinishProc);
        P.X := P.X + ColSpacing;
      end;
      P.Y := P.Y + RowSpacing;
    end;
  finally
    Point := P0;
    CalculateMatrix;
  end;
end;

procedure TsgCADMInsert.SetColSpacing(const Value: Double);
begin
  FColSpacing := Value;
end;

procedure TsgCADMInsert.SetNumCols(const Value: Integer);
begin
  if (Value >= 1) and (Value <= 65535) then
    FNumCols := Value;
end;

procedure TsgCADMInsert.SetNumRows(const Value: Integer);
begin
  if (Value >= 1) and (Value <= 65535) then
    FNumRows := Value;
end;

procedure TsgCADMInsert.SetRowSpacing(const Value: Double);
begin
  FRowSpacing := Value;
end;

function TsgCADMInsert.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlColumnCount].Name).ValueAsInt := NumCols;
  ANode.AddAttribNV(cnstXMLNames[xmlRowCount].Name).ValueAsInt := NumRows;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlColSpacing].Name).ValueData,
    ColSpacing, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlRowSpacing].Name).ValueData,
    RowSpacing, xmlForViewing in AParams.Mode);
end;

{ TsgDXFDimension }

procedure TsgDXFDimension.ApplyElevation;
var
  vPoint: TFPoint;
begin
  vPoint := Point;
  vPoint.Z := Elevation;
  Point := vPoint;
end;

procedure TsgDXFDimension.AssignEntity(Source: TsgDXFEntity);
var
  vDimension: TsgDXFDimension absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFDimension then
  begin
    FAssociated := vDimension.FAssociated;
    FDefPoint := vDimension.FDefPoint;
    Style := vDimension.Style;
    FFlags := vDimension.FFlags;
    FLinDefPoint1 := vDimension.FLinDefPoint1;
    FLinDefPoint2 := vDimension.FLinDefPoint2;
    FMiddlePoint := vDimension.FMiddlePoint;
    FTextOverride := vDimension.FTextOverride;
    FTextRotation := vDimension.FTextRotation;
    if vDimension.Properties <> nil then
      ActualDimStyle.AssignEntity(vDimension.Properties)
    else
      FPropertiesItem.Item := nil;
    FDimRot := vDimension.FDimRot;
  end;
end;

function TsgDXFDimension.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = sACADXDataAppName then
  begin
    AData.AddString(String_1001, sACADXDataAppName);
    AData.AddString(String_1000, cnstDStyle);
    AData.AddString(String_1002, '{');
    Result := True;
  end;
end;

procedure TsgDXFDimension.EndExtData(const AData: TsgCADExtendedData);
begin
  AData.AddString(String_1002, '}');
end;

procedure TsgDXFDimension.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FDimStyleItem);
  FreeAndNil(FPropertiesItem);
end;

function TsgDXFDimension.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vStyle: TsgDXFDimensionStyle;
  vArrowType: Integer;
  vArrowSize: Double;
  vPropertiesInit: TsgDimNameVals;

  function GetDimStyle(const ANodeStyle: TsgNodeSample): TsgDXFDimensionStyle;
  begin
    if Assigned(Converter) then
      Result := Converter.GetDimStyleFromNode(ANodeStyle)
    else
      Result := nil;
  end;

begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  if (not Assigned(Style)) and Assigned(Converter) then
    Style := Converter.DimensionStyleByName(Converter.HeadVarStruct.DimStyle);
  case AType.Id of
    xmlArrowType:
      begin
        vArrowType := ANode.ValueAsInt;
        if (vArrowType >= Integer(Low(TsgDimArrowType))) and
           (vArrowType <= Integer(High(TsgDimArrowType))) and
           (ArrowType <> vArrowType) then
          ArrowType := vArrowType;
      end;
    xmlArrowSize: ArrowSize := ANode.ValueAsDouble;
    xmlDimStyle:
      begin
        vStyle := GetDimStyle(ANode);
        if Assigned(vStyle) then
        begin
          vArrowType := ArrowType;
          vArrowSize := ArrowSize;
          try
            vPropertiesInit := [];
            if Assigned(Properties) then
              vPropertiesInit := Properties.PropertiesInit;
            Style := vStyle;
            ActualDimStyle.SetOwnerStyle(Style);
          finally
            if vnDIMLRBLK in vPropertiesInit then
              ArrowType := vArrowType;
            if vnDIMASZ in vPropertiesInit then
              ArrowSize := vArrowSize;
          end;
        end;
      end;
    xmlProperties:
      begin
        if (ActualDimStyle.OwnerStyle = nil) or (ActualDimStyle.PropertiesInit = []) then
          ActualDimStyle.SetOwnerStyle(Style);
        Properties.FromXMLAsProperties(ANode, AResult);
      end;
    xmlDefPoint:      DefPoint := ANode.ValueAsFPoint;
    xmlLinDefPoint1:  LinDefPoint1 := ANode.ValueAsFPoint;
    xmlLinDefPoint2:  LinDefPoint2 := ANode.ValueAsFPoint;
    xmlMiddlePoint:   MiddlePoint := ANode.ValueAsFPoint;
    xmlArcDefPoint:   ArcDefPoint := ANode.ValueAsFPoint;
    xmlRadDefPoint:   RadDefPoint := ANode.ValueAsFPoint;
    xmlTextOverride:  TextOverride := ANode.ValueAsStr;
    xmlTextRotation:  TextRotation := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFDimension.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcTextOverride].Name] := TextOverride;
  ANode.ChildValues[sPlcKeyWords[plcStyleName].Name] := Style.Name;
  SetPointToNode(ANode, DefPoint, sPlcKeyWords[plcDefPoint].Name);
  SetPointToNode(ANode, LinDefPoint1, sPlcKeyWords[plcLinDefPoint1].Name);
  SetPointToNode(ANode, LinDefPoint2, sPlcKeyWords[plcLinDefPoint2].Name);
  SetPointToNode(ANode, MiddlePoint, sPlcKeyWords[plcMiddlePoint].Name);
end;

function TsgDXFDimension.SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
  const AType: TsgPlcType; const AValue: Variant): Integer;
begin
  Result := cnstExportToXML_OK;
  case AType.Id of
    plcTextOverride: TextOverride := AValue;
    plcStyleName:    Style.Name := AValue;//??? from old version
  else
    Result := inherited SetPropertyFromPluginsInternal(ANode, AType, AValue);
  end;
end;
{$ENDIF}

function TsgDXFDimension.GetPrecision: Integer;
begin
  Result := ActualDimStyle.DIMDEC;
end;

function TsgDXFDimension.GetProperties: TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(FPropertiesItem.Item);
end;

function TsgDXFDimension.GetActualDimStyle: TsgDXFDimensionStyle;
begin
  if FPropertiesItem.Item = nil then
  begin
    FPropertiesItem.Item := TsgDXFDimensionProperties.Create;
    FPropertiesItem.Item.SetConverter(Converter);
    GetProperties.SetOwnerStyle(Self.Style);
  end;
  Result := GetProperties;
end;

function TsgDXFDimension.GetRadDefPoint: TFPoint;
begin
  Result := FRadDefPoint;
end;

procedure TsgDXFDimension.GenerateBlock(const AConverter: TsgDXFConverter);
const
  cnstBlockNameLine = 'sgCLOSEDFILEDLINE';
type
  TsgArrowPos = (arUndefined, arDefault, arTextOut, arArrowOut, arArrowAndTextOut);
var
  vCountCrossPoint, vNumLine: Integer;
  vLines: array [0..3] of TsgDXFLine;
  vPointA, vPoint1: TFPoint;
  vPointCross: array [0..1] of TFPoint;
  vAngle, vTextLen, vTextHeight, vTextRot, vTextWidth: Double;
  vTextPoint: TFPoint;
  vDimText: TsgDXFText;
  vName: string;
  vIsShort: Boolean;
  vPointClassify: TsgPointClassify;
  vTextRect: array[0..3] of TFPoint;
  vTextOffset, vArrowSize, vExtLineOffset, vExtLineExt: Double;

  function IsLineCrossed(APointA1, APointA2, APointB1, APointB2: PFPoint): Boolean;
  var
    vRes: Double;
  begin
    vRes := (APointA1^.X - APointA2^.X)*(APointB1^.Y - APointB2^.Y) - (APointA1^.Y - APointA2^.Y)*(APointB1^.X - APointB2^.X);
    Result := (Abs(vRes) >= fAccuracy);
  end;

  function PointCrossedPerpendicularLine(K, B: TsgFloat; const P: TFPoint): TFPoint;
  begin
    Result.X := (- B * K + P.Y * K + P.X) / (1 + K * K);
    Result.Y := K * Result.X + B;
    Result.Z := 0;
  end;

  function PointCrossedPerpendicularLines(const P1, P2, P: TFPoint; var ACross: TFPoint): Boolean;
  var
    K, B, DX: Double;
  begin
    DX := P2.X - P1.X;
    Result := Abs(DX) > fAccuracy;
    if Result then
    begin
      K := (P2.Y - P1.Y) / DX;
      B := P1.Y - K * P1.X;
      ACross := PointCrossedPerpendicularLine(K, B, P);
    end;
  end;

  function PointCrossedPerpendicularLinesEx(const P1, P2, P: TFPoint): TFPoint;
  var
    K, B, DX: Double;
  begin
    DX := P2.X - P1.X;
    if Abs(DX) > fAccuracy then
    begin
      K := (P2.Y - P1.Y) / DX;
      B := P1.Y - K * P1.X;
      Result := PointCrossedPerpendicularLine(K, B, P);
    end
    else
    begin
      Result.X := P1.X;
      Result.Y := P.Y;
      Result.Z := 0;
    end;
  end;
  
  function AngleInterOXandLine(AP1, AP2: PFPoint): Double;
  begin
    Result := sgFunction.GetAngleByPoints(AP2^, AP1^, True);
  end;

  function PointCrossedLine(A, B, C, D: PFPoint; var APoint: TFPoint): Boolean;
  var
    denom, r, s: Double;
  begin
    Result := False;
    denom := (B^.X - A^.X)*(D^.Y - C^.Y) - (B^.Y - A^.Y)*(D^.X - C^.X);
    if Abs(denom) > fAccuracy then
    begin
      r := ( (A^.Y - C^.Y)*(D^.X - C^.X) - (A^.X - C^.X)*(D^.Y - C^.Y) ) / denom;
      s := ( (A^.Y - C^.Y)*(B^.X - A^.X) - (A^.X - C^.X)*(B^.Y - A^.Y) ) / denom;
      if (r >= 0.0 - fAccuracy) and (r <= 1.0 + fAccuracy) and
         (s >= 0.0 - fAccuracy) and (s <= 1.0 + fAccuracy) then
      begin
        APoint := MakeFPoint(A^.X + r*(B^.X - A^.X), A^.Y + r*(B^.Y - A^.Y), 0);
        Result := True;
      end;
    end;
  end;

  procedure PointsCrossedTextBox(APoint1, APoint2: PFPoint);
  var
    I: Integer;
  begin
    vCountCrossPoint := 0;
    vNumLine := 0;
    for I := 0 to 2 do
    begin
      if PointCrossedLine(APoint1, APoint2, @vTextRect[I], @vTextRect[I + 1], vPointCross[vCountCrossPoint]) then
      begin
        case I of
          0: vNumLine := vNumLine + 1;
          1: vNumLine := vNumLine + 10;
          2: vNumLine := vNumLine + 100;
        end;
        Inc(vCountCrossPoint);
      end;
      if vCountCrossPoint > 1 then
        Break;
    end;
    if (vCountCrossPoint < 2) and (PointCrossedLine(APoint1, APoint2, @vTextRect[0], @vTextRect[3], vPointCross[vCountCrossPoint])) then
    begin
      Inc(vCountCrossPoint);
      vNumLine := vNumLine + 1000;
    end;
  end;

  procedure SetTextString(const AValue: Double);
  var
    vDIMDSEP: Char;
  begin
    if FTextOverride <> '' then
      vDimText.Text := FTextOverride
    else
    begin
      vDIMDSEP := DIMDSEP;
      if Integer(vDIMDSEP) = 0 then
        vDIMDSEP := cnstDefHeadVarStruct.DimProps.DSep;
      vDimText.Text := sgFunction.DoubleToStrF(AValue * MeasurementsScale, Precision, vDIMDSEP);
    end;
  end;

  procedure TextLoaded;
  var
    vRot: Double;
    vRotPt: TFPoint;
  begin
    vDimText.Point := vTextPoint;
    vDimText.Rotation := 0;
    vDimText.Loaded(AConverter);
    if Abs(FTextRotation) > fAccuracy then
      vDimText.Rotation := FTextRotation
    else
      vDimText.Rotation := GetTextAlignedRotation(TextAlign, vTextRot);
    vTextWidth := vDimText.FBox.Right - vDimText.FBox.Left;
    vTextHeight := vDimText.FBox.Top - vDimText.FBox.Bottom;
    vTextRect[0] := vDimText.FBox.TopLeft;
    vTextRect[2] := vDimText.FBox.BottomRight;
    if not vDimText.WinFont then
    begin
      vTextRect[0].X := vTextRect[0].X - vTextOffset;
      vTextRect[0].Y := vTextRect[0].Y + vTextOffset;
      vTextRect[2].X := vTextRect[2].X + vTextOffset;
      vTextRect[2].Y := vTextRect[2].Y - vTextOffset;
    end;
    vTextRect[1] := vTextRect[0];
    vTextRect[1].X := vTextRect[2].X;
    vTextRect[3] := vTextRect[2];
    vTextRect[3].X := vTextRect[0].X;
    if ((TextAlign = 1) or (Abs(FTextRotation) > fAccuracy)) and (not (IsEqual(vDimText.Rotation, 0) or IsEqual(vDimText.Rotation, 360))) then
    begin
      vRot := vDimText.Rotation * fPiDividedBy180;
      vRotPt := sgFunction.MiddleFPoint(vTextRect[0], vTextRect[2]);

      vDimText.Point := RotateAroundFPoint(vTextPoint, vRotPt, False, vRot);
      vDimText.Loaded(AConverter);

      vTextRect[0] := RotateAroundFPoint(vTextRect[0], vRotPt, False, vRot);
      vTextRect[1] := RotateAroundFPoint(vTextRect[1], vRotPt, False, vRot);
      vTextRect[2] := RotateAroundFPoint(vTextRect[2], vRotPt, False, vRot);
      vTextRect[3] := RotateAroundFPoint(vTextRect[3], vRotPt, False, vRot);
    end;
  end;

  procedure AddLines;
  var
    vLineA, vLineB: TsgDXFLine;
    I, vKoefSigned: Integer;
    C, S : Extended;
    A, X, Y, K, B, vMinX, vMinY, vMaxX, vMaxY: Double;
    vAngle, vDistance: Double;
    vTypePosArrow: TsgArrowPos;

    procedure MinMax;
    var
      I: Integer;
    begin
      vMinX := vLines[0].Point.X;
      vMinY := vMinX;
      vMaxX := vLines[0].Point.Y;
      vMaxY := vMaxX;
      for I := 0 to 3 do
      begin
        if vMaxX < vLines[I].Point.X then
          vMaxX := vLines[I].Point.X
        else
          if vMinX > vLines[I].Point.X then
            vMinX := vLines[I].Point.X;
        if vMaxY < vLines[I].Point.Y then
          vMaxY := vLines[I].Point.Y
        else
          if vMinY > vLines[I].Point.Y then
            vMinY := vLines[I].Point.Y;
      end;
    end;

    function IsPointInBox(APoint: PFPoint): Boolean;
    begin
      Result := ((APoint^.X >= vMinX) and (APoint^.Y >= vMinY) and
        (APoint^.X <= vMaxX) and (APoint^.Y <= vMaxY));
    end;

    procedure MakeRemoval(AMakeLineB: Boolean);
    var
      vDX, vDY, vLen, vLen1, vLen2: Double;
      vPoint1, vPoint2, vPoint: TFPoint;
      vVisible: Boolean;
      procedure SetPoints(const AL1, AL2: TsgDXFLine);
      begin
        vPoint1 := AL1.Point;
        vPoint2 := AL2.Point;
        vVisible := AL2.Visibility;        
{$IFDEF SG_BTI_TEST}
        if AMakeLineB and (not AL1.Visibility) then
          AL2.Visibility := False;
{$ENDIF}
      end;
    begin
      vTextRot := 0;
      if FFlags < 128 then
        vPoint := FDefPoint
      else
        vPoint := FMiddlePoint;
      vLen1 := DistanceFPoint(vPoint, vLines[2].Point);
      vLen2 := DistanceFPoint(vPoint, vLines[3].Point);
      if vLen1 > vLen2 then
        SetPoints(vLines[2], vLines[3])
      else
        SetPoints(vLines[3], vLines[2]);
      vLineA := TsgDXFLine.Create;
      AConverter.DoCreate(vLineA);
      vLineA.ColorCAD := cnstColorCADByBlock;
      vLineA.Point := vPoint2;
      vLineA.Point1 := cnstFPointZero;
      vDX := vPoint1.X - vPoint2.X;
      vDY := vPoint1.Y - vPoint2.Y;
      if Abs(vDX) < fAccuracy then
      begin
        vLen := DistanceFPoint(vPoint1, vPoint2);
        if vLen > fAccuracy then
          vAngle := sgFunction.sgArcSin(Abs(vDY / vLen))
        else
          vAngle := 0;
      end
      else
        vAngle := ArcTan(Abs(vDY / vDX));
      SinCos(vAngle, S, C);
      if vPoint2.X > vPoint1.X then
        vKoefSigned := 1
      else
        vKoefSigned := -1;
      if FFlags <> 129 then
      begin
        if AMakeLineB then
        begin
          vLineA.FPoint1.X := vLineA.FPoint.X + vKoefSigned * C * vArrowSize;
          if vPoint2.Y > vPoint1.Y then
            vLineA.FPoint1.Y := vLineA.FPoint.Y + S * vArrowSize
          else
            vLineA.FPoint1.Y := vLineA.FPoint.Y - S * vArrowSize;
        end
        else
        begin
          vLineA.FPoint1.X := vLineA.FPoint.X + vKoefSigned * C * (ArrowSize * 2);
          if vPoint2.Y > vPoint1.Y then
            vLineA.FPoint1.Y := vLineA.FPoint.Y + S * (vArrowSize * 2)
          else
            vLineA.FPoint1.Y := vLineA.FPoint.Y - S * (vArrowSize * 2);
        end;
        if vAngle > (Pi * 15 / 180) then
        begin
          vLineB:= TsgDXFLine.Create;
          AConverter.DoCreate(vLineB);
          vLineB.ColorCAD := cnstColorCADByBlock;
          vLineB.Point := vLineA.Point1;
          vLineB.FPoint1.Z := 0;
          vLineB.FPoint1.Y := vLineB.FPoint.Y;
          vLineB.FPoint1.X := vLineA.FPoint1.X + vKoefSigned * vArrowSize;
          vTextPoint.Y := vLineB.FPoint1.Y;
          vTextPoint.X := vLineB.FPoint1.X + vKoefSigned * vTextOffset;
          if vTextPoint.X < vLineB.Point.X then
            vTextPoint.X := vTextPoint.X - vTextWidth;
          AConverter.Loads(vLineB);
          vLineB.Visibility := vVisible;
          Block.AddEntity(vLineB);
        end
        else
        begin
          vTextPoint := vLineA.Point1;
          vTextPoint.X := vLineA.FPoint1.X + vKoefSigned * vTextOffset;
        end;
      end
      else
      begin
        vLineB:= TsgDXFLine.Create;
        AConverter.DoCreate(vLineB);
        vLineB.ColorCAD := cnstColorCADByBlock;
        vLineB.Point := FMiddlePoint;
        if FMiddlePoint.X < vPoint2.X then
          vKoefSigned := 1
        else
          vKoefSigned := -1;
        vLineB.FPoint.X := vLineB.FPoint.X + vKoefSigned * (vTextOffset + vTextWidth * 0.5);
        vLineB.FPoint1.Y := vLineB.FPoint.Y;
        if vAngle < (Pi * 15 / 180) then
        begin
          vDX := vTextWidth * 0.5;
          vLineA.FPoint1 := FMiddlePoint;
          if (DistanceFPoint(vLineA.FPoint, vLineA.FPoint1) > (vArrowSize + vTextOffset)) then
          begin
            if (vPoint2.X > vPoint1.X) then
              vLineA.FPoint1.X := vLineA.FPoint1.X - vDX
            else
              vLineA.FPoint1.X := vLineA.FPoint1.X + vDX;
          end;
          if vPoint2.Y > vPoint1.Y then
            vLineA.FPoint1.Y := vLineA.FPoint1.Y - S * (vArrowSize + Integer(AMakeLineB) * vArrowSize)
          else
            vLineA.FPoint1.Y := vLineA.FPoint1.Y + S * (vArrowSize + Integer(AMakeLineB) * vArrowSize);
          vLineB.Point := vLineA.Point;
          vLineB.Point1 := vLineA.Point;
          vTextPoint := vLineA.Point1;
          if vLineA.FPoint1.X > vLineA.FPoint.X then
            vTextPoint.X := vLineA.FPoint1.X - vKoefSigned * vArrowSize
          else
            vTextPoint.X := vLineA.FPoint1.X - vKoefSigned * vTextOffset - vDX;
        end
        else
        begin
          vLineB.FPoint1.X := (vLineB.FPoint1.Y - vPoint1.Y) * (vPoint2.X - vPoint1.X) /
              (vPoint2.Y - vPoint1.Y) + vPoint1.X;
          vLineA.Point1 := vLineB.Point1;
          vLineB.FPoint.X := vLineB.FPoint1.X - vKoefSigned * vArrowSize;
          vTextPoint := vLineB.FPoint;//FMiddlePoint;
          if vLineB.FPoint.X > vLineB.FPoint1.X then
            vTextPoint.X := vTextPoint.X + vTextOffset
          else
            vTextPoint.X := vTextPoint.X - (vTextOffset + vTextWidth);
        end;
        AConverter.Loads(vLineB);
        vLineB.Visibility := vVisible;
        Block.AddEntity(vLineB);
      end;
      AConverter.Loads(vLineA);
      vLineA.Visibility := vVisible;
      Block.AddEntity(vLineA);
      vTextPoint.Y := vTextPoint.Y - vTextHeight * 0.5;
    end;

    procedure SetLinesProps;
    begin
      vLines[2].Visibility := not DIMSD1;
      vLines[3].Visibility := not DIMSD2;
      vLines[0].Visibility := not DIMSE1;
      vLines[1].Visibility := not DIMSE2;

      vLines[2].ColorCAD := DIMCLRD;
      vLines[3].ColorCAD := vLines[2].ColorCAD;
      vLines[0].ColorCAD := DIMCLRE;
      vLines[1].ColorCAD := vLines[0].ColorCAD;

      vLines[2].LineWeight := DIMLWD;
      vLines[3].LineWeight := vLines[2].LineWeight;
      vLines[0].LineWeight := DIMLWE;
      vLines[1].LineWeight := vLines[0].LineWeight;
    end;

    procedure MakeArrowPos;
    var
      vLen1, vLen2: Double;

      procedure MakePos(const ATypePosArrow: TsgArrowPos);
      var
        vIndex: Boolean;
      begin
        SetLinesProps;
        case ATypePosArrow of
          arDefault: // <--text-->
            begin
              vIndex := DistanceFPoint(vLines[2].FPoint, vPointCross[0]) < DistanceFPoint(vLines[2].FPoint, vPointCross[1]);
              vLines[2].Point1 := vPointCross[Integer(not vIndex)];
              vLines[3].Point1 := vPointCross[Integer(vIndex)];
            end;
          arTextOut: // <---->--text
            begin
              MakeRemoval(True);
              vLines[2].Point1 := vLines[3].Point;
              vLines[3].Point1 := vLines[2].Point;
            end;
          arArrowOut: // ->text<-
            begin
              vIsShort := True;
              vPoint1 := vLines[2].Point;
              vLines[2].Point := vLines[3].Point;
              vLines[3].Point := vPoint1;
              vLines[2].Point1 := vLines[2].Point;
              vLines[3].Point1 := vLines[3].Point;
            end;
          arArrowAndTextOut:// ->  <---text
            begin
              vIsShort := True;
              vPoint1 := vLines[2].Point;
              vLines[2].Point := vLines[3].Point;
              vLines[3].Point := vPoint1;
              vLines[2].Point1 := vLines[2].Point;
              vLines[3].Point1 := vLines[3].Point;
              if ((X -(vTextLen + 2 * vTextOffset)) < vTextOffset) and (FFlags <> 129) then
                MakeRemoval(False);
            end;
        end;
      end;

      function IsAngleByTypePosArrowMode2(const AAngle: Double): Boolean;
      begin
        Result := ((AAngle >= 60) and (AAngle <= 80)) or ((AAngle >= 100) and (AAngle <= 120)) or
          ((AAngle >= 240) and (AAngle <= 260)) or ((AAngle >= 180) and (AAngle <= 200));
      end;

    begin
      vTypePosArrow := arUndefined;
      vIsShort := False;
      if FFlags >= 128 then
        vTextPoint := FMiddlePoint
      else
        vTextPoint := MakeFPoint((vLines[2].FPoint.X + vLines[3].FPoint.X) / 2, (vLines[2].FPoint.Y + vLines[3].FPoint.Y) / 2, 0);


      vTextPoint.X := vTextPoint.X - vTextWidth * 0.5;
      Y := vLines[3].Point.Y - vLines[2].Point.Y;
      vTextPoint.Y := vTextPoint.Y - vTextHeight * 0.5;
      if FFlags > 127 then
        vTextPoint.Y := vTextPoint.Y + vTextOffset * (1  + 0.4 * Integer(not vDimText.WinFont));

      vTextRot := GetAngleByPoints(vLines[3].FPoint, vLines[2].FPoint, False);
      TextLoaded;
      PointsCrossedTextBox(@vLines[2].FPoint, @vLines[3].FPoint);

      if vCountCrossPoint < 2 then
      begin
         vPointCross[0] := vLines[3].Point;
         vPointCross[1] := vLines[2].Point;
         vTextLen := vTextWidth;//DistanceFP(@vText.FBox.TopLeft, @vText.FBox.BottomRight);
      end
      else
      begin
        vTextLen := DistanceFPoint(vPointCross[0], vPointCross[1]);
        if (Y > 0) and (vNumLine <> 1010)then
          SwapFPoints(vPointCross[0], vPointCross[1])
        else
        begin
          if (FFlags = 0) and (vLines[2].Point.X < vLines[3].Point.X) and (vPointCross[0].X > vPointCross[1].X) then
            SwapFPoints(vPointCross[0], vPointCross[1]);
        end;
      end;
      X := DistanceFPoint(vLines[2].Point, vLines[3].Point);
      if FFlags < 129 then
      begin
        if (X > (vTextLen + 2 * vArrowSize + 2 * 2 * vTextOffset)) then
          vTypePosArrow := arDefault
        else
        begin
          if (X >= (4 * vArrowSize)) then
          begin
             if X > 1  then
               vTypePosArrow := arArrowOut
             else
             begin
               if IsAngleByTypePosArrowMode2(Degree(AngleInterOXandLine(@vLines[2].FPoint, @vLines[3].FPoint))) then
                 vTypePosArrow := arArrowOut
               else
               begin
                 if X > (3 * vArrowSize) then
                   vTypePosArrow := arTextOut
                 else
                   vTypePosArrow := arArrowAndTextOut
                end;
            end;
          end
          else
          begin
            if X > (3 * vArrowSize) then
              vTypePosArrow := arTextOut
            else
              vTypePosArrow := arArrowAndTextOut
          end;
        end;
      end
      else
      begin
        vLen1 := DistanceFPoint(vLines[2].Point, vPointCross[0]);
        vLen2 := DistanceFPoint(vLines[3].Point, vPointCross[1]);
        MinMax;
        if IsPointInBox(@vPointCross[0]) and IsPointInBox(@vPointCross[1]) and (vCountCrossPoint > 1) then
        begin
          if (vLen1 > vArrowSize) and (vLen2 > vArrowSize) then
            vTypePosArrow := arDefault
          else
            vTypePosArrow := arArrowOut;
        end
        else
        begin
          if (vCountCrossPoint > 1) or ((FMiddlePoint.X > vLines[2].Point.X) and (FMiddlePoint.X < vLines[3].Point.X)) or
            ((FMiddlePoint.X < vLines[2].Point.X) and (FMiddlePoint.X > vLines[3].Point.X)) then
            vTypePosArrow := arArrowAndTextOut
          else
          begin
            if X > (3 * vArrowSize) then
              vTypePosArrow := arTextOut
            else
              vTypePosArrow := arArrowAndTextOut;
          end
        end;
      end;
      if (FFlags = 128) and (vTypePosArrow = arDefault) then
      begin
        if ((vTextPoint.X > vLines[2].Point.X) and (vTextPoint.X < vLines[3].Point.X)) or
          ((vTextPoint.X < vLines[2].Point.X) and (vTextPoint.X > vLines[3].Point.X)) then
          vTypePosArrow := arDefault
        else
          vTypePosArrow := arTextOut;
      end;
      MakePos(vTypePosArrow);
    end;

    procedure MakeOffsetByDimensionStyle(AFirst, ALast: Integer; ALine: TsgDXFLine);
    var
      I: Integer;
    begin
      A := DistanceFPoint(ALine.FPoint1, ALine.FPoint);
      if A > fAccuracy then
        vAngle := (ALine.FPoint1.Y - ALine.FPoint.Y) / A
      else
        vAngle := 1;
      vAngle := sgFunction.sgArcSin(vAngle);
      SinCos(vAngle, S, C);
      for I := AFirst to ALast do
      begin
        vLines[I].FPoint.Y := vLines[I].FPoint.Y + S * vExtLineOffset;
        vLines[I].FPoint1.Y := vLines[I].FPoint1.Y + S * vExtLineExt;
        if vLines[I].FPoint.X > vLines[I].FPoint1.X then
        begin
          vLines[I].FPoint.X := vLines[I].FPoint.X - C * vExtLineOffset;
          vLines[I].FPoint1.X := vLines[I].FPoint1.X - C * vExtLineExt;
        end
        else
        begin
          vLines[I].FPoint.X := vLines[I].FPoint.X + C * vExtLineOffset;
          vLines[I].FPoint1.X := vLines[I].FPoint1.X + C * vExtLineExt;
        end;
      end;
    end;

    procedure TranslationLines;
    var
      K, B, DX: Double;
    begin
      DX := vLines[1].FPoint1.X - vLines[0].FPoint1.X;
      if Abs(DX) > fAccuracy then
      begin
        K := (vLines[1].FPoint1.Y - vLines[0].FPoint1.Y) / DX;
        B :=  FMiddlePoint.Y - K * FMiddlePoint.X;
        vLines[0].FPoint1 := PointCrossedPerpendicularLine(K, B, vLines[0].FPoint1);
        vLines[1].FPoint1 := PointCrossedPerpendicularLine(K, B, vLines[1].FPoint1);
      end
      else
      begin
        vLines[0].FPoint1.X := FMiddlePoint.X;
        vLines[1].FPoint1.X := FMiddlePoint.X;
      end;
    end;

    procedure CorrectTextPos;
    var
      I, vMode: Integer;
      vCrossPts: array [0..3] of TFPoint;
      vActLine: TsgLine;
      vTestTextPoint: TFPoint;
      vPt: PFPoint;
      vMx, vMy, vMax: Double;

      procedure InitCrossPts(const AP0, AP1: TFPoint; const ABoxPts: array of TFPoint; var ACrossPts: array of TFPoint);
      var
        I: Integer;
        vDx, K, B, X, Y: Double;
      begin
        for I := 0 to 3 do
        begin
          vDx := AP1.X - AP0.X;
          if Abs(vDx) > fAccuracy then
          begin
            K := (AP1.Y - AP0.Y) / vDx;
            B := AP0.Y - K * AP0.X;
            X := (- B * K + ABoxPts[I].Y * K + ABoxPts[I].X) / (1 + K * K);
            Y := K * X + B;
          end
          else
          begin
            X := AP1.X;
            Y := vTextRect[I].Y;
          end;
          ACrossPts[I] := MakeFPoint(X, Y, 0);
        end;
      end;

      function GetDistance(const AP0, AP1: TFPoint; const ABoxPts: array of TFPoint; var ACrossPts: array of TFPoint): Double;
      var
        I: Integer;
        vD: Double;
      begin
        Result := -MaxDouble;
        InitCrossPts(AP0, AP1, ABoxPts, ACrossPts);
        for I := 0 to 3 do
        begin
          vD := Sqrt(Sqr(ABoxPts[I].X - ACrossPts[I].X) + Sqr(ABoxPts[I].Y - ACrossPts[I].Y));
          if vD > Result then
              Result := vD;
        end;
      end;

      function GetTextPosMode(const AP1, AP2, AP: TFPoint): Integer;
      var
        vDx, vDelta: Double;
      begin
        vDx := AP2.X - AP1.X;
        if Abs(vDx) > fAccuracy then
          vDelta := AP.Y - ((AP.X - AP1.X) * (AP2.Y - AP1.Y) / vDx + AP1.Y)
        else
          vDelta := AP1.X - AP.X;
        if vDelta > fAccuracy then
          Result := 1
        else
          if vDelta < -fAccuracy then
            Result := -1
          else
            Result := 1;
      end;

    begin
      if TextPosVert in [pvCenter, pvJIS] then Exit;
      case vTypePosArrow of
        arDefault, arArrowOut:
          begin
            if IsEqualFPoints(vLines[0].FPoint, vLines[0].FPoint1) then
              if IsEqualFPoints(vLines[1].FPoint, vLines[1].FPoint1) then
                vAngle := GetAngleByPoints(vLines[2].FPoint, vLines[2].FPoint1, True) - Pi * 0.5
              else
                vAngle := GetAngleByPoints(vLines[1].FPoint, vLines[1].FPoint1, True)
            else
              vAngle := GetAngleByPoints(vLines[0].FPoint, vLines[0].FPoint1, True);
            SinCos(vAngle, S, C);
            if IsEqualFPoints(vLines[2].FPoint, vLines[2].FPoint1) then
            begin
              if IsEqualFPoints(vLines[3].FPoint, vLines[3].FPoint1) then
              begin
                vActLine.Point1 := vLines[0].FPoint1;
                vActLine.Point2 := vLines[1].FPoint1;
              end
              else
              begin
                vActLine.Point1 := vLines[3].Point;
                vActLine.Point2 := vLines[3].Point1;
              end;
            end
            else
            begin
              vActLine.Point1 := vLines[2].Point;
              vActLine.Point2 := vLines[2].Point1;
            end;
            case TextPosVert of
              pvAbove:
                begin
                  vDistance := DistanceFPoint(vActLine.Point1, vActLine.Point2);
                  if vDistance <= fAccuracy then
                    vDistance := 1024;
                  vTestTextPoint := AddFPoint(vTextPoint, MakeFPoint(vDistance * C, vDistance * S, 0));
                  vMode := GetTextPosMode(vActLine.Point1, vActLine.Point2, vTestTextPoint);
                end;
            else
              //pvOutSide:  vMode := 1;
              vMode := 1;
            end;
            TextLoaded;
            vDistance := GetDistance(vActLine.Point1, vActLine.Point2, vTextRect, vCrossPts);
            if vDistance > -1 then
            begin
              vTextPoint.X := vTextPoint.X + vMode * vDistance * C;
              vTextPoint.Y := vTextPoint.Y + vMode * vDistance * S;
              if vTypePosArrow = arDefault then
              begin
                vLines[2].FPoint1 := vLines[3].FPoint;
                vLines[3].FPoint1 := vLines[3].FPoint;
              end;
            end;
          end;
        arTextOut, arArrowAndTextOut:
          begin
            if vLineA <> nil then
            begin
              case TextPosVert of
                pvAbove:
                  begin
                    if vLineB <> nil then
                      vMode := -GetTextPosMode(vLineB.Point, vLineB.Point1, vTextPoint)
                    else
                      vMode := -GetTextPosMode(vLineA.Point, vLineA.Point1, vTextPoint);
                  end;
              else
                vMode := GetTextPosMode(vLineA.Point, vLineA.Point1, DefPoint);
              end;
              TextLoaded;
              if vLineB <> nil then
              begin
                vDistance := GetDistance(vLineB.FPoint, vLineB.FPoint1, vTextRect, vCrossPts);
                if (vLineA <> nil) and (vDistance > -1) then
                begin
                  vTextPoint.Y := vTextPoint.Y + vMode * (vDistance + vTextOffset);
                  if IsEqualFPoints(vLineA.FPoint, vLineB.Point) or IsEqualFPoints(vLineA.FPoint1, vLineB.Point) then
                    vPt := @vLineB.FPoint1
                  else
                    vPt := @vLineB.FPoint;
                  if Abs(vPt^.X - vDimText.FBox.Left) > Abs(vPt^.X - vDimText.FBox.Right) then
                    vPt^.X := vDimText.FBox.Left
                  else
                    vPt^.X := vDimText.FBox.Right;
                end;
              end
              else
              begin
                vDistance := GetDistance(vLineA.FPoint, vLineA.FPoint1, vTextRect, vCrossPts);
                if vDistance > -1 then
                begin
                  vTextPoint.Y := vTextPoint.Y + vMode * (vDistance + vTextOffset);
                  TextLoaded;
                  InitCrossPts(vLineA.FPoint, vLineA.FPoint1, vTextRect, vCrossPts);
                  vMx := (vLineA.FPoint.X + vLineA.FPoint1.X) * 0.5;
                  vMy := (vLineA.FPoint.Y + vLineA.FPoint1.Y) * 0.5;
                  vMax := -MaxDouble;
                  vPt := @cnstFPointZero;
                  for I := 0 to 3 do
                  begin
                    vDistance := Sqrt(Sqr(vCrossPts[I].X - vMx) + Sqr(vCrossPts[I].Y - vMy));
                    if vMax < vDistance then
                    begin
                      vPt := @vCrossPts[I];
                      vMax := vDistance;
                    end;
                  end;
                  if DistanceFPoint(vLineA.FPoint, vPt^) < DistanceFPoint(vLineA.FPoint1, vPt^) then
                    vLineA.FPoint := vPt^
                  else
                    vLineA.FPoint1 := vPt^;
                end;
              end;
            end;  
          end;
      end;
    end;

  begin
    vLineA := nil;
    vLineB := nil;
    for I := 0 to 3 do
    begin
      vLines[I] := TsgDXFLine.Create;
      vLines[I].ColorCAD := cnstColorCADByBlock;
      vLines[I].Point := cnstFPointZero;
      vLines[I].Point1 := cnstFPointZero;
      AConverter.DoCreate(vLines[I]);
    end;
    vLines[0].Point := FLinDefPoint2;
    vLines[0].Point1 := FDefPoint;
    vLines[1].Point := FLinDefPoint1;
    C := DistanceFPoint(FDefPoint, FLinDefPoint2);
    if C > fAccuracy then
    begin
      vDistance := DistanceFPoint(vLines[0].Point, vLines[0].Point1);
      vAngle := GetAngleByPoints(vLines[0].Point, vLines[0].Point1, True);
      SinCos(vAngle, S, C);
      vPointA.X := vLines[1].Point.X + C * vDistance;
      vPointA.Y := vLines[1].Point.Y + S * vDistance;
      vPointA.Z := 0;
      vLines[1].FPoint1 := PointCrossedPerpendicularLinesEx(FLinDefPoint1, vPointA, FDefPoint);
      vLines[0].FPoint.X := vLines[0].FPoint.X + C * vExtLineOffset;
      vLines[0].FPoint.Y := vLines[0].FPoint.Y + S * vExtLineOffset;
      vLines[1].FPoint.X := vLines[1].FPoint.X + C * vExtLineOffset;
      vLines[1].FPoint.Y := vLines[1].FPoint.Y + S * vExtLineOffset;
      if (FFlags >= 128) then
      begin
        Y := FDefPoint.Y - FLinDefPoint2.Y;
        if ((Y < 0) and ((FMiddlePoint.X - FDefPoint.X) < 0)) or (Y > 0) then
          TranslationLines;
      end;
      vLines[2].FPoint := vLines[0].FPoint1;
      vLines[3].FPoint := vLines[1].FPoint1;
      vLines[2].FPoint.X := vLines[2].FPoint.X - C * vExtLineExt;
      vLines[2].FPoint.Y := vLines[2].FPoint.Y - S * vExtLineExt;
      vLines[3].FPoint.X := vLines[3].FPoint.X - C * vExtLineExt;
      vLines[3].FPoint.Y := vLines[3].FPoint.Y - S * vExtLineExt;
    end
    else
    begin
      if FFlags = 129 then
      begin
        X := (FLinDefPoint2.X - FLinDefPoint1.X);
        if Abs(X) > fAccuracy then
        begin
          K := (FLinDefPoint2.Y - FLinDefPoint1.Y) / X;
          B := FMiddlePoint.Y - FMiddlePoint.X * K;
          vLines[0].FPoint1 := PointCrossedPerpendicularLine(K, B, FLinDefPoint2);
          vLines[1].FPoint1 := PointCrossedPerpendicularLine(K, B, FLinDefPoint1);
        end
        else
        begin
          vLines[0].FPoint1.Y := FLinDefPoint2.Y;
          vLines[0].FPoint1.X := FMiddlePoint.X;
          vLines[1].FPoint1.Y := FLinDefPoint1.Y;
          vLines[1].FPoint1.X := FMiddlePoint.X;
        end;
        vTextPoint := FMiddlePoint;
        vTextPoint.X := vTextPoint.X - vTextWidth * 0.5;
        vTextPoint.Y := vTextPoint.Y - vTextHeight * 0.5;
        vPointCross[0] := MakeFPoint(vDimText.Box.Left, vDimText.Box.Bottom, 0);
        vPointCross[1] := MakeFPoint(vDimText.Box.Right, vDimText.Box.Bottom, 0);
        if vLines[0].FPoint1.X > vLines[1].FPoint1.X then
        begin
          vMinX := vLines[1].FPoint1.X;
          vMaxX := vLines[0].FPoint1.X;
        end
        else
        begin
          vMinX := vLines[0].FPoint1.X;
          vMaxX := vLines[1].FPoint1.X;
        end;
        if vLines[0].FPoint1.Y > vLines[1].FPoint1.Y then
        begin
          vMinY := vLines[1].FPoint1.Y;
          vMaxY := vLines[0].FPoint1.Y;
        end
        else
        begin
          vMinY := vLines[0].FPoint1.Y;
          vMaxY := vLines[1].FPoint1.Y;
        end;
        if (not IsPointInBox(@FMiddlePoint)) and (IsLineCrossed(@vPointCross[0], @vPointCross[1], @vLines[0].FPoint, @vLines[1].FPoint)) then
        begin
          A := DistanceFPoint(vLines[1].FPoint1, vLines[1].FPoint);
          X := vTextWidth;// - cnstStyleTextOffset;
          if (FMiddlePoint.X < FDefPoint.X) and (FMiddlePoint.Y < FDefPoint.Y) then
            A := fAccuracy;
          if A > fAccuracy then
          begin
            vAngle := (vLines[1].FPoint.Y - vLines[1].FPoint1.Y) / A;
            vAngle := sgFunction.sgArcSin(vAngle);
            if (Abs(vLines[1].FPoint1.X - vLines[1].FPoint.X) > 0.2) then
              Y := Abs(X * Tan(vAngle))
            else
            begin
              X := 0;
              Y := 0;
            end
          end
          else
          begin
            X := 0;
            Y := 0;
          end;
          if vLines[0].FPoint1.X < vLines[1].FPoint1.X then
            vAngle := AngleInterOXandLine(@vLines[0].FPoint1, @vLines[1].FPoint1)
          else
            vAngle := AngleInterOXandLine(@vLines[1].FPoint1, @vLines[0].FPoint1);
          if vAngle > 2 * Pi then
            vAngle := vAngle - 2 * Pi;
          for I := 0 to 1 do
          begin
            if ((vAngle >= Pi/2) and (vAngle <= Pi)) or ((vAngle >= 1.5 * Pi) and (vAngle <= 2 * Pi)) then
            begin
              if (FMiddlePoint.X > FDefPoint.X) and (FMiddlePoint.Y < FDefPoint.Y) then
                vLines[I].FPoint1.X := vLines[I].FPoint1.X - X
              else
                vLines[I].FPoint1.X := vLines[I].FPoint1.X + X;
            end
            else
              vLines[I].FPoint1.X := vLines[I].FPoint1.X - X;

            if FMiddlePoint.Y < FDefPoint.Y then
              vLines[I].FPoint1.Y := vLines[I].FPoint1.Y - Y
            else
              vLines[I].FPoint1.Y := vLines[I].FPoint1.Y + Y;
          end
        end;
        vLines[3].Point := vLines[1].FPoint1;
        vLines[2].Point := vLines[0].FPoint1;
        MakeOffsetByDimensionStyle(0, 1, vLines[1]);
      end
      else
      begin
        vPointClassify := PointClassify(FMiddlePoint, FLinDefPoint1, FLinDefPoint2);
        if (FFlags = 0) and ((vPointClassify = pcLEFT) or (vPointClassify = pcRIGHT)) then
        begin
          if not PointCrossedPerpendicularLines(FDefPoint, FMiddlePoint, FLinDefPoint1, FLinDefPoint2) then
            FLinDefPoint2 := FLinDefPoint1;
          vTextPoint := FMiddlePoint;
          SetTextString(DistanceFPoint(FDefPoint, FLinDefPoint2));
          vDimText.Loaded(AConverter);
          vTextPoint.X := vTextPoint.X - vTextWidth * 0.5;
          vTextPoint.Y := vTextPoint.Y - vTextHeight * 0.5;
          vDimText.Loaded(AConverter);
          vLines[0].Point1 := vLines[0].Point;
          vLines[1].Point := FLinDefPoint1;
          vLines[1].Point1 := FLinDefPoint2;
          MakeOffsetByDimensionStyle(1, 1, vLines[1]);
          vLines[2].Point := FLinDefPoint2;
          vLines[2].Point1 := FDefPoint;
          vLines[3].Point := FDefPoint;
          vLines[3].Point1 := FLinDefPoint2;
        end
        else
        begin
          vLines[1].FPoint1 := vLines[1].FPoint;
          vLines[0].FPoint1 := vLines[0].FPoint;
          vLines[3].Point := vLines[1].FPoint1;
          vLines[2].Point := vLines[0].FPoint1;
        end;
      end;
    end;
    MakeArrowPos;
    if TextPosVert <> pvCenter then
      CorrectTextPos;
    for I := 0 to 3 do
    begin
      AConverter.Loads(vLines[I]);
      Block.AddEntity(vLines[I]);
    end;
    if FFlags = 128 then
      SetTextString(DistanceFPoint(vLines[2].Point, vLines[3].Point));
    TextLoaded;
    Block.AddEntity(vDimText);
  end;

  procedure AddPoint;
  var
    vPoint: TsgDXFPoint;
    vPDMode: Integer;
  begin
    vPDMode := AConverter.HeadVarStruct.PointDisplayMode;
    try
      AConverter.FHeadVarStruct.PointDisplayMode := 0;
      vPoint := TsgDXFPoint.Create;
      AConverter.DoCreate(vPoint);
      vPoint.FPoint.X := FLinDefPoint2.X;
      vPoint.FPoint.Y := FLinDefPoint2.Y;
      vPoint.FPoint.Z := FLinDefPoint2.Z;
      vPoint.ColorCAD := cnstColorCADByBlock;
      vPoint.Layer := AConverter.LayerByName(sLayerDefPoints);
      vPoint.Layer.IsPlotting := False;
      AConverter.Loads(vPoint);
      Block.AddEntity(vPoint);
      vPoint := TsgDXFPoint.Create;
      AConverter.DoCreate(vPoint);
      vPoint.FPoint.X := FLinDefPoint1.X;
      vPoint.FPoint.Y := FLinDefPoint1.Y;
      vPoint.FPoint.Z := FLinDefPoint1.Z;
      vPoint.ColorCAD := cnstColorCADByBlock;
      vPoint.Layer := AConverter.LayerByName(sLayerDefPoints);      
      AConverter.Loads(vPoint);
      Block.AddEntity(vPoint);
    finally
      AConverter.FHeadVarStruct.PointDisplayMode := vPDMode;
    end;
  end;

  procedure AddSolid;
  var
    vInsert: TsgDXFInsert;
    vPoint: array [0..1] of TFPoint;
    vVisible: array [0..1] of Boolean;
    vI1, vI2: Integer;
    vLen, vDX, vDY: Double;
    vRotPt: Boolean;

    procedure SetBlock(const AIns: TsgDXFInsert; const ArrowType: TsgDimArrowType);
    begin
      AIns.Block := AConverter.BlockByName(sgDimensionArrowTypeNames[ArrowType]);
      if AIns.Block = nil then
      begin
        AIns.Block := TsgDXFBlock(AConverter.NewNamedEntity(AConverter.Sections[csBlocks],
          TsgDXFBlock, sgDimensionArrowTypeNames[ArrowType]));
        AIns.Block.IsLoaded := False;
        GenerateArrow(AConverter, AIns.Block, ArrowType);
        AIns.Block.Loaded(AConverter);
      end;
    end;

  begin
    vRotPt := DistanceFPoint(vLines[2].Point, LinDefPoint1) < DistanceFPoint(vLines[3].Point, LinDefPoint1);
    vI1 := Integer(not (vRotPt));
    vI2 := Integer(vRotPt);
    vPoint[vI1] := vLines[2].Point;
    vPoint[vI2] := vLines[3].Point;
    vVisible[vI1] := not DIMSD1;
    vVisible[vI2] := not DIMSD2;
    vDX := vPoint[0].X - vPoint[1].X;
    vDY := vPoint[0].Y - vPoint[1].Y;
    if Abs(vDX) < fAccuracy then
    begin
      vLen := DistanceFPoint(vPoint[0], vPoint[1]);
      if vLen > fAccuracy then
        vAngle := sgFunction.sgArcSin(vDY / vLen)
      else
        vAngle := 0;
    end
    else
      vAngle := ArcTan(vDY / vDX);
    if (vDX < 0) and (not vIsShort) then
      vAngle := vAngle + Pi;
    vAngle := Degree(vAngle);
    vInsert := TsgDXFInsert.Create;
    AConverter.DoCreate(vInsert);
    SetBlock(vInsert, DimArrowType1);
    vInsert.ColorCAD := DIMCLRD;
    vInsert.LineWeight := DIMLWD;
    vInsert.Point := vPoint[0];
    vInsert.Visibility := vVisible[0];
    vInsert.Angle := vAngle;
    vInsert.Scale := MakeFPoint(vArrowSize, vArrowSize, vArrowSize);
    AConverter.Loads(vInsert);
    Block.AddEntity(vInsert);
    vInsert := TsgDXFInsert.Create;
    AConverter.DoCreate(vInsert);
    SetBlock(vInsert, DimArrowType2);
    vInsert.ColorCAD := DIMCLRD;
    vInsert.LineWeight := DIMLWD;
    vInsert.Point := vPoint[1];
    vInsert.Visibility := vVisible[1];
    vInsert.Angle := vAngle + 180;
    vInsert.Scale := MakeFPoint(vArrowSize, vArrowSize, vArrowSize);
    AConverter.Loads(vInsert);
    Block.AddEntity(vInsert);
    if FFlags < 128 then
    begin
      vAngle := vAngle + 180;
      vInsert := TsgDXFInsert.Create;
      AConverter.DoCreate(vInsert);
      vInsert.Block := AConverter.BlockByName(cnstBlockNameLine);
      vInsert.ColorCAD := DIMCLRD;
      vInsert.LineWeight := DIMLWD;
      vInsert.Point := vPoint[0];
      vInsert.Visibility := vVisible[0];
      vInsert.Angle := vAngle;
      vInsert.Scale := MakeFPoint(vExtLineExt, vExtLineExt, vExtLineExt);
      AConverter.Loads(vInsert);
      Block.AddEntity(vInsert);
      vInsert := TsgDXFInsert.Create;
      AConverter.DoCreate(vInsert);
      vInsert.Block := AConverter.BlockByName(cnstBlockNameLine);
      vInsert.ColorCAD := DIMCLRD;
      vInsert.LineWeight := DIMLWD;
      vInsert.Point := vPoint[1];
      vInsert.Visibility := vVisible[1];      
      vInsert.Angle := vAngle;
      vInsert.Scale := MakeFPoint(vExtLineExt, vExtLineExt, vExtLineExt);
      AConverter.Loads(vInsert);
      Block.AddEntity(vInsert);
    end;
  end;

  procedure AddText;
  var
    vTextStyle: TsgDXFStyle;
  begin
    vTextStyle := TextStyle;
    vTextPoint := cnstFPointZero;
    vTextRot := 0;
    vDimText := TsgDXFText.Create;
    vDimText.SetInsideDimension(True);
    AConverter.DoCreate(vDimText);
    //vText.SetStyle(AConverter.StyleByName(sTextStyleStandardName));
    SetTextString(DistanceFPoint(FLinDefPoint1, FLinDefPoint2));
    vDimText.ColorCAD := DIMCLRT;
    vDimText.Height := GetTextHeightReal;
    vDimText.ApplyStyle(vTextStyle);
    TextLoaded;
  end;

  procedure Clear;
  begin
    FDefPoint := cnstFPointZero;
    FLinDefPoint1 := FDefPoint;
    FLinDefPoint2 := FDefPoint;
    FMiddlePoint := FDefPoint;
    FFlags := 255;
  end;

  procedure MakeBlockClosedFilledLine;
  var
    vBlockClosedFilled: TsgDXFBlock;
    vLine: TsgDXFLine;
  begin
    if AConverter.BlockByName(cnstBlockNameLine) = nil then
    begin
      vBlockClosedFilled := TsgDXFBlock.Create;
      vBlockClosedFilled.Name := cnstBlockNameLine;
      vLine := TsgDXFLine.Create;
      vLine.ColorCAD := cnstColorCADByBlock;
      vLine.Point := MakeFPoint(0, -2/6, 0);
      vLine.Point1 := MakeFPoint(0, -1, 0);
      vBlockClosedFilled.AddEntity(vLine);
      AConverter.DoCreate(vBlockClosedFilled.Entities[0]);
      AConverter.Loads(vBlockClosedFilled.Entities[0]);
      AConverter.Sections[csBlocks].AddEntity(vBlockClosedFilled);
      AConverter.Loads(vBlockClosedFilled);
    end;
  end;

  function Error: Boolean;
  begin
    Result := (FMiddlePoint.X = FDefPoint.X) and (FMiddlePoint.Y = FDefPoint.Y);
  end;

begin
  vName := Name;
  if vName = '' then
    vName := GetInternalBlockName(AConverter);
  if (vName <> '') and not Error and ((FFlags in [0, 1, 128, 129]) and IsInternalDimension) then
  begin
    if Block <> nil then
      Block.Clear(True)
    else
    begin
      Block := TsgDXFBlock.Create;
      Block.Name := vName;
      AConverter.Sections[csBlocks].AddEntity(Block);
    end;
    Block.SetFlags(1);

    vTextOffset := Abs(TextOffset);
    vArrowSize := ArrowSize;
    vExtLineOffset := ExtLineOffset;
    vExtLineExt := ExtLineExt;

    MakeBlockClosedFilledLine;
    Block.FOffset := cnstFPointZero;
    Block.ColorCAD := cnstColorCADByLayer;
    AddPoint;
    AddText;
    AddLines;
    AddSolid;
    //Clear;
    AConverter.Loads(Block);
    Point := cnstFPointZero;//Basic parameters of the DIMENSION are set in world coordinates
  end
  else
    ApplyElevation;
end;

procedure TsgDXFDimension.ClearReferences;
begin
  inherited ClearReferences;
  FPropertiesItem.Item := nil;
  Style := nil;
end;

procedure TsgDXFDimension.CopyProperties(const ADim: TsgDXFDimension);
begin
  FPropertiesItem.Item := nil;
  if Assigned(ADim.FPropertiesItem.Item) then
  begin
    FPropertiesItem.Item := TsgDXFDimensionProperties.Create;
    GetProperties.AssignEntity(ADim.FPropertiesItem.Item);
    TsgDXFDimensionProperties(GetProperties).FOwnerStyleItem.Item := FDimStyleItem.Item;
  end;
end;

constructor TsgDXFDimension.Create;
begin
  inherited Create;
  FDimStyleItem := TsgTableItem.Create;
  FPropertiesItem := TsgTableItem.Create;
end;

procedure TsgDXFDimension.CreateBlock(const AConverter: TsgDXFConverter);
begin
  Block := TsgDXFBlock.Create;
  Block.Name := GetInternalBlockName(AConverter);
  AConverter.FBlocksSection.AddEntity(Block);
end;


function TsgDXFDimension.GetArcDefPoint: TFPoint;
begin
  Result := FArcDefPoint;
end;

function TsgDXFDimension.GetArrowSize: TsgFloat;
begin
  Result := ActualDimStyle.ArrowSize;
end;

function TsgDXFDimension.GetArrowType: Byte;
begin
  Result := sgConsts.GetArrowByte(DIMBLKT);
end;

function TsgDXFDimension.GetArrowType1: Byte;
begin
  Result := sgConsts.GetArrowByte(DimArrowType1);
end;

function TsgDXFDimension.GetArrowType2: Byte;
begin
  Result := sgConsts.GetArrowByte(DimArrowType2);
end;

function TsgDXFDimension.GetArrowTypeL: Byte;
begin
  Result := sgConsts.GetArrowByte(DIMLDRBLKT);
end;

function TsgDXFDimension.GetDefPoint: TFPoint;
begin
  Result := FDefPoint;
end;

function TsgDXFDimension.GetDimStyleInternal: Pointer;
begin
  Result := Style;
end;

function TsgDXFDimension.GetElevation: Double;
begin
  Result := FMiddlePoint.Z;
end;

function TsgDXFDimension.GetEntText: TsgDXFEntity;
var
  I: Integer;
  vEntity: TsgDXFEntity;
begin
  Result := nil;
  if Assigned(Block) then
  begin
    for I := 0 to Block.Count - 1 do
    begin
      vEntity := Block.Entities[I];
      if Assigned(vEntity) and (vEntity.EntType in [ceText, ceMText]) then
      begin
        Result := vEntity;
        Break;
      end;
    end;
  end;
end;

function TsgDXFDimension.GetTextStyleInternal: Pointer;
begin
  Result := TextStyle;//Style.TextStyle
end;

procedure TsgDXFDimension.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlArrowType));
      AHideList.Add(Integer(xmlLineWeight));
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
      AHideList.Add(Integer(xmlDimTix));
    end;
    if Assigned(Properties) then
      Properties.GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  end;
end;

function TsgDXFDimension.GetDimArrowType1: TsgDimArrowType;
begin
  Result := ActualDimStyle.DimArrowType1;
//  GetDimArrowTypeByDimSah(DIMSAH, PropertyInit[vnDIMBLK],
//    PropertyInit[vnDIMBLK1], DIMBLKT, DIMBLK1T, FDimStyleItem.DimArrowType1);
end;

function TsgDXFDimension.GetDimArrowType2: TsgDimArrowType;
begin
  Result := ActualDimStyle.DimArrowType2;
//  Result := GetDimArrowTypeByDimSah(DIMSAH, ActualDimStyle.PropertyInit[vnDIMBLK],
//    ActualDimStyle.PropertyInit[vnDIMBLK2], DIMBLKT, DIMBLK2T, FDimStyleItem.DimArrowType2);
end;

function TsgDXFDimension.GetDIMBLK: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMBLK;
end;

function TsgDXFDimension.GetDIMBLK1: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMBLK1;
end;

function TsgDXFDimension.GetDIMBLK1T: TsgDimArrowType;
begin
  Result := ActualDimStyle.DIMBLK1T;
end;

function TsgDXFDimension.GetDIMBLK2: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMBLK2;
end;

function TsgDXFDimension.GetDIMBLK2T: TsgDimArrowType;
begin
  Result := ActualDimStyle.DIMBLK2T;
end;

function TsgDXFDimension.GetDIMBLKT: TsgDimArrowType;
begin
  Result := ActualDimStyle.DIMBLKT;
end;

function TsgDXFDimension.GetDimBlockName(const AConv: TsgDXFConverter;
  const APrefix: string): string;
var
  vDimBlock: TsgDXFBlock;
begin
  repeat
    Result := cnstInternalBlockPrefix + APrefix + IntToStr(AConv.FAddedDimensionsCount);
    Inc(AConv.FAddedDimensionsCount);
    vDimBlock := AConv.BlockByName(Result);
  until vDimBlock = nil;
end;

function TsgDXFDimension.GetDIMCLRD: TsgColorCAD;
begin
  Result :=ActualDimStyle.DIMCLRD;
end;

function TsgDXFDimension.GetDIMCLRE: TsgColorCAD;
begin
  Result := ActualDimStyle.DIMCLRE;
end;

function TsgDXFDimension.GetDIMCLRT: TsgColorCAD;
begin
  Result := ActualDimStyle.DIMCLRT;
end;

function TsgDXFDimension.GetDimType: TsgDimensionType;
begin
  Result := GetDimensionType(FFlags);
end;

function TsgDXFDimension.GetDIMLDRBLK: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMLDRBLK;
end;

function TsgDXFDimension.GetDIMLDRBLKT: TsgDimArrowType;
begin
  Result := ActualDimStyle.DIMLDRBLKT;
end;

function TsgDXFDimension.GetDIMLWD: TsgFloat;
begin
  Result := ActualDimStyle.DIMLWD;
end;

function TsgDXFDimension.GetDIMLWE: TsgFloat;
begin
  Result := ActualDimStyle.DIMLWE;
end;

function TsgDXFDimension.GetDIMSAH: Boolean;
begin
  Result := ActualDimStyle.DIMSAH;
end;

function TsgDXFDimension.GetDIMSD1: Boolean;
begin
  Result := ActualDimStyle.DIMSD1;
end;

function TsgDXFDimension.GetDIMSD2: Boolean;
begin
  Result := ActualDimStyle.DIMSD2;
end;

function TsgDXFDimension.GetDIMSE1: Boolean;
begin
  Result := ActualDimStyle.DIMSE1;
end;

function TsgDXFDimension.GetDIMSE2: Boolean;
begin
  Result := ActualDimStyle.DIMSE2;
end;

function TsgDXFDimension.GetDIMTIH: Boolean;
begin
  Result := ActualDimStyle.DIMTIH;
end;

function TsgDXFDimension.GetDIMTOH: Boolean;
begin
  Result := ActualDimStyle.DIMTOH;
end;

function TsgDXFDimension.GetDIMDSEP: Char;
begin
  Result := ActualDimStyle.DIMDSEP;
end;

function TsgDXFDimension.GetDIMLUNIT: TsgDimLimitUnits;
begin
  Result := ActualDimStyle.DIMLUNIT;
end;

function TsgDXFDimension.GetStyle: TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(FDimStyleItem.Item);
end;

function TsgDXFDimension.GetEntType: TsgCADEntities;
begin
  Result := ceDimension;
end;

function TsgDXFDimension.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  if (FPropertiesItem.Item is TsgDXFDimensionProperties) and BeginExtData(AData, AAppID) then
  begin
    FPropertiesItem.Item.GetExtData(AData, AAppID);
    EndExtData(AData);
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

procedure TsgDXFDimension.SetElevation(const Value: Double);
begin
  FMiddlePoint.Z := Value;
end;

procedure TsgDXFDimension.SetExtData(const AData: TsgCADExtendedData);
var
  vProperties: TsgDXFDimensionStyle;
begin
  inherited SetExtData(AData);
  if IsEqualExtDataName(AData, sACADXDataAppName) then
  begin
    vProperties := GetActualDimStyle;
    if Assigned(vProperties) then
      vProperties.SetExtData(AData);
  end;
end;

function TsgDXFDimension.GetExtLineExt: TsgFloat;
begin
  Result := ActualDimStyle.ExtLineExt;
end;

function TsgDXFDimension.GetExtLineOffset: TsgFloat;
begin
  Result := ActualDimStyle.ExtLineOffset;
end;

function TsgDXFDimension.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgDXFDimension.GetForceText: Integer;
begin
  Result := ActualDimStyle.DIMTIX;
end;

function TsgDXFDimension.GetInternalBlockName(const AConverter: TsgDXFConverter): string;
begin
  Result := GetDimBlockName(AConverter, sInternalDimension);
end;

function TsgDXFDimension.GetLinDefPoint1: TFPoint;
begin
  Result := FLinDefPoint1;
end;

function TsgDXFDimension.GetLinDefPoint2: TFPoint;
begin
  Result := FLinDefPoint2;
end;

function TsgDXFDimension.GetMeasurementsScale: Double;
begin
  Result := ActualDimStyle.DIMLFAC;
end;

function TsgDXFDimension.GetTextAlign: Integer;
begin
  Result := ActualDimStyle.TextAlign;
end;

function TsgDXFDimension.GetTextFromBlock: string;
var
  I: Integer;
  vEnt: TsgDXFEntity;
begin
  Result := '';
  if Assigned(Block) then
    for I := 0 to Block.Count - 1 do
    begin
      vEnt := Block[I];
      case vEnt.EntType of
        ceText:
          begin
            Result := TsgDXFText(vEnt).Text;
            Break;
          end;
        ceMText:
          begin
            Result := TsgDXFMText(vEnt).Text;
            Break;
          end;
      end;
    end;
end;

function TsgDXFDimension.GetTextHeight: TsgFloat;
begin
  Result := ActualDimStyle.TextHeight;
end;

function TsgDXFDimension.GetTextHeightReal: TsgFloat;
begin
  ActualDimStyle.GetTextHeightReal(Result);
end;

function TsgDXFDimension.GetTextOffset: TsgFloat;
begin
  Result := ActualDimStyle.TextOffset;
end;

function TsgDXFDimension.GetTextOverride: string;
begin
  Result := FTextOverride;
end;

function TsgDXFDimension.GetTextPosVert: TsgDimTextPosVert;
begin
  Result := ActualDimStyle.TextPosVert;
end;

function TsgDXFDimension.GetTextRotation: Double;
begin
  Result := FTextRotation;
end;

function TsgDXFDimension.GetTextStyle: TsgDXFStyle;
begin
  Result := ActualDimStyle.TextStyle;
end;

function TsgDXFDimension.GetBlockOffset: TFPoint;
begin
  Result := cnstFPointZero;
end;

procedure TsgDXFDimension.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
  if Assigned(FPropertiesItem.Item) then
    FPropertiesItem.Item.Link(AConverter);
end;

procedure TsgDXFDimension.LoadedInternal(AConverter: TsgDXFConverter);
var
  I: Integer;
  vUpdateBlock: Boolean;
  vEntity: TsgDXFEntity;
  vText: TsgDXFText;
  vBlock: TsgDXFBlock;
(*// For future versions
  vMText: TsgDXFMText; *)
begin
  if Style = nil then
    Style := AConverter.DimensionStyleByName(sStandardName);
  if not (AConverter.FStatus = stLoading) {and IsInternalDimension} then
    GenerateBlock(AConverter) // Creation of the empty dimension block
  else
  begin
    vBlock := Block;
    if vBlock <> nil then
    begin
      vUpdateBlock := False;
      for I := 0 to vBlock.Count - 1 do
      begin
        vEntity := vBlock.Entities[I];
        case vEntity.EntType of
          ceText:
            begin
              vText := TsgDXFText(vEntity);
              if not vText.GetInsideDimension then
              begin
                vText.SetInsideDimension(True);
                if vText.Backward or vText.UpsideDown then
                begin
                  vUpdateBlock := True;
                  vEntity.Loaded(AConverter);
                end;
              end;
            end;
        end;
      end;
      if vUpdateBlock then
        vBlock.Loaded(AConverter);
    end;
    ApplyElevation;
  end;
  (*// For future versions
  else
    if (FBlock <> nil) and (FTextOverride <> '') then
    begin
      vMText := nil;
      for I := 0 to FBlock.Count-1 do
        if FBlock.Entities[I].EntType=ceMText then
        begin
          vMText := TsgDXFMText(FBlock.Entities[I]);
          Break;
        end;
      if vMText = nil then
      begin
        vMText := TsgDXFMText.Create;
        if Assigned(AConverter.OnCreate) then
          AConverter.OnCreate(vMText);
        FBlock.FLoaded := False;
        Block.AddEntity(vMText);
      end;
      if (FTextOverride <> vMText.Text) and (AnsiPos('<>', FTextOverride)=0) then
      begin
        vMText.Point := FMiddlePoint;
        vMText.Height := TextHeight;
        vMText.Text := FTextOverride;
        vMText.Loaded(AConverter);
        FBlock.Loaded(AConverter);
      end;
    end; *)
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFDimension.ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord);

  function _IsInternalDimensionBlockRecord(ABlockRecord: TsgDXFBlockRecord): Boolean;
  begin
    if ABlockRecord <> nil then
      Result := AnsiPos(sInternalDimension, ABlockRecord.Name) <> 0
    else
      Result := True;
  end;

begin
  if not _IsInternalDimensionBlockRecord(ABlockRecord) then
    inherited ReferenceBlockRecord(ABlockRecord);
end;

procedure TsgDXFDimension.SetArcDefPoint(const Value: TFPoint);
begin
  FArcDefPoint := Value;
end;

procedure TsgDXFDimension.SetArrowSize(const Value: TsgFloat);
begin
  if Value >= 0 then
    ActualDimStyle.ArrowSize := Value;
end;

procedure TsgDXFDimension.SetArrowType(const Value: Byte);
begin
  DIMBLKT := sgConsts.GetArrowType(Value);
end;

procedure TsgDXFDimension.SetArrowType1(const Value: Byte);
begin
  DimArrowType1 := sgConsts.GetArrowType(Value);
end;

procedure TsgDXFDimension.SetArrowType2(const Value: Byte);
begin
  DimArrowType2 := sgConsts.GetArrowType(Value);
end;

procedure TsgDXFDimension.SetArrowTypeL(const Value: Byte);
begin
  DIMLDRBLKT := sgConsts.GetArrowType(Value);
end;

procedure TsgDXFDimension.SetConverter(const AConverter: TsgDXFConverter);
begin
  inherited SetConverter(AConverter);
  if Assigned(FPropertiesItem.Item) then
    FPropertiesItem.Item.SetConverter(AConverter);
end;

procedure TsgDXFDimension.SetDefPoint(const Value: TFPoint);
begin
  FDefPoint := Value;
end;

procedure TsgDXFDimension.SetDimArrowType1(const Value: TsgDimArrowType);
begin
  if not DIMSAH then
    DIMBLK2T := DIMBLKT;
  DIMSAH := True;
  DIMBLK1T := Value;
  if DIMBLK1T = datClosedfilled then
    DIMBLKT := datClosedfilled;
end;

procedure TsgDXFDimension.SetDimArrowType2(const Value: TsgDimArrowType);
begin
  if not DIMSAH then
    DIMBLK1T := DIMBLKT;
  DIMSAH := True;
  DIMBLK2T := Value;
  if DIMBLK2T = datClosedfilled then
    DIMBLKT := datClosedfilled;
end;

procedure TsgDXFDimension.SetDIMBLK(const Value: TsgDXFBlock);
begin
  ActualDimStyle.DIMBLK := Value;
end;

procedure TsgDXFDimension.SetDIMBLK1(const Value: TsgDXFBlock);
begin
  ActualDimStyle.DIMBLK1 := Value;
end;

procedure TsgDXFDimension.SetDIMBLK1T(const Value: TsgDimArrowType);
begin
  ActualDimStyle.DIMBLK1T := Value;
end;

procedure TsgDXFDimension.SetDIMBLK2(const Value: TsgDXFBlock);
begin
  ActualDimStyle.DIMBLK2 := Value;
end;

procedure TsgDXFDimension.SetDIMBLK2T(const Value: TsgDimArrowType);
begin
  ActualDimStyle.DIMBLK2T := Value;
end;

procedure TsgDXFDimension.SetDIMBLKT(const Value: TsgDimArrowType);
begin
  ActualDimStyle.DIMBLKT := Value;
end;

procedure TsgDXFDimension.SetDIMCLRD(const Value: TsgColorCAD);
begin
  ActualDimStyle.DIMCLRD := Value;
end;

procedure TsgDXFDimension.SetDIMCLRE(const Value: TsgColorCAD);
begin
  ActualDimStyle.DIMCLRE := Value;
end;

procedure TsgDXFDimension.SetDIMCLRT(const Value: TsgColorCAD);
begin
  ActualDimStyle.DIMCLRT := Value;
end;

procedure TsgDXFDimension.SetDIMLDRBLK(const Value: TsgDXFBlock);
begin
  ActualDimStyle.DIMLDRBLK := Value;
end;

procedure TsgDXFDimension.SetDIMLDRBLKT(const Value: TsgDimArrowType);
begin
  ActualDimStyle.DIMLDRBLKT := Value;
end;

procedure TsgDXFDimension.SetDIMLWD(const Value: TsgFloat);
begin
  ActualDimStyle.DIMLWD := Value;
end;

procedure TsgDXFDimension.SetDIMLWE(const Value: TsgFloat);
begin
  ActualDimStyle.DIMLWE := Value;
end;

procedure TsgDXFDimension.SetDIMSAH(const Value: Boolean);
begin
  ActualDimStyle.DIMSAH := Value;
end;

procedure TsgDXFDimension.SetDIMSD1(const Value: Boolean);
begin
  ActualDimStyle.DIMSD1 := Value;
end;

procedure TsgDXFDimension.SetDIMSD2(const Value: Boolean);
begin
  ActualDimStyle.DIMSD2 := Value;
end;

procedure TsgDXFDimension.SetDIMSE1(const Value: Boolean);
begin
  ActualDimStyle.DIMSE1 := Value;
end;

procedure TsgDXFDimension.SetDIMSE2(const Value: Boolean);
begin
  ActualDimStyle.DIMSE2 := Value;
end;

procedure TsgDXFDimension.SetDIMTIH(const Value: Boolean);
begin
  ActualDimStyle.DIMTIH := Value;
end;

procedure TsgDXFDimension.SetDIMTOH(const Value: Boolean);
begin
  ActualDimStyle.DIMTOH := Value;
end;

procedure TsgDXFDimension.SetDIMDSEP(const Value: Char);
begin
  ActualDimStyle.DIMDSEP := Value;
end;

procedure TsgDXFDimension.SetDIMLUNIT(const Value: TsgDimLimitUnits);
begin
  ActualDimStyle.DIMLUNIT := Value;
end;

procedure TsgDXFDimension.SetExtLineExt(const Value: TsgFloat);
begin
  ActualDimStyle.ExtLineExt := Value;
end;

procedure TsgDXFDimension.SetExtLineOffset(const Value: TsgFloat);
begin
  ActualDimStyle.ExtLineOffset := Value;
end;

procedure TsgDXFDimension.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

procedure TsgDXFDimension.SetForceText(const Value: Integer);
begin
  ActualDimStyle.DIMTIX := Value;
end;

procedure TsgDXFDimension.SetLinDefPoint1(const Value: TFPoint);
begin
  FLinDefPoint1 := Value;
end;

procedure TsgDXFDimension.SetLinDefPoint2(const Value: TFPoint);
begin
  FLinDefPoint2 := Value;
end;

procedure TsgDXFDimension.SetMeasurementsScale(const Value: Double);
begin
  ActualDimStyle.DIMLFAC := Value;
end;

procedure TsgDXFDimension.SetPrecision(const Value: Integer);
begin
  ActualDimStyle.DIMDEC := Value;
end;

procedure TsgDXFDimension.SetRadDefPoint(const Value: TFPoint);
begin
  FRadDefPoint := Value;
end;

procedure TsgDXFDimension.SetStyle(ADimStyle: TsgDXFDimensionStyle);
begin
  SetStyleInternal(ADimStyle);
  if GetProperties <> nil then
    GetProperties.SetOwnerStyle(TsgDXFDimensionStyle(FDimStyleItem.Item));
end;

procedure TsgDXFDimension.SetStyleInternal(const AValue: TsgDXFDimensionStyle);
begin
  FDimStyleItem.Item := AValue;
end;

procedure TsgDXFDimension.SetTextAlign(const Value: Integer);
begin
  ActualDimStyle.TextAlign := Value;
end;

procedure TsgDXFDimension.SetTextHeight(const Value: TsgFloat);
begin
  ActualDimStyle.TextHeight := Value;
end;

procedure TsgDXFDimension.SetTextOffset(const Value: TsgFloat);
begin
  ActualDimStyle.TextOffset := Value;
end;

procedure TsgDXFDimension.SetTextOverride(const Value: string);
begin
  FTextOverride := Value;
end;

procedure TsgDXFDimension.SetTextPosVert(const Value: TsgDimTextPosVert);
begin
  ActualDimStyle.TextPosVert := Value;
end;

procedure TsgDXFDimension.SetTextRotation(const Value: Double);
begin
  FTextRotation := Value;
end;

procedure TsgDXFDimension.SetTextStyle(const Value: TsgDXFStyle);
begin
  ActualDimStyle.TextStyle := Value;
end;

function TsgDXFDimension.ToXMLGeoData(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLGeoData(ANode, AParams);
end;

function TsgDXFDimension.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;

begin
  Result := inherited ToXMLNode(ANode, AParams);

  ANode.RemoveAttributeByName(cnstXMLNames[xmlPoint].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlAngle].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlFPointScale].Name);

  if IsXMLHelp(AParams.Mode) then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlDimStyle].Name);
    ANode.AddChildNV(cnstXMLNames[xmlProperties].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlDefPoint].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlLinDefPoint1].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlLinDefPoint2].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlMiddlePoint].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlArcDefPoint].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlRadDefPoint].Name);
  end
  else
  begin
    if Assigned(Style) then
      ANode.AddAttribNV(cnstXMLNames[xmlDimStyle].Name).ValueAsStr := Style.Name;
    if Assigned(Properties) then
      Properties.ToXMLAsProperties(ANode.AddChildNV(cnstXMLNames[xmlProperties].Name), AParams);
    //change in future version - export by dimtype
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlDefPoint].Name).ValueData,
      DefPoint, xmlForViewing in AParams.Mode);
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlLinDefPoint1].Name).ValueData,
      LinDefPoint1, xmlForViewing in AParams.Mode);
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlLinDefPoint2].Name).ValueData,
      LinDefPoint2, xmlForViewing in AParams.Mode);
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlMiddlePoint].Name).ValueData,
      MiddlePoint, xmlForViewing in AParams.Mode);
    if not (DimType in [dmtRotHorVert, dmtAligned, dmtOrdinate]) then
    begin
      SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlArcDefPoint].Name).ValueData,
        ArcDefPoint, xmlForViewing in AParams.Mode);
      SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlRadDefPoint].Name).ValueData,
        RadDefPoint, xmlForViewing in AParams.Mode);
    end;
  end;
  ANode.AddAttribNV(cnstXMLNames[xmlArrowType].Name).ValueAsInt := ArrowType;
  if Length(TextOverride) > 0 then
    ANode.AddAttribNV(cnstXMLNames[xmlTextOverride].Name).ValueAsStr := TextOverride;
  if TextRotation <> 0 then
    ANode.AddAttribNV(cnstXMLNames[xmlTextRotation].Name).ValueAsDouble := TextRotation;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlArrowSize].Name).ValueData,
    ArrowSize, xmlForViewing in AParams.Mode);
  if (xmAddSubEntities in AParams.Mode) and Assigned(Block) then
    Block.ToXMLSubEntities(ANode, AParams);
end;

function TsgDXFDimension.UseTextStyleFixedHeight: Boolean;
var
  vHeight: Double;
begin
  Result := not ActualDimStyle.GetTextHeightReal(vHeight);
end;

function TsgDXFDimension.IsInternalDimension: Boolean;
begin
  if BlockRecord <> nil then
    Result := HasInternalDimensionBlockName(BlockRecord.Name)
  else
    Result := True;
end;

{ TsgDXFDimensionStyle }

procedure TsgDXFDimensionStyle.ClearReferences;
var
  I: TsgDimNameVal;
begin
  inherited ClearReferences;
  FTextStyleItem.Item := nil;
  for I := Low(FBlks) to High(FBlks) do
    SetBlocksInternal(I, nil);
end;

constructor TsgDXFDimensionStyle.Create;
begin
  inherited Create;
  FTextStyleItem := TsgTableItem.Create;
  Name := sStandardName;
  InitProps(nil);
end;

destructor TsgDXFDimensionStyle.Destroy;
begin
  NotifyDestroing;
  inherited Destroy;
end;

function TsgDXFDimensionStyle.GetASZ: TsgFloat;
begin
  Result := GetActualStyle(vnDIMASZ).FDimProps.Asz;
end;

function TsgDXFDimensionStyle.GetArrowTypeByBlock(const ABlock: TsgDXFBlock): TsgDimArrowType;
begin
  Result := datClosedfilled;
  if Assigned(ABlock) then
    Result := GetArrowTypeByName(ABlock.Name, datUserarrow);
end;

function TsgDXFDimensionStyle.GetArrowType: Byte;
begin
  Result := sgConsts.GetArrowByte(GetDIMBLKT);
end;

function TsgDXFDimensionStyle.GetArrowType1: Byte;
begin
  Result := sgConsts.GetArrowByte(GetDIMBLK1T);
end;

function TsgDXFDimensionStyle.GetArrowType2: Byte;
begin
  Result := sgConsts.GetArrowByte(GetDIMBLK2T);
end;

function TsgDXFDimensionStyle.GetArrowTypeL: Byte;
begin
  Result := sgConsts.GetArrowByte(GetDIMLDRBLKT);
end;

function TsgDXFDimensionStyle.GetBlocks(const AType: TsgDimNameVal): TsgDXFBlock;
begin
  Result := GetActualStyle(AType).FBlks[AType];
end;

function TsgDXFDimensionStyle.GetCLRD: TsgColorCAD;
begin
  Result := GetActualStyle(vnDIMCLRD).FDimProps.ClrD;
end;

function TsgDXFDimensionStyle.GetCLRE: TsgColorCAD;
begin
  Result := GetActualStyle(vnDIMCLRE).FDimProps.ClrE;
end;

function TsgDXFDimensionStyle.GetCLRT: TsgColorCAD;
begin
  Result := GetActualStyle(vnDIMCLRT).FDimProps.ClrT;
end;

function TsgDXFDimensionStyle.GetDEC: Integer;
begin
  Result := GetActualStyle(vnDIMDEC).FDimProps.Dec;
end;

function TsgDXFDimensionStyle.GetDimArrowType1: TsgDimArrowType;
begin
  Result := GetDimArrowTypeByDimSah(DIMSAH, DIMBLKT, DIMBLK1T);
end;

function TsgDXFDimensionStyle.GetDimArrowType2: TsgDimArrowType;
begin
  Result := GetDimArrowTypeByDimSah(DIMSAH, DIMBLKT, DIMBLK2T);
end;

function TsgDXFDimensionStyle.GetDIMBLKT: TsgDimArrowType;
begin
  Result := FDimProps.Arrows.Blks[vnDIMBLK];
  if Result = datUndefined then
    Result := datClosedfilled;
end;

function TsgDXFDimensionStyle.GetDIMBLK1T: TsgDimArrowType;
begin
  Result := FDimProps.Arrows.Blks[vnDIMBLK1];
  if Result = datUndefined then
    Result := GetDIMBLKT;
end;

function TsgDXFDimensionStyle.GetDIMBLK2T: TsgDimArrowType;
begin
  Result := FDimProps.Arrows.Blks[vnDIMBLK2];
  if Result = datUndefined then
    Result := GetDIMBLKT;
end;

function TsgDXFDimensionStyle.GetDIMLDRBLKT: TsgDimArrowType;
begin
  Result := FDimProps.Arrows.Blks[vnDIMLRBLK];
  if Result = datUndefined then
    Result := GetDIMBLKT;
end;

function TsgDXFDimensionStyle.GetDIMBLK: TsgDXFBlock;
begin
  Result := FBlks[vnDIMBLK];
end;

function TsgDXFDimensionStyle.GetDIMBLK1: TsgDXFBlock;
begin
  Result := GetActualStyle(vnDIMBLK1).FBlks[vnDIMBLK1];
  if not Assigned(Result) then
    Result := DIMBLK;
end;

function TsgDXFDimensionStyle.GetDIMBLK2: TsgDXFBlock;
begin
  Result := GetActualStyle(vnDIMBLK2).FBlks[vnDIMBLK2];
  if not Assigned(Result) then
    Result := DIMBLK;
end;

function TsgDXFDimensionStyle.GetDIMLDRBLK: TsgDXFBlock;
begin
  Result := GetActualStyle(vnDIMLRBLK).FBlks[vnDIMLRBLK];
  if not Assigned(Result) then
    Result := DIMBLK;
end;

function TsgDXFDimensionStyle.GetDIMSAH: Boolean;
begin
  Result := GetActualStyle(vnDIMSAH).FDimProps.Sah;
end;

function TsgDXFDimensionStyle.GetDIMSD1: Boolean;
begin
  Result := GetActualStyle(vnDIMSD1).FDimProps.SD1;
end;

function TsgDXFDimensionStyle.GetDIMSD2: Boolean;
begin
  Result := GetActualStyle(vnDIMSD2).FDimProps.SD2;
end;

function TsgDXFDimensionStyle.GetDIMSE1: Boolean;
begin
  Result := GetActualStyle(vnDIMSE1).FDimProps.SE1;
end;

function TsgDXFDimensionStyle.GetDIMSE2: Boolean;
begin
  Result := GetActualStyle(vnDIMSE2).FDimProps.SE2;
end;

function TsgDXFDimensionStyle.GetDIMTIH: Boolean;
begin
  Result := GetActualStyle(vnDIMTIH).FDimProps.Tih;
end;

function TsgDXFDimensionStyle.GetDIMTOH: Boolean;
begin
  Result := GetActualStyle(vnDIMTOH).FDimProps.Toh;
end;

function TsgDXFDimensionStyle.GetDIMPOST: string;
begin
  Result := GetActualStyle(vnDIMPOST).FDimProps.Post;
end;

function TsgDXFDimensionStyle.GetDIMTP: Double;
begin
  Result := GetActualStyle(vnDIMTP).FDimProps.Tp;
end;

function TsgDXFDimensionStyle.GetDIMTM: Double;
begin
  Result := GetActualStyle(vnDIMTM).FDimProps.Tm;
end;

function TsgDXFDimensionStyle.GetEXE: TsgFloat;
begin
  Result := GetActualStyle(vnDIMEXE).FDimProps.Exe;
end;

function TsgDXFDimensionStyle.GetEXO: TsgFloat;
begin
  Result := GetActualStyle(vnDIMEXO).FDimProps.Exo
end;

function TsgDXFDimensionStyle.GetLFAC: Double;
begin
  Result := GetActualStyle(vnDIMLFAC).FDimProps.LFac;
end;

function TsgDXFDimensionStyle.GetLWD: TsgFloat;
begin
  Result := GetActualStyle(vnDIMLWD).FDimProps.LwD;
end;

function TsgDXFDimensionStyle.GetLWE: TsgFloat;
begin
  Result := GetActualStyle(vnDIMLWE).FDimProps.LwE;
end;

function TsgDXFDimensionStyle.GetOwnerStyle: TsgDXFDimensionStyle;
begin
  Result := nil;
end;

function TsgDXFDimensionStyle.GetOwnerStyleInternal: TsgDXFDimensionStyle;
begin
  Result := nil;
end;

function TsgDXFDimensionStyle.GetPropertiesInit: TsgDimNameVals;
begin
  Result := [];
end;

function TsgDXFDimensionStyle.GetActualStyle(const ANameValue: TsgDimNameVal;
  const ASetValue: Boolean = False): TsgDXFDimensionStyle;
begin
  Result := Self;
end;

function TsgDXFDimensionStyle.GetScale: Double;
begin
  Result := GetActualStyle(vnDIMSCALE).FDimProps.Scale;
end;

function TsgDXFDimensionStyle.GetCEN: TsgFloat;
begin
  Result := GetActualStyle(vnDIMCEN).FDimProps.Cen;
end;

function TsgDXFDimensionStyle.GetTextAlign: Integer;
begin
  if DIMTIH then
    Result := 0//gorizontal - default
  else
  begin
    if DIMTOH then
      Result := 2//ISO
    else
      Result := 1;//align
  end;
end;

// false - lock value
function TsgDXFDimensionStyle.GetTextHeightReal(var AHeight: Double): Boolean;
begin
  if Assigned(TextStyle) then
    AHeight := TextStyle.FixedHeight
  else
    AHeight := 0;
  Result := AHeight = 0;
  if Result then
    AHeight := TextHeight;
end;

function TsgDXFDimensionStyle.GetTXT: TsgFloat;
begin
  Result := GetActualStyle(vnDIMTXT).FDimProps.Txt;
end;

function TsgDXFDimensionStyle.GetGAP: TsgFloat;
begin
  Result := GetActualStyle(vnDIMGAP).FDimProps.Gap;
end;

function TsgDXFDimensionStyle.GetTAD: TsgDimTextPosVert;
begin
  Result := TsgDimTextPosVert(GetActualStyle(vnDIMTAD).FDimProps.Tad);
end;

function TsgDXFDimensionStyle.GetTXSTY: TsgDXFStyle;
begin
  Result := TsgDXFStyle(GetActualStyle(vnDIMTXSTY).FTextStyleItem.Item);
end;

function TsgDXFDimensionStyle.GetTIX: Integer;
begin
  Result := GetActualStyle(vnDIMTIX).FDimProps.Tix;
end;

function TsgDXFDimensionStyle.GetDIMDSEP: Char;
begin
  Result := GetActualStyle(vnDIMDSEP).FDimProps.DSep;
end;

function TsgDXFDimensionStyle.GetDIMLUNIT: TsgDimLimitUnits;
begin
  Result := GetActualStyle(vnDIMLUNIT).FDimProps.LUnit;
end;

function TsgDXFDimensionStyle.GetFRAC: Integer;
begin
  Result := GetActualStyle(vnDIMFRAC).FDimProps.Frac;
end;

procedure TsgDXFDimensionStyle.InitProps(AHeader: PsgHeadVarStruct);
begin
  if AHeader = nil then
    AHeader := @cnstDefHeadVarStruct;
  FDimProps := AHeader^.DimProps;
  FTextStyleItem.Item := nil;
end;

procedure TsgDXFDimensionStyle.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFDimensionStyle.LoadedInternal(AConverter: TsgDXFConverter);
var
  I: TsgDimNameVal;
begin
  inherited LoadedInternal(AConverter);
  if Assigned(Converter) then
  begin
    for I := Low(FBlks) to High(FBlks) do
      if FBlks[I] = nil then
        SetArrowTypeEx(FDimProps.Arrows.Blks[I], I);
  end;
end;

procedure TsgDXFDimensionStyle.RemoveReferenceNotification(
  const ARefObj: TsgDXFEntity);
begin
  inherited RemoveReferenceNotification(ARefObj);
  ReplaceBlock(TsgDXFBlock(ARefObj), nil);
end;

function TsgDXFDimensionStyle.ReplaceBlock(const ABlockPrev, ABlockNew: TsgDXFBlock): Boolean;
var
  I: TsgDimNameVal;
begin
  Result := False;
  for I := Low(FBlks) to High(FBlks) do
  begin
    if FBlks[I] = ABlockPrev then
    begin
      SetBlocks(I, ABlockNew);
      Result := True;
    end;
  end;
end;

procedure TsgDXFDimensionStyle.SetArrows(AArrows: TsgArrows);
begin
  SetArrowTypeEx(AArrows.Blks[vnDIMBLK], vnDIMBLK);
  SetArrowTypeEx(AArrows.Blks[vnDIMBLK1], vnDIMBLK1);
  SetArrowTypeEx(AArrows.Blks[vnDIMBLK2], vnDIMBLK2);
end;

procedure TsgDXFDimensionStyle.SetASZ(const Value: TsgFloat);
begin
  if Value >= 0 then
    GetActualStyle(vnDIMASZ, True).FDimProps.Asz := Value;
end;

procedure TsgDXFDimensionStyle.SetArrowType(const Value: Byte);
begin
  SetDIMBLKT(sgConsts.GetArrowType(Value));
end;

procedure TsgDXFDimensionStyle.SetArrowType1(const Value: Byte);
begin
  SetDIMBLK1T(sgConsts.GetArrowType(Value));
end;

procedure TsgDXFDimensionStyle.SetArrowType2(const Value: Byte);
begin
  SetDIMBLK2T(sgConsts.GetArrowType(Value));
end;

procedure TsgDXFDimensionStyle.SetArrowTypeL(const Value: Byte);
begin
  SetDIMLDRBLKT(sgConsts.GetArrowType(Value));
end;

procedure TsgDXFDimensionStyle.SetBlocks(const AType: TsgDimNameVal;
  const AValue: string; AConverter: TsgDXFConverter);
begin
  SetConverter(AConverter);
  SetArrowTypeEx(AValue, AType);
end;

procedure TsgDXFDimensionStyle.SetBlocksInternal(const AType: TsgDimNameVal;
  const AValue: TsgDXFBlock);
var
  I: TsgDimNameVal;
begin
  if AValue <> FBlks[AType] then
  begin
    if Assigned(FBlks[AType]) then
    begin
      I := Low(FBlks);
      while (I <= High(FBlks)) and ((I = AType) or (FBlks[I] <> FBlks[AType])) do
        Inc(I);
      if (I > High(FBlks)) and FBlks[AType].InheritsFrom(TsgDXFBlock) then
        FBlks[AType].References.Remove(Self);
//      if FBlks[AType].ClassType = TsgLinkObject then
//        TsgLinkObject(FBlks[AType]).Refs.Remove(Self);
    end;
    FBlks[AType] := AValue;
    if Assigned(FBlks[AType]) then
    begin
      if FBlks[AType].ClassType = TsgDXFBlockRecord then
        FBlks[AType] := TsgDXFBlockRecord(TObject(FBlks[AType])).Block;
      if FBlks[AType].InheritsFrom(TsgDXFBlock) then
        FBlks[AType].References.Add(Self);
//      if FBlks[AType].ClassType = TsgLinkObject then
//        TsgLinkObject(FBlks[AType]).Refs.Add(Self);
    end;
  end;
  FDimProps.Arrows.Blks[AType] := GetArrowTypeByBlock(FBlks[AType]);
end;

procedure TsgDXFDimensionStyle.SetBlocks(const AType: TsgDimNameVal;
  const AValue: TsgDXFBlock);
var
  vActStyle: TsgDXFDimensionStyle;
begin
  vActStyle := GetActualStyle(AType, True);
  if Assigned(vActStyle) then
    vActStyle.SetBlocksInternal(AType, AValue);
end;

procedure TsgDXFDimensionStyle.SetArrowTypeEx(const AValue: TsgDimArrowType;
  const APropName: TsgDimNameVal);
begin
  case AValue of
    datUndefined, datUserarrow: GetActualStyle(APropName, True).FDimProps.Arrows.Blks[APropName] := AValue;
  else
    SetArrowTypeEx(sgDimensionArrowTypeNames[AValue], APropName, AValue);
  end;
end;

procedure TsgDXFDimensionStyle.SetArrowTypeEx(const AValue: string;
  const APropName: TsgDimNameVal; AValueType: TsgDimArrowType = datUndefined);
var
  vBlocks: TsgDXFTable;
  vBlock: TsgDXFBlock;
  vName: string;
begin
  vName := AValue;
  if (Length(vName) < 1) and (AValueType <> datUndefined) then
    vName := sgDimensionArrowTypeNames[AValueType];
  if Assigned(Converter) and (Length(vName) > 0) then
  begin
    vBlocks := TsgDXFTable(Converter.Sections[csBlocks]);
    vBlock := TsgDXFBlock(vBlocks.FindEntByName(vName));
    if not Assigned(vBlock) then
    begin
      vBlock := TsgDXFBlock(Converter.NewNamedEntity(vBlocks, TsgDXFBlock, vName));
      vBlock.IsLoaded := False;
      if AValueType = datUndefined then
        AValueType := GetArrowTypeByName(AValue, datClosedfilled);
      GenerateArrow(Converter, TsgDXFBlock(vBlock), AValueType);
      Converter.Loads(vBlock);
    end;
    SetBlocks(APropName, TsgDXFBlock(vBlock));
  end;
end;

procedure TsgDXFDimensionStyle.SetCLRD(const Value: TsgColorCAD);
begin
  GetActualStyle(vnDIMCLRD, True).FDimProps.ClrD := Value;
end;

procedure TsgDXFDimensionStyle.SetCLRE(const Value: TsgColorCAD);
begin
  GetActualStyle(vnDIMCLRE, True).FDimProps.ClrE := Value;
end;

procedure TsgDXFDimensionStyle.SetCLRT(const Value: TsgColorCAD);
begin
  GetActualStyle(vnDIMCLRT, True).FDimProps.ClrT := Value;
end;

procedure TsgDXFDimensionStyle.SetDEC(const Value: Integer);
begin
  GetActualStyle(vnDIMDEC, True).FDimProps.Dec := Value;
end;

procedure TsgDXFDimensionStyle.SetDimArrowType1(const Value: TsgDimArrowType);
begin
  SetDimArrowType1BySah(Value, FDimProps);
  SetArrows(FDimProps.Arrows);
end;

procedure TsgDXFDimensionStyle.SetDimArrowType2(const Value: TsgDimArrowType);
begin
  SetDimArrowType2BySah(Value, FDimProps);
  SetArrows(FDimProps.Arrows);
end;

procedure TsgDXFDimensionStyle.SetDIMBLKT(const Value: TsgDimArrowType);
begin
  SetArrowTypeEx(Value, vnDIMBLK);
end;

procedure TsgDXFDimensionStyle.SetDIMBLK1T(const Value: TsgDimArrowType);
begin
  SetArrowTypeEx(Value, vnDIMBLK1);
end;

procedure TsgDXFDimensionStyle.SetDIMBLK2T(const Value: TsgDimArrowType);
begin
  SetArrowTypeEx(Value, vnDIMBLK2);
end;

procedure TsgDXFDimensionStyle.SetDIMLDRBLKT(const Value: TsgDimArrowType);
begin
  SetArrowTypeEx(Value, vnDIMLRBLK);
end;

procedure TsgDXFDimensionStyle.SetDIMBLK(const Value: TsgDXFBlock);
begin
  SetBlocks(vnDIMBLK, Value);
end;

procedure TsgDXFDimensionStyle.SetDIMBLK1(const Value: TsgDXFBlock);
begin
  SetBlocks(vnDIMBLK1, Value);
end;

procedure TsgDXFDimensionStyle.SetDIMBLK2(const Value: TsgDXFBlock);
begin
  SetBlocks(vnDIMBLK2, Value);
end;

procedure TsgDXFDimensionStyle.SetDIMLDRBLK(const Value: TsgDXFBlock);
begin
  SetBlocks(vnDIMLRBLK, Value);
end;

procedure TsgDXFDimensionStyle.SetDIMSAH(const Value: Boolean);
begin
  GetActualStyle(vnDIMSAH, True).FDimProps.Sah := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMSD1(const Value: Boolean);
begin
  GetActualStyle(vnDIMSD1, True).FDimProps.SD1 := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMSD2(const Value: Boolean);
begin
  GetActualStyle(vnDIMSD2, True).FDimProps.SD2 := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMSE1(const Value: Boolean);
begin
  GetActualStyle(vnDIMSE1, True).FDimProps.SE1 := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMSE2(const Value: Boolean);
begin
  GetActualStyle(vnDIMSE2, True).FDimProps.SE2 := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMTIH(const Value: Boolean);
begin
  GetActualStyle(vnDIMTIH, True).FDimProps.Tih := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMTOH(const Value: Boolean);
begin
  GetActualStyle(vnDIMTOH, True).FDimProps.Toh := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMPOST(const Value: string);
begin
  GetActualStyle(vnDIMPOST, True).FDimProps.Post := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMTP(const Value: Double);
begin
  GetActualStyle(vnDIMTP, True).FDimProps.Tp := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMTM(const Value: Double);
begin
  GetActualStyle(vnDIMTM, True).FDimProps.Tm := Value;
end;

procedure TsgDXFDimensionStyle.SetEXE(const Value: TsgFloat);
begin
  GetActualStyle(vnDIMEXE, True).FDimProps.Exe := Value;
end;

procedure TsgDXFDimensionStyle.SetEXO(const Value: TsgFloat);
begin
  GetActualStyle(vnDIMEXO, True).FDimProps.Exo := Value;
end;

procedure TsgDXFDimensionStyle.SetLFAC(const Value: Double);
begin
  GetActualStyle(vnDIMLFAC, True).FDimProps.LFac := Value;
end;

procedure TsgDXFDimensionStyle.SetLWD(const Value: TsgFloat);
begin
  GetActualStyle(vnDIMLWD, True).FDimProps.LwD := Value;
end;

procedure TsgDXFDimensionStyle.SetLWE(const Value: TsgFloat);
begin
  GetActualStyle(vnDIMLWE, True).FDimProps.LwE := Value;
end;

procedure TsgDXFDimensionStyle.SetOwnerStyle(const AValue: TsgDXFDimensionStyle);
begin
end;

procedure TsgDXFDimensionStyle.SetOwnerStyleInternal(const AValue: TsgDXFDimensionStyle);
begin
end;

function TsgDXFDimensionStyle.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;

  procedure ToXMLNodeBlock(const AAttribName: string; const ABlk: TsgDXFBlock);
  var
    vValue: string;
  begin
    if Assigned(ABlk) then
      vValue := ABlk.Name
    else
      vValue := '';//sgDimensionArrowTypeNames[datClosedfilled];
    ANode.AddAttribNV(AAttribName).ValueAsStr := vValue;
  end;

var
  vPropertiesInit: TsgDimNameVals;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ToXMLNodeBlock(cnstXMLNames[xmlDimBlk].Name,  FBlks[vnDIMBLK]);
  ToXMLNodeBlock(cnstXMLNames[xmlDimBlk1].Name, FBlks[vnDIMBLK1]);
  ToXMLNodeBlock(cnstXMLNames[xmlDimBlk2].Name, FBlks[vnDIMBLK2]);
  ToXMLNodeBlock(cnstXMLNames[xmlDimRBlk].Name, FBlks[vnDIMLRBLK]);
  if IsFullProps(AParams.Mode) then
    vPropertiesInit := []
  else
    vPropertiesInit := PropertiesInit;
  TsgDXFSectionHeader.ToXMLNodeDimProps(FDimProps, ANode, AParams, vPropertiesInit);
end;

function TsgDXFDimensionStyle.ToXMLAsProperties(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  if IsFullPropsOrXMLHelp(AParams.Mode) or (PropertiesInit <> []) then
  begin
    Result := ToXMLNode(ANode, AParams);
    ANode.RemoveAttributeByName(cnstXMLNames[xmlName].Name);
  end
  else
    Result := cnstXML_OK;
end;

procedure TsgDXFDimensionStyle.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FTextStyleItem);
end;

function TsgDXFDimensionStyle.FromXMLAsProperties(const ANode: TsgNodeSample;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := FromXML(ANode, AResult);
end;

procedure TsgDXFDimensionStyle.UpdateDimProps(ADimProps: TsgDimStyle);
begin
  FDimProps := ADimProps;
end;

function TsgDXFDimensionStyle.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlDimBlk:
      begin
        DIMBLKT := GetArrowTypeByName(AnsiUpperCase(ANode.ValueAsStr), datUndefined);
      end;
    xmlDimBlk1:
      begin
        DIMBLK1T := GetArrowTypeByName(AnsiUpperCase(ANode.ValueAsStr), datUndefined);
      end;
    xmlDimBlk2:
      begin
        DIMBLK2T := GetArrowTypeByName(AnsiUpperCase(ANode.ValueAsStr), datUndefined);
      end;
    xmlDimRBlk:
      begin
        DIMLDRBLKT := GetArrowTypeByName(AnsiUpperCase(ANode.ValueAsStr), datUndefined);
      end
  else
    Result := TsgDXFSectionHeader.FromXMLNodeDimProps(FDimProps, AType, ANode,
      AIsChild, AResult);
  end;
end;

procedure TsgDXFDimensionStyle.SetScale(const Value: Double);
begin
  GetActualStyle(vnDIMSCALE, True).FDimProps.Scale := Value;
end;

procedure TsgDXFDimensionStyle.SetCEN(const Value: TsgFloat);
begin
  GetActualStyle(vnDIMCEN, True).FDimProps.Cen := Value;
end;

procedure TsgDXFDimensionStyle.SetTextAlign(const Value: Integer);
begin
  case Value of
    1://align
      begin
        DIMTIH := False;
        DIMTOH := False;
      end;
    2://ISO
      begin
        DIMTIH := False;
        DIMTOH := True;
      end;
  else//gorizontal - default
    DIMTIH := True;
    DIMTOH := True;
  end;
end;

procedure TsgDXFDimensionStyle.SetTXT(const Value: TsgFloat);
begin
  GetActualStyle(vnDIMTXT, True).FDimProps.Txt := Value;
end;

procedure TsgDXFDimensionStyle.SetGAP(const Value: TsgFloat);
begin
  GetActualStyle(vnDIMGAP, True).FDimProps.Gap := Value;
end;

procedure TsgDXFDimensionStyle.SetTAD(const Value: TsgDimTextPosVert);
begin
  GetActualStyle(vnDIMTAD, True).FDimProps.Tad := Byte(Value);
end;

procedure TsgDXFDimensionStyle.SetTXSTY(const Value: TsgDXFStyle);
begin
  GetActualStyle(vnDIMTXSTY, True).FTextStyleItem.Item := Value;
end;

procedure TsgDXFDimensionStyle.SetTIX(const Value: Integer);
begin
  GetActualStyle(vnDIMTIX, True).FDimProps.Tix := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMDSEP(const Value: Char);
begin
  GetActualStyle(vnDIMDSEP, True).FDimProps.DSep := Value;
end;

procedure TsgDXFDimensionStyle.SetDIMLUNIT(const Value: TsgDimLimitUnits);
begin
  GetActualStyle(vnDIMLUNIT, True).FDimProps.LUnit := Value;
end;

procedure TsgDXFDimensionStyle.SetFRAC(const Value: Integer);
begin
  GetActualStyle(vnDIMFRAC, True).FDimProps.Frac := Value;
end;

procedure TsgDXFDimensionStyle.AssignEntity(Source: TsgDXFEntity);
var
  I: TsgDimNameVal;
  vDimStyle: TsgDXFDimensionStyle absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFDimensionStyle then
  begin
    for I := Low(vDimStyle.FBlks) to High(vDimStyle.FBlks) do
      SetBlocksInternal(I, vDimStyle.FBlks[I]);
    FDimProps := vDimStyle.FDimProps;
    FTextStyleItem.Item := vDimStyle.FTextStyleItem.Item;
  end;
end;

{ TsgDXFLeader }

function TsgDXFLeader.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = sACADXDataAppName then
  begin
    AData.AddString(String_1001, sACADXDataAppName);
    AData.AddString(String_1000, cnstDStyle);
    AData.AddString(String_1002, '{');
    Result := True;
  end;
end;

procedure TsgDXFLeader.ClearReferences;
begin
  inherited ClearReferences;
  if Assigned(FInsert) then
    FInsert.ClearReferences;
  if GetProperties <> nil then
    GetProperties.SetOwnerStyle(nil);
  FPropertiesItem.Item := nil;
  FDimStyleItem.Item := nil;
end;

constructor TsgDXFLeader.Create;
begin
  inherited Create;
  FArrowhead := True;
  FInsert := TsgDXFInsert.Create;
  FDimStyleItem := TsgTableItem.Create;
  FPropertiesItem := TsgTableItem.Create;
end;

procedure TsgDXFLeader.DoAdditionalLine(const AHookLine: Integer;
  const AHookLineVector: TFPoint;
  const ATAD: Integer; const AGAP, AWidth: Double);

var
  vPLastPoint: TFPoint;
  vAdditional, vDirectional: TFPoint;
  vArrowSize: Double;
begin
  if (AHookLine <> 0) and (ATAD <= 0) then Exit;

  vAdditional := cnstFPointZero;

  if Self.ArrowSize = 0 then
    vArrowSize := Self.DimStyle.ArrowSize
  else
    vArrowSize := Self.ArrowSize;
  if Self.ArrowScale <> 0 then
    vArrowSize := vArrowSize * Self.ArrowScale
  else
    vArrowSize := vArrowSize * Self.DimStyle.Scale;

  vDirectional := AHookLineVector;

  if AHookLine = 0 then
  begin
    vAdditional := PtXScalar(vDirectional, vArrowSize);

    vPLastPoint := Controls.Last;
    Controls.Add(vPLastPoint);
    Controls[Controls.Count - 2] := AddFPoint(vPLastPoint, vAdditional);
  end;

  if ATAD > 0 then
  begin
    vAdditional := PtXScalar(vDirectional, -(AWidth + AGAP));

    vPLastPoint := Controls.Last;
    if Controls.Count > 1 then
    begin
      if not IsEqual(Controls[Controls.Count - 2].Y, vPLastPoint.Y) then
      begin
        Controls.Add(vPLastPoint);
      end;
    end;
    Controls.Last := AddFPoint(vPLastPoint, vAdditional)
  end;
end;


procedure TsgDXFLeader.EndExtData(const AData: TsgCADExtendedData);
begin
  AData.AddString(String_1002, '}');
end;

function TsgDXFLeader.GetArrowScale: Double;
begin
  Result := ActualDimStyle.Scale;
end;

function TsgDXFLeader.GetArrowSize: Double;
begin
  Result := ActualDimStyle.ArrowSize;
end;

procedure TsgDXFLeader.SetArrowScale(const AValue: Double);
begin
  ActualDimStyle.Scale := AValue;
end;

procedure TsgDXFLeader.SetArrowSize(AValue: Double);
begin
  if AValue >= 0 then
  begin
    ActualDimStyle.ArrowSize := AValue;
    ArrowScale := 1.0;
  end;
end;

function TsgDXFLeader.GetEntType: TsgCADEntities;
begin
  Result := ceLeader;
end;

function TsgDXFLeader.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  if BeginExtData(AData, AAppID) then
  begin
    AData.AddInt16(Integer_1070, 40);
    AData.AddDouble(Float_1040, ArrowScale);
    AData.AddInt16(Integer_1070, 41);
    AData.AddDouble(Float_1040, ArrowSize);
    if Assigned(FInsert.BlockRecord) then
    begin
      AData.AddInt16(Integer_1070, 341);
      AData.AddInt64(String_1005, FInsert.BlockRecord.Handle);
    end;
    EndExtData(AData);
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

function TsgDXFLeader.GetProperties: TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(FPropertiesItem.Item)
end;

function TsgDXFLeader.GetTextStyle: TsgDXFStyle;
begin
  Result := ActualDimStyle.TextStyle;
end;

procedure TsgDXFLeader.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlArrowhead));
      AHideList.Add(Integer(xmlLeaderPathType));
      AHideList.Add(Integer(xmlEndTangentVector));
      AHideList.Add(Integer(xmlStartTangentVector));
      AHideList.Add(Integer(xmlDegree));
    end;
  end;
end;

procedure TsgDXFLeader.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
  Prev: Boolean;
begin
  inherited Invoke(AConverter, Proc, FinishProc);
  if Visibility and FInsert.Visibility and Assigned(FInsert.BlockRecord) then
  begin
    Prev := AConverter.AutoInsert;
    AConverter.AutoInsert := True;
    FInsert.Invoke(AConverter, Proc, FinishProc);
    AConverter.AutoInsert := Prev;
  end;
end;

procedure TsgDXFLeader.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
  if Assigned(FPropertiesItem.Item) then
    FPropertiesItem.Item.Link(AConverter);
end;

procedure TsgDXFLeader.LoadedInternal(AConverter: TsgDXFConverter);
  function Sign(Value: Double): Double;
  begin
    if Value < 0 then
      Result := -1.0
    else
      Result := 1.0;
  end;
var
  I, vNextControl, CtrlsCnt: Integer;
  Knot: Single;
  LenLineWithArrow, vLineAngle: Double;
  Pt1, Pt2: TFPoint;
begin
  if DimStyle = nil then
    DimStyle := AConverter.DimensionStyleByName(sStandardName);
  CtrlsCnt := FControls.Count-1;
  if CtrlsCnt < 1 then
  begin
    inherited LoadedInternal(AConverter);
    FBox := cnstBadRect;// Invisible leader
    Exit;
  end;
  vLineAngle := 0;
  Pt1 := FControls.First;
  Pt2 := FControls.Last;
  FArrowPoint := Pt1;
  FTextPoint := Pt2;
  vNextControl := 1;
  for I := 1 to CtrlsCnt do
  begin
    Pt2 := FControls[I];
    LenLineWithArrow := DistanceFPoint(FArrowPoint, Pt2);
    if LenLineWithArrow < fAccuracy then Continue;
    vLineAngle := Sign(FArrowPoint.Y - Pt2.Y)
      * sgFunction.Degree(SGArcCos((FArrowPoint.X - Pt2.X)/ LenLineWithArrow));
    vNextControl := I;
    Break;
  end;
  if FIsSpline then
  begin
    Knot := 0.0;
    FKnots.Add(Knot);
    FKnots.Add(Knot);
    for I := 1 to CtrlsCnt do
    begin
      // Knots
      Knot := Knot + DistanceFPoint(FControls[I], FControls[I-1]);
      FKnots.Add(Knot);
    end;
    FKnots.Add(Knot);
    FKnots.Add(Knot);
    FKnots.Add(Knot);
  end;
  inherited LoadedInternal(AConverter);
  LoadInsert(AConverter, vNextControl, vLineAngle);
end;

procedure TsgDXFLeader.LoadInsert(AConverter: TsgDXFConverter;
  NextControl: Integer; const ALineAngle: Double);
var
  vSize: Double;
begin
  FInsert.Layer := Layer;
  if not FArrowhead then
    Exit;
  vSize := ArrowSize * ArrowScale;
  FInsert.Visibility := 0.5*DistanceFPoint(FControls[0], FControls[NextControl]) >= vSize;
  if not FInsert.Visibility then
    Exit;

  if (FInsert.Block = nil) and (GetDimArrowType <> datUndefined) then
  begin
    if ActualDimStyle.FBlks[vnDIMLRBLK] = nil then
      ActualDimStyle.SetArrowTypeEx(GetDimArrowType, vnDIMLRBLK);
    FInsert.Block := ActualDimStyle.FBlks[vnDIMLRBLK];
    if Assigned(FInsert.Block) and (FInsert.Block.Count = 0) and IsBadRect(FInsert.Block.Box) then
    begin
      FInsert.Block.IsLoaded := False;
      GenerateArrow(AConverter, FInsert.Block, GetDimArrowType);
      Converter.Loads(FInsert.Block);
    end;
  end;

  FInsert.Angle := ALineAngle;
  FInsert.Scale := MakeFPoint(vSize, vSize, vSize);
  FInsert.ColorCAD := ColorCAD;
  FInsert.Point := FArrowPoint;
  FInsert.Loaded(AConverter);
  UnionFRect(FBox, FInsert.Box);
end;

procedure TsgDXFLeader.SetColorCAD(const Value: TsgColorCAD);
begin
  inherited SetColorCAD(Value);
  FInsert.ColorCAD := Value;
end;

procedure TsgDXFLeader.SetConverter(const AConverter: TsgDXFConverter);
begin
  inherited SetConverter(AConverter);
  if Assigned(FPropertiesItem.Item) then
    FPropertiesItem.Item.SetConverter(AConverter); // for SetArrowTypeEx();
end;

procedure TsgDXFLeader.SetDimArrowType(const AValue: TsgDimArrowType);
begin
  ActualDimStyle.SetDIMLDRBLKT(AValue);
end;

procedure TsgDXFLeader.SetDIMBLK(const AValue: TsgDXFBlock);
begin
  ActualDimStyle.DIMBLK := AValue;
end;

procedure TsgDXFLeader.SetDIMBLK1(const AValue: TsgDXFBlock);
begin
  ActualDimStyle.DIMBLK1 := AValue;
end;

procedure TsgDXFLeader.SetDIMBLK2(const AValue: TsgDXFBlock);
begin
  ActualDimStyle.DIMBLK2 := AValue;
end;

procedure TsgDXFLeader.SetDIMLDRBLK(const AValue: TsgDXFBlock);
begin
  ActualDimStyle.DIMLDRBLK := AValue;
  FInsert.Block := nil;
end;

procedure TsgDXFLeader.SetDimStyle(const AValue: TsgDXFDimensionStyle);
begin
  FDimStyleItem.Item := AValue;
  if Assigned(FPropertiesItem.Item) then
    TsgDXFDimensionStyle(FPropertiesItem.Item).SetOwnerStyle(TsgDXFDimensionStyle(FDimStyleItem.Item));
end;

procedure TsgDXFLeader.SetDimStyleInternal(const AValue: TsgDXFDimensionStyle);
begin
  if FPropertiesItem.Item <> nil then
    TsgDXFDimensionProperties(FPropertiesItem.Item).SetOwnerStyleInternal(AValue);
  FDimStyleItem.Item := AValue;
end;

procedure TsgDXFLeader.SetTextStyle(const AValue: TsgDXFStyle);
begin
  ActualDimStyle.TextStyle := AValue;
end;

procedure TsgDXFLeader.SetVisibility(const Value: Boolean);
begin
  inherited SetVisibility(Value);
  if FInsert <> nil then
    FInsert.SetVisibility(Value);
end;

function TsgDXFLeader.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlArrowhead].Name).ValueAsBool := Arrowhead;
  if IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlDimStyle].Name)
  else
    if Assigned(DimStyle) then
      ANode.AddAttribNV(cnstXMLNames[xmlDimStyle].Name).ValueAsStr := DimStyle.Name;
  ANode.AddAttribNV(cnstXMLNames[xmlLeaderPathType].Name).ValueAsInt :=
   Integer(FIsSpline);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddChildNV(cnstXMLNames[xmlProperties].Name)
  else
    if Assigned(Properties) then
      Properties.ToXMLAsProperties(ANode.AddChildNV(cnstXMLNames[xmlProperties].Name), AParams);
//  RemoveProperty(Result, TsgDegree);
//  RemoveProperty(Result, TsgFPoint);
//  RemoveProperty(Result, TsgControlPoints);
//  RemoveProperty(Result, TsgFitPoints);
//  RemoveProperty(Result, TsgKnots);
//  RemoveProperty(Result, TsgWeights);
//  RemoveProperty(Result, TsgStartTangentVector);
//  RemoveProperty(Result, TsgEndTangentVector);
  ANode.AddAttribNV(cnstXMLNames[xmlArrowType].Name).ValueAsInt := ArrowType;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlDimScale].Name).ValueData,
    ArrowScale, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlArrowSize].Name).ValueData,
    ArrowSize, xmlForViewing in AParams.Mode);
end;

procedure TsgDXFLeader.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FInsert);
  FreeAndNil(FPropertiesItem);
  FreeAndNil(FDimStyleItem);
end;

function TsgDXFLeader.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vStyle: TsgDXFDimensionStyle;
  vArrowType: Integer;
  vArrowSize: Double;
  vPropertiesInit: TsgDimNameVals;

  function GetDimStyle(const ANodeStyle: TsgNodeSample): TsgDXFDimensionStyle;
  begin
    if Assigned(Converter) then
      Result := Converter.GetDimStyleFromNode(ANodeStyle)
    else
      Result := nil;
  end;

begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  if (not Assigned(DimStyle)) and Assigned(Converter) then
    DimStyle := Converter.DimensionStyleByName(Converter.HeadVarStruct.DimStyle);
  case AType.Id of
    xmlArrowType:
      begin
        vArrowType := ANode.ValueAsInt;
        if (vArrowType >= Integer(Low(TsgDimArrowType))) and
           (vArrowType <= Integer(High(TsgDimArrowType))) and
           (ArrowType <> vArrowType) then
          ArrowType := vArrowType;
      end;
    xmlArrowSize: ArrowSize := ANode.ValueAsDouble;
    xmlDimScale:  ArrowScale := ANode.ValueAsDouble;
    xmlArrowhead: Arrowhead := ANode.ValueAsBool;
    xmlDimStyle:
      begin
        vStyle := GetDimStyle(ANode);
        if Assigned(vStyle) then
        begin
          vArrowType := ArrowType;
          vArrowSize := ArrowSize;
          try
            vPropertiesInit := [];
            if Assigned(Properties) then
              vPropertiesInit := Properties.PropertiesInit;
            DimStyle := vStyle;//set owner in SetDimtyle
          finally
            if vnDIMLRBLK in vPropertiesInit then
              ArrowType := vArrowType;
            if vnDIMASZ in vPropertiesInit then
              ArrowSize := vArrowSize;
          end;
        end;
      end;
    xmlLeaderPathType: FIsSpline := ANode.ValueAsInt <> 0;
    xmlProperties:
      begin
        if (ActualDimStyle.OwnerStyle = nil) or (ActualDimStyle.PropertiesInit = []) then
          ActualDimStyle.SetOwnerStyle(DimStyle);
        Properties.FromXMLAsProperties(ANode, AResult);
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFLeader.GetActualDimStyle: TsgDXFDimensionStyle;
begin
  if FPropertiesItem.Item = nil then
  begin
    FPropertiesItem.Item := TsgDXFDimensionProperties.Create;
    FPropertiesItem.Item.SetConverter(Converter);
    GetProperties.SetOwnerStyle(DimStyle);
  end;
  Result := GetProperties;
end;

procedure TsgDXFLeader.AssignEntity(Source: TsgDXFEntity);
var
  vLeader: TsgDXFLeader absolute Source;
  vProperties: TsgDXFDimensionStyle;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFLeader then
  begin
    FInsert.Block := nil;
    FArrowhead := vLeader.Arrowhead;
    DimStyle := vLeader.DimStyle;
    FIsSpline := vLeader.FIsSpline;
    vProperties := vLeader.Properties;
    if Assigned(vProperties) then
      ActualDimStyle.AssignEntity(vProperties)
    else
    begin
      if Assigned(FPropertiesItem.Item) then
        Properties.SetOwnerStyle(nil);
      FPropertiesItem.Item := nil;
    end;
  end;
end;

function TsgDXFLeader.GetArrowType: Byte;
begin
  Result := GetArrowByte(GetDimArrowType);
end;

function TsgDXFLeader.GetDimArrowType: TsgDimArrowType;
begin
  Result := ActualDimStyle.GetDIMLDRBLKT;
end;

function TsgDXFLeader.GetDIMBLK: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMBLK;
end;

function TsgDXFLeader.GetDIMBLK1: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMBLK1;
end;

function TsgDXFLeader.GetDIMBLK2: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMBLK2;
end;

function TsgDXFLeader.GetDIMLDRBLK: TsgDXFBlock;
begin
  Result := ActualDimStyle.DIMLDRBLK;
end;

function TsgDXFLeader.GetDimStyle: TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(FDimStyleItem.Item);
end;

procedure TsgDXFLeader.SetArrowType(const AValue: Byte);
begin
  SetDimArrowType(sgConsts.GetArrowType(AValue));
end;

{ TsgDXFShape }

procedure TsgDXFShape.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFShape then
  begin
    FShapeName := TsgDXFShape(Source).ShapeName;
    FShapeNumber := TsgDXFShape(Source).FShapeNumber;
  end;
end;

constructor TsgDXFShape.Create;
begin
  inherited Create;
  Properties.FFontName := '';
  WinFont := False;
  FShapeName := '';
  FShapeNumber := 0;
end;

function TsgDXFShape.GetAnsiText(const AText: string; ACodePage: Integer): sgRawByteString;
{$IFDEF SGDEL_2009}
var
  I: Integer;
{$ENDIF}
begin
{$IFDEF SGDEL_2009}
  Result := '';
  for I := 1 to Length(AText) do
    Result := Result + AnsiChar(Ord(AText[I]));
{$ELSE}
  Result := inherited GetAnsiText(AText, ACodePage);
{$ENDIF}
end;

function TsgDXFShape.GetEntType: TsgCADEntities;
begin
  Result := ceShape;
end;

function TsgDXFShape.GetIsEmpty: Boolean;
begin
  Result := (Text = '');
end;

function TsgDXFShape.GetShapeName: string;
begin
  Result := FShapeName; 
end;

function TsgDXFShape.GetShapeNumber: Word;
begin
  Result := FShapeNumber;
end;

function TsgDXFShape.GetSHXFont: string;
begin
  if Style <> nil then
    Result := AnsiUpperCase(Style.GetPrimaryFontName)
  else
    Result := inherited GetSHXFont;
//  if Result = '' then
//    Result := 'LTYPESHP.SHX';
end;

procedure TsgDXFShape.LoadedInternal(AConverter: TsgDXFConverter);
var
  vList: TsgSHXVertexList;
  vFontParams: TsgFontParams;
  vSHXFont: string;
  vFindShape: Boolean;
  vSHXFontObject: TsgSHXFontAccess;
  vShapeIndex: Integer;
begin
  FBox := cnstBadRect;
  FStartPoint := Point;
  FMatrix := cnstIdentityMat;
  // Change in future versions (SHAPE style don't have the name)
  //if FStyle = nil then
  //  SetStyle(AConverter.StyleByName(sTextStyleStandardName));
  if ObliqueAngle <> 0 then
  begin
    try
      FMatrix.M[1, 0] :=  Tan(Radian(ObliqueAngle)) / Scale;
    except
      FMatrix := cnstIdentityMat;
    end;
  end;
  vSHXFont := '';
  if Style <> nil then
    vSHXFont := AnsiUpperCase(Style.PrimaryFont);
  vFindShape := FindShape(AConverter.FSHXFonts, FShapeNumber, FShapeName, vSHXFont);
  SetSHXFont(vSHXFont);
  if FShapeNumber <> 0 then
    Text := Char(FShapeNumber);
  if vFindShape and (Properties.PrimaryFont <> '') then
  begin
    FillChar(vFontParams, SizeOf(TsgFontParams), 0);
    vSHXFontObject := TsgSHXFontAccess(AConverter.GetSHXFont(Properties, Properties.BigFont <> '', vSHXFont));
    if Assigned(vSHXFontObject) and vSHXFontObject.Find(FShapeNumber, vShapeIndex) then
    begin
      SetLength(FIndices, 1);
      FIndices[High(FIndices)] := vShapeIndex;
      vList := TsgSHXVertexList.Create;
      try
        GetSHXLinesI(AConverter.FSHXFonts, vList, vFontParams);
        if vList.Count <> 0 then
        begin
          GetSHXBoxI(AConverter.FSHXFonts, vFontParams);
          FBox := MakeFRect(vFontParams.Left, vFontParams.Top, 0, vFontParams.Right, vFontParams.Bottom, 0);
          FMatrix := FMatXMat(FMatrix, StdMat(MakeFPoint(Height*Scale, Height, 1), cnstFPointZero));
          FMatrix := FMatXMat(FMatrix, MatFromExtr(Extrusion, Rotation));
          FMatrix := FMatXMat(FMatrix, StdMat(cnstFPointSingle, FStartPoint));
          TransRectCorners(FBox, FMatrix);
        end;
      finally
        vList.Free;
      end;
    end;
  end;
end;

procedure TsgDXFShape.SetShapeName(const Value: string);
begin
  FShapeName := Value;
end;

procedure TsgDXFShape.SetShapeNumber(const Value: Word);
begin
  FShapeNumber := Value;
end;

{ TsgDXFText }

constructor TsgDXFText.Create;
begin
  inherited Create;
  FBox := cnstBadRect;
  FPropertiesItem := TsgTableItem.Create;
  FPropertiesItem.Item := TsgDXFStyle.Create;
  Properties.FFontName := cnstDefaultTTFFont;
  FExtrusion := cnstExtrusion;
  FTextStyleItem := TsgStyleItem.Create;
  TsgStyleItem(FTextStyleItem).NotifyChange := StyleChanged;
  WinFont := True;
  FTracking := 1.0;
  FCharset := cnstCharSetDef;
end;

procedure TsgDXFText.CreateMText(const AConverter: TsgDXFConverter);
var
  vXrec: TsgDXFXRecord;
  vAtt: TAcadMLAttData;
begin
  ApplyRotation;
  FMText := TsgDXFMText.Create;
  AConverter.DoCreate(FMText);
  FMText.Visibility := Visibility;
  FMText.Style := Style;
  FMText.ColorCAD := ColorCAD;

  vXrec := TsgDXFXRecord(GetExtensionDictionary(cnstAcadMLAtt));
  if Assigned(vXrec) then
  begin
    ExtractMLAttData(vXrec.Data, vAtt);
    ApplyMTextFromMLAttData(vAtt, FMText);
    if vAtt.Style <> '' then
      FMText.Style := TsgDXFStyle(AConverter.Sections[csStyles].FindEntByName(vAtt.Style));
    FMText.Extrusion := Extrusion;
    FMText.SetAngle(Rotation);
  end
  else
  begin
    if Style.FWidthFactor <> XScale then
      FMText.Scale := MakeFPoint(XScale, 1, 1);
    DoExtrusion(FPoint, Extrusion);
    FMText.FPoint := FPoint;
    FMText.Extrusion := Extrusion;
    FMText.SetAngle(Rotation);
    FMText.FHeight := Height;
    FMText.FText := Text;
    FMText.Align := 1;
    if not IsMultiText then
      FMText.FAlign :=  10;// 7 in previous version
  end;

  ReplaceEvenUnEven(FMText.FText, '%%u', '\L', '\l');
  ReplaceEvenUnEven(FMText.FText, '%%o', '\O', '\o');
  FMText.Layer := Layer;
  FMText.FLineWeight := FLineWeight;
  FMText.Loaded(AConverter);
  FBox := FMText.FBox;
end;

procedure TsgDXFText.ApplyStyle(const AStyle: TsgDXFStyle);
begin
  if Style <> AStyle then
    Style := AStyle
  else
    ApplyStyleProps(Style);
end;

procedure TsgDXFText.ApplyStyleProps(const AStyle: TsgDXFStyle);
begin
  if Assigned(AStyle) then
  begin
    ObliqueAngle := AStyle.ObliqueAngle;
    Scale := AStyle.WidthFactor;
    if not InsideMText then
      if AStyle.FixedHeight <> 0 then
        Height := AStyle.FixedHeight
  end;
end;

procedure TsgDXFText.StyleChanged(Sender: TObject);
begin
  if Assigned(Style) then
    ApplyStyleProps(Style);
end;

procedure TsgDXFText.CreateTextParse;
begin
  if FTextParse = nil then
    New(FTextParse);
  FTextParse^ := cnstTextParseZero;
end;

procedure TsgDXFText.AssignEntity(Source: TsgDXFEntity);
var
  vText: TsgDXFText absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFText then
  begin
    Style := vText.Style;
    FExtrusion := vText.FExtrusion;
    FHAlign := vText.FHAlign;
    Properties := vText.Properties;
    FCharset := vText.Charset;
    FInternalFlags := vText.FInternalFlags;
    FMatrix := vText.FMatrix;
    FreeAndNil(FMText);
    Point1 := vText.Point1;
    FRotation := vText.FRotation;
    FUnicodeText := '';
    FText := vText.Text;
    FLineWeight :=  vText.FLineWeight;
    FVAlign := vText.FVAlign;
    FTracking := vText.FTracking;
  end;
end;

function TsgDXFText.HasSecond: Boolean; // is the second alignment point must be used
begin
  Result := (Point1.X <> cnstIllegal) and (Point1.Y <> cnstIllegal);
end;

function TsgDXFText.GetHeight: TsgFloat;
begin
  Result := Properties.FixedHeight;
end;

procedure TsgDXFText.SetHeight(AValue: TsgFloat);
begin
  Properties.FixedHeight := AValue;
end;

function TsgDXFText.GetPoint1: TFPoint;
begin
  Result := FPoint1;
end;

function TsgDXFText.GetProperties: TsgDXFStyle;
begin
  Result := TsgDXFStyle(FPropertiesItem.Item);
end;

procedure TsgDXFText.SetPoint1(AValue: TFPoint);
begin
  FPoint1 := AValue;
end;

procedure TsgDXFText.SetProperties(const Value: TsgDXFStyle);
begin
  Properties.AssignEntity(Value);
end;

function TsgDXFText.GetRotation: Single;
begin
  Result := FRotation;
end;

procedure TsgDXFText.SetRotation(AValue: Single);
begin
  FRotation := AValue;
end;

function TsgDXFText.GetStyle: TsgDXFStyle;
begin
  Result := TsgDXFStyle(FTextStyleItem.Item);
end;

function TsgDXFText.GetBox: TFRect;
begin
  Result := FBox;
end;

function TsgDXFText.EntName: string;
begin
  Result := inherited EntName + ' ' + FText;
end;

function TsgDXFText.IsMText(const ADiamUni: Boolean): Boolean;
begin
  Result := {Extruded(Extrusion) or} ADiamUni or IsMultiText or
    (not InsideMText and ((AnsiPos('%%U', AnsiUpperCase(Text)) <> 0) or
    (AnsiPos('%%O', AnsiUpperCase(Text)) <> 0)));
end;

function TsgDXFText.IsMultiText: Boolean;
begin
  Result := False;
end;

function TsgDXFText.IsNotSetFontName: Boolean;
begin
  Result := not (itfSetFontName in FInternalFlags);
end;

function TsgDXFText.IsOnePixelOptimisationValid: Boolean;  //evg
begin
  Result := not (IsEmpty or (Scale = 0));
end;

procedure TsgDXFText.SetOblique(Value: Single);
var
  vObliqueAngle: Double;
begin
  vObliqueAngle := Value - Floor(Value / 180) * 180;
  if Abs(vObliqueAngle) = 90  then
    vObliqueAngle := 0;
  Properties.ObliqueAngle := vObliqueAngle;
end;

procedure TsgDXFText.SetTextValue(const Value: string);
begin
  FText := SetTextStr(Value);
  FUnicodeText := '';//read only variable
  SetLength(FIndices, 0);
end;

procedure TsgDXFText.SetThicknessInt(const AValue: Double);
begin
end;

procedure TsgDXFText.SetUpsideDown(const Value: Boolean);
begin
  Properties.UpsideDown := Value;
end;

procedure TsgDXFText.SetScale(const Value: Double);
begin
  Properties.WidthFactor := AsSingle(Value, 1.0);
end;

procedure TsgDXFText.SetSHXFont(const AFontName: string);
var
  vExt: string;
begin
  if Length(AFontName) > 0 then
  begin
    vExt := AnsiLowerCase(ExtractFileExt(AFontName));
    if (Length(vExt) = 0) or (vExt = '.shx') then
    begin
      WinFont := False;
      Properties.PrimaryFont := AFontName;
      Properties.FontName := '';
    end;
  end;
end;

procedure TsgDXFText.SetStyle(AStyle: TsgDXFStyle);
begin
  FTextStyleItem.Item := AStyle;
end;

procedure TsgDXFText.SetStyleRef(const Value: TsgDXFStyle);
var
  vEvent: TNotifyEvent;
begin
  vEvent := TsgStyleItem(FTextStyleItem).NotifyChange;
  try
    TsgStyleItem(FTextStyleItem).NotifyChange := nil;
    SetStyle(Value);
  finally
    TsgStyleItem(FTextStyleItem).NotifyChange := vEvent;
  end;
end;

procedure TsgDXFText.ChangeByStyle(AStyle: TsgDXFStyle);
var
  vPos: Integer;
  vFontType: TsgFontType;
  vPrimaryFont: string;
begin
  Style := AStyle;
  Properties.PrimaryFont := Style.GetPrimaryFontName;
  Properties.BigFont := Style.BigFont;
  Properties.FontName := Style.FontName;
  Properties.FontStyle := [];
  if Properties.FontName <> '' then
  begin
    Properties.FontStyle := Style.FontStyle;
    vPos := Pos('.', Properties.FontName);
    if vPos <> 0 then
    begin
      vFontType := GetFontTypeByFileNameExt(Properties.FontName);
      if vFontType <> ftUndefined then
        SetLength(Properties.FFontName, vPos - 1);
    end;
    WinFont := not AnsiSameText(Properties.FontName, ChangeFileExt(Properties.PrimaryFont, '')) or
      (GetFontTypeByFileNameExt(Properties.PrimaryFont) in [ftTTF, ftOTF, ftTTC]);
  end
  else
  begin
    vPrimaryFont := Properties.GetPrimaryFontName;
    vFontType := GetFontTypeByFileNameExt(vPrimaryFont);
    vPos := Pos('.', vPrimaryFont);
    if vPos > 0 then
    begin
      WinFont := vFontType <> ftSHX;
      if vFontType in [ftSHX, ftUndefined] then
        Properties.FontName := Copy(vPrimaryFont, 1, vPos - 1);
    end
    else
      WinFont := vFontType in [ftTTF, ftOTF, ftTTC];
  end;
  if Style.BigFont <> '' then//need fix GetSHXLines
    Properties.FFontName := cnstDefaultTTFFontForBigFont;
  if InsideMText then
  begin
    if ObliqueAngle = 0 then
      ObliqueAngle := Style.ObliqueAngle;
    if Scale = 1 then
      Scale := Style.FWidthFactor;
  end;
  FPitch := GetFontPitch(Properties.FontName);
  Properties.UpdateFontGlyphRef(FCharset, FPitch);
end;

procedure TsgDXFText.ClearReferences;
begin
  inherited ClearReferences;
  Style := nil;
  FPropertiesItem.Item := nil;
end;

function TsgDXFText.GetText: string;
begin
  Result := FText;
end;

function TsgDXFText.GetTextStyleInternal: Pointer;
begin
  Result := Style;
end;

procedure TsgDXFText.ApplyRotation;
begin
  if WinFont and Backward and UpsideDown then
    if FRotation > 180 then
      FRotation := FRotation - 180
    else
      FRotation := FRotation + 180;
end;

procedure TsgDXFText.GetBase(AWidth, AHeight: Extended; var Base, Start: TFPoint);        // positioning
var
  L: Double;
  Pt: TFPoint;
begin
  if FHAlign or FVAlign = 0 then
    Base := Point
  else
    Base := Point1;
  case FHAlign of
    1, 4:   Start.X := -AWidth / 2;
    2:      Start.X := -AWidth;
  end;
  if (AWidth > fAccuracy) and (FHAlign in [3, 5]) then
  begin
    Base := Point;
    Pt := MakeFPoint(Point1.X - Point.X, Point1.Y - Point.Y, Point1.Z - Point.Z);
    L := Sqrt(Sqr(Pt.X) + Sqr(Pt.Y)) / AWidth;
    if FHAlign = 3 then
    begin
      Height := Height * L;
      AHeight := AHeight * L;
    end;
    Scale := Scale * L;
    if (FHAlign = 5) and (FVAlign = 0) then
    begin// "fit align" - needs to create a new FScale and recalculate rotation
      Rotation := 0;
      if (Pt.X <> 0) and (Pt.Y <> 0) then
        Rotation := Degree(ArcTan2(Pt.Y , Pt.X))
      else if (Pt.X = 0) and (Pt.Y <> 0) then
        Rotation := 90 + 180 * Ord(Sign(Pt.Y)=-1);
      //FScale := L;// it works only for correct width of the text (AWidth)
    end;
    ApplyRotation;
  end;
  case FVAlign of
    0: Start.Y := AHeight * 0.8;
    1: Start.Y := AHeight;
    2: Start.Y := AHeight / 2;
  end;
  if FHAlign = 4 then
    Start.Y := AHeight / 2;
end;

function TsgDXFText.GetMatrix: TFMatrix;
begin
  Result := FMatrix;
end;

function TsgDXFText.Expand(AWidth, AHeight, AHeightMax: Extended;
  const ASign: TFPoint): Boolean;
var
  vBase, vFitPt: TFPoint;
  L: Extended;
begin
  Result := False;
  FStartPoint := cnstFPointZero;
  if FHAlign or FVAlign = 0 then
    vBase := Point
  else
    vBase := Point1;
  case FHAlign of
    1, 4:   FStartPoint.X := ASign.Z * AWidth * Scale / 2;
    2:      if not ((AWidth < 0) and (ASign.X > 0 )) then FStartPoint.X := ASign.Z * AWidth * Scale;
  end;
  if (AWidth > 0) and (FHAlign in [3, 5]) then
  begin
    vBase := Point;
    vFitPt := SubFPoint(Point1, Point);
    L := Sqrt(Sqr(vFitPt.X) + Sqr(vFitPt.Y)) / AWidth;
    if not sgIsZero(L) then
    begin
      if FHAlign = 3 then
      begin
        Height := Height * L;
        AHeight := AHeight * L;
        L := 1;
      end
      else
      begin
        Result := True;
        Scale := Scale * L;
      end;
      if FVAlign = 0 then
      begin// "fit align" - needs to create a new FScale and recalculate rotation
        Result := True;
        Rotation := GetAngleByPoints(cnstFPointZero, vFitPt, False);
        Scale := L;
      end;
    end;// else stay align ??
    ApplyRotation;
  end;
  case FVAlign of
    0: FStartPoint.Y := 0;
    1: FStartPoint.Y := AHeight / 3;
    2: FStartPoint.Y := - AHeight / 2;
    3,4: FStartPoint.Y := - AHeight;
  end;
  if FHAlign = 4 then
    FStartPoint.Y := - AHeightMax / 2;
  FStartPoint := RotateFPoint(FStartPoint, Rotation);
  FStartPoint := MakeFPoint(FStartPoint.X + vBase.X, FStartPoint.Y + vBase.Y, vBase.Z);
  if Extruded(Extrusion) then
    DoExtrusion(FStartPoint, Extrusion);
end;

function TsgDXFText.GetScale: Double;
begin
  Result := Properties.WidthFactor;
end;

function TsgDXFText.GetSHXBoxI(ASHXFontsList: TsgSHXFontList; var AFontParams: TsgFontParams): Boolean;
var
  vSy: Double;
  vFontStyles: TmvFontStyles;
begin
  Result := False;
  vFontStyles := Properties.FontStyle;
  UpdateProperties(Converter);
  if SHXFont = '' then
    GetSHXTextBoxFromStyle(ASHXFontsList, Properties.FSHXStyle, FIndices,
      False, vFontStyles, AFontParams.Above, AFontParams.Below,
      AFontParams.Width, AFontParams.Height, AFontParams.Left, AFontParams.Bottom,
      AFontParams.Right, AFontParams.Top, AFontParams.After, FSHXMap)
  else if SHXFont <> '' then
    DrawSHXTextBox(ASHXFontsList, SHXFont, FIndices,
      False, vFontStyles, AFontParams.Above, AFontParams.Below, AFontParams.Width,
      AFontParams.Height, AFontParams.Left, AFontParams.Bottom, AFontParams.Right,
      AFontParams.Top, AFontParams.After, FSHXMap)
  else
    GetSHXTextBox(ASHXFontsList, Style.Name, FIndices, FSHXMap,
      False, vFontStyles, AFontParams.Above, AFontParams.Below, AFontParams.Width,
      AFontParams.Height, AFontParams.Left, AFontParams.Bottom, AFontParams.Right,
      AFontParams.Top, AFontParams.After);
  if AFontParams.Above <> 0 then
    Result := True;
  if FTextParse <> nil then
  begin
    if not Result then
      AFontParams.Above := fAccuracy;
    vSy := Height / AFontParams.Above;
    FTextParse^.FontParams.Above := AFontParams.Above * vSy;
    FTextParse^.FontParams.Below := AFontParams.Below * vSy;
    FTextParse^.FontParams.Width := AFontParams.Width * vSy;
    FTextParse^.FontParams.Height := AFontParams.Height * vSy;
    FTextParse^.FontParams.Top := AFontParams.Top * vSy;
    FTextParse^.FontParams.Left := AFontParams.Left * vSy;
    FTextParse^.FontParams.Bottom := AFontParams.Bottom * vSy;
    FTextParse^.FontParams.Right := {(AFontParams.Left + AFontParams.Width)}AFontParams.Right * vSy;
    FTextParse^.FontParams.DX := AFontParams.After * vSy - FTextParse^.FontParams.Right;
    FTextParse^.FontParams.DY := (FTextParse^.FontParams.Top - FTextParse^.FontParams.Above);
    if FTextParse^.FontParams.DY < fAccuracy  then
      FTextParse^.FontParams.DY := 0;
  end;
end;

function TsgDXFText.GetSHXFont: string;
begin
  Result := GetInternalSHXFont;
  if not WinFont then
  begin
    if Properties.BigFont <> '' then
      Result := '';
  end;
end;

procedure TsgDXFText.GetSHXLinesI(ASHXFontsList: TsgSHXFontList; AList: TsgSHXVertexList;
  var AFontParams: TsgFontParams; const AParams: PsgCADIterate = nil);
var
  vStyleName: string;
  vSHXFont: string;
  vFontStyles: TmvFontStyles;
  vStopped: PBoolean;
begin
  vStopped := nil;
  if AParams <> nil then
    vStopped := @AParams^.Stopped;
  vSHXFont := SHXFont;
  vFontStyles := Properties.FontStyle;
  UpdateProperties(Converter);
  if vSHXFont = '' then
    GetSHXTextFromStyle(ASHXFontsList, Properties.FSHXStyle, FIndices,
      False, Backward, AList, vFontStyles, AFontParams.Above,
      AFontParams.Below, AFontParams.Left, AFontParams.Bottom, AFontParams.Right,
      AFontParams.Top, FSHXMap, vStopped)
  else
    if vSHXFont <> '' then
      DrawSHXText(ASHXFontsList, vSHXFont, FIndices,
        False, Backward, AList, vFontStyles, AFontParams.Above,
        AFontParams.Below, AFontParams.Left, AFontParams.Bottom,
        AFontParams.Right, AFontParams.Top, FSHXMap, vStopped)
    else
    begin
      if Style <> nil then
        vStyleName := Style.Name
      else
        vStyleName := '';
      GetSHXText(ASHXFontsList, vStyleName, FIndices, AList,
        vFontStyles, AFontParams.Above, AFontParams.Below, AFontParams.Left,
        AFontParams.Bottom, AFontParams.Right, AFontParams.Top, FSHXMap, vStopped);
    end;
end;

type
  TsgProcBySHXVertex = procedure(APts: TObject; const AMatrix: TFMatrix; const V: TsgSHXVertex);


  procedure AddPoint(APts: TObject; const AMatrix: TFMatrix; const V: TsgSHXVertex);
  var
    P: TFPoint;
  begin
    P := MakeFPoint(
      V.X * AMatrix.M[0, 0] + V.Y * AMatrix.M[1, 0] + AMatrix.M[3, 0],
      V.X * AMatrix.M[0, 1] + V.Y * AMatrix.M[1, 1] + AMatrix.M[3, 1]);
    TsgIntegerList(APts).Add(Round(P.X));
    TsgIntegerList(APts).Add(Round(P.Y));
  end;

  procedure AddSHXFPoint(APts: TObject; const AMatrix: TFMatrix; const V: TsgSHXVertex);
  var
    P: PFPoint;
  begin
    New(P);
    TList(APts).Add(P);
    P^.X := V.X * AMatrix.M[0, 0] + V.Y * AMatrix.M[1, 0] + AMatrix.M[3, 0];
    P^.Y := V.X * AMatrix.M[0, 1] + V.Y * AMatrix.M[1, 1] + AMatrix.M[3, 1];
    P^.Z := V.X * AMatrix.M[0, 2] + V.Y * AMatrix.M[1, 2] + AMatrix.M[3, 2];
  end;

procedure TsgDXFText.GetSHXLinesExI(ASHXFontsList: TsgSHXFontList; AList: TList;
      AMatrix: PFMatrix; const APolyPolyline: TsgIntegerList;
      const ACounts: TsgIntegerList);
var
  vMatrix: TFMatrix;
  vVertexes: TsgSHXVertexList;
  I, Cnt, vPtCntLast, vPtCnt: Integer;
  vActList: TList;
  vFontParams: TsgFontParams;
  vVertex, vVertexPrev: TsgSHXVertex;
  vSy: Double;
//  vProc: TsgProcBySHXVertex;
  vIsNotPolyPolyline: Boolean;

  procedure ProcCase(AIndex: Boolean; const AMatrix: TFMatrix; const V: TsgSHXVertex);
  begin
    if AIndex then
      AddSHXFPoint(vActList, AMatrix, V)
    else
      AddPoint(APolyPolyline, AMatrix, V)
  end;

  procedure AddBulge(const V1, V2: TsgSHXVertex);
  var
    X0, Y0, X1, Y1, A, A1, BT: Double;
    I, vNumberOfCircleParts: Integer;
    SinA, CosA: Extended;
    vSHXVertex: TsgSHXVertex;
  begin
    vNumberOfCircleParts := GetNumberOfCircleParts;
    A := ArcTan(V1.Bulge) * 2;
    A1 := A / (vNumberOfCircleParts) * 2;
    SinCos(A1, SinA, CosA);
    BT := (1 / V1.Bulge - V1.Bulge)/2;
    X0 := ((V1.X + V2.X) - BT * (V1.Y - V2.Y)) / 2;
    Y0 := ((V1.Y + V2.Y) + BT * (V1.X - V2.X)) / 2;
    X1 := V2.X;
    Y1 := V2.Y;
    for I := 0 to vNumberOfCircleParts - 1 do
    begin
      vSHXVertex.X := X0 + (X1 - X0) * CosA - (Y1 - Y0) * SinA;
      vSHXVertex.Y := Y0 + (X1 - X0) * SinA + (Y1 - Y0) * CosA;
      ProcCase(vIsNotPolyPolyline, vMatrix, vSHXVertex);
      X1 := vSHXVertex.X;
      Y1 := vSHXVertex.Y;
    end;
  end;

begin
  if (AList = nil) and (APolyPolyline = nil) then Exit;
  vVertexes := TsgSHXVertexList.Create;
  try
    GetSHXLinesI(ASHXFontsList, vVertexes, vFontParams);
    if vVertexes.Count <= 0 then Exit;
    vPtCntLast := 0;
    if vFontParams.Above <> 0 then
    begin
      vSy := Height / vFontParams.Above;
      vMatrix := StdMat(MakeFPoint(vSy, vSy, 1), cnstFPointZero);
    end
    else
      vMatrix := cnstIdentityMat;
    vMatrix := FMatXMat(vMatrix, SHXMatrix);
    if AMatrix <> nil then
      vMatrix := FMatXMat(vMatrix, AMatrix^);
    vIsNotPolyPolyline := ACounts = nil;
    if vIsNotPolyPolyline then
    begin
      vActList := TList.Create;
      AList.Add(vActList);
//      vProc := @AddSHXFPoint
    end
    else
    begin
      //vActList := APolyPolyline;
//      vProc := @AddPoint;
      ACounts.Capacity := vVertexes.Count;
    end;
    ProcCase(vIsNotPolyPolyline, vMatrix, vVertexes[0]);
    Cnt := vVertexes.Count - 1;
    for I := 1 to Cnt do
    begin
      vVertex := vVertexes[I];
      vVertexPrev := vVertexes[I - 1];
      if vVertex.PenDown then
      begin
        if vVertex.Bulge = 0 then
          ProcCase(vIsNotPolyPolyline, vMatrix, vVertex)
        else
          AddBulge(vVertex, vVertexPrev);
      end
      else
      begin
        if vIsNotPolyPolyline then
        begin
          case vActList.Count of
            0:  begin end;
            1:
              begin
                Dispose(PFPoint(vActList.List[0]));
                vActList.Count := 0;
              end;
          else
            vActList := TList.Create;
            AList.Add(vActList);
          end;
        end
        else
        begin
          vPtCnt := (APolyPolyline.Count - vPtCntLast) shr 1;
          if vPtCnt > 1 then
          begin
            ACounts.Add(vPtCnt);
            vPtCntLast := APolyPolyline.Count;
          end
          else
            APolyPolyline.Count := vPtCntLast;
        end;
        ProcCase(vIsNotPolyPolyline, vMatrix, vVertex);
      end;
    end;
    if vIsNotPolyPolyline then
    begin
      case vActList.Count of
        0:
          begin
            vActList.Free;
            AList.Delete(AList.Count - 1);
          end;
        1:
          begin
            Dispose(PFPoint(vActList.List[0]));
            vActList.Free;
            AList.Delete(AList.Count - 1);
          end;
      end;
    end
    else
    begin
      vPtCnt := (APolyPolyline.Count - vPtCntLast) shr 1;
      if vPtCnt > 1 then
        ACounts.Add(vPtCnt)
      else
        APolyPolyline.Count := vPtCntLast;
    end;
  finally
    vVertexes.Free;
  end;
end;

procedure TsgDXFText.GetSHXLinesEx(ASHXFontsList: TsgSHXFontList;
  ACollection: TsgCustomPolyItemsCollection; const AGDI: Boolean = False;
  const AParams: PsgCADIterate = nil);
var
  vMatrix: TFMatrix;
  vVertexes: TsgSHXVertexList;
  I, Cnt: Integer;
  AddPt: TAddPt;
  vFontParams: TsgFontParams;
  vVertex: TsgSHXVertex;
  vSy: Double;
  vNumberOfCircleParts: Integer;
  V: TFPoint;
  vMaxPixelPerUnit: Double;

  function DoAddPt(const AAddPt: TAddPt; const V: TsgSHXVertex): Integer;{$IFDEF SG_INLINE} inline;{$ENDIF}
  var
    P: TFPoint;
  begin
    P.X := V.X;
    P.Y := V.Y;
    P.Z := 0;
    Result := AAddPt(P);
  end;

  function AddBulge(const AAddPt: TAddPt; const V1, V2: TsgSHXVertex): Integer;
  var
    X0, Y0, X1, Y1, A, A1, BT: Double;
    I: Integer;
    SinA, CosA: Extended;
    P: TFPoint;
  begin
    Result := 0;
    A := ArcTan(V1.Bulge) * 2;
    A1 := A / (vNumberOfCircleParts) * 2;
    SinCos(A1, SinA, CosA);
    BT := (1 / V1.Bulge - V1.Bulge)/2;
    X0 := ((V1.X + V2.X) - BT * (V1.Y - V2.Y)) / 2;
    Y0 := ((V1.Y + V2.Y) + BT * (V1.X - V2.X)) / 2;
    X1 := V2.X - X0;
    Y1 := V2.Y - Y0;
    P.Z := 0;
    for I := 0 to vNumberOfCircleParts - 1 do
    begin
      P.X := X0 + X1 * CosA - Y1 * SinA;
      P.Y := Y0 + X1 * SinA + Y1 * CosA;
      Result := AAddPt(P);
      X1 := P.X - X0;
      Y1 := P.Y - Y0;
    end;
  end;

begin
  if (ACollection = nil) then Exit;
  vVertexes := TsgSHXVertexList.Create;
  try
    GetSHXLinesI(ASHXFontsList, vVertexes, vFontParams, AParams);
    if (vVertexes.Count <= 0) or ((AParams <> nil) and AParams^.Stopped) then
      Exit;
    if vFontParams.Above <> 0 then
    begin
      vSy := Height / vFontParams.Above;
      vMatrix := FMatXMat(StdMat(MakeFPoint(vSy, vSy, 1), cnstFPointZero), SHXMatrix);
    end
    else
      vMatrix := SHXMatrix;
    vMatrix := FMatXMat(vMatrix, PFMatrix(ACollection.Transformation)^);
    ACollection.UpdateTransformation(vMatrix, {$IFDEF HAS_UNMANAGED_TYPEINFO}TypeInfo(TFMatrix){$ELSE}SizeOf(TFMatrix){$ENDIF});
    vNumberOfCircleParts := GetNumberOfCircleParts;
    if AGDI then
    begin
      V := PtXScalar(AffineTransformPoint(cnstFPointSingle, PFMatrix(ACollection.Transformation)^), 1/Sqrt(3));
      vMaxPixelPerUnit := Max(Abs(V.X), Abs(V.Y));
      if vMaxPixelPerUnit < 1 then
      begin
        vNumberOfCircleParts := Round(vNumberOfCircleParts * vMaxPixelPerUnit);
        if vNumberOfCircleParts < 3 then
          vNumberOfCircleParts := 3;
      end;
    end;

    Cnt := vVertexes.Count;
    I := 0;
    V.Z := 0;
    if I < Cnt then
    begin
      AddPt := ACollection.NewCollection();
      vVertex := vVertexes[I];
      V.X := vVertex.X;
      V.Y := vVertex.Y;
      AddPt(V);
      Inc(I);
      while I < Cnt do
      begin
        vVertex := vVertexes[I];
        if vVertex.PenDown then
        begin
          if vVertex.Bulge = 0 then
          begin
            V.X := vVertex.X;
            V.Y := vVertex.Y;
            AddPt(V);
          end
          else
            AddBulge(AddPt, vVertex, vVertexes[I - 1]);
        end
        else
        begin
          AddPt := ACollection.NewCollection();//bug: adding the last collection with 1 vertex
          V.X := vVertex.X;
          V.Y := vVertex.Y;
          AddPt(V);
        end;
        Inc(I);
      end;
    end;

  finally
    vVertexes.Free;
  end;
end;

function TsgDXFText.GetUseDefaultFontName: Boolean;
begin
  Result := itfUseDefaultFont in FInternalFlags;
end;

procedure TsgDXFText.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFText.LoadedInternal(AConverter: TsgDXFConverter);
var
  vIndex, K: Integer;
  vSy, vWidth, vMaxHeight, vScaleHeight, vHeight: Double;
  S, vFontName, vAlternateTrueFaceFromShapeFilename, vFontFileName: string;
  vWideStr: WideString;
  vList: TsgSHXVertexList;
  vTextGlyph: TsgTextGlyph;
  vFirstGlyph: TsgGlyph;
  vFontParams: TsgFontParams;
  vSign:  TFPoint;
  vUnicodeText: WideString;
  vDiamUni, vUseDefaultFontName: Boolean;
  vFontType: TsgFontType;
  vFontStyles: TFontStyles;
  vTrimmed: Boolean;
  vHAlign: Byte;

  function GetInsideDimensionEx: Boolean;
  begin
    if AConverter.HeadVarStruct.Version < Byte(acR14) then
      Result := False
    else
      Result := GetInsideDimension;
  end;

  procedure InitializeParams(AMaxHeight: PDouble);
  var
    vUpsideDown: Boolean;
    vBackward: Byte;
  begin
    if GetInsideDimensionEx or GetInsideMText then
    begin
      vBackward := 0;
      vUpsideDown := False;
    end
    else
    begin
      vUpsideDown := UpsideDown;
      vBackward := Byte(Style.Backward) shl 1 + Byte(Backward);
    end;
    if vUpsideDown then
      vSign.Y := -1
    else
      vSign.Y := 1;
    case vBackward of
      0:
        begin
          vSign.X := 1;
          vSign.Z := -1;
        end;
      2:
        begin
          vSign.X := -1;
          vSign.Z := 1;
        end;
      else
      begin
        vSign.X := -1;
        vSign.Z := -1;
      end;
    end;
    if AMaxHeight <> nil then
      if vUpsideDown then
        AMaxHeight^ := (2 * FBox.Bottom - FBox.Top)
      else
        AMaxHeight^ := (FBox.Bottom + FBox.Top);
    FMatrix := cnstIdentityMat;
    if not Converter.IsCrossoverMatrix then
      FMatrix.M[1, 1] := -1;
    if ObliqueAngle <> 0 then
    begin
      try
        FMatrix.M[1, 0] := Tan(Radian(ObliqueAngle)) / Scale;
      except
        FMatrix := cnstIdentityMat;
      end;
    end;
  end;

  // ------------- try find unknown glyphs using drawing codepage -------------
  procedure UpdateTextGlyphByDrawingCodepage(var ATextGlyph: TsgTextGlyph);
  var
    K: Integer;
  begin
    K := 0;
    while (K <= High(FIndices)) and (FIndices[K] <> cnstInvalidGlyphIndex) do Inc(K);
    if (K <= High(FIndices)) and (ATextGlyph.CharSet = DEFAULT_CHARSET) and (AConverter.Charset <> DEFAULT_CHARSET) then
    begin
      if AConverter.Charset = ANSI_CHARSET then
        ATextGlyph := UpdateTextGlyph(ATextGlyph.FontName, ATextGlyph.FontStyle, Charset, FPitch)
      else
        ATextGlyph := UpdateTextGlyph(ATextGlyph.FontName, ATextGlyph.FontStyle, AConverter.Charset, FPitch);
      ATextGlyph.GetIndices(Text, vUnicodeText, FIndices);
      Properties.FFontGlyphRef := ATextGlyph;
    end;
  end;

  function TrimRenderContent: Boolean;
  var
    L, R: Integer;
    SB: TStringBuilder;
  begin
    Result := False;
    SB := TStringBuilder.{$IFNDEF SGDEL_7}CreateFromWideString{$ELSE}Create{$ENDIF}(FUnicodeText);
    try
      L := 0;
      //while (L < SB.Length) and IsSpace(SB.Chars[L]) do Inc(L);
      R := SB.Length - 1;
      while (R > L) and IsSpace(SB.Chars[R]) do Dec(R);
      if R >= L then
      begin
        FUnicodeText := SB.ToString(L, R - L + 1);
        FIndices := Copy(FIndices, L, R - L + 1);
        Result := (R - L + 1) < SB.Length;
      end
      else
      begin
        FUnicodeText := '';
        SetLength(FIndices, 0);
      end;
    finally
      SB.Free;
    end;
  end;
  
begin
  inherited LoadedInternal(AConverter);
  if FMText <> nil then
  begin
    FMText.Free;
    FMText := nil;
  end;
  SetDefaulParams(AConverter);
  if not InsideMText then
  begin
    FUnicodeText := '';
    if IsNotSetFontName then
      ChangeByStyle(Style);
  end;
  if AConverter.CheckUnicode then
  begin
    ReplaceAnsi(FText,'%%127', cnstQuestionMark);
    ReplaceAnsi(FText,'%%128', cnstEuro);
    ReplaceAnsi(FText,'%%176', cnstDegree);
    ReplaceAnsi(FText,'%%179', cnstQuestionMark);
    ReplaceAnsi(FText,'%%220', 'U');
    vDiamUni := (AnsiPos(cnstDiameterArialUni, Text) <> 0) or (AnsiPos(cnstDiameterUni, Text) <> 0);
  end
  else
    vDiamUni := False;
  if IsMText(vDiamUni) then
  begin
    CreateMText(AConverter);
    FStartPoint := FPoint;

    if not ((EntType = ceAttdef) and not TsgDXFAttdef(Self).Constant) then
      Exit;

  end;
  if Properties.BigFont <> '' then
    UpdateProperties(AConverter);
  vTrimmed := False;
  if not InsideMText then
  begin
    ParseUnicodeText2(AConverter.CodePage, FText, AConverter.GetSHXFont(Properties, False, InternalSHXFont, IsSHXFont),
      AConverter.GetSHXFont(Properties, True, SHXFont, IsSHXFont), True);
    if (FHAlign = 4) and (FVAlign = 0) and (EntType in [ceAttdef, ceAttrib]) then
      vTrimmed := TrimRenderContent;
  end;
{$IFDEF SGDEL_2009}
  if FUnicodeText = '' then
    FUnicodeText := FText;
{$ENDIF}
  if not HasSecond then
  begin
    FHAlign := 0;
    FVAlign := 0;
  end;
  FBox := BadRect;
  if ((Text='') and (UnicodeText='')) or (not InsideMText and (IsEmpty or (Text = '%%'))) then
    Exit;
  if (not WinFont) and AConverter.UseSHXFonts then
  begin
    S := Text;
    vFontName := SHXFont;
    if vFontName = '' then
      vFontName := Properties.GetPrimaryFontName;
    FillChar(vFontParams, SizeOf(TsgFontParams), 0);
    vWideStr := '';
    AConverter.GetSHXFont(Properties, Properties.BigFont <> '', vFontName);
    if IsUnicodeSHX(AConverter.FSHXFonts, Properties.FSHXStyle, vFontName) or (Properties.BigFont <> '') then
    begin
      if ((Length(S) = 1) and (PChar(S)^ = #$D8)) and (Properties.FontName = 'Symbol') then
        vWideStr := WideChar(8709)
      else
      begin
        if Length(Properties.BigFont) = 0 then
          vWideStr := FUnicodeText
      end;
{$IFNDEF SGDEL_2009}
      if (Style.BigFont = '') and (vWideStr = '') then
{$IFDEF SGFPC}
        vWideStr := WideString(S);
{$ELSE}
        if AConverter.CodePage <> 0 then
        begin
          vWideStr := StrToUnicode(AConverter.CodePage, S);
          if vWideStr = '' then vWideStr := ConvertToWideString(S, AConverter.CodePage);
        end
        else
          vWideStr := ConvertToWideString(S, AConverter.CodePage);
{$ENDIF}
{$ENDIF}
    end;
    vList := TsgSHXVertexList.Create;
    try
      GetSHXLinesI(AConverter.FSHXFonts, vList, vFontParams);
      if (vList.Count <> 0) and (vFontParams.Above <> 0) then
      begin
        if GetSHXBoxI(AConverter.FSHXFonts, vFontParams) then
        begin
          if vFontParams.Above <> 0 then
            vSy := Height / vFontParams.Above
          else
            vSy := 1;
          FBox := MakeFRect(vFontParams.Left * vSy, vFontParams.Top * vSy, 0,
            vFontParams.Right * vSy, vFontParams.Bottom * vSy, 0);
          InitializeParams(@vMaxHeight);
          vHAlign := FHAlign;
          if vTrimmed then
            FHAlign := 0;
          if Expand(vFontParams.Width * vSy * vSign.X, Height * vSign.Y, vMaxHeight, vSign) then
            InitializeParams(nil);
          if vTrimmed then
            FHAlign := vHAlign;
          FMatrix := FMatScale(FMatrix, MakeFPoint(Scale, 1, 1));
          FMatrix := FMatXMat(FMatrix, MatFromExtr(Extrusion, vSign.X*vSign.Y*FRotation));
          FMatrix := FMatXMat(FMatrix, StdMat(MakeFPoint(vSign.X, vSign.Y, 1), FStartPoint));
          TransRectCorners(FBox, FMatrix);
        end;
      end;
    finally
      vList.Free;
    end;
  end;
  vFontName := Properties.FontName;
  if WinFont or IsBadRect(FBox) then// Box for TrueType Fonts
  begin
{$IFNDEF SGDEL_2009}
    if (FUnicodeText = '') and not (((Length(FText) = 1) and (PChar(FText)^ = #$D8)) and (vFontName = 'Symbol')) then
    begin
{$IFDEF SGFPC}
      FUnicodeText := WideString(FText);
{$ELSE}
      if AConverter.CodePage <> 0 then
      begin
        FUnicodeText := StrToUnicode(AConverter.CodePage, FText);
        if FUnicodeText = '' then FUnicodeText := ConvertToWideString(FText, AConverter.CodePage);
      end
      else
        FUnicodeText := ConvertToWideString(FText, AConverter.CodePage);
      {FUnicodeText := AConverter.ConvertToCodePage(FText);
      if Length(FUnicodeText) = Length(FText) then
      begin
        FText := FUnicodeText;
        FUnicodeText := '';
      end;}
{$ENDIF}
    end;
{$ENDIF}
    // imImport - nonunicode import mode
    if AConverter.CheckUnicode and (FUnicodeText <> '') then
    begin
{$IFNDEF UNICODE}
      if FUnicodeText <> wcDiameterUni then
        FText := ''
      else
{$ENDIF}
      begin
        FText := string(FUnicodeText);
        FUnicodeText := '';
      end;
    end;
    vFontStyles := MVFontStylesToFontStyles(Properties.FontStyle);
    if InsideMText or (Style.FontName = '') then
    begin
      vUseDefaultFontName := UseDefaultFontName;
      if not InsideMText then
        vFontName := Style.GetPrimaryFontName;
      if (Length(vFontName) > 0) then
      begin
        vFontType := GetFontTypeByFileNameExt(vFontName);
        case vFontType of
          ftTTF, ftTTC, ftOTF:
            begin
              vFontName := GetFontNameByFileName(vFontName, vFontStyles);
              if Length(vFontName) > 0 then
              begin
                Properties.FontStyle := FontStylesToMVFontStyles(vFontStyles);
                if (not InsideMText) and (Length(Style.FontName) > 0) then
                  vFontName := Style.FontName
              end
              else
                vFontName := Style.FontName;
            end;
          ftFON: vUseDefaultFontName := True;
        else
          if InsideMText then
          begin
            if IsSystemNotRasterFontEx(vFontName) <> 1 then
            begin
              vFontFileName := GetFileNameByFontName(vFontName, vFontStyles);
              if (vFontFileName = '') or (GetFontTypeByFileNameExt(vFontFileName) = ftFON) then
                vUseDefaultFontName := True;
            end;
          end
          else
          begin
            if vFontType = ftSHX then
              SetLength(vFontName, Length(vFontName) - 4);
            if IsNotTTFFont(vFontName) then
              vUseDefaultFontName := True;
          end;
          if vUseDefaultFontName then
          begin
            vAlternateTrueFaceFromShapeFilename := ChangeFileExt(Style.PrimaryFont, '');
            if ContainerOfTextGlyphs.IsFontValid(vAlternateTrueFaceFromShapeFilename, vFontStyles) then
            begin
              vFontName := vAlternateTrueFaceFromShapeFilename;
              vUseDefaultFontName := False;
            end;
          end;
        end;
      end
      else
        vUseDefaultFontName := True;
      UseDefaultFontName := vUseDefaultFontName;
      if vUseDefaultFontName then
        vFontName := AConverter.DoFindFont(Self, False, vFontName);
    end;
    if (Style.BigFont <> '') and (FUnicodeText <> '') and IsNotTTFFont(vFontName) then
      vFontName := AConverter.DoFindFont(Self, True, vFontName);// only for big fonts
    vTextGlyph := UpdateTextGlyph(vFontName, vFontStyles, Charset, FPitch);
    Properties.FFontGlyphRef := vTextGlyph;
    if Length(FUnicodeText) > 0 then
    begin
      vIndex := WideStrScan(FUnicodeText, wcDiameterUni);
      if vIndex > 0 then
      begin
      {$IFNDEF SG_FIREMONKEY}
        if vTextGlyph.GetIndex(wcDiameterUni) = cnstInvalidGlyphIndex then
      {$ENDIF}
        begin
          repeat
            FUnicodeText[vIndex] := wcDiametr;
            vIndex := WideStrScan(FUnicodeText, wcDiameterUni);
          until vIndex < 1;
        end;
      end;
    end;
    FText := AdsorbAccentSpaces(FText);
{$IFNDEF SG_NON_WIN_PLATFORM}
    if Win32Platform <> VER_PLATFORM_WIN32_NT then
    begin
{$ENDIF}
      vUnicodeText := '';
      if Length(FUnicodeText) > 0 then
        FText := string(FUnicodeText);
{$IFNDEF SG_NON_WIN_PLATFORM}
    end
    else
      vUnicodeText := FUnicodeText;
{$ENDIF};
    vTextGlyph.GetIndices(Text, vUnicodeText, FIndices);
    UpdateTextGlyphByDrawingCodepage(vTextGlyph);
// ------------- acad draw ascii glyphs using default(may be ansi?) charset -------------
    K := 0;
    while (K <= High(FIndices)) and (FIndices[K] <= 127) do Inc(K);
    if (K > High(FIndices)) and (vTextGlyph.CharSet <> DEFAULT_CHARSET) then
    begin
      vTextGlyph := UpdateTextGlyph(vTextGlyph.FontName, vTextGlyph.FontStyle, DEFAULT_CHARSET, FPitch);
      vTextGlyph.GetIndices(Text, vUnicodeText, FIndices);
      Properties.FFontGlyphRef := vTextGlyph;
    end;
    vFirstGlyph := vTextGlyph.LoadedW(Text, vUnicodeText);
    vScaleHeight := vTextGlyph.HKoef * Height;
    InitializeParams(nil);
    FMatrix := FMatScale(FMatrix, MakeFPoint(Scale * vScaleHeight, vScaleHeight, 1));
    FBox := vTextGlyph.GetBoxW(Text, vUnicodeText, FMatrix, nil, Tracking);
    vWidth := FBox.Right - FBox.Left; //vHeight := FBox.Top - FBox.Bottom;
    if Abs(Scale) > fAccuracy then
      vWidth := vWidth / Scale;
    vHeight := Height;
    if Assigned(vFirstGlyph) then
      FTextOrigin := vFirstGlyph.BlackBox.Left
    else
      FTextOrigin := 0;
    if Expand(vSign.X * vWidth, vSign.Y * Height, Height, vSign) then
    begin
      InitializeParams(nil);
      FMatrix := FMatScale(FMatrix, MakeFPoint(Scale * vScaleHeight, vScaleHeight, 1));
    end;
    if (vHeight <> Height) and (Height <> 0) then
      FMatrix := FMatScale(FMatrix, Height/vHeight);
    FMatrix := FMatXMat(FMatrix, MatFromExtr(Extrusion, vSign.X*vSign.Y*Rotation));
    FMatrix := FMatXMat(FMatrix, StdMat(MakeFPoint(vSign.X, vSign.Y, 1), FStartPoint));
    if FTextParse <> nil then
      FBox := vTextGlyph.GetBoxW(Text, vUnicodeText, FMatrix, @FTextParse^.FontParams, Tracking)
    else
      FBox := vTextGlyph.GetBoxW(Text, vUnicodeText, FMatrix, nil, Tracking);
  end;
end;

{$IFNDEF UNICODE}
{$IFDEF SGFPC}
{$IFDEF HAS_FEATURE_ENCODING}
{$DEFINE SG_NEED_CONVERT_TO_WIDESTRING}
{$ENDIF}
{$ENDIF}
{$ENDIF}

procedure TsgDXFText.ParseUnicodeText(const AConverter: TsgDXFConverter;
  const AText: string);
var
  I, vLength, vLengtCode, vNumber: Integer;
  vCode: string;
  vAdd: Boolean;
  WCh, vSymbol: WideChar;
{$IFDEF SG_NEED_CONVERT_TO_WIDESTRING}
  S: UnicodeString;
{$ENDIF}
begin
  I := 1;
{$IFDEF SG_NEED_CONVERT_TO_WIDESTRING}
  S := UnicodeString(AText);
  vLength := Length(S);
{$ELSE}
  vLength := Length(AText);
{$ENDIF}
  while I <= vLength do
  begin
    vAdd := True;
{$IFDEF SG_NEED_CONVERT_TO_WIDESTRING}
    WCh := WideChar(S[I]);
{$ELSE}
    WCh := WideChar(AText[I]);
{$ENDIF}
    case WCh of
      '\':
        begin
          vLengtCode := TsgUnicodeParser.ReadUnicode(AText, I, vCode);
          if vLengtCode > 0 then
          begin
            vAdd := False;
            vNumber := 0;
            if vLengtCode <> 4 then
            begin
              vNumber := StrToIntDef(vCode[1], cnstExtWideChar);
              Delete(vCode, 1, 1);
            end;
            vSymbol := GetSymbolFromMultibyte(AConverter,
              StringHexToIntDef(Copy(vCode, 1, 2), 0),
              StringHexToIntDef(Copy(vCode, 3, 2), 0),
              vNumber, (vLengtCode <> 5), False);
            FUnicodeText := FUnicodeText + vSymbol;
            Inc(I, 3 + vLengtCode);
          end;
        end;
      '%':
        begin
          vLengtCode := TsgUnicodeParser.ReadPercent(AText, I, vCode);
          if (vLengtCode > 0) then
          begin
            if Length(vCode) > 0 then
              FUnicodeText := FUnicodeText + vCode;
            vAdd := False;
            Inc(I, vLengtCode);
          end;
        end;
    end;
    if vAdd then
    begin
      Inc(I);
      FUnicodeText := FUnicodeText + WCh;
    end;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFText.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
var
  S: string;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  if EntType = ceText then//only text
  begin
    S := Text;
    if (Pos(#1, S) > 0) or (Pos(#3, S) > 0) then
      PluginsReplaceAnsis(S);
    ANode.ChildValues[sPlcKeyWords[plcText].Name] := S;
  end;
end;
{$ENDIF}

procedure TsgDXFText.ParseUnicodeText2(const ACodePage: Integer;
  const AText: string; const AFont, ABigFont: TsgSHXFont;
  const AParsePercentSymbols: Boolean);
type
  TWordArray = array of Word;
var
  vParser: TsgUnicodeParser;
begin
  FUnicodeText := '';
  if Assigned(AFont) and ((Assigned(ABigFont) or IsSHXFont or (not Assigned(Converter)))) then
  begin
    vParser := TsgUnicodeParser.Create(AText, ACodePage, AFont, ABigFont);
    try
      vParser.Execute(AParsePercentSymbols);
      FUnicodeText := vParser.Unicode;
      FSHXMap := vParser.SHXMap;
      TWordArray(FIndices) := TWordArray(vParser.FIndices);
      if vParser.FHasUndefinedUnicodeSymbol then
        WinFont := True;
    finally
      vParser.Free;
    end;
  end
  else
    ParseUnicodeText(Converter, AText);
end;

procedure TsgDXFText.DoNewText(const ANewText: string);
begin
  if Assigned(Converter) then
  begin
    if not (CompareStr(FText, ANewText) = 0) then
    begin
      FText := ANewText;
      self.Loaded(Converter);
    end;
  end;
end;

procedure TsgDXFText.SetBackward(const AValue: Boolean);
begin
  Properties.Backward := AValue;
end;

procedure TsgDXFText.SetDefaulParams(AConverter: TsgDXFConverter);
begin
  if Height <= 0 then//for default value as autocad
    Height := AConverter.HeadVarStruct.TextSize;
  //WinFont := True;
  if Style = nil then
    SetStyle(AConverter.StyleByName(sStandardName));
  if Layer = nil then
    Layer := AConverter.LayerByName('0');
end;

procedure TsgDXFText.SetExtrusion(const Value: TFPoint);
begin
  FExtrusion := Value;
end;

procedure TsgDXFText.SetFontName(const AFontName: string; AStyles: TFontStyles);
var
  vFontType: TsgFontType;
  vFileName: string;
begin
  if Length(AFontName) > 0 then
  begin
    Include(FInternalFlags, itfSetFontName);
    vFontType := GetFontTypeByFileNameExt(AFontName);
    case vFontType of
      ftUndefined:
        begin
          vFileName := GetFileNameByFontName(AFontName, AStyles);
          if vFileName <> '' then
            SetTTFFont(AFontName, AStyles)
          else
            SetSHXFont(AFontName);
        end;
      ftTTF, ftTTC, ftFON:SetTTFFont(AFontName, AStyles);
    else
      SetSHXFont(AFontName);
    end;
  end
  else
    Exclude(FInternalFlags, itfSetFontName);
end;

procedure TsgDXFText.SetInsideDimension(const AValue: Boolean);
begin
  SetInternalFlag(itfInsideDimension, AValue);
end;

procedure TsgDXFText.SetInsideMText(const AValue: Boolean);
begin
  SetInternalFlag(itfInsideMText, AValue);
end;

procedure TsgDXFText.SetInternalFlag(const AInternalFlag: TsgInternalTextFlag; const AValue: Boolean);
begin
  if AValue then
    Include(FInternalFlags, AInternalFlag)
  else
    Exclude(FInternalFlags, AInternalFlag);
end;

procedure TsgDXFText.SetInternalTextFlags(const AValue: TsgInternalTextFlags);
begin
  FInternalFlags := AValue;
end;

procedure TsgDXFText.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgDXFText.SetIsSHXFont(const AValue: Boolean);
begin
  WinFont := not AValue;
end;

procedure TsgDXFText.SetUseDefaultFontName(const AValue: Boolean);
begin
  SetInternalFlag(itfUseDefaultFont, AValue);
end;

procedure TsgDXFText.SetTTFFont(const AFontName: string; AStyles: TFontStyles);
var
  vFontType: TsgFontType;
begin
  if Length(AFontName) > 0 then
  begin
    vFontType := GetFontTypeByFileNameExt(AFontName);
    if vFontType <> ftSHX then
    begin
      WinFont := True;
      if vFontType <> ftUndefined then
        Properties.FontName := GetFontNameByFileName(AFontName, AStyles)
      else
        Properties.FontName := AFontName;
      Include(FInternalFlags, itfSetFontName);
    end;
  end;
end;

procedure TsgDXFText.SetWinFont(const AValue: Boolean);
begin
  SetInternalFlag(itfWinFont, AValue);
end;

procedure TsgDXFText.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
begin
  if not IsInvoke(AConverter) then
    Exit;
  if (MText = nil) or ((EntType = ceAttdef) and not TsgDXFAttdef(Self).Constant) then
    Proc(Self)
  else
    MText.Invoke(AConverter,Proc, FinishProc);
end;

procedure TsgDXFText.SetGeneration(const Value: Byte);
begin
  Properties.TextGenFlags := Value;
end;

function TsgDXFText.GetAnsiText(const AText: string; ACodePage: Integer): sgRawByteString;
begin
{$IFDEF SGDEL_2009}
    Result := ConvertToAnsiString(AText, ACodePage)
{$ELSE}
    Result := AText;
{$ENDIF}
end;

function TsgDXFText.GetBackward: Boolean;
begin
  Result := Properties.Backward;
end;

function TsgDXFText.GetGeneration: Byte;
begin
  Result := 2 * Ord(Backward) + 4 * Ord(UpsideDown);
end;

function TsgDXFText.GetInsideDimension: Boolean;
begin
  Result := itfInsideDimension in FInternalFlags;
end;

function TsgDXFText.GetInsideMText: Boolean;
begin
  Result := itfInsideMText in FInternalFlags;
end;

function TsgDXFText.GetInternalSHXFont: string;
begin
  Result := '';
  if not WinFont then
  begin
    Result := ChangeFileExt(Properties.PrimaryFont, cnstSHXFontExt);
    if Result = cnstSHXFontExt then
      Result := ChangeFileExt(Properties.FontName, cnstSHXFontExt);
  end;
end;

function TsgDXFText.GetFFontName: string;
begin
  Result := Properties.FFontName;
end;

function TsgDXFText.GetFontName: string;
begin
  if (Style = nil) or InsideMText then
    Result := Properties.FontName
  else
    Result := Style.GetPrimaryFontName;
end;

function TsgDXFText.GetFontStyle: TmvFontStyles;
begin
  if (Style = nil) or InsideMText then
    Result := Properties.FontStyle
  else
    Result := Style.FontStyle
end;

function TsgDXFText.GetIsSHXFont: Boolean;
begin
  Result := not WinFont;
end;

function TsgDXFText.GetSymbolFromMultibyte(const AConverter: TsgDXFConverter;
  const ALeft, ARight: Byte; const ANumber: Integer;
  const AUnicodeAlways: Boolean; const ACheckByNumber: Boolean = True): WideChar;
var
  vText: TsgDXFText;
begin
   if AUnicodeAlways or (not WinFont and AConverter.UseSHXFonts) then
     Result := WideChar((ALeft shl 8) or ARight)
   else   { \M+ }
   begin
     Result := GetMultibyteSymbol(ALeft, ARight, ANumber);
     if ACheckByNumber and Assigned(Converter) and (ANumber <> 0) then
     begin
       vText := TsgDXFText.Create;
       try
         vText.AssignEntity(Self);
          vText.Text := '\M+' + IntToStr(ANumber) + IntToHex(ALeft, 2) + IntToHex(ARight, 2);
         vText.ParseUnicodeText2(Converter.CodePage, vText.Text, Converter.GetSHXFont(vText.Properties, False, vText.SHXFont),
           Converter.GetSHXFont(vText.Properties, True, vText.SHXFont), False);
         if Length(vText.FUnicodeText) > 0 then
           Result := vText.FUnicodeText[1];
       finally
         vText.Free
       end;
     end;
   end;
end;

function TsgDXFText.GetUnicodeText: WideString;
begin
  Result := FUnicodeText;
end;

function TsgDXFText.GetUpsideDown: Boolean;
begin
  if Style <> nil then
    Result := Properties.UpsideDown or Style.UpsideDown
  else
    Result := Properties.UpsideDown
end;

function TsgDXFText.GetWinFont: Boolean;
begin
  Result := itfWinFont in FInternalFlags;
end;

function TsgDXFText.SHXMatrix: TFMatrix;
begin
  Result := FMatrix;
end;

function TsgDXFText.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlHeight].Name).ValueData,
    Height, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlRotation].Name).ValueData,
    Rotation, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlWidthFactor].Name).ValueData,
    XScale, xmlForViewing in AParams.Mode); // Single
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlObliqueAngle].Name).ValueData,
    ObliqueAngle, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlText].Name).ValueAsStr := Text;
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPoint1].Name).ValueData,
    FPoint1, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlHAlign].Name).ValueAsInt := HAlign;
  ANode.AddAttribNV(cnstXMLNames[xmlVAlign].Name).ValueAsInt := VAlign;
  if IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlStyleName].Name)
  else
    if Assigned(Style) then
      ANode.AddAttribNV(cnstXMLNames[xmlStyleName].Name).ValueAsStr := Style.Name;
  if itfInsideMText in FInternalFlags then
    ANode.AddAttribNV(cnstXMLNames[xmlFontName].Name).ValueAsStr := GetFontName;
end;

procedure TsgDXFText.UpdateProperties(AConverter: TsgDXFConverter);
begin
  if not Assigned(Properties.FSHXStyle) and Assigned(AConverter) then
    Properties.LoadedInternal(AConverter);
end;

procedure TsgDXFText.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FMText);
  DisposeAndNil(FTextParse);
  FreeAndNil(FTextStyleItem);
  FreeAndNil(FPropertiesItem);
end;

function TsgDXFText.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlHeight: Height := ANode.ValueAsDouble;
    xmlRotation: Rotation := ANode.ValueAsDouble;
    xmlObliqueAngle: ObliqueAngle := ANode.ValueAsDouble;
    xmlText: Text := ANode.ValueAsStr;
    xmlStyleName: Style := Converter.StyleByName(ANode.Value);
    xmlWidthFactor: XScale := ANode.ValueData.ValueAsSingle;
    xmlPoint1: FPoint1 := ANode.ValueData.ValueAsFPoint;
    xmlHAlign: HAlign := ANode.ValueData.ValueAsInt;
    xmlVAlign: VAlign := ANode.ValueData.ValueAsInt;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFText.GetThicknessInt: Double;
begin
  Result := cnstThicknessDefault;
end;

procedure TsgDXFText.SetExtData(const AData: TsgCADExtendedData);
begin
  SetExtDataHyperLink(AData);
end;

procedure TsgDXFText.SetLWeight(Value: Integer);
begin
  if FLineWeight = 0 then FLineWeight := Value / 100;
end;

function TsgDXFText.GetIsUnicodeText: Boolean;
begin
  Result := (FUnicodeText <> '');
end;

function TsgDXFText.GetEntType: TsgCADEntities;
begin
  Result := ceText;
end;

function TsgDXFText.GetExtrusion: TFPoint;
begin
  Result := FExtrusion;
end;

function TsgDXFText.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgDXFText.GetIsEmpty: Boolean;
begin
  Result := (Trim(Text) = '') and (Trim(UnicodeText) = '');
end;

procedure TsgDXFText.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AChangeList) then
    begin
      AChangeList.Add(Integer(xmlText));
    end;
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlHAlign));
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
      AHideList.Add(Integer(xmlPoint1));
      AHideList.Add(Integer(xmlVAlign));
    end;
  end;
end;

function TsgDXFText.GetXScale: Single;
begin
  Result := Properties.WidthFactor;
end;

procedure TsgDXFText.SetXScale(const Value: Single);
begin
  Properties.WidthFactor := Value;
end;

function TsgDXFText.GetOblique: Single;
begin
  Result := Properties.ObliqueAngle;
end;

{ TsgDXFMText }

procedure TsgDXFMText.AddBackground(const AConverter: TsgDXFConverter);
var
  vBox: TFRect;
  vWidth, vExpand: Double;
  vSolid: TsgDXFSolid;
begin
  if HasBackgroundColor then
  begin
    Block.Loaded(AConverter);
    Block.IsLoaded := False;
    vBox := Block.Box;
    if RectWidth > 0 then
    begin
      vWidth := vBox.Right - vBox.Left;
      if vWidth < RectWidth then
        vBox.Right := vBox.Left + RectWidth;
    end;
    if (FBackgroundScaleFactor >= 1) and (FBackgroundScaleFactor <= 5) then
    begin
      vExpand := Height * (FBackgroundScaleFactor - 1);
      InflateFRect(@vBox, vExpand, vExpand, 0);
    end;
    vSolid := TsgDXFSolid.Create;
    Block.InsertEntity(0, vSolid);
    vSolid.Point := vBox.TopLeft;
    vSolid.Point1 := MakeFPoint(vBox.Right, vBox.Top, vBox.Z1);
    vSolid.Point2 := MakeFPoint(vBox.Left, vBox.Bottom, vBox.Z2);
    vSolid.Point3 := vBox.BottomRight;
    vSolid.ColorCAD := BackgroundColor;
    vSolid.Layer := Layer;
    AConverter.Loads(vSolid);
  end;
end;

function TsgDXFMText.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := (AAppID = sACADXDataAppName) and (AData.Version <= acR2000);
  if Result then
    AData.AddString(String_1001, sACADXDataAppName);
end;

procedure TsgDXFMText.ClearReferences;
begin
  inherited ClearReferences;
  Style := nil;
end;

constructor TsgDXFMText.Create;
begin
  inherited Create;
  FAlign := 1;
  FPoint1 := cnstFPointIllegal;
  Block := TsgDXFBlock.Create;
  FLineSpacingFactor := 1;
  FLineSpacingStyle := 1;// at least (taller characters will override)
  FBackgroundScaleFactor := 1.5;
  FBackgroundTransparency := cnstBackgroundTransparencyDefault;//test!
  FTextStyleItem := TsgTableItem.Create;
end;

destructor TsgDXFMText.Destroy;
begin
  inherited Destroy;
end;

procedure TsgDXFMText.AssignEntity(Source: TsgDXFEntity);
var
  vMText: TsgDXFMText absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFMText then
  begin
    FAlign := vMText.FAlign;
    Block.Clear;
    FHeight := vMText.Height;
    FPoint1 := vMText.FPoint1;
    FLineSpacingFactor := vMText.FLineSpacingFactor;
    FRectWidth := vMText.FRectWidth;
    Style := vMText.Style;
    FLineSpacingStyle := vMText.FLineSpacingStyle;
    FText := vMText.FText;
    FLineWeight := vMText.FLineWeight;
    FBackgroundFlags := vMText.FBackgroundFlags;
    FBackgroundScaleFactor := vMText.FBackgroundScaleFactor;
    FBackgroundColor := vMText.FBackgroundColor;
    FBackgroundTransparency := vMText.FBackgroundTransparency;
  end;
end;

function TsgDXFMText.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := inherited GetExtData(AData, AAppID);
  if not Result and BeginExtData(AData, AAppID) then
  begin
    AData.AddString(String_1000, cnstMTextBegin);
    AData.AddComplexInt16(Integer_73, LineSpacingStyle);
    AData.AddComplexDouble(Float_44, LineSpacingFactor);
    AData.AddString(String_1000, cnstMTextEnd);
    if HasBackgroundColor then
    begin
      AData.AddString(String_1000, cnstAcadMtextBBRT);
      AData.AddComplexInt32(Integer_90 + 1, BackgroundFlags);
      AData.AddComplexDouble(Float_45 + 1, BackgroundScaleFactor);
      AData.AddComplexInt32(Integer_63 + 1, ColorCADToCmEntityColor(BackgroundColor));
      AData.AddComplexString(Integer_64 + 1, BackgroundColor.AlbumString);
      AData.AddComplexString(Integer_65 + 1, '');
      AData.AddComplexInt32(Integer_441 + 1, BackgroundTransparency);
      AData.AddString(String_1000, cnstAcadMtextBERT);
    end;
    EndExtData(AData);
    Result := True;
  end;
end;

function TsgDXFMText.EntName: string;
begin
  Result := inherited EntName + ' ' + FText;
end;

function TsgDXFMText.HasSecond: Boolean; // is the second alignment point must be used
begin
  Result := (Point1.X <> cnstIllegal) and (Point1.Y <> cnstIllegal);
end;

function TsgDXFMText.IsAngleBySecondPoint: Boolean;
begin
  Result := HasSecond and not CompareMem(@FPoint1, @FExtrusion, SizeOf(FPoint1));
end;

procedure TsgDXFMText.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFMText.LoadedInternal(AConverter: TsgDXFConverter);
var
  X, Y, vAngle: Double;
  vExtrusion: TFPoint;
begin
  if Style = nil then
    Style := AConverter.StyleByName(sStandardName);
  Block.Clear;
  Block.IsLoaded := False;
  if Parsing(AConverter, nil, cnstColorCADByLayer, 0, Align) then
  begin
    AddBackground(AConverter);
    Block.IsLoaded := False;
    Block.Loaded(AConverter);
    X := Block.Box.Right - Block.Box.Left;
    Y := Block.Box.Top - Block.Box.Bottom;
    if X < RectWidth then
      X := RectWidth;
    Block.FOffset := cnstFPointZero;
    case Align of
      2, 5, 8: Block.FOffset.X := X / 2;
      3, 6, 9: Block.FOffset.X := X;
      10:{new} Block.FOffset.X := 0;
    end;
    case Align of
      4, 5, 6: Block.FOffset.Y := 0.5 * (Block.FBox.Top + Block.FBox.Bottom);//Block.FOffset.Y := -Y / 2;
      7, 8, 9: Block.FOffset.Y := Block.Box.Bottom;
      10:{new} Block.FOffset.Y := -Y / 2 - Height / 2;
    end;
    if Layer = nil then
      Layer := AConverter.LayerByName('0');
    vAngle := GetRealAngle(@vExtrusion);
    FMatrix := FMatXMat(StdMat(Scale, Reverse(GetBlockOffset)),
      MatFromExtr(vExtrusion, vAngle));
    FMatrix := FMatTranslate(FMatrix, Point);
    FBox := Block.FBox;
    if not IsBadRect(FBox) then
      TransRectCorners(FBox, FMatrix);
  end
  else
    FBox := cnstBadRect;
end;

function TsgDXFMText.Parsing(const AConverter: TsgDXFConverter; AList: TsgEntitiesList;
  const AColor: TsgColorCAD; ASize: Double; const AAlign: Byte): Boolean;
var
  vMTextParser: TsgMTextParser;
begin
  vMTextParser := TsgMTextParser.Create(AConverter);
  try
    vMTextParser.FCells := AList;
    vMTextParser.FCellColor := AColor;
    vMTextParser.FCellSize :=  ASize;
    vMTextParser.FAlign := AAlign;
    Result := vMTextParser.Parse(Self, Self.Block);
  finally
    vMTextParser.Free;
  end;
end;

procedure TsgDXFMText.ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord);
begin
  // do nothing, MText must use only self created block
end;

procedure TsgDXFMText.SetExtData(const AData: TsgCADExtendedData);
var
  J: Integer;
  vMText, vMTextEnd, vMTextBk, vMTextBkEnd: Integer;

  function MarkerIs(const AMarker: string; I, AOffs: Integer; var ADataIndex: Integer): Boolean;
  begin
    Result := False;
    if ADataIndex = AData.DataCount then
      if sgSameText(AData.DataString[I], AMarker) then
      begin
        ADataIndex := I + AOffs;
        Result := True;
      end;
  end;

  procedure ApplyProps(AFirstIndex, ALastIndex, ACodeShift: Integer);
  var
    I: Integer;
    vCode: SmallInt;
  begin
    I := AFirstIndex;
    while (I < AData.DataCount) and (I <= ALastIndex) do
    begin
      if TsgCADExtendedDataAccess(AData).GetCodeFor(I, vCode) then
      begin
        case vCode - ACodeShift of
          Integer_73: LineSpacingStyle := AData.DataInt16[I];
          Float_44: LineSpacingFactor := AData.DataDouble[I];
          Integer_74:; //??

          Integer_90: BackgroundFlags := AData.DataInt[I];
          Float_45: BackgroundScaleFactor := AData.DataDouble[I];
          Integer_63: BackgroundColor := CmEntityColorToColorCAD(AData.DataInt[I]);
          Integer_64: BackgroundColor := MakeColorCAD(BackgroundColor.Active, BackgroundColor.Color, AData.DataString[I]);
          Integer_65:; //?? block name
          Integer_441: BackgroundTransparency := AData.DataInt[I];
        end;
        Inc(I);
      end;
      Inc(I);
    end;
  end;

begin
  if Assigned(AData) and AData.IsEqualName(sACADXDataAppName) then
  begin
    J := 1;
    vMText := AData.DataCount;
    vMTextEnd := AData.DataCount;
    vMTextBk := AData.DataCount;
    vMTextBkEnd := AData.DataCount;
    repeat
      if (AData.DataType[J] = edtString) and (AData.DataCode[J] = String_1000) then
        if not MarkerIs(cnstMTextBegin, J, +2, vMText) then
          if not MarkerIs(cnstMTextEnd, J, -1, vMTextEnd) then
            if not MarkerIs(cnstAcadMTextBBRT, J, +2, vMTextBk) then
              MarkerIs(cnstAcadMTextBBRT, J, -1, vMTextBkEnd);
      Inc(J);
    until J >= AData.DataCount;
    ApplyProps(vMText, vMTextEnd, 0);
    ApplyProps(vMTextBk, vMTextBkEnd, 1);
  end;
end;

procedure TsgDXFMText.SetLWeight(Value: Integer);
begin
  if FLineWeight = 0 then FLineWeight := Value / 100;
end;

procedure TsgDXFMText.SetRectWidth(const Value: Single);
begin
  FRectWidth := Value;
end;

function TsgDXFMText.GetThicknessInt: Double;
begin
  Result := cnstThicknessDefault;
end;

procedure TsgDXFMText.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlBlockName));
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
      AHideList.Add(Integer(xmlFPointScale));
    end;
  end;
end;

function TsgDXFMText.GetHeight: TsgFloat;
begin
  Result := FHeight;
end;

function TsgDXFMText.GetRealAngle(const AExtrusion: PFPoint): Double;
var
  vExtrusion, vPt, vPoint1: TFPoint;

  function GetSecondPoint(var APoint1: TFPoint): Boolean;
  begin
    Result := IsAngleBySecondPoint;
    if not Result and (Extruded(Extrusion) and not IsEqualFPoints(Extrusion, cnstXOrtAxis)) then
    begin
      APoint1 := cnstXOrtAxis;
      Result := True;
    end
    else
      APoint1 := FPoint1;
  end;

begin
  Result := Angle;
  vExtrusion := Extrusion;
  if GetSecondPoint(vPoint1) then
  begin
    vPt := sgFunction.Vector(FExtrusion, vPoint1);
    vExtrusion := sgFunction.Vector(vPoint1, vPt);
    vPt := vPoint1;
    DoPreExtrusion(vPt, vExtrusion);
    Result := Degree(ArcTan2(vPt.Y, vPt.X));
  end;
  if AExtrusion <> nil then
    AExtrusion^ := vExtrusion;
end;

function TsgDXFMText.GetRectWidth: Single;
begin
  Result := FRectWidth;
end;

function TsgDXFMText.HasBackgroundColor: Boolean;
begin
  Result := FBackgroundFlags <> 0;
end;

procedure TsgDXFMText.SetHeight(AValue: TsgFloat);
begin
  FHeight := AValue;
end;

procedure TsgDXFMText.SetHyphenation(const AValue: Boolean);
begin
  FHyphenation := AValue;
end;

function TsgDXFMText.GetStyle: TsgDXFStyle;
begin
  Result := TsgDXFStyle(FTextStyleItem.Item);
end;

procedure TsgDXFMText.SetStyle(AValue: TsgDXFStyle);
begin
  FTextStyleItem.Item := AValue;
end;

function TsgDXFMText.GetText: string;
begin
  Result := FText;
end;

function TsgDXFMText.GetTextStyleInternal: Pointer;
begin
  Result := Style;
end;

procedure TsgDXFMText.SetTextValue(AValue: string);
begin
  FText := AValue;
end;

procedure TsgDXFMText.SetThicknessInt(const AValue: Double);
begin
end;

function TsgDXFMText.ToXMLGeoData(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  vNodeAngle: TsgNodeSample;
begin
  Result := inherited ToXMLGeoData(ANode, AParams);
  if IsAngleBySecondPoint then
  begin
    vNodeAngle := ANode.GetAttributeByName(cnstXMLNames[xmlAngle].Name);
    if Assigned(vNodeAngle) then
      vNodeAngle.ValueAsDouble := GetAngleInsp
    else
      ANode.AddAttribNV(cnstXMLNames[xmlAngle].Name).ValueAsDouble := GetAngleInsp;
  end;
end;

function TsgDXFMText.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsXMLHelp(AParams.Mode) then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlPoint1].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlStyleName].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlBackgroundFlags].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlBackgroundColor].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlScale].Name);
    ANode.AddAttribNV(cnstXMLNames[xmlTransparency].Name);
  end
  else
  begin
    if HasSecond then
      ANode.AddAttribNV(cnstXMLNames[xmlPoint1].Name).ValueAsFPoint := Point1
    else
    begin
      if IsFullProps(AParams.Mode) then
        ANode.AddAttribNV(cnstXMLNames[xmlPoint1].Name).ValueAsFPoint := cnstFPointIllegal;
    end;
    if Assigned(Style) then
      ANode.AddAttribNV(cnstXMLNames[xmlStyleName].Name).ValueAsStr := Style.Name;
  end;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlHeight].Name).ValueData,
    Height, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlRectWidth].Name).ValueData,
    RectWidth, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlAlign].Name).ValueAsInt := Align;
  ANode.AddAttribNV(cnstXMLNames[xmlTextValue].Name).ValueAsStr := Text;
  if HasBackgroundColor then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlBackgroundFlags].Name).ValueData.ValueAsByte := FBackgroundFlags;
    ANode.AddAttribNV(cnstXMLNames[xmlBackgroundColor].Name).ValueData.ValueAsColorCAD := FBackgroundColor;
    ANode.AddAttribNV(cnstXMLNames[xmlScale].Name).ValueAsDouble := FBackgroundScaleFactor;
    ANode.AddAttribNV(cnstXMLNames[xmlTransparency].Name).ValueAsInt := FBackgroundTransparency;
  end;
  if (xmAddSubEntities in AParams.Mode) and Assigned(Block) then
    Block.ToXMLSubEntities(ANode, AParams);
end;

procedure TsgDXFMText.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FTextStyleItem);
end;

function TsgDXFMText.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vPoint: TFPoint;
begin
  // Block exist
  if AType.Id = xmlBlockName then
  begin
    Result := cnstXML_OK;
    Exit;
  end;

  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlAlign:  Align := ANode.ValueAsInt and $FF;
    xmlHeight: Height := ANode.ValueAsDouble;
    xmlRectWidth: RectWidth := ANode.ValueAsDouble;
    xmlTextValue: Text := ANode.ValueAsStr;
    xmlStyleName: Style := Converter.StyleByName(ANode.Value);
    xmlScale: BackgroundScaleFactor := ANode.ValueAsDouble;
    xmlBackgroundFlags: BackgroundFlags := ANode.ValueAsInt;
    xmlBackgroundColor: BackgroundColor := ANode.ValueData.ValueAsColorCAD;
    xmlTransparency: BackgroundTransparency := ANode.ValueAsInt;
    xmlPoint1:
      begin
        if Length(ANode.ValueAsStr) > 0 then
        begin
          vPoint := ANode.ValueAsFPoint;
          if CompareMem(@vPoint, @cnstFPointIllegal, SizeOf(vPoint)) then//for debug
            Point1 := cnstFPointIllegal
          else
            Point1 := vPoint;
        end
        else
          Point1 := cnstFPointIllegal;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFMText.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
var
  S: string;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  S := Text;
  if Length(S) > 0 then
  begin
    PluginsReplaceAnsis(S);
    ANode.ChildValues[sPlcKeyWords[plcText].Name] := S;
  end;
end;

function TsgDXFMText.SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
  const AType: TsgPlcType; const AValue: Variant): Integer;
begin
  Result := cnstExportToXML_OK;
  case AType.Id of
    plcText: Text := AValue;
  else
    Result := inherited SetPropertyFromPluginsInternal(ANode, AType, AValue);
  end;
end;
{$ENDIF}

function TsgDXFMText.GetEntType: TsgCADEntities;
begin
  Result := ceMText;
end;

function TsgDXFMText.GetBackgroundColor: TsgColorCAD;
begin
  Result := FBackgroundColor;
end;

function TsgDXFMText.GetBackgroundFlags: Byte;
begin
  Result := FBackgroundFlags;
end;

function TsgDXFMText.GetBackgroundTransparency: Integer;
begin
  Result := FBackgroundTransparency;
end;

function TsgDXFMText.GetBackgroundScaleFactor: Double;
begin
  Result := FBackgroundScaleFactor;
end;

procedure TsgDXFMText.SetAngle(const Value: Double);
begin
  inherited SetAngle(Value);
  FPoint1 := cnstFPointIllegal;
end;

procedure TsgDXFMText.SetAngleInsp(const AValue: Single);
begin
  SetAngle(AValue);
end;

function TsgDXFMText.GetAlign: Byte;
begin
  Result := FAlign;
end;

function TsgDXFMText.GetAngleInsp: Single;
var
  vAngle: Double;
begin
  vAngle := GetRealAngle(nil);
  if Abs(vAngle) <= MaxSingle then
    Result := vAngle
  else
    Result := Sign(vAngle) * MaxSingle;
end;

procedure TsgDXFMText.SetAlign(const Value: Byte);
begin
  FAlign := Value;
end;

procedure TsgDXFMText.SetBackgroundFlags(const AValue: Byte);
begin
  FBackgroundFlags := AValue and 3;
end;

procedure TsgDXFMText.SetBackgroundColor(const AColor: TsgColorCAD);
begin
  FBackgroundColor := AColor;
end;

procedure TsgDXFMText.SetBackgroundTransparency(const AColor: Integer);
begin
  FBackgroundTransparency := AColor;
end;

procedure TsgDXFMText.SetBackgroundScaleFactor(AValue: Double);
begin
  if AValue > MaxSingle then
    AValue := MaxSingle
  else
    if AValue < MinSingle then
      AValue := MinSingle;
  FBackgroundScaleFactor := Abs(AValue);
  if FBackgroundScaleFactor = 0 then
    FBackgroundScaleFactor := 1;
end;

function TsgDXFMText.GetLineSpacingStyle: Byte;
begin
  Result := FLineSpacingStyle;
end;

procedure TsgDXFMText.SetLineSpacingStyle(const Value: Byte);
begin
  FLineSpacingStyle := Value;
end;

function TsgDXFMText.GetLineSpacingFactor: Single;
begin
  Result := FLineSpacingFactor;
end;

procedure TsgDXFMText.SetLineSpacingFactor(const Value: Single);
begin
  FLineSpacingFactor := Value;
end;

{ TsgDXFAttdef }

procedure TsgDXFAttdef.AssignEntity(Source: TsgDXFEntity);
var
  vAttdef: TsgDXFAttdef absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFAttdef then
  begin
    FFlags := vAttdef.FFlags;
    FHasChanging := False;
    Tag := vAttdef.Tag;
    Value := vAttdef.Value;
    LockPosition := vAttdef.LockPosition;
    FType := vAttdef.TypeValue;
  end;
end;

procedure TsgDXFAttdef.CheckValue;
begin
  case TypeValue of
    atPoint:
      begin
        Value := CheckStringFPoint(Value);
      end;
    atInteger:
      begin
        Value := CheckStringInteger(Value);
      end;
    atDouble:
      begin
        Value := CheckStringDouble(Value);
      end;
  end;
end;

constructor TsgDXFAttdef.Create;
begin
  inherited Create;
end;

function TsgDXFAttdef.EntName: string;
var
  P: Integer;
begin
  Result := inherited EntName;
  P := Pos(' ',Result);
  if P > 0 then
    Insert(Tag + ' = ', Result, P + 1);
end;

procedure TsgDXFAttdef.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
begin
  if Self.ClassType = TsgDXFAttdef then
  begin
    if (AConverter.Params.Insert <> nil) and
      ((Flags = 0) or NotAppear or Controlled or Preset) then
      Exit;
    if FHasChanging then
    begin
      FHasChanging := False;
      Exit;
    end;
    if AConverter.Params.Insert <> nil then
      if FText <> FValue then// if current ATTDEF is inside INSERT
      begin
        FText := FValue;
        LoadedInternal(AConverter);
      end;
  end
  else
    if NotAppear then
      Exit;
  inherited Invoke(AConverter, Proc, FinishProc);
end;

function TsgDXFAttdef.IsMultiText: Boolean;
begin
  Result := inherited IsMultiText or (TypeValue = atMText);
end;

function TsgDXFAttdef.GetTypeValue: TsgAttribType;
begin
  Result := FType;
end;

function TsgDXFAttdef.GetDeletable: Boolean;
begin
  Result := True;
end;

function TsgDXFAttdef.GetReadOnly: Boolean;
begin
  Result := False;
end;

function TsgDXFAttdef.GetRequiredField: Boolean;
begin
  Result := False;
end;

function TsgDXFAttdef.GetIdValueIndex: Integer;
begin
  Result := -1;
end;

function TsgDXFAttdef.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgNamedItem;
end;

// ---------------------- Attdef flags support ----------------------
function TsgDXFAttdef.GetFlags: Integer;
begin
  Result := FFlags;
end;

procedure TsgDXFAttdef.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

function TsgDXFAttdef.GetNotAppear: Boolean;
begin
  Result := FFlags and $01 <> 0;
end;

function TsgDXFAttdef.GetConstant: Boolean;
begin
  Result := FFlags and $02 <> 0;
end;

function TsgDXFAttdef.GetControlled: Boolean;
begin
  Result := FFlags and $04 <> 0;
end;

function TsgDXFAttdef.GetPreset: Boolean;
begin
  Result := FFlags and $08 <> 0;
end;

procedure TsgDXFAttdef.SetNotAppear(const Value: Boolean);
begin
  FFlags := (FFlags and not $01) or Ord(Value);
end;

procedure TsgDXFAttdef.SetConstant(const Value: Boolean);
begin
  FFlags := (FFlags and not $02) or (Ord(Value) shl 1);
end;

procedure TsgDXFAttdef.SetControlled(const Value: Boolean);
begin
  FFlags := (FFlags and not $04) or (Ord(Value) shl 2);
end;

procedure TsgDXFAttdef.SetPreset(const Value: Boolean);
begin
  FFlags := (FFlags and not $08) or (Ord(Value) shl 3);
end;

procedure TsgDXFAttdef.SetIdValueByIndex(const AIndexInValues: Integer);
begin
end;
// ---------------------- Attdef flags support ----------------------

function TsgDXFAttdef.GetEntType: TsgCADEntities;
begin
  Result := ceAttdef;
end;

function TsgDXFAttdef.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  // without begin/end xdata
  if AAppID = sACADXDataAttribAppName then
  begin
    AData.AddString(String_1001, sACADXDataAttribAppName);
    AData.AddInt16(Integer_1070, 0);
    AData.AddInt16(Integer_1070, Ord(LockPosition));
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

function TsgDXFAttdef.GetOwner: TsgDXFEntity;
begin
  if Assigned(FLinkID.Owner) then
    Result := TsgDXFEntity(TsgOwneredItem(FLinkID.Owner).Ancestor)
  else
    Result := nil;
end;

function TsgDXFAttdef.GetStrValue: string;
begin
  Result := FValue;
end;

function TsgDXFAttdef.GetTag: string;
begin
  Result := FLinkID.Name;
end;

function TsgDXFAttdef.GetValue: string;
begin
  Result := FValue;
end;

procedure TsgDXFAttdef.SetExtData(const AData: TsgCADExtendedData);
var
  I: Integer;
  vCode: SmallInt;
begin
  if IsEqualExtDataName(AData, sACADXDataAttribAppName) then
  begin
    I := 1;
    vCode := -1;
    while I < AData.DataCount do
    begin
      case AData.DataType[I] of
        edtInt16:
          if (AData.DataCode[I] = Integer_1070) and (vCode = -1) then
            vCode := AData.DataInt16[I]
          else
            if vCode = 0 then
            begin
              LockPosition := AData.DataInt16[I] <> 0;
              vCode := -1;
            end;
      end;
      Inc(I);
    end;
  end;
end;

procedure TsgDXFAttdef.SetOwner(const Value: TsgDXFEntity);
begin
  if Assigned(Value) then
    FLinkID.Owner := Value.GetNamedItem
  else
    FLinkID.Owner := nil;
end;

function TsgDXFAttdef.SetStrValue(const S: string): Boolean;
begin
  FValue := S;
  Result := True;
end;

procedure TsgDXFAttdef.SetTag(const ATag: string);
begin
  Text := ATag;// if ATTDEF is not inside INSERT
  FLinkID.Name := Text;
end;

procedure TsgDXFAttdef.SetTypeValue(const AValue: TsgAttribType);
begin
  FType := AValue;
end;

procedure TsgDXFAttdef.SetValue(const AValue: string);
begin
  FValue := AValue;
end;

function TsgDXFAttdef.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  // used only if ATTDEF is not inside INSERT
  ANode.RemoveAttributeByName(cnstXMLNames[xmlText].Name);
  //
  ANode.AddAttribNV(cnstXMLNames[xmlAttribTag].Name).ValueAsStr := Tag;
  ANode.AddAttribNV(cnstXMLNames[xmlAttribValue].Name).ValueAsStr := FValue;
end;

procedure TsgDXFAttdef.FreeReferences;
begin
  inherited FreeReferences;
end;

function TsgDXFAttdef.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  case AType.Id of
    xmlText:  Result := cnstXML_OK;//nothing
  else
    Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  end;
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlAttribTag: Tag := ANode.ValueAsStr;
    xmlAttribValue: Value := ANode.ValueAsStr;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFAttdef.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcTag].Name] := Tag;
  ANode.ChildValues[sPlcKeyWords[plcValue].Name] := Value;
end;

function TsgDXFAttdef.SetPropertyFromPluginsInternal(ANode: IsgNodeFrame;
  const AType: TsgPlcType; const AValue: Variant): Integer;
begin
  Result := cnstExportToXML_OK;
  case AType.Id of
//    plcTag:   Tag := AValue;
    plcValue: Value := AValue;
  else
    Result := inherited SetPropertyFromPluginsInternal(ANode, AType, AValue);
  end;
end;
{$ENDIF}

{ TsgDXFAttrib }

function TsgDXFAttrib.GetEntType: TsgCADEntities;
begin
  Result := ceAttrib;
end;

function TsgDXFAttrib.GetOwnerInsert: TsgDXFInsert;
begin
  Result := nil;
end;

procedure TsgDXFAttrib.SetOwnerInsert(const AValue: TsgDXFInsert);
begin
end;

function TsgDXFAttrib.SetStrValue(const S: string): Boolean;
begin
  Result := True;
  SetValue(S);
end;

procedure TsgDXFAttrib.SetTag(const ATag: string);
begin
  FLinkID.Name := ATag;
end;

procedure TsgDXFAttrib.SetValue(const AValue: string);
begin
  Text := AValue;
  FValue := Text;
end;

function TsgDXFAttrib.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
end;

function TsgDXFAttrib.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
end;

{ TsgDXFViewport }

constructor TsgDXFViewport.Create;
begin
  inherited Create;
  FBox := BadRect;// by default there is not boundary (only rectangle)
  FFrozenLayers := TsgInt64List.Create;
  FOrdIndexInt := -1;
  FStatusField := 1;
  FThisID := 1;
  FVisibleBoundary := True;
  FViewDirection.Z := 1;
end;

destructor TsgDXFViewport.Destroy;
begin
  NotifyDestroing;
  inherited Destroy;
end;

function TsgDXFViewport.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = sACADXDataAppName then
  begin
    AData.AddString(String_1001, sACADXDataAppName);
    AData.AddString(String_1000, cnstMView);
    AData.AddString(String_1002, '{');
    Result := True;
  end;
end;

procedure TsgDXFViewport.EndExtData(const AData: TsgCADExtendedData);
begin
  AData.AddString(String_1002, '}');
end;

procedure TsgDXFViewport.FreeReferences;
var
  vHasList: Boolean;
  vList: TsgNotifyEventsList;
  vAttributes: IsgGlobalPropProvider;
begin
  inherited FreeReferences;
  FreeAndNil(FFrozenLayers);
  if GetGlobalPropProvider(Self, False, vAttributes) then
  begin
    vHasList := VarCastToObj(vAttributes[cnstDestroyNotification], vList);
    vAttributes.Clear;
    if vHasList then
      vList.Free; // because TsgNotifyEventsList do not implements refcount!
  end;
end;

function TsgDXFViewport.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPSpaceCenter: FPSpaceCenter := ANode.ValueAsFPoint;
    xmlMSpaceCenter: FMSpaceCenter := ANode.ValueAsFPoint;
    xmlViewDirection: FViewDirection := ANode.ValueAsFPoint;
    xmlViewTarget: FViewTarget := ANode.ValueAsFPoint;
    xmlPSpaceWidth: FPSpaceWidth := ANode.ValueAsDouble;
    xmlPSpaceHeight: FPSpaceHeight := ANode.ValueAsDouble;
    xmlFrontClipPlane: FFrontClipPlane := ANode.ValueAsDouble;
    xmlBackClipPlane: FBackClipPlane := ANode.ValueAsDouble;
    xmlMSpaceHeight: FMSpaceHeight := ANode.ValueAsDouble;
    xmlViewTwistAngle: FViewTwistAngle := ANode.ValueAsDouble;
    xmlStatusField: FStatusField := ANode.ValueAsInt;
    xmlThisID: FThisID := ANode.ValueAsInt;
    xmlClippingBoundaryHandle: ClippingBoundary := Owner.FindEntByHandle(ANode.ValueAsHandle);
    xmlScale:     SetScale(ANode.ValueAsDouble);
    xmlTurnsOff : SetTurnsOff(ANode.ValueAsBool);//xmlStatusField !!!
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFViewport.CalcMatrix: TFMatrix;
var
  vPosition, vScale: TFPoint;
  vNewViewTarget: TFPoint;
begin
  vScale.X := FPSpaceHeight;
  vScale.Y := FMSpaceHeight;
  if vScale.X = 0 then
    vScale.X := 1.0;
  if vScale.Y = 0 then
    vScale.Y := vScale.X;
  vScale.X := vScale.X / vScale.Y;// from Model to Paper space
  vScale.Y := vScale.X;
  vScale.Z := vScale.X;
  if not NotZeroPoint(FViewDirection) then
    FViewDirection := cnstZOrtAxis;
  Result := GetViewTwistMatrix(FViewDirection, FViewTwistAngle);
  vNewViewTarget := FPointXMat(FViewTarget, Result);
  vPosition.X := FPSpaceCenter.X - (vNewViewTarget.X + FMSpaceCenter.X) * vScale.X;
  vPosition.Y := FPSpaceCenter.Y - (vNewViewTarget.Y + FMSpaceCenter.Y) * vScale.Y;
  vPosition.Z := FPSpaceCenter.Z - vNewViewTarget.Z * vScale.Z;
  Result := FMatXMat(Result, StdMat(vScale, vPosition));
end;

function TsgDXFViewport.CanDraw: Boolean;
begin
  Result := True;
end;

procedure TsgDXFViewport.ClearReferences;
begin
  inherited ClearReferences;
  FFrozenLayers.Clear;
  FClippingBoundary := nil;
end;

function TsgDXFViewport.GetBox: TFRect;
begin
  Result := BadRect;
  if GetDrawModel or (FStatusField = 0) then
    Result := FBox;
end;

procedure TsgDXFViewport.AssignEntity(Source: TsgDXFEntity);
var
  vViewport: TsgDXFViewport absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFViewport then
  begin
    FBackClipPlane := vViewport.FBackClipPlane;
    FClippingBoundary := vViewport.FClippingBoundary;
    FFlags := vViewport.FFlags;
    FFrontClipPlane := vViewport.FFrontClipPlane;
    FFrozenLayers.Assign(vViewport.FFrozenLayers);
    FMatrix := vViewport.FMatrix;
    FMSpaceCenter := vViewport.FMSpaceCenter;
    FMSpaceHeight := vViewport.FMSpaceHeight;
    FOrdIndexInt := vViewport.FOrdIndexInt;
//    FPaperSpaceBlock := vViewport.FPaperSpaceBlock;
    FPSpaceCenter := vViewport.FPSpaceCenter;
    FPSpaceHeight := vViewport.FPSpaceHeight;
    FPSpaceWidth := vViewport.FPSpaceWidth;
    FStatusField := vViewport.FStatusField;
    FThisID := vViewport.FThisID;
    FViewDirection := vViewport.FViewDirection;
    FViewTarget := vViewport.FViewTarget;
    FViewTwistAngle := vViewport.FViewTwistAngle;
    FVisibleBoundary := vViewport.FVisibleBoundary;
  end;
end;

function TsgDXFViewport.GetBoundariesAsPoints(AConverter: TsgDXFConverter): TList;
var
  vClipBoundary: TsgDXFEntity;
  vPoly: TsgCADBasePolyline;
  vEntity: TsgDXFEntity;
  vRegion: TsgDXFRegion;
  vPoints: TList;
  vRect: TFRect;
  I: Integer;
begin
  Result := TList.Create;
  vClipBoundary := GetClipBoundary(AConverter);
  if vClipBoundary <> nil then
  begin
    if vClipBoundary is TsgCADBasePolyline then
    begin
      vPoly := TsgCADBasePolyline(vClipBoundary);
      AddListPointsPolyline(Result, vPoly, True, False);
    end
    else
    begin
      if vClipBoundary is TsgDXFRegion then
      begin
        vRegion := TsgDXFRegion(vClipBoundary);
        I := 0;
        repeat
          while I < vRegion.Count do
          begin
            vEntity := vRegion.Entities[I];
            Inc(I);
            if vEntity.EntType <> ceEntity then
            begin
              if vEntity is TsgDXFLine then
              begin
                vPoints := TList.Create;
                Result.Add(vPoints);
                vPoints.Capacity := 2;
                AddFPointInList(vPoints, TsgDXFLine(vEntity).Point);
                AddFPointInList(vPoints, TsgDXFLine(vEntity).Point1);
              end
              else
              begin
                if vEntity is TsgCADBasePolyline then
                begin
                  vPoly := TsgCADBasePolyline(vEntity);
                  AddListPointsPolyline(Result, vPoly, False,
                    (vPoly.Flags and 8) <> 0);
                end;
              end;
            end
            else
              Break;
          end;
        until I >= vRegion.Count;
      end;
    end;
  end
  else
  begin
    vRect := Rect;
    vPoints := TList.Create;
    Result.Add(vPoints);
    vPoints.Capacity := 5;
    AddFPointInList(vPoints, vRect.TopLeft);
    AddFPointInList(vPoints, MakeFPoint(vRect.Right, vRect.Top));
    AddFPointInList(vPoints, vRect.BottomRight);
    AddFPointInList(vPoints, MakeFPoint(vRect.Left, vRect.Bottom));
    AddFPointInList(vPoints, vRect.TopLeft);
  end;
end;

function TsgDXFViewport.GetClipBoundary(AConverter: TsgDXFConverter): TsgDXFEntity;
var
  vEntity: TsgDXFEntity;
begin
  Result := nil;
  vEntity := FClippingBoundary;
  if vEntity <> nil then
  begin
    if vEntity is TsgCADBasePolyline then
    begin
      if TsgCADBasePolyline(vEntity).PointCount > 2 then
        Result := vEntity;
    end
    else
    begin
      if vEntity is TsgDXFRegion then
          Result := vEntity;
    end;
  end;
end;

procedure TsgDXFViewport.Invoke(AConverter: TsgDXFConverter;
  Proc, FinishProc: TsgCADEntityProc);
var
  PrevParams: TsgCADIterate;
  vSavedMat: TFMatrix;
  vConv: TsgDXFConverter;
  vParams: PsgCADIterate;
  vModelSpace: TsgDXFLayout;

  procedure DoFrozenByViewportForLayers(const AFrozen: Boolean);
  var
    vLayer: TsgDXFLayer;
    I: Integer;
  begin
    if Assigned(FFrozenLayers) and (FFrozenLayers.Count > 0) then
      for I := 0 to AConverter.Counts[csLayers] - 1 do
      begin
        vLayer := AConverter.Layers[I];
        if FFrozenLayers.IndexOf(vLayer.Handle) >= 0 then
          vLayer.IsFrozenByViewPort := AFrozen;
      end;
  end;

  procedure ApplyLayers;  // Adding new frozen to model
  begin
    DoFrozenByViewportForLayers(True);
  end;

  procedure RestoreLayers;// Extract new added frozen from model
  begin
    DoFrozenByViewportForLayers(False);
  end;

begin
  if AConverter.Params^.Viewport = Self then Exit;
  if GetDrawModel then
  begin
    inherited Invoke(AConverter, Proc, FinishProc);
    if Assigned(Converter) then
    begin
      vConv := Converter.GetMainConverter;
      vSavedMat := Converter.GetTransform3D;
      vConv.SetTransform3D(FMatXMat(FMatrix, vConv.GetTransform3D));
    end
    else
      vConv := nil;
    ApplyLayers;
    try
      vParams := AConverter.Params;
      PrevParams := vParams^;
      try
        vParams^.ViewPortRect.TopLeft := FPointXMat(FBox.TopLeft, vParams^.Matrix);
        vParams^.ViewPortRect.BottomRight := FPointXMat(FBox.BottomRight, vParams^.Matrix);
        NormFRect(vParams^.ViewPortRect);
        vParams^.Matrix := FMatXMat(FMatrix, vParams^.Matrix);
        vParams^.DrawMatrix := FMatXMat(FMatrix, vParams^.DrawMatrix);
        vParams^.Additional := Ord(IsRotatedFMat(vParams^.Matrix));
        vParams^.Insert := nil;
        vParams^.ConvertMatrixCurrentInsertToWCS := cnstIdentityMat;
        vParams^.XScale := 0.0;
        vParams^.YScale := 0.0;
        vParams^.LType := StdLines;
        vParams^.Viewport := Self;
        { TODO: Update Model annotation objects }
        vModelSpace := AConverter.GetModelLayout;
        if (AConverter.Status = stRegeneration) and
           (Assigned(vModelSpace.FPaperSpaceBlock) and (vModelSpace.FPaperSpaceBlock.FRegenFlags > 0)) then
        begin
          if vModelSpace.FPaperSpaceBlock.FRegenFlags < 2 then
          begin
            vModelSpace.FPaperSpaceBlock.FRegenFlags := 2;
            vModelSpace.Iterate(AConverter, Proc, FinishProc);
          end;
        end
        else
          vModelSpace.Iterate(AConverter, Proc, FinishProc);// this Iterate only for Model Space
        PrevParams.Stopped := vParams^.Stopped;
      finally
        vParams^ := PrevParams;
      end;
    finally
      RestoreLayers;
      if Assigned(vConv) then
        vConv.SetTransform3D(vSavedMat);
    end;
    if Assigned(FinishProc) then
      FinishProc(Self);
  end
  else
    if FStatusField = 0 then// Only boundary
    begin
      inherited Invoke(AConverter, Proc, FinishProc);
      if Assigned(FinishProc) then
        FinishProc(Self);
    end;
end;

function TsgDXFViewport.IsDraw: Boolean;
begin
  Result := VisibleBoundary or (not TurnsOff);
end;

function TsgDXFViewport.IsOwnerLayout: Boolean;
begin
  Result := Assigned(Owner) and Assigned(TsgDXFBlock(Owner).Layout);
end;

function TsgDXFViewport.IsOwnerModel: Boolean;
begin
  Result := Assigned(Owner) and TsgDXFBlock(Owner).IsModalSpaceBlock;
end;

procedure TsgDXFViewport.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFViewport.LoadedInternal(AConverter: TsgDXFConverter);
begin
  FBox.Left := FPSpaceCenter.X - 0.5 * FPSpaceWidth;
  FBox.Top := FPSpaceCenter.Y + 0.5 * FPSpaceHeight;
  FBox.Right := FPSpaceCenter.X + 0.5 * FPSpaceWidth;
  FBox.Bottom :=  FPSpaceCenter.Y - 0.5 * FPSpaceHeight;
  FBox.Z1 := 0;
  FBox.Z2 := 0;
  FRect := FBox;
  FMatrix := CalcMatrix;
  if Assigned(Owner) and (((AConverter.Version > acR12) and not IsOwnerLayout) or IsOwnerModel) then
  begin
    TurnsOff := True;
    VisibleBoundary := False;
    FBox := cnstBadRect;
  end;
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFViewport.Offset(const P: TFPoint);
begin
  FMSpaceCenter.X := FMSpaceCenter.X + P.X;
  FMSpaceCenter.Y := FMSpaceCenter.Y + P.Y;
end;

function TsgDXFViewport.GetDrawModel: Boolean;
begin
  Result := not TurnsOff;// $20000 = Turns the viewport off
  if Owner <> nil then
    Result := Result and (OrdIndex > 0)
  else
    Result := Result and (FStatusField > 0) and ((FThisID <> 1) or (OrdIndex > 0));
end;

function TsgDXFViewport.GetEntType: TsgCADEntities;
begin
  Result := ceViewport;
end;

function TsgDXFViewport.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  if BeginExtData(AData, AAppID) then
  begin
    AData.AddInt16(Integer_1070, 16);
    AData.AddPoint(Float_1010, ViewTarget);
    AData.AddPoint(Float_1010, ViewDirection);
    AData.AddDouble(Float_1040, ViewTwistAngle);
    AData.AddDouble(Float_1040, MSpaceHeight);
    AData.AddDouble(Float_1040, MSpaceCenter.X);
    AData.AddDouble(Float_1040, MSpaceCenter.Y);
    AData.AddDouble(Float_1040, 50.0);// DXF code 42
    AData.AddDouble(Float_1040, FrontClipPlane);
    AData.AddDouble(Float_1040, BackClipPlane);
    EndExtData(AData);
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

function TsgDXFViewport.GetPSpaceCenter: TFPoint;
begin
  Result := FPSpaceCenter;
end;

function TsgDXFViewport.GetPSpaceHeight: Double;
begin
  Result := FPSpaceHeight;
end;

procedure TsgDXFViewport.SetPSpaceCenter(const Value: TFPoint);
begin
  FPSpaceCenter := Value;
end;

procedure TsgDXFViewport.SetPSpaceHeight(const Value: Double);
begin
  FPSpaceHeight := Value;
end;

function TsgDXFViewport.GetPSpaceWidth: Double;
begin
  Result := FPSpaceWidth;
end;

function TsgDXFViewport.GetScale: Double;
begin
  Result := 0;
  if FMSpaceHeight <> 0 then
    Result := FPSpaceHeight / FMSpaceHeight;
end;

function TsgDXFViewport.GetTurnsOff: Boolean;
begin
  Result := ((FFlags and $20000) <> 0) or IsOwnerModel;
end;

procedure TsgDXFViewport.SetPSpaceWidth(const Value: Double);
begin
  FPSpaceWidth := Value;
end;

procedure TsgDXFViewport.SetScale(const Value: Double);
begin
  if Value > 0 then
    FMSpaceHeight := FPSpaceHeight / Value;
end;

procedure TsgDXFViewport.SetTurnsOff(const Value: Boolean);
var
  vValue: Boolean;
begin
  vValue := Value or IsOwnerModel;
  FFlags := (FFlags and $FFFDFFFF) or ($20000 * Cardinal(vValue));
  FStatusField := IfThen(vValue, 0, -1);
end;

function TsgDXFViewport.GetViewDirection: TFPoint;
begin
  Result := FViewDirection;
end;

procedure TsgDXFViewport.SetViewDirection(const Value: TFPoint);
begin
  FViewDirection := Value;
end;

function TsgDXFViewport.GetViewTarget: TFPoint;
begin
  Result := FViewTarget;
end;

procedure TsgDXFViewport.SetViewTarget(const Value: TFPoint);
begin
  FViewTarget := Value;
end;

function TsgDXFViewport.GetViewTwistAngle: Single;
begin
  Result := FViewTwistAngle;
end;

function TsgDXFViewport.GetVisibleBoundary: Boolean;
begin
  Result := FVisibleBoundary;
end;

procedure TsgDXFViewport.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
      AHideList.Add(Integer(xmlMSpaceHeight));
      AHideList.Add(Integer(xmlStatusField));
      AHideList.Add(Integer(xmlThisID));
      AHideList.Add(Integer(xmlViewDirection));
      AHideList.Add(Integer(xmlClippingBoundaryHandle));
    end;
  end;
end;

function TsgDXFViewport.HasLineWeight: Boolean;
begin
  Result := False;
end;

procedure TsgDXFViewport.SetViewTwistAngle(const Value: Single);
begin
  FViewTwistAngle := Value;
end;

procedure TsgDXFViewport.SetVisibleBoundary(const Value: Boolean);
begin
  FVisibleBoundary := Value;
  if IsOwnerModel then
    FVisibleBoundary := False;
end;

function TsgDXFViewport.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  I: Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPSpaceCenter].Name).ValueData,
    FPSpaceCenter, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlMSpaceCenter].Name).ValueData,
    FMSpaceCenter, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlViewDirection].Name).ValueData,
    FViewDirection, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlViewTarget].Name).ValueData,
    FViewTarget, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlPSpaceWidth].Name).ValueData,
    FPSpaceWidth, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlPSpaceHeight].Name).ValueData,
    FPSpaceHeight, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlFrontClipPlane].Name).ValueData,
    FFrontClipPlane, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlBackClipPlane].Name).ValueData,
    FBackClipPlane, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlMSpaceHeight].Name).ValueData,
    FMSpaceHeight, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlViewTwistAngle].Name).ValueData,
    FViewTwistAngle, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlScale].Name).ValueData,
    GetScale, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlTurnsOff].Name).ValueAsBool := TurnsOff;
  ANode.AddAttribNV(cnstXMLNames[xmlStatusField].Name).ValueAsInt := FStatusField;
  ANode.AddAttribNV(cnstXMLNames[xmlThisID].Name).ValueAsInt := FThisID;
  if Assigned(FClippingBoundary) then
    ANode.AddAttribNV(cnstXMLNames[xmlClippingBoundaryHandle].Name).ValueAsHandle := FClippingBoundary.Handle
  else
    ANode.AddAttribNV(cnstXMLNames[xmlClippingBoundaryHandle].Name).ValueAsHandle := cnstBadHandle;
  for I := 0 to FFrozenLayers.Count - 1 do
  begin
  end;
end;



//procedure TdxfViewport.Commit(const AReader: TdxfReader);
//var
//  vViewport: TsgDXFViewport;
//begin
//  inherited Commit(AReader);
//  vViewport := TsgDXFViewport(FEnt);






//  vViewport.Handle := FHandle;
//  AReader.Conv.SetHandle(vViewport);
//end;
//
//procedure TdxfViewport.ReadProperty(const AReader: TdxfReader);
//var
//  vViewport: TsgDXFViewport;
//begin
//  vViewport := TsgDXFViewport(FEnt);
//  inherited ReadProperty(AReader);
//  case AReader.Code of
//    Integer_90:  vViewport.Flags := AReader.IntValue;
//    String_340:  vViewport.ClippingBoundaryHandle := AReader.HandleValue;
//    String_341, String_331: vViewport.FrozenLayers.Add(AReader.HandleValue);
//      // acR2000 - String_341; acR2004+ - String_331; acR12 - 1003 (see below)
//    String_1001:
//      begin
//        vViewport.XDataAppName := AReader.UValue;
//        FIsAcad := vViewport.XDataAppName = sACADXDataAppName;
//      end;
//  end;
//  case AReader.Code of
//    1003: if FIsAcad then vViewport.FrozenLayers.Add(AReader.Conv.LayerByName(AReader.UValue).Handle);
//    1040: if FIsAcad then NextReal(AReader);
//    1010,1020,1030: if FIsAcad then Next3Reals(AReader);
//  end;
//end;

function TsgDXFViewport.GetMSpaceCenter: TFPoint;
begin
  Result := FMSpaceCenter;
end;

function TsgDXFViewport.GetOwner: TsgDXFEntity;
begin
  if Assigned(FLinkID.Owner) then
    Result := TsgDXFEntity(TsgOwneredItem(FLinkID.Owner).Ancestor)
  else
    Result := nil;
end;

procedure TsgDXFViewport.SetMSpaceCenter(const Value: TFPoint);
begin
  FMSpaceCenter := Value;
end;

procedure TsgDXFViewport.SetOrdIndex(const Value: Integer);
begin
  FOrdIndexInt := Value;
end;

procedure TsgDXFViewport.SetOwner(const Value: TsgDXFEntity);
begin
  if Assigned(Value) then
    FLinkID.Owner := Value.GetNamedItem
  else
    FLinkID.Owner := nil;
end;

function TsgDXFViewport.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgDXFViewport.GetFrontClipPlane: Single;
begin
  Result := FFrontClipPlane;
end;

procedure TsgDXFViewport.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

procedure TsgDXFViewport.SetFrontClipPlane(const Value: Single);
begin
  FFrontClipPlane := Value;
end;

function TsgDXFViewport.GetBackClipPlane: Single;
begin
  Result := FBackClipPlane;
end;

procedure TsgDXFViewport.SetBackClipPlane(const Value: Single);
begin
  FBackClipPlane := Value;
end;

procedure TsgDXFViewport.SetClippingBoundary(AValue: TsgDXFEntity);
const
  cnstNonRectangularClippingFlag = $10000;
begin
  if AValue <> FClippingBoundary then
  begin
    FClippingBoundary := AValue;
    if Assigned(FClippingBoundary) then
      FFlags := FFlags or cnstNonRectangularClippingFlag
    else
      FFlags := FFlags and not cnstNonRectangularClippingFlag;
  end;
end;

{ TsgDXFVport }

procedure TsgDXFVport.AssignEntity(Source: TsgDXFEntity);

var
  vVPort: TsgDXFVport absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFVport then
  begin
    FCircleZoomPercent := vVPort.FCircleZoomPercent;
    FUCSOrigin := vVPort.FUCSOrigin;
    FUCSXDir := vVPort.FUCSXDir;
    FUCSYDir := vVPort.FUCSYDir;
    FUCSVP := vVPort.FUCSVP;
    FViewAspectRatio := vVPort.FViewAspectRatio;
    FViewCenterPoint := vVPort.FViewCenterPoint;
    FViewDirection := vVPort.FViewDirection;
    FViewTarget := vVPort.FViewTarget;
    FViewHeight := vVPort.FViewHeight;
    FViewTwistAngle := vVPort.FViewTwistAngle;
  end;
end;

constructor TsgDXFVport.Create;
begin
  inherited Create;
  FViewDirection.Z := 1;
  FCircleZoomPercent := cntViewPortCircleZoomPercent;
  FViewAspectRatio := 1;
  FUCSOrigin.Z := 1;
  FUCSXDir.X := 1;
  FUCSYDir.Y := 1;
end;

function TsgDXFVport.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlCircleZoomPercent: FCircleZoomPercent := ANode.ValueAsInt;
    xmlUCSOrigin: FUCSOrigin := ANode.ValueAsFPoint;
    xmlUCSXDir: FUCSXDir := ANode.ValueAsFPoint;
    xmlUCSYDir: FUCSYDir := ANode.ValueAsFPoint;
    xmlUCSVP: FUCSVP := ANode.ValueAsBool;
    xmlViewAspectRatio: FViewAspectRatio := ANode.ValueAsDouble;
    xmlViewCenterPoint: FViewCenterPoint := ANode.ValueAsFPoint;
    xmlViewDirection: FViewDirection := ANode.ValueAsFPoint;
    xmlViewTarget: FViewTarget := ANode.ValueAsFPoint;
    xmlViewHeight: FViewHeight := ANode.ValueAsDouble;
    xmlViewTwistAngle: FViewTwistAngle := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFVport.GetViewDirection: TFPoint;
begin
  Result := FViewDirection;
end;

function TsgDXFVport.GetViewHeight: TsgFloat;
begin
  Result := FViewHeight;
end;

function TsgDXFVport.GetViewTwistAngle: Double;
begin
  Result := FViewTwistAngle;
end;

procedure TsgDXFVport.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  AConverter.IsHaveActiveVPort := True;
end;

procedure TsgDXFVport.SetViewDirection(const Value: TFPoint);
begin
  FViewDirection := Value;
  if (Value.X = 0) and (Value.Y = 0) and (Value.Z = 0) then
    FViewDirection.Z := 1;
end;

procedure TsgDXFVport.SetViewHeight(const Value: TsgFloat);
begin
  FViewHeight := Value;
end;

procedure TsgDXFVport.SetViewTwistAngle(const Value: Double);
begin
  FViewTwistAngle := Value;
end;

function TsgDXFVport.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlCircleZoomPercent].Name).ValueAsInt := FCircleZoomPercent;
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSOrigin].Name).ValueData,
     FUCSOrigin, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSXDir].Name).ValueData,
     FUCSXDir, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSYDir].Name).ValueData,
     FUCSYDir, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlUCSVP].Name).ValueAsBool := FUCSVP;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlViewAspectRatio].Name).ValueData,
     FViewAspectRatio, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlViewCenterPoint].Name).ValueData,
     FViewCenterPoint, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlViewDirection].Name).ValueData,
     FViewDirection, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlViewTarget].Name).ValueData,
     FViewTarget, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlViewHeight].Name).ValueData,
     FViewHeight, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlViewTwistAngle].Name).ValueData,
     FViewTwistAngle, xmlForViewing in AParams.Mode);
end;

{ TsgCADPolyPolygon }

function TsgCADPolyPolygon.ApplyAngle(const AngleRel: Double): Boolean;
begin
  Result := False;
end;

function TsgCADPolyPolygon.ApplyScale(const AScaleRel: Double): Boolean;
begin
  Result := False;
end;

procedure TsgCADPolyPolygon.AssignEntity(Source: TsgDXFEntity);
var
  vPolygon: TsgCADPolyPolygon absolute Source;
  I: Integer;
  vSourcePoints: TF2DPointList;
begin
  inherited AssignEntity(Source);
  if not(Source is TsgCADPolyPolygon) then Exit;
  if FBoundaryPolylines.Count <> 0 then
    TsgObjectList.ClearList(FBoundaryPolylines);
  FBoundaryPolylines.Capacity := vPolygon.FBoundaryPolylines.Count;
  for I := 0 to vPolygon.FBoundaryPolylines.Count - 1 do
  begin
    vSourcePoints := TF2DPointList(vPolygon.FBoundaryPolylines.Items[I]);
    if (vSourcePoints = nil) or (vSourcePoints.Count = 0) then
      Continue;
    FBoundaryPolylines.Add(TF2DPointList.Create(vSourcePoints));
  end;
end;

procedure TsgCADPolyPolygon.CalcFMatrix;
begin
end;

function TsgCADPolyPolygon.CanDraw: Boolean;
begin
  Result := True;
end;

procedure TsgCADPolyPolygon.ClearBoundaryData;
begin
end;

procedure TsgCADPolyPolygon.ClearReferences;
begin
  inherited ClearReferences;
  TsgObjectList.ClearList(FBoundaryPolylines);
end;

procedure TsgCADPolyPolygon.CloseBoundary;
var
  I: Integer;
  vPoints: TF2DPointList;
begin
  for I := 0 to FBoundaryPolylines.Count - 1 do
  begin
    vPoints := TF2DPointList(FBoundaryPolylines[I]);
    if (vPoints = nil) or (vPoints.Count = 0) then
      Continue;
    if not IsEqualF2DPoints(vPoints.First, vPoints.Last) then
      vPoints.Add(vPoints.First);
  end;
end;

constructor TsgCADPolyPolygon.Create;
begin
  inherited Create;
  FBoundaryPolylines := TsgObjectList.Create;
  FBox := BadRect;
end;

function TsgCADPolyPolygon.BoxTransformation(AConverter: TsgDXFConverter; const ABox: TFRect): TFRect;
begin
  Result := ABox;
end;

function TsgCADPolyPolygon.GetBox: TFRect;
begin
  Result := BoxTransformation(Converter, FBox);
end;

function TsgCADPolyPolygon.GetBoxPoints(Proc: TFPointProc;
  Full: Boolean): Boolean;
begin
  Result := inherited GetBoxPoints(Proc, Full);
end;

function TsgCADPolyPolygon.GetEntType: TsgCADEntities;
begin
  Result := cePolyPolygon;
end;

function TsgCADPolyPolygon.GetHatchName: string;
begin
  Result := sSOLID;
end;

function TsgCADPolyPolygon.GetSolidFill: Boolean;
begin
  Result := True;
end;

function TsgCADPolyPolygon.IsEmptykBox(const AConverter: TsgDXFConverter): Boolean;
begin
  Result := False;
end;

procedure TsgCADPolyPolygon.LoadedInternal(AConverter: TsgDXFConverter);
var
  vPoints: TF2DPointList;
  I, J: Integer;
begin
  CalcFMatrix;
  if Layer = nil then
    Layer := AConverter.LayerByName('0');
  inherited LoadedInternal(AConverter);
  MakeBorderPolylines(AConverter);
  CloseBoundary;
  FBox := BadRect;
  if (FBoundaryPolylines = nil) or (FBoundaryPolylines.Count = 0) then Exit;
  for I := 0 to FBoundaryPolylines.Count - 1 do
  begin
    if FBoundaryPolylines[I] = nil then
      Continue;
    vPoints := TF2DPointList(FBoundaryPolylines[I]);
    for J := 0 to vPoints.Count - 1 do
      ExpandFRect(FBox, MakeFPoint(vPoints[J].X, vPoints[J].Y, 0));
  end;
  if FBox.Bottom = BadRect.Bottom then
    Exit;
  NormFRect(FBox);
  if IsEmptykBox(AConverter) then
  begin
    FBox := cnstBadRect;
    Exit;
  end;
  ParseLines;
end;

procedure TsgCADPolyPolygon.MakeBorderPolylines(AConverter: TsgDXFConverter);
begin
end;

procedure TsgCADPolyPolygon.ParseLines;
begin
end;

procedure TsgCADPolyPolygon.SetHatchName(const AHatchName: string);
begin
end;

procedure TsgCADPolyPolygon.SetSolidFill(const Value: Boolean);
begin
end;

function TsgCADPolyPolygon.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vBoundaryPolylines, vBoundaryPolyline: TsgNode;
  I: Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlHatchName].Name).ValueAsStr := HatchName;
  ANode.AddAttribNV(cnstXMLNames[xmlSolidFill].Name).ValueAsBool := SolidFill;
  if not (xmOnlyChildNodes in AParams.Mode) then
  begin
    vBoundaryPolylines := ANode.AddChildNV(cnstXMLNames[xmlBoundaryPolylines].Name);
    for I := 0 to FBoundaryPolylines.Count - 1 do
    begin
      vBoundaryPolyline := vBoundaryPolylines.AddChildNV(cnstXMLNames[xmlBoundaryPolyline].Name);
      TF2DPointList(FBoundaryPolylines[I]).ToXML(vBoundaryPolyline,
        cnstXMLNames[xmlPoint].Name);
    end;
  end;
end;

procedure TsgCADPolyPolygon.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FBoundaryPolylines);
end;

function TsgCADPolyPolygon.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
//    xmlHatchName: HatchName := ANode.ValueAsStr;
    xmlSolidFill: SolidFill := ANode.ValueAsBool;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgCADPolyPolygon.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcHatchName].Name] := HatchName;//HatchName
end;
{$ENDIF}

{ TsgCADCustomRectangle }

procedure TsgCADCustomRectangle.AddPoint(const APoinst: TFPoint);
begin
  AddPoint(APoinst.X, APoinst.Y);
end;

procedure TsgCADCustomRectangle.AddPoint(X, Y: Double);
begin
  FClipPoints.Add(MakeF2DPoint(X, Y));
end;

procedure TsgCADCustomRectangle.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADCustomRectangle then
  begin
    FClippingBoundaryType := TsgCADCustomRectangle(Source).ClippingBoundaryType;
    FClipPoints.Assign(TsgCADCustomRectangle(Source).ClipPoints);
    FSize := TsgCADCustomRectangle(Source).Size;
    FUseClipping := TsgCADCustomRectangle(Source).UseClipping;
    FUVector := TsgCADCustomRectangle(Source).UVector;
    FVVector := TsgCADCustomRectangle(Source).VVector;
  end;
end;

procedure TsgCADCustomRectangle.ChangeSizes(K: Double);
begin
  if K <> 0 then
  begin
    K := Abs(K);
    FUVector.X := K * FUVector.X;
    FUVector.Y := K * FUVector.Y;
    FVVector.X := K * FVVector.X;
    FVVector.Y := K * FVVector.Y;
  end;
end;

procedure TsgCADCustomRectangle.ClearReferences;
begin
  inherited ClearReferences;
  FClipPoints.Clear(True);
end;

constructor TsgCADCustomRectangle.Create;
begin
  inherited Create;
  FClipPoints := TF2DPointList.Create;
  FUVector := cnstXOrtAxis;
  FVVector := cnstYOrtAxis;
  FSize := cnstFPointSingle;
  //1 = Show image;
  //2 = Show image when not aligned with screen;
  //4 = Use clipping boundary;
  //8 = Transparency is on
  FFlags := 7;// 1+2+4
end;

procedure TsgCADCustomRectangle.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FClipPoints);
end;

function TsgCADCustomRectangle.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlUVector: UVector := ANode.ValueAsFPoint;
    xmlVVector: VVector := ANode.ValueAsFPoint;
    xmlSize: Size := ANode.ValueAsFPoint;
    xmlWidth: Width := ANode.ValueAsDouble;
    xmlHeight: Height := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgCADCustomRectangle.GetClipPointsCount: Integer;
begin
  Result := FClipPoints.Count;
end;

function TsgCADCustomRectangle.GetClosed: Boolean;
begin
  Result := True;
end;

function TsgCADCustomRectangle.GetHeight: Double;
begin
  Result := Size.Y * Sqrt(Sqr(VVector.X) + Sqr(VVector.Y));
end;

function TsgCADCustomRectangle.GetMatrix: TFMatrix;
begin
  Result.EX := UVector;
  Result.EY := VVector;
  Result.EZ := Ort(sgFunction.Vector(Result.EY, Result.EX));
  Result.E0 := Point;
end;

function TsgCADCustomRectangle.GetPoint1: TFPoint;
begin
  Result := GetPointInternal(Size.X, 0);
end;

function TsgCADCustomRectangle.GetPoint2: TFPoint;
begin
  Result := GetPointInternal(0, Size.Y);
end;

function TsgCADCustomRectangle.GetPoint3: TFPoint;
begin
  Result := GetPointInternal(Size.X, Size.Y);
end;

function TsgCADCustomRectangle.GetPointInternal(X, Y: Double): TFPoint;
begin
  Result.X := Point.X + X * UVector.X + Y * VVector.X;
  Result.Y := Point.Y + X * UVector.Y + Y * VVector.Y;
  Result.Z := Point.Z + X * UVector.Z + Y * VVector.Z;
end;

function TsgCADCustomRectangle.GetWidth: Double;
begin
  Result := Size.X * Sqrt(Sqr(UVector.X) + Sqr(UVector.Y));
end;

function TsgCADCustomRectangle.GetWipeOutClipPoint(const AParam: Double;
  const APoint: TFPoint): TF2DPoint;
var
  vDX, vDY: Double;
begin
  vDX := APoint.X - Point.X;
  vDY := APoint.Y - Point.Y;
  Result.X := -(vDY * VVector.X - vDX * VVector.Y) * AParam - 0.5;
  Result.Y := Size.Y - (vDY * UVector.X - vDX * UVector.Y) * AParam - 0.5;
end;

function TsgCADCustomRectangle.GetWipeOutParam: Double;
begin
  Result := (VVector.Y * UVector.X - VVector.X * UVector.Y);
  if Abs(Result) > fAccuracy then
    Result := 1 / Result
  else
    Result := sgConsts.cnstNan;
end;

procedure TsgCADCustomRectangle.ReloadPolyPoints(const AConverter: TsgDXFConverter);
var
  I: Integer;
begin
  inherited ReloadPolyPoints(AConverter);
  Closed := True;
  if ClippingBoundaryType = 1 then
  begin
    if FClipPoints.Count >= 2 then
    begin
      FPolyPoints.Add(GetPointInternal(0.5 + ClipPoints[0].X, Size.Y - 0.5 - ClipPoints[0].Y));
      FPolyPoints.Add(GetPointInternal(0.5 + ClipPoints[1].X, Size.Y - 0.5 - ClipPoints[0].Y));
      FPolyPoints.Add(GetPointInternal(0.5 + ClipPoints[1].X, Size.Y - 0.5 - ClipPoints[1].Y));
      FPolyPoints.Add(GetPointInternal(0.5 + ClipPoints[0].X, Size.Y - 0.5 - ClipPoints[1].Y));
    end;
  end
  else
  begin
    for I := 0 to FClipPoints.Count-1 do
      FPolyPoints.Add(GetPointInternal(0.5 + ClipPoints[I].X, Size.Y - 0.5 - ClipPoints[I].Y));
  end;
end;

procedure TsgCADCustomRectangle.SetClosed(const AClosed: Boolean);
begin
end;

procedure TsgCADCustomRectangle.SetHeight(const AValue: Double);
begin
  ChangeSizes(AValue / Height);
end;

procedure TsgCADCustomRectangle.CheckUVVectors;
begin
  if (Width = 0) or (Height = 0) then
  begin
    if IsEqualFPoints(Size, cnstFPointZero) then
      Size := cnstFPointSingle;
    if IsEqualFPoints(UVector, cnstFPointZero) then
      UVector := cnstXOrtAxis;
    if IsEqualFPoints(VVector, cnstFPointZero) then
      VVector := cnstYOrtAxis;
  end;
end;

procedure TsgCADCustomRectangle.SetHeightInternal(const AValue: Double);
begin
  if AValue > 0 then
  begin
    CheckUVVectors;
    SetHeight(AValue);
  end;
end;

procedure TsgCADCustomRectangle.SetPoint1(const AValue: TFPoint);
begin
  FUVector := AValue;
end;

procedure TsgCADCustomRectangle.SetPoint2(const AValue: TFPoint);
begin
  FVVector := AValue;
end;

procedure TsgCADCustomRectangle.SetPoint3(const AValue: TFPoint);
begin
  FSize := AValue;
end;

procedure TsgCADCustomRectangle.SetWidth(const AValue: Double);
begin
  ChangeSizes(AValue / Width);
end;

procedure TsgCADCustomRectangle.SetWidthInternal(const AValue: Double);
begin
  if AValue > 0 then
  begin
    CheckUVVectors;
    SetWidth(AValue);
  end;
end;

function TsgCADCustomRectangle.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUVector].Name).ValueData,
    UVector, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlVVector].Name).ValueData,
    VVector, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlSize].Name).ValueData,
    Size, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlWidth].Name).ValueData,
    Width, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlHeight].Name).ValueData,
    Height, xmlForViewing in AParams.Mode);
end;

{ TsgCADWipeout }

function TsgCADWipeout.GetEntType: TsgCADEntities;
begin
  Result := ceWipeout;
end;

procedure TsgCADWipeout.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlSize));
      AHideList.Add(Integer(xmlUvector));
      AHideList.Add(Integer(xmlVvector));
    end;
  end;
end;

{ TsgCADCurvePolygon }

function TsgCADCurvePolygon.AddBoundaryList(const AFlags: Byte = 0): Tsg2DBoundaryList;
begin
  Result := FBoundaryData.AddBoundaryList(AFlags);
end;

procedure TsgCADCurvePolygon.AssignEntity(Source: TsgDXFEntity);
var
  vPolygon: TsgCADCurvePolygon absolute Source;
begin
  inherited AssignEntity(Source);
  if not (Source is TsgCADCurvePolygon) then Exit;
  CopyBoundaryData(TsgCADCurvePolygon(Source));
  FElevation := vPolygon.FElevation;
  FExtrusion := vPolygon.FExtrusion;
  FMatrix := vPolygon.FMatrix;
  FTransparency := vPolygon.FTransparency;
end;

procedure TsgCADCurvePolygon.CalcFMatrix;
begin
  if UseMatrix then
    FMatrix := FMatXMat(StdMat(cnstFPointSingle, FElevation),
      MatFromExtr(FExtrusion, 0.0))
  else
    FMatrix := cnstIdentityMat;  
end;

procedure TsgCADCurvePolygon.ClearBoundaryData;
begin
  FBoundaryData.ClearBoundaries;
end;

procedure TsgCADCurvePolygon.ClearReferences;
begin
  inherited ClearReferences;
  ClearBoundaryData;
end;

procedure TsgCADCurvePolygon.CopyBoundaryData(const APolygon: TsgCADCurvePolygon);
begin
  FBoundaryData.ClearBoundaries;
  if Assigned(APolygon.FBoundaryData) then
    FBoundaryData.CopyBoundaries(APolygon.FBoundaryData);
end;

procedure TsgCADCurvePolygon.ChechBoundaryData(const AHatch: TsgCADCurvePolygon);
begin
  CheckListOfObject(FBoundaryData.Boundaries,
    AHatch.FBoundaryData.Boundaries, Tsg2DBoundaryList);
end;

constructor TsgCADCurvePolygon.Create;
begin
  inherited Create;
  FTransparency := fTransparencyByLayer;
  FBoundaryData := TsgCADBoundaryData.Create;
  FBoundaryData.ParentEntity := Self;
  FExtrusion := cnstExtrusion;
  FMatrix := cnstIdentityMat;
end;

procedure TsgCADCurvePolygon.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FBoundaryData);
end;

function TsgCADCurvePolygon.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vElevation: TFPoint;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlBoundaries:
      begin
        FBoundaryData.Clear;
        FBoundaryData.FromXML(ANode, AResult);
      end;
    xmlElevation:
      begin
        vElevation := ANode.ValueAsFPoint;
        vElevation.X := 0;
        vElevation.Y := 0;
        Elevation := vElevation;
      end;
    xmlExtrusion: Extrusion := ANode.ValueAsFPoint;
    xmlOffset:    Offset := ANode.ValueAsFPoint;
    xmlTransparency: Transparency := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgCADCurvePolygon.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  SetPointToNode(ANode, Elevation, sPlcKeyWords[plcElevation].Name);
end;
{$ENDIF}

function TsgCADCurvePolygon.BoxTransformation(AConverter: TsgDXFConverter; const ABox: TFRect): TFRect;
begin
  Result := ABox;
  if (Assigned(AConverter) and (AConverter.ImportMode <> imImport)) and UseMatrix and not IsBadRect(FBox) then
    TransRectCorners(Result, FMatrix);
end;

function TsgCADCurvePolygon.GenerateListOfBoundaries(const AList: TsgObjectList;
  AExplodePolyline: Boolean = False): TFRect;
begin
  Result := FBoundaryData.GenerateListOfBoundaries(AList, AExplodePolyline);
end;

function TsgCADCurvePolygon.GetBoundaryData(const AIndex: Integer): Tsg2DBoundaryList;
begin
  Result := Tsg2DBoundaryList(FBoundaryData.Boundaries[AIndex]);
end;

function TsgCADCurvePolygon.GetBoundaryDataCount: Integer;
begin
  if FBoundaryData <> nil then
    Result := FBoundaryData.Boundaries.Count
  else
    Result := -1;
end;

function TsgCADCurvePolygon.GetBoundaryDataLast: Tsg2DBoundaryList;
begin
  if FBoundaryData <> nil then
    Result := Tsg2DBoundaryList(FBoundaryData.Boundaries.Last)
  else
    Result := nil;
end;

function TsgCADCurvePolygon.GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean;
begin
  Result := EnumBoxPoints(FBox, Proc, Full);
end;

function TsgCADCurvePolygon.GetElevation: TFPoint;
begin
  Result := FElevation;
end;

function TsgCADCurvePolygon.GetEntType: TsgCADEntities;
begin
  Result := ceCurvePolygon;
end;

function TsgCADCurvePolygon.GetExtrusion: TFPoint;
begin
  Result := FExtrusion;
end;

function TsgCADCurvePolygon.GetFillColor: TsgColorCAD;
begin
  Result := ColorCAD;
end;

function TsgCADCurvePolygon.GetMatrix: TFMatrix;
begin
  Result := FMatrix;
end;

function TsgCADCurvePolygon.GetOffset: TFPoint;
begin
  Result := cnstFPointZero;
end;

procedure TsgCADCurvePolygon.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlGradientTypeName));
      AHideList.Add(Integer(xmlGradientUseCenter));
      AHideList.Add(Integer(xmlGradientTypeName));
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
      AHideList.Add(Integer(xmlOffset));
      AHideList.Add(Integer(xmlElevation));
      AHideList.Add(Integer(xmlSolidFill));
    end;
  end;
end;

function TsgCADCurvePolygon.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  ListNotify(AEntity, lnAdded);
  Result := AEntity = FBoundaryData;
end;

procedure TsgCADCurvePolygon.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
  PrevParams: TsgCADIterate;
  vParams: PsgCADIterate;
begin
  if UseMatrix then
  begin
    vParams := AConverter.Params;
    PrevParams := vParams^;
    try
      vParams^.Matrix := FMatXMat(FMatrix, vParams^.Matrix);
      vParams^.XScale := 0.0;
      vParams^.YScale := 0.0;
    inherited Invoke(AConverter, Proc, FinishProc);
    finally
      vParams^ := PrevParams;
    end;
  end
  else
    inherited Invoke(AConverter, Proc, FinishProc);
end;

function TsgCADCurvePolygon.IsInvoke(AConverter: TsgDXFConverter): Boolean;
begin
  Result := True;
  if (AConverter.ImportMode = imImport) and Assigned(AConverter.Params^.Viewport) then
    Result := (IntersectRects(FBox, AConverter.Params^.ViewPortRect, AConverter.Params.Matrix) <> -1);
end;

function TsgCADCurvePolygon.IsViewAsLine(const ALine: PsgLine = nil): Boolean;
var
  vLine: TsgF2DLine;
begin
  Result := False;
  if FBoundaryData.Boundaries.Count = 1 then
  begin
    if Tsg2DBoundaryList(FBoundaryData.Boundaries[0]).ViewType(@vLine) = 1 then
    begin
      Result := True;
      if ALine <> nil then
      begin
        ALine^.Point1 := MakeFPointFrom2D(vLine.Point1);
        ALine^.Point2 := MakeFPointFrom2D(vLine.Point2);
      end;
    end;
  end;
end;

procedure TsgCADCurvePolygon.ListNotify(const Obj: TObject; Action: TListNotification);
begin
  inherited ListNotify(Obj, Action);
  case Action of
    lnAdded:
      begin
        if TObject(Obj).InheritsFrom(TsgCADBoundaryData) then
        begin
          FBoundaryData.Free;
          FBoundaryData := TsgCADBoundaryData(Obj);
        end;
      end;
  end;
end;

procedure TsgCADCurvePolygon.MakeBorderPolylines(AConverter: TsgDXFConverter);
begin
  MakeBorderPolylinesWithProgress(AConverter, nil);
end;

procedure TsgCADCurvePolygon.MakeBorderPolylinesWithProgress(
  const AConverter: TsgDXFConverter; AProgress: IsgProgress = nil);
begin
//  FBoundaryData.Owner := Self; see TsgCADCurvePolygon.Create
  FBoundaryData.MakeBorderPolylines(AConverter, FBoundaryPolylines,
    SolidFill, AProgress);
end;

procedure TsgCADCurvePolygon.RemoveIncorrectBoundaries(const ARemoveLine: Boolean);
var
  I, vViewAsLine: Integer;
  vBoundary: Tsg2DBoundaryList;
begin
  for I := FBoundaryData.Boundaries.Count - 1 downto 0 do
  begin
    vBoundary := Tsg2DBoundaryList(FBoundaryData.Boundaries[I]);
    vViewAsLine := vBoundary.ViewType;
    if (vViewAsLine < 0) or (ARemoveLine and (vViewAsLine = 1)) then
    begin
      FBoundaryData.Boundaries.Delete(I);
      FreeAndNil(vBoundary);
    end;
  end;
end;

procedure TsgCADCurvePolygon.SetElevation(const Value: TFPoint);
begin
  FElevation.X := 0;
  FElevation.Y := 0;
  FElevation.Z := Value.Z;
end;

procedure TsgCADCurvePolygon.SetExtrusion(const Value: TFPoint);
begin
  FExtrusion := Value;
end;

procedure TsgCADCurvePolygon.SetFillColor(const Value: TsgColorCAD);
begin

end;

procedure TsgCADCurvePolygon.SetOffset(const Value: TFPoint);
begin
end;

procedure TsgCADCurvePolygon.SetTransparency(const Value: Single);
begin
  if Value >= 0 then
  begin
    FTransparency := Value;
    if FTransparency > 100 then
      FTransparency := 100;
  end
  else
  begin
    if (Value = fTransparencyByBlock) or (Value = fTransparencyByLayer) then
      FTransparency := Value;
  end;
end;

function TsgCADCurvePolygon.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vBoundaries: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlElevation].Name).ValueData,
    Elevation, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlExtrusion].Name).ValueData,
    Extrusion, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlOffset].Name).ValueData,
    Offset, xmlForViewing in AParams.Mode);
  if (Transparency <> 0) or IsFullPropsOrXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlTransparency].Name).ValueAsDouble := Transparency;
  if not (xmOnlyChildNodes in AParams.Mode) then
  begin
    vBoundaries := ANode.AddChildNV(FBoundaryData.GetNodeName);
    FBoundaryData.ToXMLNode(vBoundaries, AParams);
  end;
end;

function TsgCADCurvePolygon.UseMatrix: Boolean;
begin
  Result := Extruded(FExtrusion) or NotZeroPoint(FElevation);
end;

{ TsgCADHatch }

procedure TsgCADHatch.ClearHatchPatternData;
begin
  FHatchPatternData.ClearPatterns;
end;

procedure TsgCADHatch.ClearReferences;
begin
  inherited ClearReferences;
  FHatchPatternData.ClearReferences;
  FParsedLines.Clear;
end;

procedure TsgCADHatch.CopyHatchPatternData(const AHatch: TsgCADHatch);
begin
  FHatchPatternData.CopyPatterns(AHatch.FHatchPatternData);
  FHatchStyles := AHatch.FHatchStyles;
end;

constructor TsgCADHatch.Create;
begin
  inherited Create;
  SetFillStyle(fsCAD);
  FParsedLines := TF2DPointList.Create;
  FHatchPatternData := TsgCADHatchPatternData.Create;
end;

procedure TsgCADHatch.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FHatchPatternData);
  FreeAndNil(FParsedLines);
end;

function TsgCADHatch.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPatternAngle: PatternAngle := ANode.ValueAsDouble;
    xmlPatternScale: PatternScale := ANode.ValueAsDouble;
    xmlPatterns:
      begin
        FHatchPatternData.Clear;
        FHatchPatternData.FromXML(ANode, AResult);
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgCADHatch.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcHatchStyle].Name] := HatchStyle;
  ANode.ChildValues[sPlcKeyWords[plcAngle].Name] := PatternAngle;
  ANode.ChildValues[sPlcKeyWords[plcScale].Name] := PatternScale;
end;
{$ENDIF}

function TsgCADHatch.AddPatternData(const ABasePoint: TFPoint;
  const Angle: Double; const ASign: Integer): PsgHatchPatternData;
begin
  Result := FHatchPatternData.AddPatternData(ABasePoint, Angle, ASign);
end;

function TsgCADHatch.ApplyAngle(const AngleRel: Double): Boolean;
begin
  Result := (Abs(AngleRel) > fAccuracy) and (FHatchPatternData <> nil);
  if Result then
    FHatchPatternData.ApplyAngle(AngleRel);
end;

procedure TsgCADHatch.ApplyFillStyle(const AFillStyle: TsgFillStyle;
  const ABasePoint: TFPoint);
begin
  if AFillStyle <> fsCAD then
  begin
    ClearHatchPatternData;
    case AFillStyle of
      fsHorizontal:  AddPatternData(ABasePoint, 0, 1);
      fsVertical:    AddPatternData(ABasePoint, 90, 1);
      fsBDiagonal:   AddPatternData(ABasePoint, 45, -1);
      fsFDiagonal:   AddPatternData(ABasePoint, -45, 1);
      fsCross:
         begin
           AddPatternData(ABasePoint, 0, 1);
           AddPatternData(ABasePoint, 90, 1);
         end;
      fsDiagCross:
         begin
           AddPatternData(ABasePoint, 45, -1);
           AddPatternData(ABasePoint,-45, 1);
         end;
    end;
  end;
end;

function TsgCADHatch.ApplyScale(const AScaleRel: Double): Boolean;
begin
  Result := (Abs(AScaleRel - 1) > fAccuracy) and (FHatchPatternData <> nil);
  if Result then
    FHatchPatternData.ApplyScale(AScaleRel);
end;

procedure TsgCADHatch.AssignEntity(Source: TsgDXFEntity);
var
  vHatch: TsgCADHatch absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADHatch then
  begin
    FParsedLines.Clear(False);
    ClearHatchPatternData;
    CopyHatchPatternData(vHatch);
    FDoubleHatch := TsgCADHatch(Source).DoubleHatch;
  end;
end;

procedure TsgCADHatch.ParseLines;
begin
  FParsedLines.Clear(False);
  if ParseLineOnDraw or DrawAsSolid then
    Exit;
  if FillStyle <> fsCAD then
    Exit;//draw fill gdi
  try
    HatchStyle := FHatchPatternData.ParseLines(FParsedLines,
      FBoundaryPolylines, FBox, HatchStyle);
  except
    on EsgLimitMemoryUsesException do
    begin
      FParsedLines.Clear(True);
    end;
    on EsgLimitTimeUsesException do
    begin
      FParsedLines.Clear(True);
    end;
    on EsgOverflowUsesException do
    begin
      FParsedLines.Clear(True);
    end;
  end;
end;

function TsgCADHatch.GetEntType: TsgCADEntities;
begin
  Result := ceHatch;
end;

function TsgCADHatch.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgCADHatch.GetHatchStyle: TsgHatchStyle;
begin
  Result := TsgHatchStyle(FHatchStyles and $FF);
end;

function TsgCADHatch.GetFillStyle: TsgFillStyle;
begin
  Result := TsgFillStyle((FHatchStyles shr 8) and $FFFF);
end;

function TsgCADHatch.GetParseLineOnDraw: Boolean;
begin
  Result := FHatchStyles and $1000000 <> 0;
end;

function TsgCADHatch.GetDrawAsSolid: Boolean;
begin
  Result := FHatchStyles and $2000000 <> 0;
end;

function TsgCADHatch.GetPatternAngle: TsgFloat;
begin
  Result := FHatchPatternData.Angle;
end;

function TsgCADHatch.GetPatternScale: TsgFloat;
begin
  Result := FHatchPatternData.Scale;
end;

function TsgCADHatch.GetSolidFill: Boolean;
begin
  Result := False;
end;

function TsgCADHatch.GetThicknessInt: Double;
begin
  Result := cnstThicknessDefault;
end;

function TsgCADHatch.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  inherited InsertEntity(AIndex, AEntity); //ListNotify(AEntity, lnAdded);
  Result := AEntity = FHatchPatternData;
end;

function TsgCADHatch.GetHatchName: string;
begin
  Result := FHatchPatternData.Name;
  if Length(Result) = 0 then
    Result := inherited GetHatchName;
end;

function TsgCADHatch.GetHatchPatternData: TList;
begin
  Result := FHatchPatternData.Patterns;
end;

procedure TsgCADHatch.ListNotify(const Obj: TObject; Action: TListNotification);
begin
  inherited ListNotify(Obj, Action);
  case Action of
    lnAdded:
      if TObject(Obj).InheritsFrom(TsgCADHatchPatternData) then
      begin
        FHatchPatternData.Free;
        FHatchPatternData := TsgCADHatchPatternData(Obj);
      end;
  end;
end;

procedure TsgCADHatch.SetFillStyleWithApplyStyle(const Value: TsgFillStyle);
begin
  if FillStyle <> Value then
  begin
    SetFillStyle(Value);
    ApplyFillStyle(Value, cnstFPointZero);
  end;
end;

procedure TsgCADHatch.SetHatchName(const AHatchName: string);
begin
  FHatchPatternData.Name := AHatchName;
end;

procedure TsgCADHatch.SetHatchStyle(const Value: TsgHatchStyle);
begin
  FHatchStyles := (FHatchStyles and $FFFFFF00) or Byte(Value);
end;

procedure TsgCADHatch.SetFillStyle(const Value: TsgFillStyle);
begin
  FHatchStyles := (FHatchStyles and $FF0000FF) or ((Word(Value) shl 8) and $00FFFF00);
end;

procedure TsgCADHatch.SetParseLineOnDraw(const Value: Boolean);
begin
  FHatchStyles := (FHatchStyles and $FEFFFFFF) or (Byte(Value) shl 24);
end;

procedure TsgCADHatch.SetConverter(const AConverter: TsgDXFConverter);
begin
  inherited SetConverter(AConverter);
  if Assigned(FHatchPatternData) then
    FHatchPatternData.SetConverter(AConverter);
end;

procedure TsgCADHatch.SetDrawOnSolid(const Value: Boolean);
begin
  FHatchStyles := (FHatchStyles and $FDFFFFFF) or (Byte(Value) shl 25);
end;

procedure TsgCADHatch.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgCADHatch.SetPatternAngle(const AVal: TsgFloat);
begin
  FHatchPatternData.DoAngle(AVal);
  if FillStyle <> fsCAD then
    FillStyle := fsCAD;
end;

procedure TsgCADHatch.SetPatternScale(const AVal: TsgFloat);
begin
  if AVal < fAccuracy then
    Exit;
  if FillStyle <> fsCAD then
    FillStyle := fsCAD;
  FHatchPatternData.DoScale(AVal);
end;

procedure TsgCADHatch.SetThicknessInt(const AValue: Double);
begin
end;

function TsgCADHatch.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vPatterns: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);

  ANode.RemoveAttributeByName(cnstXMLNames[xmlGradientTypeName].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlGradientAngle].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlGradientOneColor].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlGradientTwoColor].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlGradientUseCenter].Name);

  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlPatternAngle].Name).ValueData,
    PatternAngle, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlPatternScale].Name).ValueData,
    PatternScale, xmlForViewing in AParams.Mode);
  vPatterns := ANode.AddChildNV(FHatchPatternData.GetNodeName);
  FHatchPatternData.ToXMLNode(vPatterns, AParams);
end;

{ TsgCADMPolygon }

procedure TsgCADMPolygon.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADMPolygon then
  begin
    FOffset := TsgCADMPolygon(Source).FOffset;
    FFillColor := TsgCADMPolygon(Source).FFillColor;
  end;
end;

procedure TsgCADMPolygon.CalcFMatrix;
begin
  inherited CalcFMatrix;
  FMatrix := FMatXMat(FMatByTranslate(FOffset.X, FOffset.Y, 0), FMatrix);
end;

constructor TsgCADMPolygon.Create;
begin
  inherited Create;
  SolidFill := True;
  FillColor := ColorCAD;
end;

function TsgCADMPolygon.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlFillColor: FillColor := ANode.ValueData.ValueAsColorCAD;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgCADMPolygon.GetEntType: TsgCADEntities;
begin
  Result := ceMPolygon;
end;

function TsgCADMPolygon.GetOffset: TFPoint;
begin
  Result.X := FOffset.X;
  Result.Y := FOffset.Y;
  Result.Z := 0;
end;

function TsgCADMPolygon.GetSolidFill: Boolean;
begin
  Result := FFlag and 1 <> 0;
end;

function TsgCADMPolygon.GetFillColor: TsgColorCAD;
begin
  Result := FFillColor;
end;

procedure TsgCADMPolygon.SetOffset(const Value: TFPoint);
begin
  FOffset.X := Value.X;
  FOffset.Y := Value.Y;
end;

procedure TsgCADMPolygon.SetSolidFill(const Value: Boolean);
begin
  FFlag := (FFlag and 254) or Byte(Value);
end;

function TsgCADMPolygon.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlFillColor].Name).ValueData.ValueAsColorCAD := FillColor;
end;

function TsgCADMPolygon.UseMatrix: Boolean;
begin
  Result := True;
end;

procedure TsgCADMPolygon.SetFillColor(const Value: TsgColorCAD);
begin
  FFillColor := Value;
end;

{ TsgDXFGradient}
  (*
constructor TsgDXFGradient.Create;
begin
  inherited Create;
  FColors := TList.Create;
  FPositions := TList.Create;
end;

destructor TsgDXFGradient.Destroy;
begin
  if FMatrix <> nil then
    Dispose(FMatrix);
  FColors.Free;
  FPositions.Free;
  inherited Destroy;
end;

procedure TsgDXFGradient.AssignEntity(Source: TsgDXFEntity);
var
  vGradient: TsgDXFGradient absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFGradient then
  begin
    FPData1 := vGradient.FPData1;
    FPData2 := vGradient.FPData2;
    FRadius := vGradient.FRadius;
    FGFlags := vGradient.FGFlags;
    FColors.Count := vGradient.FColors.Count;
    CopyMemory(FColors.List, vGradient.FColors.List, vGradient.FColors.Count shl 2);
    FPositions.Count := vGradient.FPositions.Count;
    CopyMemory
    (FPositions.List, vGradient.FPositions.List, vGradient.FPositions.Count shl 2);
    if vGradient.HasMatrix then
      Transform := vGradient.Transform
    else
    begin
      if FMatrix <> nil then
      begin
        Dispose(FMatrix);
        FMatrix := nil;
      end;
    end;
  end;
end;

function TsgDXFGradient.GetAbsParam: Boolean;
begin
  Result := FGFlags and 1 <> 0;
end;

function TsgDXFGradient.GetEntType: TsgCADEntities;
begin
  Result := ceGradient;
end;

function TsgDXFGradient.GetHatchName: string;
begin
  Result := 'GRADIENT';
end;

function TsgDXFGradient.GetPData1: TFPoint;
begin
  Result.X := FPData1.X;
  Result.Y := FPData1.Y;
  Result.Z := 0;
end;

function TsgDXFGradient.GetPData2: TFPoint;
begin
  Result.X := FPData2.X;
  Result.Y := FPData2.Y;
  Result.Z := 0;
end;

function TsgDXFGradient.GetRadius: Double;
begin
  Result := FRadius;
end;

function TsgDXFGradient.GetTransform: TFMatrix;
begin
  if FMatrix = nil then
    Result := cnstIdentityMat
  else
    Result := FMatrix^;
end;

function TsgDXFGradient.HasMatrix: Boolean;
begin
  Result := FMatrix <> nil;
end;

function TsgDXFGradient.IsHorizontal: Boolean;
begin
  Result := FPData1.Y = FPData2.Y;
end;

function TsgDXFGradient.IsSpheric: Boolean;
begin
  Result := FRadius > 0;
end;

function TsgDXFGradient.IsVertical: Boolean;
begin
  Result := FPData1.X = FPData2.X;
end;

procedure TsgDXFGradient.SetAbsParams(const Value: Boolean);
begin
  FGFlags := (FGFlags and 254) or Byte(Value);
end;

procedure TsgDXFGradient.SetPData1(const Value: TFPoint);
begin
  FPData1.X := Value.X;
  FPData1.Y := Value.Y;
end;

procedure TsgDXFGradient.SetPData2(const Value: TFPoint);
begin
  FPData2.X := Value.X;
  FPData2.Y := Value.Y;
end;

procedure TsgDXFGradient.SetRadius(const Value: Double);
begin
  FRadius := Value;
end;

procedure TsgDXFGradient.SetTransform(const Value: TFMatrix);
begin
  if CompareMem(@Value, @cnstIdentityMat, Sizeof(Value)) then
  begin
    if FMatrix <> nil then
    begin
      Dispose(FMatrix);
      FMatrix := nil;
    end;
  end
  else
  begin
    if FMatrix = nil then
      New(FMatrix);
    FMatrix^ := Value;
  end;
end;
  *)

{ TsvgStyleFill }

constructor TsgCADStyleFill.Create;
begin
end;

destructor TsgCADStyleFill.Destroy;
begin
  if FTransform <> nil then
    Dispose(FTransform);
  inherited Destroy;
end;

procedure TsgCADStyleFill.Assign(const AObj: TObject);
var
  vSFill: TsgCADStyleFill absolute AObj;
begin
  if not (AObj is TsgCADStyleFill) then Exit;
  FFlags := vSFill.FFlags;
  FRef := vSFill.FRef;
  Transform := vSFill.Transform;
  CopyMemory(@FValues[0], @vSFill.FValues[0], SizeOf(FValues));
end;

procedure TsgCADStyleFill.CheckParams;
begin
end;

function TsgCADStyleFill.GetLocal: Boolean;
begin
  Result := FFlags and 1 <> 0;
end;

function TsgCADStyleFill.GetPoint1: TFPoint;
begin
  Result.X := FValues[0];
  Result.Y := FValues[1];
  Result.Z := 0;
end;

function TsgCADStyleFill.GetTransform: TFMatrix;
begin
  if FTransform = nil then
    Result := cnstIdentityMat
  else
    Result := FTransform^;
end;

function TsgCADStyleFill.GetUnits: TsgStyleFillUnits;
begin
  if FFlags and 2 = 0 then
    Result := sfUserSpaceOnUse
  else
    Result := sfObjectBoundingBox;
end;

function TsgCADStyleFill.GetV0: Double;
begin
  Result := FValues[0];
end;

function TsgCADStyleFill.GetV1: Double;
begin
  Result := FValues[1];
end;

function TsgCADStyleFill.GetV2: Double;
begin
  Result := FValues[2];
end;

function TsgCADStyleFill.GetV3: Double;
begin
  Result := FValues[3];
end;

function TsgCADStyleFill.GetV4: Double;
begin
  Result := FValues[4];
end;

procedure TsgCADStyleFill.SetTransform(const Value: TFMatrix);
begin
  if CompareMem(@Value, @cnstIdentityMat, Sizeof(Value)) then
  begin
    if FTransform <> nil then
    begin
      Dispose(FTransform);
      FTransform := nil;
    end;
  end
  else
  begin
    if FTransform = nil then
      New(FTransform);
    FTransform^ := Value;
  end;
end;

procedure TsgCADStyleFill.SetLocal(const Value: Boolean);
begin
  FFlags := (FFlags and 254) or Byte(Value)
end;

procedure TsgCADStyleFill.SetPoint1(const Value: TFPoint);
begin
  FValues[0] := Value.X;
  FValues[1] := Value.Y;
end;

procedure TsgCADStyleFill.SetRef(const Value: TsgCADStyleFill);
begin
  FRef := Value;
end;

procedure TsgCADStyleFill.SetUnits(const Value: TsgStyleFillUnits);
var
  vFlag: Byte;
begin
  if Value = sfUserSpaceOnUse then
    vFlag := 0
  else
    vFlag := 2;
  FFlags := (FFlags and 253) or vFlag;
end;

procedure TsgCADStyleFill.SetV0(const Value: Double);
begin
  FValues[0] := Value;
end;

procedure TsgCADStyleFill.SetV1(const Value: Double);
begin
  FValues[1] := Value;
end;

procedure TsgCADStyleFill.SetV2(const Value: Double);
begin
  FValues[2] := Value;
end;

procedure TsgCADStyleFill.SetV3(const Value: Double);
begin
  FValues[3] := Value;
end;

procedure TsgCADStyleFill.SetV4(const Value: Double);
begin
  FValues[4] := Value;
end;

{  TsvgStyleGradient  }

destructor TsgCADStyleGradient.Destroy;
begin
  if FStops <> nil then
    FStops.Free;
  Inherited Destroy;
end;

procedure TsgCADStyleGradient.SetRef(const Value: TsgCADStyleFill);
begin
  if Value is TsgCADStyleGradient then
    FRef := Value
  else
    FRef := nil;
end;

function TsgCADStyleGradient.GetLinear: Boolean;
begin
  Result := (FFlags and 4) <> 0;
end;

function TsgCADStyleGradient.GetPoint2: TFPoint;
begin
  Result.X := FValues[2];
  Result.Y := FValues[3];
  Result.Z := 0;
end;

procedure TsgCADStyleGradient.GetPositionColors(const APos: TsgSingleList;
  const AColor: TsgIntegerList);
var
  vStops: TsgSingleList;
  I, J, K: Integer;
  vColor: Integer;
  vIsLinear: Boolean;
begin
  if HasStops then
  begin
    vStops := GetStopList;
    AColor.Count := vStops.Count div 2;
    APos.Count := AColor.Count;
    I := 0;
    J := 0;
    K := AColor.Count - 1;
    vIsLinear := Linear;
    while I < vStops.Count do
    begin
      vColor := PInteger(@vStops.List[I])^;
      if vIsLinear then
        AColor[J] := vColor
      else
        AColor[K - J] := vColor;
      APos[J] := vStops[I + 1] * 0.01;
      Inc(I, 2);
      Inc(J);
    end;
  end;
end;

function TsgCADStyleGradient.GetSpreadMethod: TsgStyleGradSpreadMethod;
begin
  case FFlags and 24 of
    0:  Result := smPad;
    8:  Result := smReflect;
    16:  Result := smRepeat;
  else
    Result := smPad;
  end;
end;

function TsgCADStyleGradient.GetStopList: TsgSingleList;
begin
  if FStops <> nil then
    Result := FStops
  else
    if FRef is TsgCADStyleGradient then
      Result := TsgCADStyleGradient(FRef).GetStopList
    else
      Result := nil;
end;

function TsgCADStyleGradient.GetStopsCount: Integer;
var
  vStops: TsgSingleList;
begin
  vStops := GetStopList;
  if vStops <> nil then
    Result := vStops.Count shr 1
  else
    Result := 0;
end;

function TsgCADStyleGradient.HasStops: Boolean;
var
  vStops: TsgSingleList;
begin
  Result := False;
  vStops := GetStopList;
  if (vStops <> nil) and (vStops.Count > 1) then
    Result := True;
end;

procedure TsgCADStyleGradient.SetLinear(const Value: Boolean);
begin
  FFlags := (FFlags and 251) or (Byte(Value) shl 2);
end;

procedure TsgCADStyleGradient.SetPoint2(const Value: TFPoint);
begin
  FValues[2] := Value.X;
  FValues[3] := Value.Y;  
end;

procedure TsgCADStyleGradient.SetSpreadMethod(const Value: TsgStyleGradSpreadMethod);
var
  vFlag: Byte;
begin
  case Value of
    smPad:      vFlag := 0;
    smReflect:  vFlag := 1;
    smRepeat:   vFlag := 2;
  else
    vFlag := 0;
  end;
  FFlags := (FFlags and 231) or (Byte(vFlag) shl 3);
end;

procedure TsgCADStyleGradient.AddStops(const AColor: Integer; const AOffset: Double);
var
  vOffset: Single;
  vIndex: Integer;
begin
  if FStops = nil then
    FStops := TsgSingleList.Create;

  vIndex := FStops.Add(0);
  PInteger(@FStops.List[vIndex])^ := AColor;

  vOffset := AOffset;
  FStops.Add(vOffset);
end;

procedure TsgCADStyleGradient.Assign(const AObj: TObject);
begin
  inherited Assign(AObj);
  if AObj is TsgCADStyleGradient then
    FStops.Assign(TsgCADStyleGradient(AObj).FStops);
end;

procedure TsgCADStyleGradient.CheckParams;
const
  cnst100per: Single = 100;//$42C80000;//
var
  I, J: Integer;
  vTmp: Single;
  vOffset: Single;
begin
  if (FStops = nil) or (FStops.Count < 4) then Exit;
  I := 1;
  while I < FStops.Count - 2 do
  begin
    J := I + 2;
    while J < FStops.Count do
    begin
      if FStops.List^[I] > FStops.List^[J] then
      begin
        vTmp := FStops.List[I];
        FStops.List[I] := FStops.List[J];
        FStops.List[J] := vTmp;

        vTmp := FStops.List^[I - 1];
        FStops.List^[I - 1] := FStops.List^[J - 1];
        FStops.List^[J - 1] := vTmp;
      end;
      Inc(J, 2);
    end;
    Inc(I, 2);
  end;
  if FStops.List^[FStops.Count - 1] < 10 then//can be max = 1.8
  begin
    I := 1;
    while I < FStops.Count do
    begin
      vOffset := FStops.List^[I] * 100;
      if vOffset < 0 then
        vOffset := 0
      else
        if vOffset > 100 then
          vOffset := 100;
      FStops.List^[I] := vOffset;
      Inc(I, 2);
    end;
  end
  else
  begin
    I := 1;
    while I < FStops.Count do
    begin
      vOffset := FStops.List^[I];
      if vOffset < 0 then
        FStops.List^[I] := 0
      else
        if vOffset > 100 then
          FStops.List[I] := cnst100per;//Single(100)
      Inc(I, 2);
    end;
  end;
  if FStops.List[1] > 0 then
  begin
    FStops.Insert(0, FStops.List[0]);
    FStops.Insert(1, 0);
  end;
  if FStops.List[FStops.Count - 1] < 100 then
  begin
    FStops.Add(FStops.List[FStops.Count - 2]);
    FStops.Add(cnst100per);
  end;
end;

{  TsvgStylePattern  }

constructor TsgCADStylePattern.Create;
begin
  inherited Create;
  FEntities := TList.Create;
  FBox := cnstBadRect;
end;

destructor TsgCADStylePattern.Destroy;
begin
  Dispose(FViewBox);
  FreeList(FEntities);
  inherited Destroy;
end;

procedure TsgCADStylePattern.AddEntity(const AEntity: TsgDXFEntity);
begin
  FEntities.Add(AEntity);
end;

procedure TsgCADStylePattern.Assign(const AObj: TObject);
var
  vSPattern: TsgCADStylePattern absolute AObj;
  I: Integer;
  vEnt, vNew: TsgDXFEntity;
begin
  inherited Assign(AObj);
  if AObj is TsgCADStylePattern then
  begin
    ClearList(FEntities, False);
    //for future version
    for I := 0 to vSPattern.FEntities.Count - 1 do
    begin
      vEnt := vSPattern.FEntities[I];
      vNew := TsgDXFEntityClass(vEnt.ClassType).Create;
      FEntities.Add(vNew);
      vNew.AssignEntity(vEnt);
    end;
  end;
end;

procedure TsgCADStylePattern.CheckParams;
begin
end;

function TsgCADStylePattern.GetContainerSize: TFRect;
begin
  Result := FBox;
end;

function TsgCADStylePattern.GetContainerBox: TFRect;
begin
  if FViewBox = nil then
    Result := FBox
  else
  begin
    Result.Left := FViewBox^.X;
    Result.Bottom := FViewBox^.Y;
    Result.Right := FViewBox^.X + FViewBox^.Width;
    Result.Top := FViewBox^.Y + FViewBox^.Height;
    Result.Z1 := 0;
    Result.Z2 := 0;
  end;
end;

//function TsgCADStylePattern.GetContainerByHatch: TList;
//begin
//  if FEntities <> nil then
//    Result := FEntities
//  else
//    if FRef is TsgCADStylePattern then
//      Result := TsgCADStylePattern(FRef).GetContainerByHatch
//    else
//      Result := nil;
//end;

function TsgCADStylePattern.GetContentUnits: TsgStyleFillUnits;
begin
  if FFlags and 32 = 0 then
    Result := sfUserSpaceOnUse
  else
    Result := sfObjectBoundingBox;
end;

function TsgCADStylePattern.GetCount: Integer;
begin
  Result := FEntities.Count;
end;

function TsgCADStylePattern.GetEntity(const AIndex: Integer): TsgDXFENtity;
begin
   Result := FEntities.List[AIndex];
end;

function TsgCADStylePattern.GetSize: TFPoint;
begin
  Result.X := FValues[2];
  Result.Y := FValues[3];
  Result.Z := 0;
end;

function TsgCADStylePattern.GetViewBox: TsgViewBox;
begin
  if FViewBox <> nil then
    Result := FViewBox^
  else
    Result := cnstViewBoxZero;
end;

procedure TsgCADStylePattern.Iterate(AConverter: TsgDXFConverter; Proc,
  FinishProc: TsgCADEntityProc);
var
  I: Integer;
begin
  for I := 0 to FEntities.Count - 1 do
    TsgDXFEntity(FEntities.List[I]).Invoke(AConverter, Proc, FinishProc);
end;

procedure TsgCADStylePattern.Loaded(const AConverter: TsgDXFConverter);
var
  I: Integer;
  vEntity: TsgDXFEntity;
begin
  FBox := cnstBadRect;
  for I := 0 to FEntities.Count - 1 do
  begin
    vEntity := FEntities.List[I];
    AConverter.Loads(vEntity);
    UnionFRect(FBox, vEntity.Box);
  end;
end;

procedure TsgCADStylePattern.SetContentUnits(const Value: TsgStyleFillUnits);
var
  vFlag: Byte;
begin
  if Value = sfUserSpaceOnUse then
    vFlag := 0
  else
    vFlag := 1;
  FFlags := (FFlags and 223) or (vFlag shl 5);
end;

procedure TsgCADStylePattern.SetRef(const Value: TsgCADStyleFill);
begin
  if Value is TsgCADStylePattern then
    FRef := Value
  else
    FRef := nil;
end;

procedure TsgCADStylePattern.SetSize(const Value: TFPoint);
begin
  FValues[2] := Value.X;
  FValues[3] := Value.Y;
end;

procedure TsgCADStylePattern.SetViewBox(const Value: TsgViewBox);
begin
  if (Value.Width > 0) and (Value.Height > 0) then
  begin
    if FViewBox = nil then
    begin
      New(FViewBox);
      FViewBox^ := Value;
    end;
  end
  else
  begin
    if FViewBox <> nil then
    begin
      Dispose(FViewBox);
      FViewBox := nil;
    end;
  end;
end;

{  TsgCADFill  }

procedure TsgCADFill.AssignEntity(Source: TsgDXFEntity);
var
  vFill: TsgCADFill absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADFill then
  begin
    FCADFillFlags := vFill.FCADFillFlags;
    StyleFill := vFill.StyleFill;
    FreeAndNil(FImage);
  end;
end;

procedure TsgCADFill.ClearReferences;
begin
  inherited ClearReferences;
end;

procedure TsgCADFill.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FImage);
  if (FStyleFill <> nil) and FStyleFill.Local then
    FreeAndNil(FStyleFill);
end;

function TsgCADFill.ConvertToImageEnt(const AConverter: TsgDXFConverter): TsgDXFImageEnt;
const
  cnstMaxMetafileSize = cnstMaxImgSize * 1000;
var
  vCADImage: TsgCADImage;
  vExportImage: {$IFDEF SG_DELPHI_VCL}TMetafile {$ELSE}TsgBitmap{$ENDIF};
  vWidth, vHeight: Integer;
  vBox: TFRect;
  vCADFillFlags: Byte;
begin
  Result := nil;
  vBox := Self.Box;
  SetMaxMetafileExtents(Abs(vBox.Right - vBox.Left),
    Abs(vBox.Top - vBox.Bottom), vWidth, vHeight, cnstMaxMetafileSize);
  if (vWidth > 0) and (vHeight > 0) then
  begin
    vCADFillFlags := FCADFillFlags;
    vCADImage := TsgCADImage.Create;
    try
      vCADImage.Converter.InitializeSectionsBegin;
      vCADImage.Converter.InitializeSectionsEnd;
      vCADImage.CurrentLayout := vCADImage.Layouts[0];
      vCADImage.Transparent := True;
      vCADImage.BorderType := btGlobal;
      vCADImage.BorderSize := 0;
      vCADImage.IsWithoutBorder := True;
      vCADImage.CurrentLayout.AddEntity(Self);
      vCADImage.GetExtents;
      UseBuffer := False;
      vExportImage := {$IFDEF SG_DELPHI_VCL}vCADImage.ExportToMetafile(vWidth, vHeight){$ELSE}nil{$ENDIF};
      try
        if vExportImage <> nil then
        begin
          Result := TsgDXFImageEnt.Create;
          try
            Result.SetImage(vExportImage);
            Result.Size := MakeFPoint(vExportImage.Width, vExportImage.Height);
            Result.Point := MakeFPoint(vBox.Left, vBox.Bottom, 0);
            Result.Loaded(AConverter);
            Result.UVector := MakeFPoint(Abs(vBox.Right - vBox.Left) /
               Abs(Result.Box.Left - Result.Box.Right), 0);
            Result.VVector := MakeFPoint(0, Abs(vBox.Top - vBox.Bottom) /
               Abs(Result.Box.Top - Result.Box.Bottom));
            Result.Loaded(AConverter);
          except
            FreeAndNil(Result);
          end;
        end;
      finally
        vExportImage.Free;
      end;
    finally
      FCADFillFlags := vCADFillFlags;
      vCADImage.CurrentLayout.RemoveEntity(Self);
      vCADImage.Free;
    end;
  end;
end;

function TsgCADFill.CreateBMPFill(const AMatrix: TFMatrix; const AClass: TClass): Boolean;
var
  vBMP: TBitmap;
  vPattern: TsgCADStylePattern;
  vHeight, vWidth, vPW, vPH, CX, CY, X, Y, PX, PY: Integer;
  {$IFNDEF SG_FIREMONKEY}
  vSDC, vDDC: THandle;
  {$ENDIF}
  vImgBox, vPatBox: TRect;
  vPatPos: TPoint;

  procedure SetRectWH(const ARect: TRect; var W, H: Integer);
  begin
    W := ARect.Right - ARect.Left;
    H := ARect.Bottom - ARect.Top;    
  end;

  function GetScreenRect(ARect: TFRect): TRect;
  begin
    TransRectCorners(ARect, AMatrix);
    Result.Left := Floor(ARect.Left);
    Result.Top := Floor(ARect.Bottom);
    Result.Right := Ceil(ARect.Right);
    Result.Bottom := Ceil(ARect.Top);
    if Result.Left = Result.Right then
      Inc(Result.Right);
    if Result.Top = Result.Bottom then
      Inc(Result.Bottom);
  end;

  function GetPatSize: TRect;
  var
    vKX, vKY: Double;
  begin
    if vPattern.Units = sfUserSpaceOnUse then
      Result := GetScreenRect(MakeFRect(0, vPattern.Height, 0, vPattern.Width, 0, 0))
    else
    begin
      vKX := (vImgBox.Right - vImgBox.Left) / 100;
      vKY := (vImgBox.Bottom - vImgBox.Top) / 100;
      Result.Left := vImgBox.Left;
      Result.Top := vImgBox.Top;
      Result.Right := Result.Left + Ceil(vKX * vPattern.Width);
      Result.Bottom := Result.Top + Ceil(vKY * vPattern.Height);
    end;
    if Result.Left = Result.Right then
      Inc(Result.Right);
    if Result.Top = Result.Bottom then
      Inc(Result.Bottom);
  end;

  function GetPatPos: TPoint;
  var
    vKX, vKY: Double;
    vP: TFPoint;
  begin
    if vPattern.Units = sfUserSpaceOnUse then
    begin
      vP := FPointXMat(MakeFPoint(vPattern.X1, vPattern.Y1, 0), AMatrix);
      Result.X :=  Round(vP.X);
      Result.Y :=  Round(vP.Y);
    end
    else
    begin
      vKX := (vImgBox.Right - vImgBox.Left) / 100;
      vKY := (vImgBox.Bottom - vImgBox.Top) / 100;
      Result.X := vImgBox.Left + Ceil(vKX * vPattern.X1);
      Result.Y := vImgBox.Top + Ceil(vKY * vPattern.Y1);
    end;
  end;

  function GetStart(const VImg, VPat, VSize: Integer): Integer;
  var
    vDelta, vShift: Integer;
  begin
    vDelta := VImg - VPat;
    if vDelta = 0 then
      Result := 0
    else
    begin
       vShift := (vDelta div VSize) * VSize;
       Result :=  VPat + vShift - VImg;
    end;
  end;

begin
  Result := False;
  vPattern := TsgCADStylePattern(FStyleFill);
  vImgBox := GetScreenRect(FBox);
  SetRectWH(vImgBox, vWidth, vHeight);
  if (vWidth < cnstMaxImgSize) and (vHeight < cnstMaxImgSize) then
  begin
    vPatBox := GetPatSize;
    SetRectWH(vPatBox, vPW, vPH);
    if (vPW < cnstMaxImgSize) and (vPH < cnstMaxImgSize) then
    begin
      if FImage = nil then
      begin
        FImage := TBitmap.Create;
        FImage.PixelFormat := pf24bit;
      end
      else
        if (FImage.Width = vWidth) and (FImage.Height = vHeight) then
        begin
          Result := True;
          Exit;//FBitmap not changed
        end;
      SetSizeBmp(FImage, vWidth, vHeight);
      SetBackgroundColor(FImage);
      SetTransparentColor(FImage);

      vPatPos := GetPatPos;
      PX := GetStart(vImgBox.Left, vPatPos.X, vPW);
      PY := GetStart(vImgBox.Bottom, vPatPos.Y, vPH);

      vBMP := GetBush(vPW, vPH, AClass);
      try
        {$IFNDEF SG_FIREMONKEY}
        vSDC := vBMP.Canvas.Handle;
        vDDC := FImage.Canvas.Handle;
        {$ENDIF}
        CX := (vWidth + Abs(PX)) div vPW + 1;
        CY := (vHeight + Abs(PY)) div vPH + 1;
        for Y := 0 to CY do
          for X := 0 to CX do
          {$IFNDEF SG_FIREMONKEY}
            BitBlt(vDDC, PX + X * vPW, PY + Y * vPH, vPW, vPH, vSDC, 0, 0, SRCCOPY);
          {$ELSE}
            FImage.Canvas.DrawBitmap(vBMP, vBMP.BoundsF, TRectF.Create(PX + X * vPW,
              PY + Y * vPH, PX + X * vPW + vPW, PY + Y * vPH + vPH), 1);
          {$ENDIF}
        Result := True;
      finally
        vBMP.Free;
      end;
    end
    else
      FreeAndNil(FImage);
  end
  else
    FreeAndNil(FImage);
end;

function TsgCADFill.CreateBMPPattern(AWidth, AHeight: Integer; const AClass: TClass): TBitmap;
begin
  if AWidth > cnstMaxImgSize then
    AWidth := cnstMaxImgSize;
  if AHeight > cnstMaxImgSize then
    AHeight := cnstMaxImgSize;
  Result := GetBush(AWidth, AHeight, AClass);
  SetTransparentColor(Result);
end;

function TsgCADFill.CreateInsertAndBlock(const AImg: TObject): TsgDXFInsert;
var
  vLayout: TsgDXFLayout;
  vConverter: TsgDXFConverter;
  vHandle: UInt64;
begin
  Result := nil;
  if  AImg is  TsgCADImage then
  begin
    vLayout := TsgCADImage(AImg).CurrentLayout;
    vConverter := TsgCADImage(AImg).Converter;
  end
  else
  begin
    if AImg is TsgDXFConverter then
    begin
      vLayout := TsgDXFConverter(AImg).Layouts[0];
      vConverter := TsgDXFConverter(AImg);
    end
    else
    begin
      vLayout := nil;
      vConverter := nil;
    end;
  end;
  if Assigned(vConverter) and Assigned(vLayout) then
  begin
    Result := TsgDXFInsert.Create;
    vLayout.AddEntity(Result);
    Result.Block :=  TsgDXFBlock.Create;
    vHandle := {$IFDEF SGDEL_7}UInt64{$ELSE}Integer{$ENDIF}(Result);
    Result.Block.Name := cnstSVGBlockNameBase + IntToHex(vHandle, 0);
    vConverter.Sections[csBlocks].AddEntity(Result.Block);
    Result.Scale := MakeFPoint(1, -1, 1);
  end;
end;

function TsgCADFill.GetBackground: TColor;
begin
  Result := clWhite;
end;

function TsgCADFill.GetBush(const W, H: Integer; AClass: TClass): TBitmap;
var
  I: Integer;
  vImg: TsgCADImage;
  vBlock: TSgDXFBlock;
  vPattern: TsgCADStylePattern;
  vRect: TRect;
  vInsert: TsgDXFInsert;
begin
  vRect := Rect(0, 0, W, H);
  vPattern := TsgCADStylePattern(FStyleFill);
  Result := TBitmap.Create;
  Result.PixelFormat := pf24bit;
  SetSizeBmp(Result, W, H);
  SetBackgroundColor(Result);
  if AClass = nil then
    AClass := TsgCADImage;
  vBlock := nil;
  vImg := TsgCADImageClass(AClass).Create;
  try
    vImg.Converter.InitializeSectionsBegin;
    vImg.Converter.InitializeSectionsEnd;
    vImg.Converter.DoExtents;
    vImg.CurrentLayout := vImg.Layouts[0];
    vImg.Transparent := True;
    vImg.BorderSize := 0;
    vImg.IsWithoutBorder := True;
//    vImg.DefaultColor := 0;
    vImg.BackgroundColor := Background;
    vImg.Stretch := True;
    vImg.SetMatrixMode(smDisabled);
    vInsert := CreateInsertAndBlock(vImg);
    if Assigned(vInsert) then
    begin
      vBlock := vInsert.Block;
      for I := 0 to vPattern.Count - 1 do
        vBlock.AddEntity(vPattern.Entities[I]);
      vImg.Converter.Loads(vBlock);
      vBlock.FBox := vPattern.ContainerBox;
      vImg.Converter.Loads(vInsert);
      vImg.GetExtents;
      Result.Canvas.StretchDraw(vRect, vImg);
    end;
  finally
    if Assigned(vBlock) then
      vBlock.Clear(False);
    vImg.Free;
  end;
end;

function TsgCADFill.GetStyleFill: TsgCADStyleFill;
begin
  Result := FStyleFill;
end;

function TsgCADFill.GetUseBuffer: Boolean;
begin
  Result := FCADFillFlags and 1 = 0;
end;

function TsgCADFill.GroupExists: Boolean;
begin
  Result := True;
end;

function TsgCADFill.GroupFill(AConverter: TsgDXFConverter): Boolean;
var
  vImageEnt: TsgDXFImageEnt;
begin
  Result := False;
  vImageEnt := ConvertToImageEnt(AConverter);
  if Assigned(vImageEnt) then
  begin
//    Loaded(vImageEnt);
    Group.AddEntity(vImageEnt);
    Result := True;
  end;
end;

function TsgCADFill.GroupHasAddedEntities: Boolean;
begin
  Result := True;
end;

procedure TsgCADFill.LoadedInternal(AConverter: TsgDXFConverter);
begin
  if FStyleFill <> nil then
    FType := gtOther
  else
    FType := gtNone;
  inherited LoadedInternal(AConverter);
end;

procedure TsgCADFill.SetBackgroundColor(const ABmp: TBitmap);
begin
  ABmp.Canvas.Pen.Color := Background;
{$IFNDEF SG_FIREMONKEY}
  ABmp.Canvas.Brush.Style := bsSolid;
{$ELSE}
  ABmp.Canvas.Fill.Kind := TBrushKind.Solid;
{$ENDIF}
  ABmp.Canvas.Brush.Color := Background;
  ABmp.Canvas.FillRect(ABmp.Canvas.ClipRect);
end;

procedure TsgCADFill.SetStyleFill(const Value: TsgCADStyleFill);
begin
  if (FStyleFill <> nil) and FStyleFill.Local then
  begin
    FStyleFill.Free;
    FStyleFill := nil;
  end;
  if (Value <> nil) and Value.Local then
  begin
    FStyleFill := TsgClassOfCADStyleFill(Value.ClassType).Create;
    FStyleFill.Assign(Value);
  end
  else
    FStyleFill := Value;
end;

procedure TsgCADFill.SetTransparentColor(const ABmp: TBitmap);
begin
{$IFNDEF SG_FIREMONKEY}
  ABmp.Transparent := True;
  ABmp.TransparentColor := Background;
  ABmp.TransparentMode := tmFixed;
{$ENDIF}
//TODO: TsgCADFill.SetTransparentColor for Firemonkey
end;

procedure TsgCADFill.SetUseBuffer(const Value: Boolean);
begin
  FCADFillFlags := (FCADFillFlags and 254) or Byte(not Value);
end;

{ TsgDXFXRef }

function TsgDXFXRef.CanDraw: Boolean;
begin
  Result := True;
end;

procedure TsgDXFXRef.ClearReferences;
begin
  inherited ClearReferences;
{$IFDEF SG_OPENING_IN_THEADS}
  MonitorEnter(GlobalLoadingXRefsStack);
  try
{$ENDIF}
    GlobalLoadingXRefsStack.Remove(Self);
{$IFDEF SG_OPENING_IN_THEADS}
  finally
    MonitorExit(GlobalLoadingXRefsStack);
  end;
{$ENDIF}
end;

constructor TsgDXFXRef.Create;
begin
  inherited Create;
  FInvokeConverters := TsgList.Create;
end;

procedure TsgDXFXRef.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FCADImage);
  FreeAndNil(FInvokeConverters);
end;

function TsgDXFXRef.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vFileName: string;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlFileName:
      begin
        vFileName := ANode.ValueAsStr;
        if not SameText(vFileName, FPath) then
        begin
          AddCADImage(Converter, vFileName);
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFXRef.GetBlock: TsgDXFBlock;
begin
  if GetOwner is TsgDXFBlock then
    Result := TsgDXFBlock(GetOwner)
  else
    Result := nil;
end;

function TsgDXFXRef.GetBox: TFRect;
begin
  Result := FBox;
end;

function TsgDXFXRef.GetEntType: TsgCADEntities;
begin
  Result := ceXRef;
end;

function TsgDXFXRef.GetLayer: TsgDXFLayer;
begin
  Result := nil;
  if Assigned(GetOwner()) then
    Result := GetOwner().Layer;
end;

//procedure TsgDXFXRef.GraphicChange(Sender: TObject);
//begin
//end;

procedure TsgDXFXRef.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
  vXRefParams: PsgCADIterate;
  PrevParams: TsgCADIterate;
  PrevAutoInsert: Boolean;
  vConv: TsgDXFConverter;
  vSHXFontList: TsgSHXFontList;
  vParams: PsgCADIterate;
begin
  if FCADImage <> nil then
  begin
    inherited Invoke(AConverter, Proc, FinishProc);
    try
      vConv := TsgCADImage(FCADImage).Converter;
      if FInvokeConverters.IndexOf(vConv) < 0 then
      begin
        vParams := AConverter.Params;
        vXRefParams := vConv.ExchangeParams(vParams);
        FInvokeConverters.Add(vConv);
        try
          PrevParams := vParams^;
          PrevAutoInsert := vConv.AutoInsert;
          vSHXFontList := AConverter.FSHXFonts;
          try
            vConv.AutoInsert := AConverter.AutoInsert;
      //    vConv.Iterate(Proc, AConverter.FParams^);
          //Not setting AConverter.Params^.Insert
            AConverter.Params^.Color := clByLayer;
            AConverter.Params^.XScale := 0.0;
            AConverter.Params^.YScale := 0.0;
            AConverter.FSHXFonts := vConv.FSHXFonts;
            vConv.GetModelLayout.PaperSpaceBlock.Iterate(AConverter, Proc, FinishProc);
            PrevParams.Stopped := AConverter.Params^.Stopped;
          finally
            AConverter.FSHXFonts := vSHXFontList;
            vParams^ := PrevParams;
            vConv.AutoInsert := PrevAutoInsert;
          end;
        finally
          vConv.ExchangeParams(vXRefParams);
          FInvokeConverters.Remove(vConv);
        end;
      end;
      // else circular reference
    finally
      if Assigned(FinishProc) then
        FinishProc(Self);
    end;
  end;
end;

procedure TsgDXFXRef.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  FBox := BadRect;
  if FCADImage <> nil then
  begin
    TsgCADImage(FCADImage).Converter.FOwnerConverter := AConverter;
    if TsgCADImage(FCADImage).Converter.GetModelLayout <> nil then
      FBox := TsgCADImage(FCADImage).Converter.GetModelLayout.Box;// always only Model Box
    TsgCADImage(FCADImage).Converter.NumberOfPartsInSpline := AConverter.NumberOfPartsInSpline;
    TsgCADImage(FCADImage).Converter.NumberOfPartsInCircle := AConverter.NumberOfPartsInCircle;
  end;
end;

function TsgDXFXRef.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlFileName].Name).ValueAsStr := FPath;
end;

//procedure TsgDXFXRef.ProgressEvent(Sender: TObject; Stage: TProgressStage;
//  PercentDone: Byte; RedrawNow: Boolean; const R: TRect; const Msg: string);
//begin
//  if Assigned(FOwnerProgress) then
//    FOwnerProgress(Sender, Stage, PercentDone, RedrawNow, R, Msg);
//end;

function TsgDXFXRef.AddCADImage(const AMainConv: TsgDXFConverter;
  const AFilePath: string; ASearchPaths: TStrings = nil): Boolean;
var
  vPrevCADPreview: Boolean;
  vFileName: string;
  I: Integer;

  procedure FreeCADImage;
  begin
//    FOwnerProgress := nil;
    FreeAndNil(FCADImage);
  end;

  { Function FileExistsEx

    var AFileName: string - in/out parameter.

    If no AFileName extension, try find first with
    cnstSupportedSGXRefExtesions items as extension

   TODO: FileExists(): - change in the future version the xref with network path
  }
  function FileExistsEx(var AFileName: string): Boolean;
  const
    //??extensions priority: 'dwg', 'dxf', ...
    cnstSupportedSGXRefExtesions: array[0 .. 1] of string = ('.dxf', '.dwg');
  var
    J: Integer;
  begin
    Result := False;
    if Assigned(XRefFileClasses) and (ExtractFileExt(AFileName) = '') then
    begin
      J := High(cnstSupportedSGXRefExtesions);
      while not Result and (J >= Low(cnstSupportedSGXRefExtesions)) do
      begin
        if (XRefFileClasses.IndexOf(cnstSupportedSGXRefExtesions[J]) >= 0) and
           FileExists(AFileName + cnstSupportedSGXRefExtesions[J]) then
          Inc(Result)
        else
          Dec(J);
      end;
      if Result then
        AFileName := AFileName + cnstSupportedSGXRefExtesions[J];
    end
    else
      Result := FileExists(AFileName);
  end;

  function ForcePathSlash(const APath: string): string;
  begin
    Result := APath;
    if (Result <> '') and (Result[Length(Result)] <> PathDelim) then
      Result := Result + PathDelim;
  end;

begin
  FreeCADImage;
  FPath := AFilePath;
  Result := FileExistsEx(FPath);
  if not Result then
  begin
    FPath := ExtractFileName(FPath);
    Result := FileExistsEx(FPath);
    if ASearchPaths = nil then
      ASearchPaths := AMainConv.FXRefSearchPaths;
    if not Result and (ASearchPaths <> nil) then
    begin
      vFileName := FPath;
      for I := 0 to ASearchPaths.Count - 1 do
      begin
        FPath := ForcePathSlash(ASearchPaths[I]);
        FPath := FPath + vFileName;
        Result := FileExists(FPath);
        if Result then
          Break;
      end;
    end
    else
    begin
      FPath := ForcePathSlash(GetCurrentDir) + ExtractFileName(AFilePath);
      Result := SysUtils.FileExists(FPath);
    end;
  end;
  if not Result then
    AMainConv.ResolveNotFoundXRef(Self, FPath, Result);
  if Result and Assigned(XRefFileClasses) then
  try
    vPrevCADPreview := CADPreview;
    CADPreview := False;
    try
      I := XRefFileClasses.IndexOf(ExtractFileExt(FPath));
      if (I >= 0) and TGraphicClass(TsgObjectTClass(XRefFileClasses.Objects[I]).FieldClass).InheritsFrom(TsgCADImage) then
      begin
{$IFDEF SG_OPENING_IN_THEADS}
        MonitorEnter(GlobalLoadingXRefsStack);
        try
{$ENDIF}
          FCADImage := TGraphic(TGraphicClass(TsgObjectTClass(XRefFileClasses.Objects[I]).FieldClass).NewInstance);
          GlobalLoadingXRefsStack.Add(Self);
          try
//            FCADImage.OnChange := GraphicChange;
//            if Assigned(Loading) and Assigned(Loading.OnProgress) then
//              if TObject(TMethod(Loading.OnProgress).Data) is TPicture then
//                FOwnerProgress := Loading.OnProgress;
//            FCADImage.OnProgress := ProgressEvent;
            FCADImage.Create;
            Converter.InitXRefConverter(TsgCADImage(FCADImage).Converter, Self);
            FCADImage.LoadFromFile(ExpandFileName(FPath)); //Autodesk uses only DWG in Xref
          finally
            GlobalLoadingXRefsStack.Remove(Self);
          end;
{$IFDEF SG_OPENING_IN_THEADS}
        finally
          MonitorExit(GlobalLoadingXRefsStack);
        end;
{$ENDIF}
      end;
    finally
      CADPreview := vPrevCADPreview;
    end;
  except
    Result := False;
    FreeCADImage;
  end;
  Name := ChangeFileExt(ExtractFileName(FPath), '');
end;

{ TsgDXFLayout }

constructor TsgDXFLayout.Create;
begin
  inherited Create;
  FBox := BadRect;
  Name := sModel;
  FPlotSettings := TsgDXFPlotSettings.Create;
  FCADSpace := cs3D;//cs2D - it is not completely tested for viewports
  FRotMatrix := cnstIdentityMat;
  FView := TsgView.Create(0);
end;

function TsgDXFLayout.GetBlockName(const AIndex: Integer = -1): string;
var
  I: Integer;
begin
  I := Self.Index;
  if AIndex > -1 then
    I := AIndex;
  case I of
    -1: Result :=  '*[' + Name + ']'; // need to correct!!!
    0: Result := sModelSpace;
    1: Result := sPaperSpace;
  else
    Result := sPaperSpace + IntToStr(I - 2);
  end;
end;

function TsgDXFLayout.GetBlockRecord: TsgDXFEntity;
begin
  Result := nil;
  if Assigned(FPaperSpaceBlock) then
    Result := FPaperSpaceBlock.BlockRecord;
end;

function TsgDXFLayout.GetBox: TFRect;
begin
  Result := FBox;
end;

function TsgDXFLayout.GetCount: Integer;
begin
  if FPaperSpaceBlock = nil then
    Result := 0
  else
    Result := PaperSpaceBlock.Count;
end;

function TsgDXFLayout.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  if FPaperSpaceBlock = nil then
    Result := nil
  else
    Result := PaperSpaceBlock.Entities[AIndex];
end;

procedure TsgDXFLayout.GetExtents(var AMin, AMax: array of TsgFloat);
var
  R: TFRect;

  function CopyArrayValues(const ASrc: array of TsgFloat;
    var ADst: array of TsgFloat): Integer;
  begin
    Result := MinI(High(ASrc), High(ADst));
    if Result >= 0 then
      System.Move(ASrc[0], ADst[0], (Result + 1) * SizeOf(ASrc[0]));
  end;

begin
  R := Box;
  if not IsBadRect(R) then
    TransRectCorners(R, RotMatrix);
  SwapDoubles(R.Top, R.Bottom);
  CopyArrayValues(R.TopLeft.V, AMin);
  CopyArrayValues(R.BottomRight.V, AMax);
end;

function TsgDXFLayout.GetExtMax: TFPoint;
begin
  GetExtents(Slice(PsgFloatArray(nil)^, 0), Result.V);
end;

function TsgDXFLayout.GetExtMin: TFPoint;
begin
  GetExtents(Result.V, Slice(PsgFloatArray(nil)^, 0));
end;

procedure TsgDXFLayout.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFLayout then
  begin
    FView.Assign(TsgDXFLayout(Source).FView);
    FPlotSettings.AssignEntity(TsgDXFLayout(Source).PlotSettings);
  end;
end;

function TsgDXFLayout.GetEmpty: Boolean;
begin
  Result := (Count = 0);
end;

function TsgDXFLayout.GetIndex: Integer;
begin
//  if Assigned(Owner) then
//    Result := Owner.IndexOfEntity(Self)
//  else
//    Result := -1;
  Result := -1;
  if Assigned(Converter)and Assigned(Converter.Sections[csLayouts]) then
    Result := Converter.Sections[csLayouts].IndexOfEntity(Self);
end;

function TsgDXFLayout.GetIsModel: Boolean;
begin
  Result := (Converter = nil) or
   ((Assigned(Converter)) and (Self = Converter.GetModelLayout));
end;

function TsgDXFLayout.GetPaperSpaceBlock: TsgDXFBlock;
var
  vBlock: TsgDXFBlock;
  vBlockName: string;
  vConv: TsgDXFConverter;
begin
  if (FPaperSpaceBlock = nil) and (Converter <> nil) then
  begin
    vConv := Converter;
    vBlockName := GetBlockName;
    vBlock := TsgDXFBlock(vConv.NewNamedEntity(
      vConv.Sections[csBlocks], TsgDXFBlock, vBlockName));
    vConv.SetHandle(vBlock);
    vConv.SetHandle(vBlock.BlockRecord);
    SetPaperSpaceBlock(vBlock);
  end;
  Result := FPaperSpaceBlock;
  if Assigned(Result) then
    Result.IsLoaded := False;
end;

{$IFDEF SG_VERSION_OLD}
function TsgDXFLayout.GetPlotPaperUnits: Integer;
begin
  Result := Integer(PlotSettings.PlotPaperUnits);
end;
{$ENDIF}

{ TsgDXFLayout.IsgListOfEntities }

function TsgDXFLayout.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := PaperSpaceBlock.DeleteEntity(AIndex);
end;

destructor TsgDXFLayout.Destroy;
begin
  NotifyDestroing;
  inherited Destroy;
end;

function TsgDXFLayout.AddEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := PaperSpaceBlock.AddEntity(AEntity);
end;

function TsgDXFLayout.CanAddedToXMLParams: Boolean;
begin
  Result := True;
end;

procedure TsgDXFLayout.Clear(const ADoFree: Boolean = True);
begin
  if FPaperSpaceBlock <> nil then
    FPaperSpaceBlock.Clear(ADoFree);
end;

procedure TsgDXFLayout.ClearReferences;
begin
  inherited ClearReferences;
  PaperSpaceBlock := nil;
end;

function TsgDXFLayout.IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := PaperSpaceBlock.IndexOfEntity(AEntity);
end;

function TsgDXFLayout.IndexOfName(const AName: string): Integer;
begin
  Result := PaperSpaceBlock.IndexOfName(AName);
end;

function TsgDXFLayout.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := PaperSpaceBlock.InsertEntity(AIndex, AEntity);
end;

procedure TsgDXFLayout.Iterate(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
{$IFDEF DEMO}
  vEnt: TsgDXFEntity;
{$ENDIF}
  vCreatedBlockStack: Boolean;
begin
  AConverter.Params^.Insert := nil;
  AConverter.Params^.ConvertMatrixCurrentInsertToWCS := cnstIdentityMat;
  AConverter.Params^.Color := clByLayer;
  AConverter.Params^.XScale := 0.0;
  AConverter.Params^.YScale := 0.0;
  AConverter.Params^.LType := StdLines;
  vCreatedBlockStack := not Assigned(AConverter.Params^.BlockStack);
  if vCreatedBlockStack then
    AConverter.Params^.BlockStack := {$IFDEF SG_FIREMONKEY}TsgObjectList{$ELSE}TsgList{$ENDIF}.Create;
  try
    AConverter.Params^.BlockStack.Sorted := True;
    AConverter.Params^.BlockStack.Duplicates := dupIgnore;
    AConverter.Params^.BlockStack.Add(PaperSpaceBlock);
    Converter.DoIterateBegin(Self);
    PaperSpaceBlock.Iterate(AConverter, Proc, FinishProc);
  finally
    Converter.DoIterateEnd(Self);
    if vCreatedBlockStack then
      FreeAndNil(AConverter.Params^.BlockStack);
  end;
{$IFDEF DEMO}
  vEnt := DrawSGBlock(Self, AConverter);
  if vEnt is TsgDXFGroup then
    TsgDXFGroup(vEnt).Iterate(AConverter, Proc, FinishProc);
{$ENDIF}
end;

procedure TsgDXFLayout.LoadedInternal(AConverter: TsgDXFConverter);
var
  vEntity : TsgDXFEntity;
begin
  if Assigned(FPlotSettings) and (FPlotSettings.PageSetupName <> '') then
  begin
     vEntity := AConverter.Sections[csObjects].FindEntByName(FPlotSettings.PageSetupName);
     if (vEntity <> nil) and (vEntity <> FPlotSettings) then
       FPlotSettings.AssignEntity(vEntity);
  end;
  DoExtents(AConverter);
  inherited LoadedInternal(AConverter);
end;

function TsgDXFLayout.RotMatrix: TFMatrix;
begin
  Result := FRotMatrix;
end;

procedure TsgDXFLayout.SetRotMatrix(ARotMatrix: TFMatrix);
begin
  FRotMatrix := ARotMatrix;
end;

procedure TsgDXFLayout.UpdatePlotSettingsByExtents;
begin
  if Assigned(PlotSettings) then
    PlotSettings.UpdateExtents(Box);
end;

function TsgDXFLayout.UsingPlotSettings: Boolean;
begin
  Result := Assigned(FPlotSettings) and
    (FPlotSettings.PlotPaperSize.X * FPlotSettings.PlotPaperSize.Y <> 0);
end;

function TsgDXFLayout.IsLayerInVisible(ALayer: TsgDXFLayer; AConv: TsgDXFConverter; AnnOnly: Boolean): Boolean;
var
  LS,MS: Double;
begin
  Result := False;
  if AnnOnly and not ALayer.Annotative then Exit;
  Result := (ALayer <> nil) and not (ALayer.Visible and not ALayer.Frozen);
  if Result or (ALayer=nil) or not ALayer.Annotative then
    Exit;
  if PlotSettings.StandardScaleType = 0 then
  begin
    if not Assigned(AConv) or not Assigned(AConv.AnnoScale) then
      Exit;
    if (Assigned(AConv.Params) and Assigned(AConv.Params^.Viewport)) or (Self = AConv.GetModelLayout) then //IsModel
    begin
      LS := AConv.AnnoScale.LayoutScale;
      MS := AConv.AnnoScale.ModelScale;
    end
    else
    begin
      LS := 1.0;
      MS := 1.0;
    end;
  end
  else
  begin
    LS := PlotSettings.NumeratorOfCustomPrintScale;
    MS := PlotSettings.DenominatorOfCustomPrintScale;
  end;
  Result := (ALayer.AnnoScale.LayoutScale <> LS) or (ALayer.AnnoScale.ModelScale <> MS);
end;

procedure TsgDXFLayout.DoExtents(AConverter: TsgDXFConverter);
var
  I: Integer;
  vRays: TsgObjectList;
  vRay: TsgDXFRay;
  vHeadVarStruct: PsgHeadVarStruct;
begin
  vRays := TsgObjectList.Create;
  try
    if Assigned(AConverter) then
      vHeadVarStruct := AConverter.PHeadVarStruct
    else
      vHeadVarStruct := @cnstDefHeadVarStruct;
    if FPaperSpaceBlock <> nil then
      FPaperSpaceBlock.IsLoaded := False;
    FBox := BadRect;
    for I := 0 to Count - 1 do
      if not IsInvisible(Entities[I], AConverter, vRays, vHeadVarStruct^) then
        UnionFRect(FBox, Entities[I].BoxForLayout(Self,AConverter));
    for I := 0 to vRays.Count - 1 do
    begin
      vRay := TsgDXFRay(vRays[I]);
      if not IsLayerInVisible(vRay.Layer, AConverter) then
        if IsRayIntersectsBox(vRay.StartPoint, vRay.Direction, FBox, nil) or
          ((vRay.EntType = ceXline) and
            IsRayIntersectsBox(vRay.StartPoint, Reverse(vRay.Direction), FBox, nil)) then
          UnionFRect(FBox, vRay.Box);
    end;
  finally
    vRays.Free;
  end;
end;

function TsgDXFLayout.IsInvisible(E: TsgDXFEntity; AConv: TsgDXFConverter; const ARays: TsgObjectList;
  const AHeadVarStruct: TsgHeadVarStruct): Boolean;
var
  L: TsgDXFLayer;
  vEntType: TsgCADEntities;

  function IsBlockVisible(ABlock: TsgDXFBlock): Boolean;
  var
    EL: TsgDXFLayer;
    J: Integer;
  begin
    Result := False;
    for J := 0 to ABlock.Count - 1 do
    begin
      EL := TsgDXFEntity(ABlock.Entities[J]).Layer;
      if (EL <> nil) and (EL.Visible and not EL.IsFrozenByViewPort and not EL.Frozen) then
      begin
        Result := True;
        Break;
      end;
    end;
  end;

  function IsCustomApplicationBlockReference(E: TsgDXFEntity): Boolean;
  var
    vClass: TClass;
  begin
    vClass := E.ClassType;
    //Result := E is TsgCADCustomApplicationBlockReference;
    Result := (vClass = TsgCADAcDbViewRepBlockReference) or (vClass = TsgCADAcIdBlockReference);
  end;

begin
  vEntType := E.EntType;
  case vEntType of
    ceRay, ceXline:
      begin
        Result := not E.Visibility;
        if not Result then
        begin
          if Assigned(ARays) then
          begin
            ARays.Add(E);
            Result := True;
          end;
        end;
      end;
    ceInsert:
      begin
        Result := not E.Visibility;
        if not Result and (AConv.GetModelLayout = Self) and IsCustomApplicationBlockReference(E) then
          Result := True;
      end;
  else
    Result := (vEntType = ceEntity) or
      ((vEntType = cePoint) and (AHeadVarStruct.PointDisplayMode = 1)) or
      not E.Visibility;
  end;
  if not (Result or (vEntType = ceViewport)) then
  begin
    L := E.Layer;
    Result := IsLayerInVisible(L,AConv);
    if Result and not L.Frozen and (not L.Annotative or (L.Annotative and E.Annotative)) and
       E.IsInsert and (TsgDXFInsert(E).Block <> nil) then
      Result := not IsBlockVisible(TsgDXFInsert(E).Block);
  end;
end;

procedure TsgDXFLayout.SetBox(const ABox: TFRect);
begin
  FBox := ABox;
  if Assigned(FPaperSpaceBlock) then
    FPaperSpaceBlock.FBox := FBox;
end;

procedure TsgDXFLayout.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  if FPaperSpaceBlock <> nil then
    PaperSpaceBlock.SetEntity(AIndex, AEntity);
end;

function TsgDXFLayout.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := Count;
  if IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlPaperSpaceBlock].Name)
  else
    if FPaperSpaceBlock <> nil then
      ANode.AddAttribNV(cnstXMLNames[xmlPaperSpaceBlock].Name).ValueAsStr :=
        FPaperSpaceBlock.Name;
  if IsFullPropsOrXMLHelp(AParams.Mode) or (not IsEqualFPoints(FUCSOrigin, cnstFPointZero)) then
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSOrigin].Name).ValueData,
      FUCSOrigin, xmlForViewing in AParams.Mode);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (not IsEqualFPoints(FUCSXDir, cnstFPointZero)) then
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSXDir].Name).ValueData,
      FUCSXDir, xmlForViewing in AParams.Mode);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (not IsEqualFPoints(FUCSYDir, cnstFPointZero)) then
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSYDir].Name).ValueData,
      FUCSYDir, xmlForViewing in AParams.Mode);
end;

procedure TsgDXFLayout.ToXMLSubEntities(const AParentNode: TsgNode;
  const AParams: TsgXMLParams);
var
  vSubEntities: TsgNode;
  vParams: TsgXMLParams;
begin
  vParams := AParams;
  vSubEntities := GetSubEntitiesNode(AParentNode, vParams, True);
  if Assigned(vSubEntities) then
  begin
    if Assigned(FPlotSettings) then
      FPlotSettings.ToXMLWithParams(vSubEntities, AParams);
  end;
end;

function TsgDXFLayout.ForceSetPaperSpaceBlock(const AConverter: TsgDXFConverter): TsgDXFBlock;
var
  I: Integer;
  vBlockName: string;
  vPaperSpaceBlock: TsgDXFBlock;
  vConv: TsgDXFConverter;
begin
  Result := nil;
  vConv := AConverter;
  if not Assigned(vConv) then
    vConv := Converter;
  if not Assigned(vConv) then
    Exit;

  I := Self.Index;
  repeat
    vBlockName := Self.GetBlockName(I);
    vPaperSpaceBlock := vConv.BlockByName(vBlockName);
    Inc(I);
  until not Assigned(vPaperSpaceBlock);

  vPaperSpaceBlock := TsgDXFBlock.Create;
  vPaperSpaceBlock.Name := vBlockName;
  vConv.Loads(vPaperSpaceBlock);
  vConv.Sections[csBlocks].AddEntity(vPaperSpaceBlock);
  vPaperSpaceBlock.IsLoaded := False;

  Self.PaperSpaceBlock := vPaperSpaceBlock;
  Result := Self.PaperSpaceBlock;
end;

procedure TsgDXFLayout.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FPlotSettings);
  FreeAndNil(FView);
end;

function TsgDXFLayout.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vSectionBlocks: TsgDXFSectionBlocks;
  vStr: string;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlUCSOrigin: FUCSOrigin := ANode.ValueAsFPoint;
    xmlUCSXDir: FUCSXDir := ANode.ValueAsFPoint;
    xmlUCSYDir: FUCSYDir := ANode.ValueAsFPoint;
    xmlPaperSpaceBlock:
      begin
        vStr := ANode.Value;
        if Length(vStr) > 0 then
        begin
          vSectionBlocks := TsgDXFSectionBlocks(Converter.Sections[csBlocks]);
          if Assigned(vSectionBlocks) then
          begin
            if IsHandleStr(vStr)  then
              FPaperSpaceBlock :=
                TsgDXFBlock(vSectionBlocks.FindEntByHandle(ANode.ValueAsHandle))
            else
              FPaperSpaceBlock :=
                TsgDXFBlock(vSectionBlocks.FindEntByName(ANode.ValueAsStr));
          end;
        end
        else
        begin
          FPaperSpaceBlock := nil;
          GetPaperSpaceBlock;//reinit
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFLayout.FromXMLSubEntities(const ANode: TsgNodeSample;
  const AResult: IsgResultNode): Integer;
var
  vPlotSettings: TsgNodeSample;
begin
 Result := cnstXML_OK;
  if Assigned(FPlotSettings) then
  begin
    vPlotSettings := ANode.GetChildByName(FPlotSettings.GetXMLName);
    if Assigned(vPlotSettings) then
    begin
      if not Assigned(FPaperSpaceBlock) then
        GetPaperSpaceBlock;
      Result := FPlotSettings.FromXML(vPlotSettings, AResult);
    end;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgDXFLayout.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcName].Name] := Name;
end;
{$ENDIF}

procedure TsgDXFLayout.SetPaperSpaceBlock(ABlock: TsgDXFBlock);
begin
  if FPaperSpaceBlock <> ABlock then
  begin
    if Assigned(FPaperSpaceBlock) then
      FPaperSpaceBlock.Layout := nil;
    FPaperSpaceBlock := ABlock;
    if Assigned(FPaperSpaceBlock) and (FPaperSpaceBlock.ClassType = TsgDXFBlockRecord) then
      FPaperSpaceBlock := TsgDXFBlockRecord(TObject(ABlock)).Block;
    if Assigned(FPaperSpaceBlock) and (FPaperSpaceBlock.InheritsFrom(TsgDXFBlock)) then
      FPaperSpaceBlock.Layout := Self;
  end;
end;

{$IFDEF SG_VERSION_OLD}
procedure TsgDXFLayout.SetPlotPaperUnits(const Value: Integer);
begin
  PlotSettings.PlotPaperUnits := TsgPlotPaperUnits(Value);
end;
{$ENDIF}

procedure TsgDXFLayout.SetPlotSettings(const Value: TsgDXFPlotSettings);
begin
  if Assigned(Value) then
    FPlotSettings.AssignEntity(Value);
end;

{ TsgImageDefPicture }

constructor TsgImageDefPicture.Create(AImageDef: TsgDXFImageDef);
begin
  inherited Create;
  FImageDef := AImageDef;
end;

destructor TsgImageDefPicture.Destroy;
begin
  FImageDef.FPicture := nil;
  FImageDef := nil;
  inherited Destroy;
end;

{ TsgDXFImageDef }

procedure TsgDXFImageDef.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFImageDef then
    FFileName := TsgDXFImageDef(Source).FFileName;
end;

function TsgDXFImageDef.EntName: string;
begin
  if Pos('/', FileName) > 0 then
    Result := ExtractWebFileName(FileName)
  else
    Result := ExtractFileName(FileName);
  Result := ChangeFileExt(Result, '');
  if Result = '' then
    Result := inherited EntName;
end;

procedure TsgDXFImageDef.ClearReferences;
var
  I: Integer;
begin
  inherited ClearReferences;
  if FReferences <> nil then
    for I := FReferences.Count - 1 downto 0 do
      TsgDXFEntity(FReferences[I]).RemoveReferenceNotification(Self);
end;

constructor TsgDXFImageDef.Create;
begin
  inherited Create;
  FPicture := TsgImageDefPicture.Create(Self);
end;

class function TsgDXFImageDef.GetGraphicParams(AGraphic: TPersistent;
  var ATransparentColor: TColor; var AMonochrome: Boolean;
  var ATransparency: Boolean): TFPoint;
begin
  Result := cnstFPointZero;
  ATransparentColor := clWhite;
  AMonochrome := False;
  ATransparency := False;
  if Assigned(AGraphic) then
  begin
    ATransparentColor := GetColorByLeftTopPixel(TGraphic(AGraphic), ATransparency, ATransparentColor);
    if AGraphic.InheritsFrom(TBitmap) then
    begin
      AMonochrome := TBitmap(AGraphic).Monochrome;
      Result := MakeFPoint(TBitmap(AGraphic).Width, TBitmap(AGraphic).Height, 0);
    end
    else
      if AGraphic.InheritsFrom(TsgBitmap) then
      begin
        AMonochrome := TsgBitmap(AGraphic).PixelFormat = pf1bit;
        Result := MakeFPoint(TsgBitmap(AGraphic).Width, TsgBitmap(AGraphic).Height, 0);
      end
      else
        Result := MakeFPoint(TGraphic(AGraphic).Width, TGraphic(AGraphic).Height, 0);
  end;
end;

function TsgDXFImageDef.GetReferences: TsgList;
begin
  if FReferences = nil then
  begin
    FReferences := TsgList.Create;
    FReferences.Sorted := True;
    FReferences.Duplicates := dupIgnore;
  end;
  Result := FReferences;
end;

function TsgDXFImageDef.GetSize: TFPoint;
begin
  if FPicture.Graphic <> nil then
  begin
    Result.X := FPicture.Width;
    Result.Y := FPicture.Height;
    Result.Z := 0;
  end
  else
    Result := cnstFPointZero
end;


function TsgDXFImageDef.LoadImageInternal(const AResolve: Boolean): Boolean;
begin
  if IsFileOnWeb(FFileName) then
    Result := LoadPictureFromWEB(FPicture, FFileName)  // request INDY components
  else
    Result := LoadPictureFromDisk(FPicture, CheckPathDelim(FFileName));
  if AResolve and (not Result) and Assigned(Converter) then
    Converter.ResolveNotFoundImageDef(Self, FFileName, Result);
end;

procedure TsgDXFImageDef.LoadedInternal(AConverter: TsgDXFConverter);
var
{$IFNDEF SG_FIREMONKEY}
  BM: TsgBitmap;
{$ENDIF}
  vIsResolve: Boolean;

  function LoadImage: Boolean;
{$IFNDEF SGFPC}
  {$IFDEF SG_THREAD_DRAW}
  var
    vRez: Boolean;
  {$ENDIF}
{$ENDIF}
  begin
{$IFNDEF SGFPC}
  {$IFDEF SG_THREAD_DRAW}
    if GetCurrentThreadId <> MainThreadID then
    begin
      Result := True;
      TThread.Synchronize(nil, procedure
        begin
          vRez := LoadImageInternal(True);
        end);
    end
    else
      Result := LoadImageInternal(False);
  {$ELSE}
      Result := LoadImageInternal(False);
  {$ENDIF}
{$ELSE}
      Result := LoadImageInternal(False);
{$ENDIF}
  end;

begin
  inherited LoadedInternal(AConverter);
  try
    try
      if not LoadImage then
      begin
        vIsResolve := False;
        AConverter.ResolveNotFoundImageDef(Self, FFileName, vIsResolve);
        if vIsResolve then
          LoadImage;
      end;
{$IFNDEF SG_FIREMONKEY}
      if FPicture.Graphic is TBitmap then
      begin
        BM := TsgBitmap.Create;
        try
          BM.AssignFromBMP(FPicture.Bitmap);
          FPicture.Graphic := BM;
        finally
          BM.Free;
        end;
      end;
{$ENDIF}
    finally
      UpdateReferences(True, FReferences);
    end;
  except
  end;
end;

function TsgDXFImageDef.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlFileName].Name).ValueAsStr := FileName;
end;

procedure TsgDXFImageDef.UpdateReferences(AResetPictureRef: Boolean; AImageEnts: TsgList);
var
  vTransparentColor: TColor;
  vMonochrome: Boolean;
  vTransparency: Boolean;
  vSize: TFPoint;
  vImageEnt: TsgDXFImageEnt;
  I: Integer;
begin
  if Assigned(AImageEnts) then
  begin
    vSize := GetGraphicParams(FPicture.Graphic, vTransparentColor, vMonochrome, vTransparency);
    for I := 0 to AImageEnts.Count - 1 do
    begin
      vImageEnt := TsgDXFImageEnt(AImageEnts[I]);
      vImageEnt.IsMonoChrome := vMonochrome;
      //vImageEnt.Transparency := vTransparency;
      vImageEnt.TransparentColor := vTransparentColor;
      if not IsEqualF2DPoints(vSize.Point2D, cnstF2DPointZero) then
        vImageEnt.Size := vSize;
      if AResetPictureRef then
      begin
        vImageEnt.FreeGraphics;
        vImageEnt.FPicture := FPicture;
      end;
    end;
  end;
end;

procedure TsgDXFImageDef.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FReferences);
  FreeAndNil(FPicture);
end;

function TsgDXFImageDef.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlFileName: FileName := ANode.ValueAsStr;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{ TsgDXFImageEnt }

procedure TsgDXFImageEnt.AssignEntity(Source: TsgDXFEntity);
var
  vImageEnt: TsgDXFImageEnt absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFImageEnt then
  begin
    if Assigned(vImageEnt.FImageProperties) then
    begin
      if not Assigned(FImageProperties) then
        New(FImageProperties);
      FImageProperties^ := vImageEnt.FImageProperties^;
    end
    else
      DisposeAndNil(FImageProperties);
{$IFNDEF SG_FIREMONKEY}
    FreeAndNil(FBitMap);
{$ENDIF}
    FFlagsEx := vImageEnt.FFlagsEx;
    ImageDef := vImageEnt.ImageDef;
    if not Assigned(FPicture) and Assigned(vImageEnt.Picture) and
       not vImageEnt.Picture.InheritsFrom(TsgImageDefPicture) then
    begin
      if Assigned(FImageDef) then
        FImageDef.References.Remove(Self);
      FImageDef := nil;
      FPicture := TPicture.Create;
      FPicture.Graphic := vImageEnt.Picture.Graphic;
    end;
    TransparentColor := vImageEnt.TransparentColor;
{$IFDEF SG_USEGDIPLUS}
   GDIPFree;
{$ENDIF}
  end;
end;

function TsgDXFImageEnt.IsEmpty: Boolean;
begin
  if Assigned(FImageDef) then
  begin
    if (Length(FImageDef.FileName) = 0) and (Length(FImageDef.Name) = 0) then
      Result := True
    else
      Result := False;
  end
  else
    Result := True;
end;

function TsgDXFImageEnt.IsOnePixelOptimisationValid: Boolean;  //evg
begin
  Result := False;
end;

function TsgDXFImageEnt.EntName: String;
begin
  Result := inherited EntName;
  if Picture <> nil then
    Result := Format('%s %d x %d', [Result, Picture.Width, Picture.Height]);
end;

procedure TsgDXFImageEnt.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFImageEnt.LoadedInternal(AConverter: TsgDXFConverter);
var
  vEmpty: Boolean;
  vIsImageDefPicture: Boolean;
begin
{$IFDEF SG_USEGDIPLUS}
  GDIPFree;
{$ENDIF}
{$IFNDEF SG_FIREMONKEY}
  FreeAndNil(FBitMap);
{$ENDIF}
  vEmpty := False;
  try
    vIsImageDefPicture := FPicture is TsgImageDefPicture;
    if Assigned(FPicture) and Assigned(FPicture.Graphic) and not vIsImageDefPicture then
    begin
{$IFNDEF SG_FIREMONKEY}
      FPicture.Graphic.Transparent := Transparency;
      if FPicture.Graphic.InheritsFrom(Graphics.TBitmap) then
        Graphics.TBitmap(FPicture.Graphic).TransparentColor := TransparentColor;
{$ELSE}
//      if FPicture.Graphic is TBitmap then
//        TBitmap(FPicture.Graphic).Transparent := Transparency
//      else
        if FPicture.Graphic is TGraphic then
          TGraphic(FPicture.Graphic).Transparent := Transparency;
{$ENDIF}
    end
    else
    begin
      if not vIsImageDefPicture then
      begin
        SetMonochrome;
        if Assigned(FPicture) then
          SetDefaultTransparentColor(TGraphic(FPicture.Graphic), nil);
      end;
      if IsEmpty then
        vEmpty := True;
    end;
    inherited LoadedInternal(AConverter);
  finally
    if vEmpty then
      FBox := cnstBadRect;
  end;
end;

function TsgDXFImageEnt.PictureUpdate(const ACADImage: TObject): Boolean;
begin
  Result := False;
end;

procedure TsgDXFImageEnt.RemoveReferenceNotification(
  const ARefObj: TsgDXFEntity);
begin
  inherited RemoveReferenceNotification(ARefObj);
  if ARefObj = ImageDef then
    ImageDef := nil;
end;

procedure TsgDXFImageEnt.SetMnChrome(const AValue: Boolean);
begin
  FFlagsEx := (FFlagsEx and 254) or Byte(AValue);
end;

procedure TsgDXFImageEnt.SetMonochrome;
var
  vIsMonoChrome: Boolean;
begin
  vIsMonoChrome := IsMonoChrome;
{$IFNDEF SG_FIREMONKEY}
  if Assigned(FPicture) then
    vIsMonoChrome :=
    ((FPicture.Graphic is TBitmap) and FPicture.Bitmap.Monochrome) or
    ((FPicture.Graphic is TsgBitmap) and (TsgBitmap(FPicture.Graphic).PixelFormat = pf1bit));
{$ELSE}
  if Assigned(FPicture) and (FPicture.Graphic is TBitmap) then
    vIsMonoChrome := TBitmap(FPicture.Graphic).Monochrome;
{$ENDIF}
  IsMonoChrome := vIsMonoChrome;
end;

procedure TsgDXFImageEnt.SetRotate(const Value: Double);
begin
end;

procedure TsgDXFImageEnt.SetTransparency(const Value: Boolean);
begin
  FFlags := (FFlags and -9) or (Byte(Value) shl 3);
end;

procedure TsgDXFImageEnt.SetTransparentColor(const AValue: Cardinal);
begin
  FTransparentColor := AValue;
end;

function TsgDXFImageEnt.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vFileName: string;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlTransparency].Name).ValueAsBool := Transparency;
  ANode.AddAttribNV(cnstXMLNames[xmlTransparentColor].Name).ValueData.ValueAsColor := TransparentColor;
  vFileName := GetFileName;
  if (Length(vFileName) > 0) then
    ANode.AddAttribNV(cnstXMLNames[xmlFileName].Name).ValueAsStr := vFileName
  else
    if IsFullPropsOrXMLHelp(AParams.Mode) then
      ANode.AddAttribNV(cnstXMLNames[xmlFileName].Name);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlImageDef].Name)
  else
    if Assigned(ImageDef) then
      ANode.AddAttribNV(cnstXMLNames[xmlImageDef].Name).ValueAsHandle := ImageDef.Handle;
end;

procedure TsgDXFImageEnt.FreeGraphics;
begin
{$IFDEF SG_USEGDIPLUS}
  GDIPFree;
{$ENDIF}
  DisposeAndNil(FImageProperties);
{$IFNDEF SG_FIREMONKEY}
  FreeAndNil(FBitMap);
{$ENDIF}
  if not (FPicture is TsgImageDefPicture) then
    FreeAndNil(FPicture)
  else
    FPicture := nil;
end;

procedure TsgDXFImageEnt.FreeReferences;
begin
  inherited FreeReferences;
  FreeGraphics;
end;

function TsgDXFImageEnt.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;

  function GetSize(const AGraphic: TObject): TFPoint;
  begin
    Result := cnstFPointZero;
    if Assigned(AGraphic) then
    begin
      if AGraphic is TGraphic then
        Result := MakeFPoint(TGraphic(AGraphic).Width, TGraphic(AGraphic).Height)
      else
        if AGraphic is TBitmap then
          Result := MakeFPoint(TBitmap(AGraphic).Width, TBitmap(AGraphic).Height);
    end;
  end;

var
  vNode: TsgNodeSample;
  vImageDef: TsgDXFImageDef;
  vHandle: Int64;
  vVVector, vUVector: TFPoint;
  vMode: Integer;
  vWidth, vHeight, vAngle: Double;
{$IFDEF SG_FIREMONKEY}
  vBitmap: TBitmap;
{$ENDIF}
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlFileName:
      begin
        if FPicture = nil then
          FPicture := TPicture.Create;
        {$IFNDEF SG_FIREMONKEY}
        LoadPictureFromDisk(FPicture, ANode.ValueAsStr);
        if not (FPicture.Graphic is TBitmap) then
          Exit;
        ChangeGraphic;
        Size := GetSize(FPicture.Graphic);
      {$ELSE}
        vBitmap := TBitmap.Create;
        try
          vBitmap.LoadFromFile(ANode.ValueAsStr);
          FPicture.Graphic := vBitmap;
        finally
          vBitmap.Free;
        end;
      {$ENDIF}
      end;
    xmlImageDef:
      begin
        vHandle := Converter.RestoreHandle(ANode);
        if vHandle <> cnstBadHandle then
        begin
          vImageDef := TsgDXFImageDef(Converter.Sections[csImageDefs].
          FindEntByHandle(vHandle));
          if vImageDef <> nil then
          begin
            ImageDef := vImageDef;
            if Assigned(FPicture) then
              Size := GetSize(FPicture.Graphic);
          end;
        end;
      end;
    xmlTransparency:
      begin
        Transparency := ANode.ValueAsBool;
      end;
    xmlTransparentColor:
      begin
        TransparentColor := ANode.ValueData.ValueAsColor;
      end;
    xmlCalc:
      begin
        vNode := ANode.GetAttributeByName(cnstXMLNames[xmlMode].Name);
        if Assigned(vNode) then
        begin
          vMode := vNode.ValueAsInt;
          case vMode of
            0:
            begin
              vNode := ANode.GetAttributeByName(cnstXMLNames[xmlPoint1].Name);
              if Assigned(vNode) then
              begin
                vVVector := vNode.ValueAsFPoint;
                vNode := ANode.GetAttributeByName(cnstXMLNames[xmlPoint2].Name);
                if Assigned(vNode) and (Size.X * Size.Y <> 0) then
                begin
                  if Size.X * Size.Y <> 0 then
                  begin
                    vUVector := vNode.ValueAsFPoint;
                    UVector := SubFPoint2D(vUVector, Point);
                    VVector := SubFPoint2D(vVVector, Point);
                    UVector := PtXScalar(UVector,1/Size.X);
                    VVector := PtXScalar(VVector,1/Size.Y);
                  end
                  else
                  begin
                    UVector := cnstXOrtAxis;
                    VVector := cnstYOrtAxis;
                  end;
                end;
              end;
            end;
            1:
            begin
              vNode := ANode.GetAttributeByName(cnstXMLNames[xmlWidth].Name);
              if Assigned(vNode) then
              begin
                vWidth := vNode.ValueAsDouble;
                vNode := ANode.GetAttributeByName(cnstXMLNames[xmlHeight].Name);
                if Assigned(vNode) then
                begin
                  vHeight := vNode.ValueAsDouble;
                  UVector := cnstXOrtAxis;
                  VVector := cnstYOrtAxis;
                  if Size.X * Size.Y <> 0 then
                  begin
                    vNode := ANode.GetAttributeByName(cnstXMLNames[xmlAngle].Name);
                    if Assigned(vNode) then
                    begin
                      vAngle := vNode.ValueAsDouble;
                      if vAngle <> 0 then
                      begin
                        UVector := RotateFPoint(UVector, vAngle);
                        VVector := RotateFPoint(VVector, vAngle);
                      end;
                    end;
                    UVector := PtXScalar(UVector,vWidth/Size.X);
                    VVector := PtXScalar(VVector,vHeight/Size.Y);
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure TsgDXFImageEnt.SetImageDef(const Value: TsgDXFImageDef);
var
  vList: TsgList;
begin
  if FImageDef <> Value then
  begin
    if Assigned(FPicture) then
      if FPicture.InheritsFrom(TsgImageDefPicture) then
        FPicture := nil
      else
        FreeAndNil(FPicture);
    if Assigned(FImageDef) then
      FImageDef.References.Remove(Self);
    FImageDef := Value;
    if Assigned(FImageDef) then
    begin
      FImageDef.References.Add(Self);
      vList := TsgList.Create;
      try
        vList.Add(Self);
        FImageDef.UpdateReferences(True, vList);
      finally
        vList.Free;
      end;
    end
    else
    begin
      SetMonochrome;
      if Assigned(FPicture) then
        SetDefaultTransparentColor(TGraphic(FPicture.Graphic), nil);
    end;
  end;
end;

{$IFNDEF SG_FIREMONKEY}
procedure TsgDXFImageEnt.SetImgLittle(const ABitmap: TBitmap);
begin
  if FBitMap <> nil then
    FBitMap.Free;
  FBitMap := TsgBitmap.Create;
  FBitMap.Assign(ABitmap);
end;
{$ENDIF}

procedure TsgDXFImageEnt.SetInternal(const AValue: Boolean);
begin
  FFlagsEx := (FFlagsEx and 253) or (Byte(AValue) shl 1);
end;

procedure TsgDXFImageEnt.SetDefaultTransparentColor(const Image: TGraphic;
  const ImageDef: TsgDXFImageDef);
var
  vGraphic: TGraphic;
  vTransparency: Boolean;
begin
  TransparentColor := clWhite;
  if (Image = nil) and (ImageDef = nil) then
    Exit;
  vGraphic := nil;
  if ImageDef <> nil then
  begin
    if ImageDef.FPicture <> nil then
      vGraphic := TGraphic(ImageDef.FPicture.Graphic)
  end
  else
    vGraphic := Image;
  vTransparency := Transparency;
  TransparentColor := GetColorByLeftTopPixel(vGraphic, vTransparency,
    TransparentColor);
  if Assigned(Image) then
    Transparency := vTransparency;
end;

procedure TsgDXFImageEnt.SetImage(Image: TGraphic);
begin
  if FPicture is TsgImageDefPicture then
    FPicture := nil;
  if FPicture = nil then
    FPicture := TPicture.Create;
{$IFDEF SG_USEGDIPLUS}
  GDIPFree;
{$ENDIF}
  FPicture.Graphic := Image;
{$IFNDEF SG_FIREMONKEY}
  FreeAndNil(FBitMap);
{$ENDIF}
  SetMonochrome;
  SetDefaultTransparentColor(Image, nil);
end;

function TsgDXFImageEnt.GetEmpty: Boolean;
begin
  Result := True;
  if Assigned(FPicture) and Assigned(FPicture.Graphic) then
  begin
{$IFNDEF SG_FIREMONKEY}
    Result := FPicture.Graphic.Empty;
{$ELSE}
   Result := (FPicture.Width = 0) and (FPicture.Height = 0)
{$ENDIF}
  end;
end;

function TsgDXFImageEnt.GetEntType: TsgCADEntities;
begin
  Result := ceImageEnt;
end;

function TsgDXFImageEnt.GetFileName: string;
begin
  Result := '';
  if Assigned(ImageDef) then
    Result := ImageDef.FileName;
end;

function TsgDXFImageEnt.GetInternal: Boolean;
begin
  Result := (FFlagsEx and 2) <> 0;
end;

function TsgDXFImageEnt.GetMnChrome: Boolean;
begin
  Result := (FFlagsEx and 1) <> 0;
end;

{$IFDEF SG_USEGDIPLUS}
procedure TsgDXFImageEnt.GDIPCreate;
var
  vMemoryStream: TMemoryStream;

  procedure ConvertTosgBitmap;
  var
    vBitMap: TsgBitmap;
    vBMP: TBitMap;
    vColor: array[0..1] of TRGBQuad;
    vNeedConvert: Boolean;
  begin
    vNeedConvert := FPicture.Graphic is TsgBitmap;
    ChangeGraphic;
    vBitMap := TsgBitmap(FPicture.Graphic);
    case vBitMap.PixelFormat of
      pf1Bit:
        begin
          // fix by chahge color for gdi+ drawing
          if vNeedConvert and (TsgBitmapAccess(vBitMap).FROP <> SRCCOPY) then
          begin
            FillChar(vColor, 8, 0);
            FillChar(vColor[0], 4, 255);
            vBitMap.SetColors(@vColor[0]);
          end;
        end;
      pfCustom, pfDevice:
        begin
          vBMP := TBitMap.Create;
          try
            SetSizeBmp(vBMP, vBitMap.Width, vBitMap.Height);
            vBMP.PixelFormat := pf24bit;
            vBMP.Canvas.Draw(0, 0, vBitMap);
            vBitMap.Assign(vBMP);
          finally
            vBMP.Free;
          end;
        end;
    end;
    //FGDIPImage := TsgGDIPlusImage(TsgGDIPlusBitmap.Create(vBitMap.Width, vBitMap.Height,
      //vBitMap.RowSize, GetPixelFormat(vBitMap.PixelFormat), vBitMap.ScanLine[0]));
    FGDIPImage := TGPBitmap.Create(
      vBitMap.ImageData.Info^,
      vBitMap.ImageData.Data);
  end;

begin
  if (FGDIPImage <> nil) or Empty then Exit;
  if GetAnimate then
  begin
    vMemoryStream := TMemoryStream.Create;
    FPicture.Graphic.SaveToStream(vMemoryStream);
    vMemoryStream.Position := 0;
    FGDIPImage := TGPBitmap.Create(TStreamAdapter.Create(vMemoryStream, soOwned));
  end
  else
  begin
    if Picture.Graphic is TMetafile then
      FGDIPImage := TGPMetafile.Create(TMetafile(Picture.Graphic).Handle, False)
    else
      ConvertTosgBitmap;
  end;
  if FGDIPImage.{$IFDEF SG_WINAPI_GDIPLUS}GetLastStatus{$ELSE}GetStatusOfFunction{$ENDIF} <> Ok then
    GDIPFree;
end;

procedure TsgDXFImageEnt.GDIPFree;
var
  vGDIPImage: TGPImage;
begin
  if FGDIPImage <> nil then
  begin
    vGDIPImage := FGDIPImage;
    FGDIPImage := nil;
    vGDIPImage.Free;
  end;
end;
{$ENDIF}

procedure TsgDXFImageEnt.ChangeGraphic;
{$IFNDEF SG_FIREMONKEY}
var
  vBitMap: TsgBitMap;
  vBtmp: TBitmap;
  vOutOfMemory: Boolean;

  procedure ChangeGraphicUseBitMap(const AGraphic: TGraphic);
  var
    vBmp: TBitmap;
  begin
    vBmp := TBitmap(CreateCopyGraphicAsBitmap(AGraphic));
    try
      if vBmp <> nil then
        vBitMap.Assign(vBmp);
    finally
      vBmp.Free;
    end;
  end;
{$ENDIF}

begin
{$IFNDEF SG_FIREMONKEY}
  if (FPicture.Graphic = nil) or (FPicture.Graphic is TsgBitMap)  then Exit;
  vOutOfMemory := False;
  vBitMap := TsgBitMap.Create;
  try
    if FPicture.Graphic is TBitMap then
    begin
      try
        if TBitmap(FPicture.Graphic).PixelFormat in [pfDevice, pfCustom] then
        begin
          vBtmp := TBitmap.Create;
          try
            ConvertToBitmap(vBtmp, 1);
            vBitMap.Assign(vBtmp);
          finally
            vBtmp.Free;
          end;
        end
        else
          vBitMap.Assign(FPicture.Graphic);
      except
        on E: Exception do
        begin
          if not (E is EOutOfMemory) then
            ChangeGraphicUseBitMap(FPicture.Graphic)
          else
            vOutOfMemory := True;
        end;
      end;
    end
    else
    begin
      {$IFDEF SG_DELPHI_VCL}
      if FPicture.Graphic.ClassType <> TMetafile then
      begin
      {$ENDIF}
        vBtmp := TBitmap.Create;
        try
          ConvertToBitmap(vBtmp, 0);
          vBitMap.Assign(vBtmp);
          vBtmp.Free;
        except
          on E: Exception do
          begin
            if not (E is EOutOfMemory) then
              ChangeGraphicUseBitMap(FPicture.Graphic)
            else
              vOutOfMemory := True;
          end;
        end;
      {$IFDEF SG_DELPHI_VCL}
      end
      else
        ChangeGraphicUseBitMap(FPicture.Graphic);
      {$ENDIF}
    end;
  finally
    if not vOutOfMemory then
      FPicture.Graphic := vBitMap;
    vBitMap.Free;
    if FPicture is TsgImageDefPicture then
      TsgImageDefPicture(FPicture).ImageDef.UpdateReferences(False, TsgImageDefPicture(FPicture).ImageDef.FReferences)
    else
    begin
      SetMonochrome;
      SetDefaultTransparentColor(FPicture.Graphic, nil);
    end;
  end;
{$ENDIF}
end;

procedure TsgDXFImageEnt.ConvertToBitmap(const ABitmap: TBitmap; const AMode: Integer);
var
  vGraphic: TObject;
begin
  vGraphic := FPicture.Graphic;
  if vGraphic is TsgVectorImage then
  begin
    ABitmap.PixelFormat := pf24bit;
    SetSizeBmp(ABitmap, TsgVectorImage(vGraphic).Width * 2, TsgVectorImage(vGraphic).Height * 2, 3);
    TsgVectorImage(vGraphic).ConvertToBitmap(ABitmap);
  end
  else
  begin
    case AMode of
      1:
        begin
          if vGraphic is TGraphic then
          begin
            ABitmap.PixelFormat := pf24bit;
            SetSizeBmp(ABitmap, TGraphic(vGraphic).Width, TGraphic(vGraphic).Height, 3);
            ABitmap.Canvas.StretchDraw(ABitmap.Canvas.ClipRect, TGraphic(vGraphic));
          end;
        end;
    else
      ABitmap.Assign(TPersistent(vGraphic));
    end;
  end;
end;

procedure TsgDXFImageEnt.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  FreeGraphics;// set ImageEnt in empty state (do not need calculate GroupCountEntities)
end;

procedure TsgDXFImageEnt.ClearReferences;
begin
  inherited ClearReferences;
  ImageDef := nil;
end;

constructor TsgDXFImageEnt.Create;
begin
  inherited Create;
  FFlags := 3;
  FDirectExportConverImageToOLE := False;
  FDirectExportImageFileIndex := -1;
  SetDefaultTransparentColor(nil, nil);
end;

{$IFNDEF SG_FIREMONKEY}
procedure TsgDXFImageEnt.CreateImgLittle(const Scale: Integer);
var
  vBMP: TBitMap;
  vMax: Integer;
  vSize: Double;
  vPixelFormat: TPixelFormat;

  function CreateLittleBitmapBy1pxl: Boolean;
  var
    vBitMap: TsgBitMap;
  begin
    ChangeGraphic;
    vBitMap := TsgBitmap(FPicture.Graphic);
    if (vBitMap.PixelFormat = pf1bit) then
    begin
      case Scale of
        4:
          begin
            FScaleMode := 4;
            CreatesgBitMapBy1pxlDiv4(vBitMap, TsgBitMap(FBitMap));
          end;
        8:
          begin
            FScaleMode := 8;
            CreatesgBitMapBy1pxlDiv8(vBitMap, TsgBitMap(FBitMap));
          end;
      end;
      Result := True;
    end
    else
      Result := False;
  end;

begin
  FScaleMode := 0;
  if FBitMap <> nil then
  begin
    FBitMap.Free;
    FBitMap := nil;
  end;
  if (FPicture <> nil) and (FPicture.Graphic <> nil)  then
  begin
    try
      vSize := FPicture.Graphic.Width * FPicture.Graphic.Height;
      if vSize / cnstMaxImgSizeSqrt > 1.20 then
      begin
        if FPicture.Graphic is TBitmap then
        begin
          vPixelFormat := TBitmap(FPicture.Graphic).PixelFormat;
          if (vPixelFormat = pf1bit) and CreateLittleBitmapBy1pxl then
            Exit;
        end
        else
          if FPicture.Graphic is TsgBitmap then
          begin
            vPixelFormat := TsgBitmap(FPicture.Graphic).PixelFormat;
            if (vPixelFormat = pf1bit) and CreateLittleBitmapBy1pxl then
              Exit;
          end
          else
            vPixelFormat := pf24bit;
        vBMP := Graphics.TBitMap.Create;
        try
          vMax := MaxI(FPicture.Graphic.Width, FPicture.Graphic.Height);
          vBMP.PixelFormat := vPixelFormat;
          vBMP.Width  := cnstMaxImgSize * FPicture.Graphic.Width div vMax;
          vBMP.Height := cnstMaxImgSize * FPicture.Graphic.Height div vMax;
          vBMP.Canvas.StretchDraw(Rect(0, 0,  vBMP.Width,  vBMP.Height), FPicture.Graphic);
          SetImgLittle(vBMP);
        finally
          vBMP.Free;
        end;
      end;
    finally
      if FBitMap <> nil then
        FBitMap.Transparent := Transparency;
    end;
  end;
end;
{$ENDIF}

function TsgDXFImageEnt.DoRotate(const Angle: Double;
  const AConverter: TsgDXFConverter): Boolean;
var
  vAngle: Integer;
  vDelta, vDP1, vDP2: TFPoint;
  vOldWidth: Double;
begin
  Result := False;
  vAngle := (Round(sgMod(Angle, 360)) div 90) * 90;
  if vAngle <> 0 then
  begin
    if (FPicture = nil) or (FPicture is TsgImageDefPicture) then
    begin
      FPicture := TPicture.Create;
      FPicture.Assign(ImageDef.Picture);
{$IFNDEF SG_FIREMONKEY}
      FreeAndNil(FBitMap);
{$ENDIF}
    end;

    ChangeGraphic;
 {$IFNDEF SG_FIREMONKEY}
    vOldWidth := TsgBitmap(FPicture.Graphic).Width;
  {$ELSE}
    vOldWidth := TBitmap(FPicture.Graphic).Width;
  {$ENDIF}
{$IFNDEF SG_FIREMONKEY}
    if FBitMap <> nil then
      TsgBitmap(FBitMap).Rotate(vAngle);
{$ENDIF}
  {$IFNDEF SG_FIREMONKEY}
    TsgBitmap(FPicture.Graphic).Rotate(vAngle);
  {$ELSE}
    TBitmap(FPicture.Graphic).Rotate(vAngle);
  {$ENDIF}

    vDP1 := MiddleFPoint(Point1, Point2);
    DoRotateVectors(vAngle);
    FSize := AbsFPoint(RotateFPoint(FSize, vAngle));
    vDP2 := MiddleFPoint(Point1, Point2);
    vDelta := SubFPoint(vDP1, vDP2);
    Point := AddFPoint(Point, vDelta);

    if FClippingBoundaryType = 1 then
    begin
      if vOldWidth <> TsgBitmap(FPicture.Graphic).Width then
      begin
        if FClipPoints.Count >= 2 then
        begin
          SwapSGFloats(FClipPoints.List^[0].X, FClipPoints.List^[0].Y);
          SwapSGFloats(FClipPoints.List^[1].X, FClipPoints.List^[1].Y);
        end;
      end;
    end;

    Result := True;
    if AConverter <> nil then
      LoadedInternal(AConverter);
  end;
end;

procedure TsgDXFImageEnt.DoRotateVectors(const Angle: Double);
begin
  FUVector := RotateFPoint(FUVector, Angle);
  FVVector := RotateFPoint(FVVector, Angle);
end;

function TsgDXFImageEnt.GetAnimate: Boolean;
begin
  Result := False;
end;

function TsgDXFImageEnt.GetBoxPoints(Proc: TFPointProc; Full: Boolean): Boolean;
begin
  //Result := inherited GetBoxPoints(Proc, Full);// for future versions
  Proc(Point);
  Proc(Point1);
  Proc(Point2);
  Proc(Point3);
  Result := False;// See CADImage.DrawPoly (!)
end;

function TsgDXFImageEnt.GetRotate: Double;
begin
  Result := 0;
end;

function TsgDXFImageEnt.GetTransparency: Boolean;
begin
  Result := (FFlags and 8) <> 0;
end;

function TsgDXFImageEnt.GetTransparentColor: Cardinal;
begin
  Result := FTransparentColor;
end;

procedure TsgDXFImageEnt.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlImageDef));
      AHideList.Add(Integer(xmlTransparency));
      AHideList.Add(Integer(xmlTransparentColor));
      AHideList.Add(Integer(xmlUVector));
      AHideList.Add(Integer(xmlVVector));
      AHideList.Add(Integer(xmlSize));
    end;
  end;
end;

procedure TsgDXFImageEnt.GroupClear;
var
  vGroup: TsgDXFGroup;
begin
  //if not GroupExists then Exit; // do not need calculate GroupCountEntities
  vGroup := Group;
  FGroup := nil;
  if Assigned(vGroup) then
  begin
    if GroupHasAddedEntities then
      vGroup.Clear
    else
      vGroup.FEntities.Clear;
    vGroup.Free;
  end;
end;

function TsgDXFImageEnt.GroupCountEntities: Integer;
var
  vGr: TObject;
  vGrBmp: TBitmap;
  vBitmap: TsgBitmap;
  vChunk, vChunkRes: TPoint;
begin
  Result := 0;
  if Empty then Exit;
  vGr := Picture.Graphic;
{$IFDEF SG_DELPHI_VCL}
  if vGr is TMetafile then
    if CheckExportOLEAsMetafile(TMetafile(vGr).Handle) then
       Exit;
{$ENDIF}
  vGrBmp := nil;
  vBitmap := nil;
  try
    if vGr is TBitmap then
      vGrBmp := TBitmap(vGr)
    else
      if vGr is TsgBitmap then
        vBitmap := TsgBitmap(vGr);
  except
  end;
  if Assigned(vGrBmp) or Assigned(vBitmap) then
  begin
    try
      if vBitmap = nil then
        vBitmap := TsgBitmap.Create;
      try
        if vBitmap <> vGr then
          vBitmap.Assign(TPersistent(vGrBmp));
        vChunk := GetCountBlocksForOLEExport(vBitmap.Width, vBitmap.Height,
          vBitmap.PixelFormat, vChunkRes);
        if (vChunk.X >= 0) and (vChunk.Y >= 0) then
          Result := (vChunk.X + 1) * (vChunk.Y + 1);
      except
      end;
    finally
      if vBitmap <> vGr then
        vBitmap.Free;
    end;
  end;
end;

function TsgDXFImageEnt.GroupExists: Boolean;
var
  vIndex: Integer;
begin
  vIndex := GetExportImageIndex(Self, FDirectExportImageFileIndex,
    FDirectExportConverImageToOLE);
  if vIndex = cntImageExportAsOLE2Frame then
    Result := GroupCountEntities > 1
  else
    Result := False;
end;

function TsgDXFImageEnt.GroupFill(AConverter: TsgDXFConverter = nil): Boolean;
var
  I, vCount: Integer;
  vPoint: TsgDXFPoint;
begin
  if AConverter <> nil then
  begin
    vCount := GroupCountEntities;
    for I := 0 to vCount - 1 do
    begin
      vPoint := TsgDXFPoint.Create;
      vPoint.Loaded(AConverter);
      Group.AddEntity(vPoint);
    end;
  end;
  Result := Group.Count > 0;
end;

function TsgDXFImageEnt.GroupHasAddedEntities: Boolean;
begin
  Result := True;
end;

procedure TsgDXFImageEnt.UpdateBox;
begin
  inherited UpdateBox;
  ExpandFRect(FBox, Point);
  ExpandFRect(FBox, Point1);
  ExpandFRect(FBox, Point2);
  ExpandFRect(FBox, Point3);
end;

{ TsgDXFStyle }

procedure TsgDXFStyle.AssignEntity(Source: TsgDXFEntity);
var
  vStyle: TsgDXFStyle absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFStyle then
  begin
    FBigFont := vStyle.FBigFont;
    FFlags := vStyle.FFlags;
    FFixedHeight := vStyle.FFixedHeight;
    FFontName := vStyle.FontName;
    FFontStyle := vStyle.FontStyle;
    FLastHeightUsed := vStyle.FLastHeightUsed;
    FObliqueAngle := vStyle.FObliqueAngle;
    FPrimaryFont := vStyle.FPrimaryFont;
    FSHXStyle := nil;
    FTextGenFlags := vStyle.FTextGenFlags;
    FWidthFactor := vStyle.FWidthFactor;
  end;
end;

function TsgDXFStyle.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = sACADXDataAppName then
  begin
    AData.AddString(String_1001, sACADXDataAppName);
    Result := True;
  end;
end;

constructor TsgDXFStyle.Create;
begin
  inherited Create;
  Name := sStandardName;
  FWidthFactor := 1.0;
  FLastHeightUsed := 2.5;
  FPrimaryFont := 'txt';
end;

procedure TsgDXFStyle.EndExtData(const AData: TsgCADExtendedData);
begin
end;

function TsgDXFStyle.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlWidthFactor: FWidthFactor := ANode.ValueAsDouble;
    xmlObliqueAngle: FObliqueAngle := ANode.ValueAsDouble;
    xmlTextGenFlags: FTextGenFlags := ANode.ValueAsInt;
    xmlLastHeightUsed: FLastHeightUsed := ANode.ValueAsDouble;
    xmlPrimaryFont:
      begin
        FPrimaryFont := ANode.ValueAsStr;
        FFontName := '';
        FFontStyle := [];
        SetFontNameByPrimaryFont;
      end;
    xmlBigFont: FBigFont := ANode.ValueAsStr;
    xmlFontName: FFontName := ANode.ValueAsStr;
    xmlFixedHeight: FFixedHeight := ANode.ValueAsDouble;
    xmlFontStyle: FFontStyle := IntegerToFontStyles(ANode.ValueAsInt);
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFStyle.GetBackward: Boolean;
begin
  Result := (FTextGenFlags and  2) <> 0;
end;

function TsgDXFStyle.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
var
  vFontStyle: Integer;
  vFontName: string;
  vFontStyles: TFontStyles;
  vFontType: TsgFontType;
  vNeedAddACADAppData: Boolean;
begin
  Result := False;
  if AAppID = sACADXDataAppName then
  begin
    vFontStyles := [];
    vFontName := FontName;
    vNeedAddACADAppData := True;
    vFontStyles := MVFontStylesToFontStyles(FFontStyle);
    vFontType := GetFontTypeByFileNameExt(FPrimaryFont);
    case vFontType of
      ftTTF, ftOTF, ftTTC:
        begin
          vNeedAddACADAppData := (vFontName <> '');
          if vNeedAddACADAppData then
            vFontName := GetFontNameByFileName(GetPrimaryFontName, vFontStyles);
        end;
      ftSHX:
        begin
          vNeedAddACADAppData := (FontName <> '') and (FontName <> ChangeFileExt(ExtractFileName(FPrimaryFont), ''));
        end;
    else
      if (vFontName <> '') and (vFontName = ExtractFileName(FPrimaryFont)) then
        vNeedAddACADAppData := vFontStyles * [fsBold, fsItalic] <> [];
    end;
    if vNeedAddACADAppData and BeginExtData(AData, AAppID) then
    begin
      AData.AddString(String_1000, vFontName);
      vFontStyle := 0;
      if fsItalic in vFontStyles then
        vFontStyle := vFontStyle or $1000000;
      if fsBold in vFontStyles then
        vFontStyle := vFontStyle or $2000000;
      AData.AddInt(Integer_1071, vFontStyle);
      EndExtData(AData); // do nothing
      Result := True;
    end;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

function TsgDXFStyle.GetPrimaryFontName: string;
begin
  Result := '';
  if Length(FPrimaryFont) > 0 then
    Result := ExtractFileName(FPrimaryFont);
end;

function TsgDXFStyle.GetUpsideDown: Boolean;
begin
  Result := (FTextGenFlags and  4) <> 0;
end;

procedure TsgDXFStyle.LoadedInternal(AConverter: TsgDXFConverter);
var
  vName: string;
begin
  inherited LoadedInternal(AConverter);
  if FWidthFactor < fAccuracy then // FWidthFactor = 0
    FWidthFactor := 1.0;
// export already check this flag!!!
//  if FFlags and 1 <> 0 then
//    FName := '';// SHAPE style name must be empty (see SHX and export to DXF)
  if FFontName = '' then
    SetFontNameByPrimaryFont;
  vName := '';
  if FFlags and 1 = 0 then
    vName := Name;
  FSHXStyle := AConverter.FSHXFonts.AddStyle(vName, FPrimaryFont, FBigFont, FFlags and 4 <> 0,
    UpsideDown, Backward, FObliqueAngle, FWidthFactor);
  UpdateFontGlyphRef(cnstCharSetDef, GetFontPitch(FFontName));
end;

procedure TsgDXFStyle.SetBackward(const AValue: Boolean);
begin
  FTextGenFlags := (FTextGenFlags and 253) or Integer(AValue) shl 1;
end;

procedure TsgDXFStyle.SetPrimaryFont(const AValue: string);
begin
  FPrimaryFont := AValue;//can have full file path
end;

procedure TsgDXFStyle.SetFontNameByPrimaryFont;
var
  vPrimaryFont: string;
  vFontType: TsgFontType;
  vFontStyles: TFontStyles;
begin
  vPrimaryFont := GetPrimaryFontName;
  vFontType := GetFontTypeByFileNameExt(vPrimaryFont);
  if vFontType in [ftTTF, ftOTF, ftTTC] then
  begin
    FFontName := GetFontNameByFileName(vPrimaryFont, vFontStyles);
    FFontStyle := FFontStyle - [fmBold, fmItalic] + FontStylesToMVFontStyles(vFontStyles);
  end
  else
  begin
    if vPrimaryFont <> '' then
    begin
      // For future versions
      //FSHXStyle := AConverter.FSHXFonts.AddStyle(FName, FPrimaryFont, FBigFont, FFlags and 4 <> 0,
      //  UpsideDown, Backward, FObliqueAngle, FWidthFactor);
    end
    else
      FPrimaryFont := sDefaultSHXFont;
    FFontName := ChangeFileExt(vPrimaryFont, '');
    if not ContainerOfTextGlyphs.IsFontValid(FFontName, MVFontStylesToFontStyles(FFontStyle)) then
      FFontName := '';
  end;
end;

procedure TsgDXFStyle.SetUpsideDown(const AValue: Boolean);
begin
  FTextGenFlags := (FTextGenFlags and 251) or Integer(AValue) shl 2;
end;

function TsgDXFStyle.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlWidthFactor].Name).ValueData,
    FWidthFactor, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlObliqueAngle].Name).ValueData,
    FObliqueAngle, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlTextGenFlags].Name).ValueAsInt := FTextGenFlags;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLastHeightUsed].Name).ValueData,
    FLastHeightUsed, xmlForViewing in AParams.Mode);
  if (Length(FPrimaryFont) > 0) or IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlPrimaryFont].Name).ValueAsStr := FPrimaryFont;
  if (Length(FBigFont) > 0) or IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlBigFont].Name).ValueAsStr := FBigFont;
  if (Length(FFontName) > 0) or IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlFontName].Name).ValueAsStr := FFontName;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlFixedHeight].Name).ValueData,
    FFixedHeight, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlFontStyle].Name).ValueAsInt :=
    FontStylesToInteger(FFontStyle);
end;

procedure TsgDXFStyle.UpdateFontGlyphRef(ACharset: TFontCharset; APitch: Byte);
begin
  FFontGlyphRef := UpdateTextGlyph(FFontName, MVFontStylesToFontStyles(FFontStyle), ACharset, APitch);
end;

{ TsgDXFRegion }

function TsgDXFRegion.GetEntType: TsgCADEntities;
begin
  Result := ceRegion;
end;

{$IFNDEF SG_VM_PLUGIN}
procedure TsgDXFRegion.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlLineTypeName));
    end;
  end;
end;

{$ENDIF}

{ TsgDXFBody }

function TsgDXFBody.GetEntType: TsgCADEntities;
begin
  Result := ceBody;
end;

{ TsgDXFSurface }

constructor TsgDXFSurface.Create;
begin
  inherited Create;
  FIsoCountU := 6;
  FIsoCountV := 6;
end;

function TsgDXFSurface.GetEntType: TsgCADEntities;
begin
  Result := ceSurface;
end;

procedure TsgDXFSurface.SetIsoCountU(const AValue: Integer);
begin
  FIsoCountU := AValue;
end;

procedure TsgDXFSurface.SetIsoCountV(const AValue: Integer);
begin
  FIsoCountV := AValue;
end;

{ TsgDXF3DSolid }

function TsgDXF3DSolid.GetEntType: TsgCADEntities;
begin
  Result := ce3DSolid;
end;

{ TsgAcadTableCell }

procedure TsgAcadTableCell.Assign(ASource: TPersistent);
var
  I: Integer;
  vCell: TsgAcadTableCell;
begin
  if ASource is ClassType then
  begin
    vCell := TsgAcadTableCell(ASource);
    FAutoFit := vCell.AutoFit;
    FBlockRecordHandle := vCell.BlockRecordHandle;
    FBlockScale := vCell.BlockScale;
    Field := vCell.Field;
    FFlags := vCell.Flags;
    FIsTextType := vCell.IsTextType;
    FMergedHeight := vCell.MergedHeight;
    FMergedValue := vCell.MergedValue;
    FMergedWidth := vCell.MergedWidth;
    FNumAttdefs := vCell.NumAttdefs;
    FOverrideFlag := vCell.OverrideFlag;
    FRotation := vCell.Rotation;
    FText := vCell.Text;
    FAttdefHandle := vCell.AttdefHandle;
    FVirtualEgdeFlag := vCell.VirtualEgdeFlag;
    FCol := vCell.Col;
    FRow := vCell.Row;
    FSpanX := vCell.SpanX;
    FSpanY := vCell.SpanY;
    FCellProps.Assign(vCell.FCellProps);
    for I := 0 to 5 do
      UpdateFlags(I);
  end
  else
    inherited Assign(ASource);
end;

constructor TsgAcadTableCell.Create(AAcadTable: TsgDXFAcadTable;
  const ACol, ARow: Integer; const ACellType: TsgAcadTableCellType);
begin
  inherited Create;
  FAcadTable := AAcadTable;
  if Assigned(FAcadTable) then
    FCellProps := TsgAcadTableCellStyle.Create(FAcadTable.Properties, ACellType)
  else
    FCellProps := TsgAcadTableCellStyle.Create(nil, ACellType);
  FIsTextType := True;
  FCol := ACol;
  FRow := ARow;
  FMergedValue := 0;
  FMergedWidth := 1;
  FMergedHeight := 1;
end;

destructor TsgAcadTableCell.Destroy;
begin
  Field := nil;
  FreeAndNil(FCellProps);
  inherited Destroy;
end;

function TsgAcadTableCell.GenerateMText(const AConv: TsgDXFConverter;
  const AAcadTable: TsgDXFAcadTable): TsgDXFMText;
var
  vAcadTableGenerator: TsgAcadTableGenerator;
begin
  Result := nil;
  if Assigned(AAcadTable) and Assigned(AConv) then
  begin
    vAcadTableGenerator := TsgAcadTableGenerator.Create(AConv, AAcadTable);
    try
      Result := vAcadTableGenerator.CreateMText(Self, False, True);
    finally
      vAcadTableGenerator.Free;
    end;
  end;
end;

function TsgAcadTableCell.GetBaseCell: TsgAcadTableCell;
begin
  Result := Self;
  if not IsBaseCell and Assigned(FAcadTable) then
    Result := FAcadTable.Cell[FCol - FSpanX, FRow - FSpanY];
end;

function TsgAcadTableCell.GetBaseCellRange: TRect;
var
  vBaseCell: TsgAcadTableCell;
begin
  if IsBaseCell then
    Result := CellRange
  else
  begin
    vBaseCell := BaseCell;
    Result := Rect(vBaseCell.Col, vBaseCell.Row,
      vBaseCell.Col + vBaseCell.SpanX, vBaseCell.Row + vBaseCell.SpanY);
  end;
end;

function TsgAcadTableCell.GetBkColorOn: Boolean;
begin
  Result := StyleByProp(cpBkColorOn).BkColorOn;
end;

function TsgAcadTableCell.GetBorderColor(Index: Integer): TsgColorCAD;
var
  vOverride: Boolean;
begin
  vOverride := IsBorderColorOverriden(Index);
  if not vOverride and HasOwnerStyle then
    Result := GetOwnerStyle.BorderColor[Index]
  else
    Result := FCellProps.BorderColor[Index]
end;

function TsgAcadTableCell.GetBorderLineWeight(Index: Integer): Double;
var
  vOverride: Boolean;
begin
  vOverride := IsBorderLineweightOverriden(Index);
  if not vOverride and HasOwnerStyle then
    Result := GetOwnerStyle.BorderLineWeight[Index]
  else
    Result := FCellProps.BorderLineWeight[Index]
end;

function TsgAcadTableCell.GetBorderPropOverridenMask(
  const ABorderProp: TsgBorderProp; const AIndex: Integer): Integer;
const
  // 0 - horizontal inside ??
  // 1 - right border
  // 2 - bottom border
  // 3 - vertical inside ??
  // 4 - left border
  // 5 - top border
  cnstShiftVal: array[0 .. 5] of Integer = (0, 1, 2, 0, 3, 0);
begin
  if AIndex in [0, 3] then
    Result := 0
  else
    Result := ($40 shl (Ord(ABorderProp) shl 2)) shl cnstShiftVal[AIndex];
end;

function TsgAcadTableCell.GetBorderVisible(Index: Integer): Boolean;
var
  vOverride: Boolean;
begin
  vOverride := IsBorderVisibleOverriden(Index);
  if not vOverride and HasOwnerStyle then
    Result := GetOwnerStyle.BorderVisible[Index]
  else
    Result := FCellProps.BorderVisible[Index]
end;

function TsgAcadTableCell.GetCellAlignment: Integer;
begin
  Result := StyleByProp(cpCellAllignment).CellAlignment;
end;

function TsgAcadTableCell.GetCellRange: TRect;
begin
  Result := Rect(FCol, FRow, FCol, FRow);
end;

function TsgAcadTableCell.GetCellType: TsgAcadTableCellType;
begin
  if HasOwnerStyle then
  begin
    case FRow of
      0: Result := cttTitle;
      1: Result := cttHeader;
    else
      Result := cttData;
    end;
  end
  else
    Result := FCellType;
end;

function TsgAcadTableCell.GetDataType: Integer;
begin
  Result := StyleByProp(cpDataType).DataType;
end;

function TsgAcadTableCell.GetFillColor: TsgColorCAD;
begin
  Result := StyleByProp(cpFillColor).FillColor;
end;

function TsgAcadTableCell.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgAcadTableCell.GetFlagsMask(AIndex: Integer): Integer;
const
  // 1:  right
  // 2:  bottom
  // 4:  left
  // 5:  top
  cnstMasks: array[0 .. 5] of Integer = (0, $02, $04, 0, $08, $01);
begin
  Result := cnstMasks[AIndex];
end;

function TsgAcadTableCell.GetIsBaseCell: Boolean;
begin
  Result := FMergedValue = 0;
end;

function TsgAcadTableCell.GetMerged: Boolean;
begin
  Result := (FSpanX > 0) or (FSpanY > 0);
end;

function TsgAcadTableCell.GetMergedRect: TFRect;
var
  vBaseCell: TsgAcadTableCell;
  I: Integer;
begin
  if IsBaseCell and not Merged then
    Result := GetRect
  else
  begin
    vBaseCell := BaseCell;
    Result := vBaseCell.GetRect;
    for I := vBaseCell.Col + 1 to vBaseCell.Col + vBaseCell.MergedWidth - 1 do
      Result.Right := Result.Right + AcadTable.ColWidth[I];
    for I := vBaseCell.Row + 1 to vBaseCell.Row + vBaseCell.MergedHeight - 1 do
      Result.Bottom := Result.Bottom - AcadTable.RowHeight[I];
  end;
end;

function TsgAcadTableCell.GetOwnerStyle: TsgAcadTableCellStyle;
begin
  Result := AcadTable.Style.CellStyle[CellType];
end;

function TsgAcadTableCell.GetRect: TFRect;
var
  I: Integer;
begin
  FillChar(Result, SizeOf(TFRect), 0);
  I := 0;
  while I < FCol do
  begin
    Result.Left := Result.Left + AcadTable.ColWidth[I];
    Inc(I);
  end;
  Result.Right := Result.Left + AcadTable.ColWidth[I];
  I := 0;
  while I < FRow do
  begin
    Result.Top := Result.Top - AcadTable.RowHeight[I];
    Inc(I);
  end;
  Result.Bottom := Result.Top - AcadTable.RowHeight[I];
end;

function TsgAcadTableCell.GetTextColor: TsgColorCAD;
begin
  Result := StyleByProp(cpTextColor).TextColor;
end;

function TsgAcadTableCell.GetTextHeight: Double;
begin
  if (FOverrideFlag and $20 = 0) and HasOwnerStyle then
    Result := GetOwnerStyle.TextHeight
  else
    Result := FCellProps.TextHeight;
end;

function TsgAcadTableCell.GetTextStyle: TsgDXFStyle;
begin
  Result := StyleByProp(cpTextStyle).TextStyle;
end;

function TsgAcadTableCell.GetUnitType: Integer;
begin
  Result := StyleByProp(cpUnitType).UnitType;
end;

function TsgAcadTableCell.IsBorderColorOverriden(
  const AIndex: Integer): Boolean;
begin
  Result := IsBorderPropOverriden(bpColor, AIndex);
end;

function TsgAcadTableCell.IsBorderEq(const AIndex: Integer;
  const ACell: TsgAcadTableCell): Boolean;
begin
  Result := IsBorderEqEx(AIndex, ACell, AIndex);
end;

function TsgAcadTableCell.IsBorderEqEx(const AIndex: Integer;
  const AAdjacentCell: TsgAcadTableCell;
  const AAdjacentIndex: Integer): Boolean;
begin
  Result := (BorderVisible[AIndex] = AAdjacentCell.BorderVisible[AAdjacentIndex]) and
    IsColorCADEqual(BorderColor[AIndex], AAdjacentCell.BorderColor[AAdjacentIndex]) and
    (BorderLineWeight[AIndex] = AAdjacentCell.BorderLineWeight[AAdjacentIndex]);
end;

function TsgAcadTableCell.IsBorderLineweightOverriden(
  const AIndex: Integer): Boolean;
begin
  Result := IsBorderPropOverriden(bpLineweight, AIndex);
end;

function TsgAcadTableCell.IsBorderPropOverriden(
  const ABorderProp: TsgBorderProp; const AIndex: Integer): Boolean;
var
  vMask: Integer;
begin
  vMask := GetBorderPropOverridenMask(ABorderProp, AIndex);
  Result := (FOverrideFlag and vMask <> 0) or (AIndex in [0, 3]);
end;

function TsgAcadTableCell.IsBorderVisibleOverriden(
  const AIndex: Integer): Boolean;
begin
  Result := IsBorderPropOverriden(bpVisible, AIndex);
end;

function TsgAcadTableCell.IsPropInit(const ACellProp: TsgCellProp): Boolean;
begin
  Result := FCellProps.IsPropInit(ACellProp);
end;

procedure TsgAcadTableCell.Link(AConverter: TsgDXFConverter);
begin
end;

function TsgAcadTableCell.HasOwnerStyle: Boolean;
begin
  Result := Assigned(FAcadTable) and Assigned(FAcadTable.Style);
end;

procedure TsgAcadTableCell.SetAttdefHandle(const AValue: UInt64);
begin
  FAttdefHandle := AValue;
end;

procedure TsgAcadTableCell.SetAttdefValue(const AValue: string);
begin
  FAttdefValue := AValue;
end;

procedure TsgAcadTableCell.SetAutoFit(const AValue: Boolean);
begin
  FAutoFit := AValue;
end;

procedure TsgAcadTableCell.SetBkColorOn(const AValue: Boolean);
begin
  FCellProps.BkColorOn := AValue;
  FCellProps.SetPropInit(cpBkColorOn, True);
  if HasOwnerStyle and
     GetOwnerStyle.BkColorOn = FCellProps.BkColorOn then
    FCellProps.SetPropInit(cpBkColorOn, False);
end;

procedure TsgAcadTableCell.SetBlockRecordHandle(const AValue: UInt64);
begin
  FBlockRecordHandle := AValue;
end;

procedure TsgAcadTableCell.SetBlockScale(const AValue: Single);
begin
  FBlockScale := AValue;
end;

procedure TsgAcadTableCell.SetBorderColor(Index: Integer;
  const AValue: TsgColorCAD);
var
  vMaskOverrideFlag: Integer;
begin
  vMaskOverrideFlag := GetBorderPropOverridenMask(bpColor, Index);
  FCellProps.BorderColor[Index] := AValue;
  if HasOwnerStyle and
     IsColorCADEqual(GetOwnerStyle.BorderColor[Index], FCellProps.BorderColor[Index]) then
    FOverrideFlag := FOverrideFlag and not vMaskOverrideFlag
  else
    FOverrideFlag := FOverrideFlag or vMaskOverrideFlag;
  UpdateFlags(Index);
end;

procedure TsgAcadTableCell.SetBorderLineWeight(Index: Integer;
  const AValue: Double);
var
  vMaskOverrideFlag: Integer;
begin
  vMaskOverrideFlag := GetBorderPropOverridenMask(bpLineweight, Index);
  FCellProps.BorderLineWeight[Index] := AValue;
  if HasOwnerStyle and
     (GetOwnerStyle.BorderLineWeight[Index] = FCellProps.BorderLineWeight[Index]) then
    FOverrideFlag := FOverrideFlag and not vMaskOverrideFlag
  else
    FOverrideFlag := FOverrideFlag or vMaskOverrideFlag;
  UpdateFlags(Index);
end;

procedure TsgAcadTableCell.SetBorderVisible(Index: Integer;
  const AValue: Boolean);
var
  vMaskOverrideFlag: Integer;
begin
  vMaskOverrideFlag := GetBorderPropOverridenMask(bpVisible, Index);
  FCellProps.BorderVisible[Index] := AValue;
  if HasOwnerStyle and
     (GetOwnerStyle.BorderVisible[Index] = FCellProps.BorderVisible[Index]) then
    FOverrideFlag := FOverrideFlag and not vMaskOverrideFlag
  else
    FOverrideFlag := FOverrideFlag or vMaskOverrideFlag;
  UpdateFlags(Index);
end;

procedure TsgAcadTableCell.SetCellAlignment(const AValue: Integer);
begin
  FCellProps.CellAlignment := AValue;
  FCellProps.SetPropInit(cpCellAllignment, True);
  if HasOwnerStyle and
     (GetOwnerStyle.CellAlignment = FCellProps.CellAlignment) then
    FCellProps.SetPropInit(cpCellAllignment, False);
end;

procedure TsgAcadTableCell.SetCellType(const AValue: TsgAcadTableCellType);
begin
  FCellType := AValue;
end;

procedure TsgAcadTableCell.SetDataType(const AValue: Integer);
begin
  FCellProps.DataType := AValue;
  FCellProps.SetPropInit(cpDataType, True);
  if HasOwnerStyle and (GetOwnerStyle.DataType = FCellProps.DataType) then
    FCellProps.SetPropInit(cpDataType, False);
end;

procedure TsgAcadTableCell.SetField(const AValue: TsgDXFField);
begin
  FField := AValue;
end;

procedure TsgAcadTableCell.SetFillColor(const AValue: TsgColorCAD);
begin
  FCellProps.FillColor := AValue;
  FCellProps.SetPropInit(cpFillColor, True);
  if HasOwnerStyle and
     IsColorCADEqual(GetOwnerStyle.FillColor, FCellProps.FillColor) then
    FCellProps.SetPropInit(cpFillColor, False);
  BkColorOn := not IsColorCADEqual(MakeColorCAD(acIndexColor, clDXFBlackWhite),
    FCellProps.FillColor);
end;

procedure TsgAcadTableCell.SetFlags(const AValue: Integer);
begin
  FFlags := AValue;
end;

procedure TsgAcadTableCell.SetIsBaseCell(const AValue: Boolean);
begin
  FMergedValue := Ord(not AValue);
end;

procedure TsgAcadTableCell.SetIsTextType(const AValue: Boolean);
begin
  FIsTextType := AValue;
end;

procedure TsgAcadTableCell.SetMergedHeight(const AValue: Integer);
begin
  FMergedHeight := AValue;
end;

procedure TsgAcadTableCell.SetMergedValue(const AValue: Integer);
begin
  FMergedValue := AValue;
end;

procedure TsgAcadTableCell.SetMergedWidth(const AValue: Integer);
begin
  FMergedWidth := AValue;
end;

procedure TsgAcadTableCell.SetNumAttdefs(const AValue: Integer);
begin
  FNumAttdefs := AValue;
end;

procedure TsgAcadTableCell.SetOverrideFlag(const AValue: Integer);
begin
  FOverrideFlag := AValue;
end;

procedure TsgAcadTableCell.SetRotation(const AValue: Single);
begin
  FRotation := AValue;
end;

procedure TsgAcadTableCell.SetText(const AValue: string);
begin
  FText := AValue;
end;

procedure TsgAcadTableCell.SetTextColor(const AValue: TsgColorCAD);
begin
  FCellProps.TextColor := AValue;
  FCellProps.SetPropInit(cpTextColor, True);
  if HasOwnerStyle and
     IsColorCADEqual(GetOwnerStyle.TextColor, FCellProps.TextColor) then
    FCellProps.SetPropInit(cpTextColor, False);
end;

procedure TsgAcadTableCell.SetTextHeight(const AValue: Double);
begin
  FCellProps.TextHeight := AValue;
  FOverrideFlag := FOverrideFlag or $20;
  if HasOwnerStyle and (GetOwnerStyle.TextHeight = FCellProps.TextHeight) then
    FOverrideFlag := FOverrideFlag and not $20;
end;

procedure TsgAcadTableCell.SetTextStyle(const AValue: TsgDXFStyle);
begin
  FCellProps.TextStyle := AValue;
  FCellProps.SetPropInit(cpTextStyle, True);
  if HasOwnerStyle and (GetOwnerStyle.TextStyle = FCellProps.TextStyle) then
    FCellProps.SetPropInit(cpTextStyle, False);
end;

procedure TsgAcadTableCell.SetUnitType(const AValue: Integer);
begin
  FCellProps.UnitType := AValue;
  FCellProps.SetPropInit(cpUnitType, True);
  if HasOwnerStyle and (GetOwnerStyle.UnitType = FCellProps.UnitType) then
    FCellProps.SetPropInit(cpUnitType, False);
end;

procedure TsgAcadTableCell.SetVirtualEgdeFlag(const AValue: Boolean);
begin
  FVirtualEgdeFlag := AValue;
end;

function TsgAcadTableCell.StyleByProp(
  const ACellProp: TsgCellProp): TsgAcadTableCellStyle;
begin
  if not IsPropInit(ACellProp) and HasOwnerStyle then
    Result := GetOwnerStyle
  else
    Result := FCellProps;
end;

procedure TsgAcadTableCell.UpdateFlags(const AIndex: Integer);
var
  I: TsgBorderProp;
  vSetBit: Boolean;
begin
  I := Low(TsgBorderProp);
  vSetBit := False;
  while not vSetBit and (I <= High(TsgBorderProp)) do
    if IsBorderPropOverriden(I, AIndex) then
      Inc(vSetBit)
    else
      Inc(I);
  if vSetBit then
    FFlags := FFlags or GetFlagsMask(AIndex)
  else
    FFlags := FFlags and not GetFlagsMask(AIndex)
end;

{ TsgDXFAcadTable }

procedure TsgDXFAcadTable.SetNumCols(const AValue: Integer);
begin
  if FColWidth.Count <> AValue then
    Resize(AValue, FRowHeight.Count);
end;

procedure TsgDXFAcadTable.SetRowHeight(Index: Integer; const AValue: Double);
begin
  FRowHeight[Index] := AValue;
end;

procedure TsgDXFAcadTable.SetSizes(ANeedRowSize: Boolean; Index: Integer;
  const AValue: Double);
begin
  case ANeedRowSize of
    False: ColWidth[Index] := AValue;
    True: RowHeight[Index] := AValue;
  end;
end;

procedure TsgDXFAcadTable.SetStyle(const AValue: TsgDXFAcadTableStyle);
begin
  if FStyleRef <> AValue then
  begin
    FStyleRef := AValue;
    if Assigned(FStyleRef) then
      EnumCells(SetCellTextStyle, FStyleRef);
  end;
end;

procedure TsgDXFAcadTable.SplitCells(ACol, ARow: Integer);
var
  vBC: TsgAcadTableCell;
begin
  vBC := Cell[ACol, ARow].BaseCell;
  EnumRange(Rect(vBC.Col, vBC.Row, vBC.Col + vBC.MergedWidth - 1,
    vBC.Row + vBC.MergedHeight - 1), SplitCell, vBC);
end;

function TsgDXFAcadTable.SplitCell(ACol, ARow: Integer;
  AParam: Pointer): Boolean;
var
  vCell: TsgAcadTableCell;
begin
  Result := True;
  vCell := Cell[ACol, ARow];
  vCell.IsBaseCell := True;
  vCell.MergedWidth := 1;
  vCell.MergedHeight := 1;
  vCell.SpanX := 0;
  vCell.SpanY := 0;
end;

procedure TsgDXFAcadTable.SetCell(ACol, ARow: Integer;
  const AValue: TsgAcadTableCell);
begin
  Cell[ACol, ARow].Assign(AValue);
end;

function TsgDXFAcadTable.SetCellTextStyle(ACol, ARow: Integer; AParam: Pointer): Boolean;
begin
  Result := True;
  if not Cell[ACol, ARow].IsPropInit(cpTextStyle) then
    Cell[ACol, ARow].FCellProps.TextStyle :=
      TsgDXFAcadTableStyle(AParam).CellStyle[Cell[ACol, ARow].CellType].TextStyle;
end;

procedure TsgDXFAcadTable.SetColWidth(Index: Integer; const AValue: Double);
begin
  FColWidth[Index] := AValue;
end;

procedure TsgDXFAcadTable.SetFlags(const AValue: Integer);
begin
  FFlags := AValue;
end;

procedure TsgDXFAcadTable.SetNumRows(const AValue: Integer);
begin
  if FRowHeight.Count <> AValue then
    Resize(FColWidth.Count, AValue);
end;

{ Method TsgDXFAcadTable.SetOverrideFlags

  0 bit: Flag for an override                       (93)
  1 bit: Flag for an override of border color       (94)
  2 bit: Flag for an override of border lineweight  (95)
  3 bit: Flag for an override of border visibility  (96) }
procedure TsgDXFAcadTable.SetOverrideFlags(const AValue: Byte);
begin
  FOverrideFlags := AValue;
end;

procedure TsgDXFAcadTable.SetProperties(const AValue: TsgDXFAcadTableStyle);
begin
  FProperties.AssignEntity(AValue);
end;

procedure TsgDXFAcadTable.AssignEntity(Source: TsgDXFEntity);
var
  vAcadTable: TsgDXFAcadTable;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFAcadTable then
  begin
    vAcadTable := TsgDXFAcadTable(Source);
    FStyleRef := vAcadTable.Style;
    Properties := vAcadTable.Properties;
    Resize(vAcadTable.NumCols, vAcadTable.NumRows);
    FColWidth.Assign(vAcadTable.FColWidth);
    FRowHeight.Assign(vAcadTable.FRowHeight);
    EnumCells(AssignCell, vAcadTable);
  end;
end;

function TsgDXFAcadTable.AddCol: Integer;
begin
  Result := NumCols;
  InsertCol(Result);
end;

function TsgDXFAcadTable.AddRow: Integer;
begin
  Result := NumRows;
  InsertRow(Result);
end;

function TsgDXFAcadTable.AssignCell(ACol, ARow: Integer; AParam: Pointer): Boolean;
begin
  Result := True;
  Cell[ACol, ARow] := TsgDXFAcadTable(AParam).Cell[ACol, ARow];
end;

procedure TsgDXFAcadTable.Clear(const ADoFree: Boolean = True);
var
  vList: TsgObjectList;
begin
  if Assigned(FColWidth) then FColWidth.Clear;
  if Assigned(FRowHeight) then FRowHeight.Clear;
  if Assigned(FRows) then
    while FRows.Count > 0 do
    begin
      vList := TsgObjectList(FRows.Last);
      TsgObjectList.FreeList(vList, True);
      FRows.Delete(FRows.Count - 1);
    end;
end;

procedure TsgDXFAcadTable.ClearReferences;
begin
  inherited ClearReferences;
  Style := nil;
end;

constructor TsgDXFAcadTable.Create;
begin
  inherited Create;
  FRows := TsgObjectList.Create;
  FColWidth := TsgDoubleList.Create;
  FRowHeight := TsgDoubleList.Create;
  FProperties := TsgDXFAcadTableStyle.Create;
  FLockGenerateBlock := False;
end;

function TsgDXFAcadTable.CreateBlock(AConv: TsgDXFConverter): TsgDXFBlock;
begin
  Result := TsgDXFBlock.Create;
  AConv.DoCreate(Result);
  Result.Name := GetUniqueBlockName(AConv);
  AConv.Sections[csBlocks].AddEntity(Result);
  Block := Result;
end;

procedure TsgDXFAcadTable.DeleteCol(ACol: Integer);
var
  R: Integer;
  vList: TsgObjectList;
  vCell: TsgAcadTableCell;
begin
  for R := 0 to NumRows - 1 do
  begin
    vList := TsgObjectList(FRows[R]);
    vCell := TsgAcadTableCell(vList[ACol]);
    vList.Delete(ACol);
    vCell.Free;
  end;
  FColWidth.Delete(ACol);
end;

procedure TsgDXFAcadTable.DeleteCols(AColFrom, AColTo: Integer);
var
  C: Integer;
begin
  for C := AColTo downto AColFrom do
    DeleteCol(C);
end;

procedure TsgDXFAcadTable.DeleteRow(ARow: Integer);
var
  vRow: TsgObjectList;
begin
  vRow := TsgObjectList(FRows[ARow]);
  FRows.Delete(ARow);
  TsgObjectList.ClearList(vRow, True);
  FRowHeight.Delete(ARow);
end;

procedure TsgDXFAcadTable.DeleteRows(ARowFrom, ARowTo: Integer);
var
  R: Integer;
begin
  for R := ARowTo downto ARowFrom do
    DeleteRow(R);
end;

function TsgDXFAcadTable.EnumCells(AEnumCellsProc: TsgEnumCellsProc;
  AParam: Pointer): Boolean;
begin
  Result := EnumRange(Rect(0, 0, NumCols - 1, NumRows - 1), AEnumCellsProc, AParam);
end;

function TsgDXFAcadTable.EnumRange(ARange: TRect;
  AEnumCellsProc: TsgEnumCellsProc; AParam: Pointer): Boolean;
var
  R, C: Integer;
  vStopEnum: Boolean;
begin
  vStopEnum := False;
  if Assigned(AEnumCellsProc) then
  begin
    R := ARange.Top;
    while not vStopEnum and (R <= ARange.Bottom) do
    begin
      C := ARange.Left;
      while not vStopEnum and (C <= ARange.Right) do
        if AEnumCellsProc(C, R, AParam) then
          Inc(C)
        else
          Inc(vStopEnum);
      Inc(R, Ord(not vStopEnum));
    end;
  end;
  Result := not vStopEnum;
end;

procedure TsgDXFAcadTable.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FProperties);
  FreeAndNil(FColWidth);
  FreeAndNil(FRowHeight);
  FreeAndNil(FRows);
end;

function TsgDXFAcadTable.GetNumRows: Integer;
begin
  Result := FRowHeight.Count;
end;

function TsgDXFAcadTable.GetPropertiesAcadTableStyle: TsgDXFAcadTableStyle;
begin
  Result := FProperties;
end;

function TsgDXFAcadTable.GetRowHeight(Index: Integer): Double;
begin
  if Index >= FRowHeight.Count then
  begin
    if FRowHeight.Count = 0 then
    begin
      if Assigned(Converter) then
        Result := Converter.HeadVarStruct.TextSize + 2 * fCellMargin
      else
        Result := cnstDefHeadVarStruct.TextSize + 2 * fCellMargin;
    end
    else
      Result := FRowHeight.Last
  end
  else
    if Index >= 0 then
      Result := FRowHeight[Index]
    else
      Result := 0;
end;

function TsgDXFAcadTable.GetSizes(ANeedRowSize: Boolean; Index: Integer): Double;
begin
  if ANeedRowSize then
    Result := RowHeight[Index]
  else
    Result := ColWidth[Index];
end;

function TsgDXFAcadTable.GetStyle: TsgDXFAcadTableStyle;
begin
  Result := FStyleRef;
end;

function TsgDXFAcadTable.GetUniqueBlockName(
  const AConv: TsgDXFConverter): string;
begin
  Result := AConv.GetUniqueBlockName(sInternalACADTable, @AConv.FAddedTablesCount);
end;

procedure TsgDXFAcadTable.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlBlockName));
      AHideList.Add(Integer(xmlAngle));
      AHideList.Add(Integer(xmlFPointScale));
    end;
  end;
end;

procedure TsgDXFAcadTable.InsertCol(AIndex: Integer);
var
  R: Integer;
begin
  for R := 0 to NumRows - 1 do
    TsgObjectList(FRows[R]).Insert(AIndex, nil);
  FColWidth.Insert(AIndex, ColWidth[AIndex]);
end;

procedure TsgDXFAcadTable.InsertRow(AIndex: Integer);
var
  vList: TsgObjectList;
begin
  vList := TsgObjectList.Create;
  try
    vList.Count := NumCols;
    FRows.Insert(AIndex, vList);
  except
    vList.Free;
    raise;
  end;
  FRowHeight.Insert(AIndex, RowHeight[AIndex]);
end;

function TsgDXFAcadTable.IsBlockInternal: Boolean;
begin
  Result := not Assigned(BlockRecord) or (AnsiPos(sInternalACADTable, BlockRecord.Name) = 1);
end;

function TsgDXFAcadTable.GetNumCols: Integer;
begin
  Result := FColWidth.Count;
end;

function TsgDXFAcadTable.GenerateMText(const AConv: TsgDXFConverter; ACol,
  ARow: Integer): TsgDXFMText;
begin
  Result := Cell[ACol, ARow].GenerateMText(AConv, Self);
end;

function TsgDXFAcadTable.GetBaseCell(ACol, ARow: Integer): TsgAcadTableCell;
begin
  Result := Cell[ACol, ARow].BaseCell;
end;

function TsgDXFAcadTable.GetCell(ACol, ARow: Integer): TsgAcadTableCell;
var
  vCellType: TsgAcadTableCellType;
begin
  if ARow < 0 then
    ARow := 0
  else
    if ARow >= NumRows then
      ARow := NumRows - 1;
  if ACol < 0 then
    ACol := 0
  else
    if ACol >= NumCols then
      ACol := NumCols - 1;
  Result := TsgAcadTableCell(TsgObjectList(FRows[ARow])[ACol]);
  if not Assigned(Result) then
  begin
    case ARow of
      0: vCellType := cttTitle;
      1: vCellType := cttHeader;
    else
      vCellType := cttData;
    end;
    Result := TsgAcadTableCell.Create(Self, ACol, ARow, vCellType);
    TsgObjectList(FRows[ARow])[ACol] := Result;
  end;
end;

function TsgDXFAcadTable.GetColWidth(Index: Integer): Double;
const
  cnstSymCount = 10;
begin
  if Index >= FColWidth.Count then
  begin
    if FColWidth.Count = 0 then
    begin
      if Assigned(Converter) then
        Result := cnstSymCount * (Converter.HeadVarStruct.TextSize + 2 * fCellMargin)
      else
        Result := cnstSymCount * (cnstDefHeadVarStruct.TextSize + 2 * fCellMargin);
    end
    else
      Result := FColWidth.Last
  end
  else
    if Index >= 0 then
      Result := FColWidth[Index]
    else
      Result := 0;
end;

function TsgDXFAcadTable.GetEntType: TsgCADEntities;
begin
  Result := ceACADTable;
end;

function TsgDXFAcadTable.GetFlags: Integer;
begin
  Result := FFlags;
end;

procedure TsgDXFAcadTable.Link(AConverter: TsgDXFConverter);
var
  R, C: Integer;
begin
  inherited Link(AConverter);
  if not Assigned(Style) or not Style.InheritsFrom(TsgDXFAcadTableStyle) then
    Style := AConverter.TableStyleByName(sStandardName);
  for R := 0 to NumRows - 1 do
    for C := 0 to NumCols - 1 do
      Cell[C, R].Link(AConverter);
end;

procedure TsgDXFAcadTable.LoadedInternal(AConverter: TsgDXFConverter);
var
  I, R, C: Integer;
  vCell: TsgAcadTableCell;
  vAcadTableGenerator: TsgAcadTableGenerator;
begin
  FScale := cnstFPointSingle;
  FAngle := 0;
  // initialize SpanX and SpanY property of TsgAcadTableCell class
  R := 0;
  while R < NumRows do
  begin
    C := 0;
    while C < NumCols do
    begin
      vCell := Cell[C, R];
      if vCell.IsBaseCell then
      begin
        MergeCells(C, R, vCell.MergedWidth - 1, vCell.MergedHeight - 1);
        Inc(C, vCell.MergedWidth);
      end
      else
        Inc(C);
    end;
    Inc(R);
  end;

  R := 0;
  while R < NumRows do
  begin
    C := 0;
    while C < NumCols do
    begin
      vCell := Cell[C, R];
      for I := 0 to 5 do
        vCell.UpdateFlags(I);
      Inc(C);
    end;
    Inc(R);
  end;

  if not (AConverter.FStatus = stLoading) and IsBlockInternal then
    if not FLockGenerateBlock then
    begin
      vAcadTableGenerator := TsgAcadTableGenerator.Create(AConverter, Self);
      try
        Block := vAcadTableGenerator.GenerateBlock;
      finally
        vAcadTableGenerator.Free;
      end;
    end;
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFAcadTable.MergeCells(const ACol, ARow, ASpanX, ASpanY: Integer);
var
  vRange: TRect;
begin
  vRange := Rect(ACol, ARow, ACol + ASpanX, ARow + ASpanY);
  EnumRange(vRange, MergeCell, @vRange);
end;

function TsgDXFAcadTable.MergeCell(ACol, ARow: Integer; AParam: Pointer): Boolean;
var
  vRange: PRect;
  vCell: TsgAcadTableCell;
begin
  Result := True;
  vCell := Cell[ACol, ARow];
  vRange := PRect(AParam);
  vCell.IsBaseCell := (ACol = vRange^.Left) and (ARow = vRange^.Top);
  if vCell.IsBaseCell then
  begin
    vCell.MergedWidth := vRange^.Right - ACol + 1;
    vCell.MergedHeight := vRange^.Bottom - ARow + 1;
    vCell.SpanX := vCell.MergedWidth - 1;
    vCell.SpanY := vCell.MergedHeight - 1;
  end
  else
  begin
    vCell.MergedWidth := 1;
    vCell.MergedHeight := 1;
    vCell.SpanX := vRange^.Right - ACol;
    vCell.SpanY := vRange^.Bottom - ARow;
  end;
end;

procedure TsgDXFAcadTable.ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord);
  function _IsInternalTableBlockRecord(ABlockRecord: TsgDXFBlockRecord): Boolean;
  begin
    if ABlockRecord <> nil then
      Result := AnsiPos(sInternalACADTable, ABlockRecord.Name) = 1
    else
      Result := True;
  end;
begin
  if not _IsInternalTableBlockRecord(ABlockRecord) then
    inherited ReferenceBlockRecord(ABlockRecord);
end;

function TsgDXFAcadTable.ReleaseBlock: TsgDXFBlock;
begin
  Result := Block;
  Block := nil;
end;

procedure TsgDXFAcadTable.Resize(const AColCount, ARowCount: Integer);
var
  I, vCount: Integer;
begin
  if ARowCount < NumRows then
    DeleteRows(ARowCount, NumRows - 1)
  else
    if ARowCount > NumRows then
    begin
      vCount := ARowCount - NumRows - 1;
      for I := 0 to vCount do
        AddRow;
    end;
  if AColCount < NumCols then
    DeleteCols(AColCount, NumCols - 1)
  else
    if AColCount > NumCols then
    begin
      vCount := AColCount - NumCols - 1;
      for I := 0 to vCount do
        AddCol;
    end;
end;

{ TsgDXFAcadTableStyle }

function TsgDXFAcadTableStyle.GetCellStyle(
  Index: TsgAcadTableCellType): TsgAcadTableCellStyle;
begin
  Result := FCellStyle[Index];
end;

function TsgDXFAcadTableStyle.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgDXFAcadTableStyle.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgDescriptedNamedItem;
end;

procedure TsgDXFAcadTableStyle.Link(AConverter: TsgDXFConverter);
var
  I: TsgAcadTableCellType;
begin
  inherited Link(AConverter);
  for I := Low(TsgAcadTableCellType) to High(TsgAcadTableCellType) do
    CellStyle[I].Link(AConverter);
end;

procedure TsgDXFAcadTableStyle.LoadedInternal(AConverter: TsgDXFConverter);
var
  I: TsgAcadTableCellType;
begin
  inherited LoadedInternal(AConverter);
  for I := Low(TsgAcadTableCellType) to High(TsgAcadTableCellType) do
    if not Assigned(CellStyle[I].TextStyle) then
      CellStyle[I].TextStyle := AConverter.StyleByName(sStandardName);
end;

procedure TsgDXFAcadTableStyle.SetCellStyle(Index: TsgAcadTableCellType;
  const AValue: TsgAcadTableCellStyle);
begin
  FCellStyle[Index].Assign(AValue);
end;

procedure TsgDXFAcadTableStyle.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

procedure TsgDXFAcadTableStyle.SetFlowDirection(const AValue: Integer);
begin
  FFlowDirection := AValue;
end;

procedure TsgDXFAcadTableStyle.SetHeaderSuppressed(const AValue: Boolean);
begin
  FHeaderSuppressed := AValue;
end;

procedure TsgDXFAcadTableStyle.SetHorzCellMargin(const AValue: Double);
begin
  FHorzCellMargin := AValue;
end;

procedure TsgDXFAcadTableStyle.SetTitleSuppressed(const AValue: Boolean);
begin
  FTitleSuppressed := AValue;
end;

procedure TsgDXFAcadTableStyle.SetVertCellMargin(const AValue: Double);
begin
  FVertCellMargin := AValue;
end;

procedure TsgDXFAcadTableStyle.ClearReferences;
begin
  inherited ClearReferences;
end;

constructor TsgDXFAcadTableStyle.Create;
var
  I: TsgAcadTableCellType;
begin
  inherited Create;
  for I := Low(TsgAcadTableCellType) to High(TsgAcadTableCellType) do
    FCellStyle[I] := TsgAcadTableCellStyle.Create(Self, I);
  FHorzCellMargin := fCellMargin;
  FVertCellMargin := fCellMargin;
end;

procedure TsgDXFAcadTableStyle.FreeReferences;
var
  I: TsgAcadTableCellType;
begin
  inherited FreeReferences;
  for I := Low(TsgAcadTableCellType) to High(TsgAcadTableCellType) do
    FreeAndNil(FCellStyle[I]);
end;

procedure TsgDXFAcadTableStyle.AssignEntity(Source: TsgDXFEntity);
var
  I: TsgAcadTableCellType;
  vSource: TsgDXFAcadTableStyle;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFAcadTableStyle then
  begin
    vSource := TsgDXFAcadTableStyle(Source);
    FFlags := vSource.Flags;
    for I := Low(TsgAcadTableCellType) to High(TsgAcadTableCellType) do
      CellStyle[I] := vSource.CellStyle[I];
    FHeaderSuppressed := vSource.HeaderSuppressed;
    FFlowDirection := vSource.FlowDirection;
    FHorzCellMargin := vSource.HorzCellMargin;
    FTitleSuppressed := vSource.TitleSuppressed;
    FVertCellMargin := vSource.VertCellMargin;
  end;
end;

{ TsgAcadTableCellStyle }

procedure TsgAcadTableCellStyle.Assign(Source: TPersistent);
var
  I: Integer;
  vSource: TsgAcadTableCellStyle;
begin
  if Source is TsgAcadTableCellStyle then
  begin
    vSource := TsgAcadTableCellStyle(Source);
    FAcadTableStyle := vSource.AcadTableStyle;
    FBkColorOn := vSource.BkColorOn;
    for I := 0 to FBorderParams.Count - 1 do
      PsgCellBorderParam(FBorderParams[I])^ :=
        PsgCellBorderParam(vSource.FBorderParams[I])^;
    FCellAlignment := vSource.CellAlignment;
    FDataType := vSource.DataType;
    FFillColor := vSource.FillColor;
    FCellInitProps := vSource.FCellInitProps;
    TextStyle := vSource.TextStyle;
    FTextColor := vSource.TextColor;
    FTextHeight := vSource.TextHeight;
    FUnitType := vSource.UnitType;
  end
  else
    inherited Assign(Source);
end;

constructor TsgAcadTableCellStyle.Create(AAcadTableStyle: TsgDXFAcadTableStyle);
begin
  Create(AAcadTableStyle, cttData);
end;

constructor TsgAcadTableCellStyle.Create(AAcadTableStyle: TsgDXFAcadTableStyle;
  const ACellType: TsgAcadTableCellType);
var
  I: Integer;
  vCellBorderParam: PsgCellBorderParam;
begin
  FAcadTableStyle := AAcadTableStyle;
  FCellType := ACellType;
  FTextStyleItem := TsgTableItem.Create;
  FTextColor := MakeColorCAD(acIndexColor, clDXFByBlock);
  FFillColor := MakeColorCAD(acIndexColor, clDXFBlackWhite);
  FTextHeight := cnstDefHeadVarStruct.TextSize;
  FDataType := 0;
  FCellAlignment := 2;
  FUnitType := 0;
  FBkColorOn := False;
  FBorderParams := TList.Create;
  for I := 0 to 5 do
  begin
    New(vCellBorderParam);
    FBorderParams.Add(vCellBorderParam);
    vCellBorderParam^.Color := FTextColor;
    vCellBorderParam^.LineWeight := fLineWeightByBlock;
    vCellBorderParam^.Visible := True;
  end;
end;


destructor TsgAcadTableCellStyle.Destroy;
begin
  FreeRecordList(FBorderParams);
  FAcadTableStyle := nil;
  TextStyle := nil;
  FreeAndNil(FTextStyleItem);
  inherited Destroy;
end;

function TsgAcadTableCellStyle.GetBorderColor(Index: Integer): TsgColorCAD;
begin
  Result := PsgCellBorderParam(FBorderParams[Index])^.Color;
end;

function TsgAcadTableCellStyle.GetBorderCount: Integer;
begin
  Result := FBorderParams.Count;
end;

function TsgAcadTableCellStyle.GetBorderLineWeight(Index: Integer): Double;
begin
  Result := PsgCellBorderParam(FBorderParams[Index])^.LineWeight;
end;

function TsgAcadTableCellStyle.GetBorderVisible(Index: Integer): Boolean;
begin
  Result := PsgCellBorderParam(FBorderParams[Index])^.Visible;
end;

function TsgAcadTableCellStyle.GetTextStyle: TsgDXFStyle;
begin
  Result := TsgDXFStyle(FTextStyleItem.Item);
end;

function TsgAcadTableCellStyle.IsPropInit(
  const ACellProp: TsgCellProp): Boolean;
begin
  Result := ACellProp in FCellInitProps;
end;

procedure TsgAcadTableCellStyle.Link(AConverter: TsgDXFConverter);
begin
end;

procedure TsgAcadTableCellStyle.SetBkColorOn(const AValue: Boolean);
begin
  FBkColorOn := AValue;
end;

procedure TsgAcadTableCellStyle.SetBorderColor(Index: Integer;
  const AValue: TsgColorCAD);
begin
  PsgCellBorderParam(FBorderParams[Index])^.Color := AValue;
end;

procedure TsgAcadTableCellStyle.SetBorderLineWeight(Index: Integer;
  const AValue: Double);
begin
  PsgCellBorderParam(FBorderParams[Index])^.LineWeight := AValue;
end;

procedure TsgAcadTableCellStyle.SetBorderVisible(Index: Integer;
  const AValue: Boolean);
begin
  PsgCellBorderParam(FBorderParams[Index])^.Visible := AValue;
end;

procedure TsgAcadTableCellStyle.SetCellAlignment(const AValue: Integer);
begin
  FCellAlignment := AValue;
end;

procedure TsgAcadTableCellStyle.SetCellType(const AValue: TsgAcadTableCellType);
begin
  FCellType := AValue;
end;

procedure TsgAcadTableCellStyle.SetDataType(const AValue: Integer);
begin
  FDataType := AValue;
end;

procedure TsgAcadTableCellStyle.SetFillColor(const AValue: TsgColorCAD);
begin
  FFillColor := AValue;
end;

procedure TsgAcadTableCellStyle.SetPropInit(const ACellProp: TsgCellProp;
  const AInclude: Boolean);
begin
  if AInclude then
    Include(FCellInitProps, ACellProp)
  else
    Exclude(FCellInitProps, ACellProp);
end;

procedure TsgAcadTableCellStyle.SetTextColor(const AValue: TsgColorCAD);
begin
  FTextColor := AValue;
end;

procedure TsgAcadTableCellStyle.SetTextHeight(const AValue: Double);
begin
  FTextHeight := AValue;
end;

procedure TsgAcadTableCellStyle.SetTextStyle(const AValue: TsgDXFStyle);
begin
  FTextStyleItem.Item := AValue;
end;

procedure TsgAcadTableCellStyle.SetUnitType(const AValue: Integer);
begin
  FUnitType := AValue;
end;

{ TsgDXFProxy }

function TsgDXFProxy.CanAddedToXMLParams: Boolean;
begin
  Result := False;
end;

procedure TsgDXFProxy.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  ClearEntCollection(FEntities, ADoFree);
end;

constructor TsgDXFProxy.Create;
begin
  inherited Create;
  FEntities := TsgEntitiesList(TsgEntitiesList.CreateList(ListNotify));
end;

procedure TsgDXFProxy.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FEntities);
end;

function TsgDXFProxy.GetBox: TFRect;
begin
  Result := FBox;
end;

function TsgDXFProxy.GetCount: Integer;
begin
  Result := FEntities.Count;
end;

function TsgDXFProxy.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FEntities[AIndex];
end;

function TsgDXFProxy.GetEntType: TsgCADEntities;
begin
  Result := ceProxy;
end;

function TsgDXFProxy.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := True;
  FEntities.Insert(AIndex, AEntity);
end;

procedure TsgDXFProxy.Invoke(AConverter: TsgDXFConverter; Proc, FinishProc: TsgCADEntityProc);
var
  I: Integer;
  vInvokeChild: Boolean;
begin
  vInvokeChild := True;
  if Assigned(Proc) then
    vInvokeChild := Proc(Self) = 0;
  try
    if vInvokeChild then
      for I := 0 to Count - 1 do
        Entities[I].Invoke(AConverter, Proc, FinishProc);
  finally
    if Assigned(FinishProc) then
      FinishProc(Self);
  end;
end;

function TsgDXFProxy.GroupExists: Boolean;
begin
  Result := True;
end;

procedure TsgDXFProxy.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  UpdateBox;
end;

procedure TsgDXFProxy.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  FEntities[AIndex] := AEntity;
end;

procedure TsgDXFProxy.UpdateBox;
var
  I: Integer;
begin
  FBox := BadRect;
  for I := 0 to Count - 1 do        // FBox is union of all entities
    if Entities[I].Visibility then
      UnionFRect(FBox, Entities[I].Box);
end;

{ TsgFlatEntity }

function TsgFlatEntity.CanDraw: Boolean;
begin
  Result := True;
end;

function TsgFlatEntity.CanHaveHandle: Boolean;
begin
  Result := False;
end;

procedure TsgFlatEntity.ClearReferences;
begin
  inherited ClearReferences;
  FCounts.Clear;
  if Assigned(FPoints) then
    FPoints.Clear;
end;

procedure TsgFlatEntity.CopyProperty(const AEntity: TsgDXFEntity);
begin
  ColorCAD := AEntity.ColorCAD;
  LineWeight := AEntity.LineWeight;
  Layer := AEntity.Layer;
end;

constructor TsgFlatEntity.Create;
begin
  inherited Create;
  FBox := BadRect;
  FCounts := TsgIntegerList.Create;
  FPoints := TsgBaseListClass(GetPointsClass).Create;
end;

function TsgFlatEntity.GroupFill(AConverter: TsgDXFConverter): Boolean;
begin
  Result := False;
end;

procedure TsgFlatEntity.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FCounts);
  FreeAndNil(FPoints);
end;

function TsgFlatEntity.Accepts(const AEntity: TsgDXFEntity): Boolean;
begin
  Result := (Color = AEntity.Color);
end;

procedure TsgFlatEntity.AddPolyline(P: TsgCADBasePolyline);
var
  vBox: TFRect;
begin
  if PCount = 0 then
    CopyProperty(P);
  begin
    ColorCAD := P.ColorCAD;
    LineWeight := P.LineWeight;
    Layer := P.Layer;
  end;
  vBox := P.Box;
  AddPoints(P.PolyPoints, P.Closed, @vBox);
end;

procedure TsgFlatEntity.AddPolygon(P: TsgCADPolyPolygon);
var
  C,I,J: Integer;
  vPoint2D: TF2DPoint;
  L: TF2DPointList;
begin
  if FCounts.Count = 0 then
    ColorCAD := P.ColorCAD;//CopyProperty(P);
  C := 0;
  for I := 0 to P.Boundaries.Count-1 do
  begin
    L := TF2DPointList(P.Boundaries[I]);
    if L.Count > 0 then
      Inc(C);
  end;
  FCounts.Add(C);
  C := 0;
  UnionFRect(FBox, P.Box);
  for I := 0 to P.Boundaries.Count-1 do
  begin
    L := TF2DPointList(P.Boundaries[I]);
    if L.Count = 0 then Continue;
    FCounts.Add(L.Count);
    for J := 0 to L.Count-1 do
    begin
      vPoint2D := L[J];
      AddPoint(vPoint2D.X, vPoint2D.Y);
      Inc(C);
    end;
  end;
  FCounts.Add(C);
end;

procedure TsgFlatEntity.AddPoint(const X, Y, Z: Double);
begin

end;

procedure TsgFlatEntity.AddPoints(const APoints: TFPointList;
  const AClosed: Boolean; const ABox: PFRect = nil);
var
  C,I: Integer;
  vExpandBox: Boolean;
begin
  if APoints.Count < 1 then
    Exit;
  vExpandBox := (ABox = nil) or IsBadRect(ABox^);
  if not vExpandBox then
    UnionFRect(FBox, ABox^);
  C := APoints.Count;
  for I := 0 to C - 1 do
  begin
    AddFPoint(APoints[I]);
    if vExpandBox then
      ExpandFRect(FBox, APoints[I]);
  end;
  if AClosed then
  begin
    AddFPoint(APoints[0]);
    Inc(C);
  end;
  FCounts.Add(C);
end;

procedure TsgFlatEntity.AddLine(const ALine: TsgDXFLine);
begin
  if PCount = 0 then
    CopyProperty(ALine);
  UnionFRect(FBox, ALine.Box);
  AddFPoint(ALine.Point);
  AddFPoint(ALine.Point1);
  FCounts.Add(2);
end;

function TsgFlatEntity.Add(const AEntity: TsgDXFEntity): Boolean;
begin
  Result := False;
  if AEntity is TsgCADBasePolyline then
  begin
    Result := True;
    AddPolyline(TsgCADBasePolyline(AEntity));
  end
  else
  begin
    if AEntity is TsgCADPolyPolygon then
    begin
      Result := True;
      AddPolygon(TsgCADPolyPolygon(AEntity));
    end
    else
    begin
      if AEntity is TsgDXFLine then
      begin
        Result := True;
        AddLine(TsgDXFLine(AEntity));
      end;
    end;
  end;
end;

function TsgFlatEntity.AddSegment(const APoints: TFPointList; const AMerge: Boolean): Boolean;
var
  I: Integer;
begin
  Result := AMerge and (APoints.Count > 0) and (PCount > 0) and
    IsEqualFPoints(XY[PCount - 1], APoints.First);
  if Result then
  begin
    for I := 1 to APoints.Count - 1 do
      AddSegmentPoint(APoints[I], False);
  end
  else
    AddPoints(APoints, False, nil);
end;

function TsgFlatEntity.AddSegmentPoint(const APoint: TFPoint;
  const ACreateNewSegment: Boolean): Integer;
begin
  if ACreateNewSegment or (FCounts.Count = 0) then
    FCounts.Add(0);
  FCounts.Last := FCounts.Last + 1;
  AddFPoint(APoint);
  ExpandFRect(FBox, APoint);
  Result := FCounts.Last;
end;

procedure TsgFlatEntity.AddFPoint(const APoint: TFPoint);
begin
  AddPoint(APoint.X, APoint.Y, APoint.Z);
end;

procedure TsgFlatEntity.AssignEntity(Source: TsgDXFEntity);
var
  vFlatEntity: TsgFlatEntity absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgFlatEntity then
  begin
    FBox := vFlatEntity.FBox;
    FCounts.Assign(vFlatEntity.FCounts);
    if FPoints.ClassType = vFlatEntity.FPoints.ClassType then
      FPoints.Assign(vFlatEntity.FPoints);
  end;
end;

function TsgFlatEntity.GetBox: TFRect;
begin
  Result := FBox;
end;

function TsgFlatEntity.GetPointsClass: TClass;
begin
  Result := TsgSingleList;
end;

function TsgFlatEntity.GetPointsSignleList: TsgSingleList;
begin
  Result := nil;
end;

function TsgFlatEntity.GetXY(Index: Integer): TFPoint;
begin

end;

function TsgFlatEntity.GetXYLast: TFPoint;
begin
  if PCount > 0 then
    Result := XY[PCount-1]
  else
    Result := cnstBadPoint;
end;

function TsgFlatEntity.PCount: Integer;
begin
  Result := 0;
end;


procedure TsgFlatEntity.PoinsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams);
begin
end;

procedure TsgFlatEntity.ReCalcBox;
var
  I: Integer;
  vPoint: TFPoint;
  vSingles: TsgSingleList;
  vPoints: TsgBasePointList;
begin
  FBox := cnstBadRect;
  if Assigned(FPoints) and (FPoints.Count > 0)then
  begin
    if FPoints is TsgSingleList then
    begin
      vSingles := TsgSingleList(FPoints);
      I := 0;
      vPoint.Z := 0;
      while I < vSingles.Count do
      begin
        vPoint.X := vSingles[I];
        Inc(I);
        vPoint.Y := vSingles[I];
        Inc(I);
        ExpandFRect(FBox, vPoint);
      end;
    end
    else
    begin
      if FPoints is TsgBasePointList then
      begin
        vPoints := TsgBasePointList(FPoints);
        FBox := vPoints.GetBox;
      end;
    end;
  end;
end;

function TsgFlatEntity.GroupHasAddedEntities: Boolean;
begin
  Result := True;
end;

procedure TsgFlatEntity.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  if Layer = nil then
    Layer := AConverter.LayerByName('0');
end;

function TsgFlatEntity.GroupExists: Boolean;
begin
  Result := True;
end;

procedure TsgFlatEntity.SetBox(const ABox: TFRect);
begin
  FBox := ABox;
end;

procedure TsgFlatEntity.SetHandle(const Value: UInt64);
begin
{$IFDEF SG_MODULE_LOG}
  inherited SetHandle(Value);
{$ENDIF}
end;

procedure TsgFlatEntity.SetXY(Index: Integer; const Value: TFPoint);
begin

end;

function TsgFlatEntity.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if (Counts.Count > 0) or IsXMLHelp(AParams.Mode) then
    PoinsToXMLNode(ANode, AParams);
end;

{ TsgFlatPoly }

function TsgFlatPoly.Accepts(const AEntity: TsgDXFEntity): Boolean;
var
  P: TsgCADBasePolyline absolute AEntity;
begin
  Result := inherited Accepts(AEntity) and (AEntity is TsgCADBasePolyline) and
   (PCount + P.PolyPoints.Count < $4000);
  if Result and (PCount > 0) then
    Result := (FLineWeight = P.LineWeight);
end;

function TsgFlatPoly.GetEntType: TsgCADEntities;
begin
  Result := ceFlatPoly;
end;

{ TsgFlatHatch }

function TsgFlatHatch.Accepts(const AEntity: TsgDXFEntity): Boolean;
var
  P: TsgCADPolyPolygon absolute AEntity;
begin
  Result := inherited Accepts(AEntity) and (AEntity is TsgCADPolyPolygon) and
    (Counts.Count + P.Boundaries.Count <= 4096);
end;

function TsgFlatHatch.GroupFill(AConverter: TsgDXFConverter = nil): Boolean;
var
  I, J, K, vCount, vSubCount, vIndex: Integer;
  vHatch: TsgCADMPolygon;
  vBoundary: Tsg2DBoundaryList;
  procedure AddCurve(Boundary: Tsg2DBoundaryList; StartPoint, EntPoint: TF2DPoint);
  var
    vCurve: Tsg2DLine;
  begin
    vCurve := Tsg2DLine.Create;
    vCurve.SetStartPoint(StartPoint);
    vCurve.SetEndPoint(EntPoint);
    Boundary.Add(vCurve);
  end;
begin
  vIndex := 0;
  I := 0;
  while I < Counts.Count do
  begin
    vCount := Self.Counts[I];
    Inc(I);
    if vCount = 0 then Break;
    vHatch := TsgCADMPolygon.Create;
    for J := 0 to vCount - 1 do
    begin
      vBoundary := vHatch.AddBoundaryList(1);
      vSubCount := Self.Counts[I];
      Inc(I);
      for K := vIndex + 1 to (vIndex + vSubCount - 1) do
        AddCurve(vBoundary, MakeF2DPointFrom3D(Self.XY[K - 1]), MakeF2DPointFrom3D(Self.XY[K]));
      AddCurve(vBoundary, MakeF2DPointFrom3D(Self.XY[vIndex + vSubCount - 1]),       // To close
        MakeF2DPointFrom3D(Self.XY[vIndex]));
      Inc(vIndex, vSubCount);
    end;
    Inc(I);
    vHatch.AssignEntity(Self);
    vHatch.Extrusion := cnstZOrtAxis;
    vHatch.Elevation := cnstFPointZero;
    vHatch.HatchName := sSOLID;
    TsgCADMPolygon(vHatch).FillColor := ColorCAD;
    vHatch.SolidFill := True;
    vHatch.HatchStyle := hsSolid;
    vHatch.FillStyle := fsSolid;
    vHatch.Loaded(AConverter);
    Group.AddEntity(vHatch);
  end;
  Result := Group.Count > 0;
end;

procedure TsgFlatHatch.PoinsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams);
var
  vNodePoints, vNodeBoundaries: TsgNode;
  I, J, K, vCount, vIndex, vPointsCount, vAllPointsCount: Integer;
  vPoints: TsgBaseList;
  vPoint: TFPoint;
begin
  vPoints := TF2DPointList.Create;
  try
    I := 0;
    vIndex := 0;
    while I < Counts.Count do
    begin
      vCount := Counts[I];
      Inc(I);
      vNodeBoundaries := ANode.AddChildNV(cnstXMLNames[xmlBoundaries].Name);
      for J := 0 to vCount - 1 do
      begin
        vPoints.Count := 0;
        vPointsCount := Counts[I];
        Inc(I);
        for K := 0 to vPointsCount - 1do
        begin
          vPoint := XY[vIndex];
          Inc(vIndex);
          TF2DPointList(vPoints).Add(vPoint.Point2D);
        end;
        vNodePoints := vNodeBoundaries.AddChildNV(cnstXMLNames[xmlVertexes].Name);
        if vPoints.Count > 0 then
          vPoints.ToXML(vNodePoints, cnstXMLNames[xmlPoint].Name);
      end;
      vAllPointsCount := Counts[I];
      vNodeBoundaries.AddAttribNV(cnstXMLNames[xmlPointsCount].Name).ValueAsInt := vAllPointsCount;
      Inc(I);
    end;
  finally
    FreeAndNil(vPoints);
  end;
end;

function TsgFlatHatch.GetEntType: TsgCADEntities;
begin
  Result := ceFlatHatch;
end;

{ TsgDXFOle2Frame }

constructor TsgDXFOle2Frame.Create;
begin
  inherited Create;
  FTileModeDescriptor := 0; // Object resides in model space. On export header need xor 1
  FAspect := DVASPECT_CONTENT;
  FOLEObjectType := 2;
  FOLEBitmap := nil;
end;

procedure TsgDXFOle2Frame.AssignEntity(Source: TsgDXFEntity);
var
  vOle2Frame: TsgDXFOle2Frame absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFOle2Frame then
  begin
    FAspect := vOle2Frame.FAspect;
    FBinaryData := vOle2Frame.FBinaryData;
    DestroyOleObject;
    FOLEObjectType := vOle2Frame.FOLEObjectType;
    FPoint1 :=  vOle2Frame.FPoint1;
  end;
end;

procedure TsgDXFOle2Frame.DestroyOleObject;
{$IFDEF SG_HAS_ACTIVEX}
var
  vBindCtx: IBindCtx;
{$ENDIF}
begin
{$IFDEF SG_HAS_ACTIVEX}
  if (FStorage <> nil) and (CreateBindCtx(0, vBindCtx) = S_OK) then
    vBindCtx.RevokeObjectBound(FStorage);
{$ENDIF}
  FOleObject := nil;
  FStorage := nil;
  FMoniker := nil;
  FTID := 0;
  FreeAndNil(FOLEBitmap);
end;

function TsgDXFOle2Frame.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
var
  S: string;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result = cnstXML_UNSUPPORTED then
  begin
    Result := cnstXML_OK;
    case AType.Id of
      xmlSize: SetSize(ANode.ValueAsFPoint);
      xmlBinaryData:
        begin
          S := ANode.ValueAsStr;
          if S <> '' then
            if not LoadFromBase64(S, FBinaryData) then
              Result := cnstXML_ERROR;
        end
    else
      Result := cnstXML_UNSUPPORTED;
    end;
  end;
end;

function TsgDXFOle2Frame.GetBox: TFRect;
begin
  Result := cnstBadRect;
  ExpandFRect(Result, Point);
  ExpandFRect(Result, Point1);
end;

procedure TsgDXFOle2Frame.LoadedInternal(AConverter: TsgDXFConverter);
{$IFDEF SG_HAS_ACTIVEX}
const
  cnstUlOffset{$IFDEF SGFPC}: ULarge_Integer = (){$ELSE} = 0{$ENDIF};
{$ELSE}
const
   cnstOleIcoBmpSize = 200;
   cnstOleFontSize = 23;
   cnstOleStr = 'Ole Frame';
   cnstBMPSign: Word = $4D42;
{$ENDIF}
var
{$IFDEF SG_HAS_ACTIVEX}
  vMiscStatus: {$IFDEF SGFPC}DWORD{$ELSE}Integer{$ENDIF};
  vLockBytes: ILockBytes;
  vWrites: {$IFDEF SGFPC}LongWord{$ELSE}Longint{$ENDIF};
  vBindCtx: IBindCtx;
{$ELSE}
  vOLEFile: TPoifsFile;
  vStream: TMemoryStream;
  vBMPStream: TMemoryStream;
{$IFNDEF SG_FIREMONKEY}
  vTxtWidth, vTxtHeight: Integer;
{$ELSE}
  vRect: TRectF;
{$ENDIF}
{$ENDIF}
begin
  inherited LoadedInternal(AConverter);
  DestroyOleObject;
{$IFDEF SG_HAS_ACTIVEX}
  try
    if (Length(FBinaryData) > 0) and Succeeded(CreateILockBytesOnHGlobal(0, True, vLockBytes)) then
    try
      vLockBytes.WriteAt(cnstUlOffset, Pointer(FBinaryData), Length(FBinaryData), {$IFDEF SGFPC}vWrites{$ELSE}@vWrites{$ENDIF});
      if Succeeded(StgOpenStorageOnILockBytes(vLockBytes, nil, STGM_READWRITE or
        STGM_SHARE_EXCLUSIVE, nil, 0, FStorage)) then
      begin
        if CreateBindCtx(0, vBindCtx) = S_OK then
        begin
          vBindCtx.RegisterObjectBound(FStorage);
          CreatePointerMoniker(FStorage, FMoniker);
        end;
        if not Succeeded(OleLoad(FStorage, IOleObject, nil, FOleObject)) then
          DestroyOleObject
        else
        begin
          FTID := GetCurrentThreadId;
          if Succeeded(FOleObject.GetMiscStatus(FAspect, vMiscStatus)) then
            if vMiscStatus and OLEMISC_STATIC <> 0 then
              FOLEObjectType := 3
            else
              if vMiscStatus and OLEMISC_ISLINKOBJECT <> 0 then
              begin
                FOLEObjectType := 1;
                FOleObject.Update;
              end
              else
                FOLEObjectType := 2;
        end;
      end
      else
        DestroyOleObject;
    finally
      vLockBytes := nil;
    end;
  except
  end;
{$ELSE}
  vStream := TMemoryStream.Create;
  try
    vStream.Write(Pointer(@FBinaryData[1])^, Length(FBinaryData));
    vOLEFile := TPoifsFile.Create(vStream);
    try
      if vOLEFile.LoadFromStream then
      begin
        vBMPStream := TMemoryStream.Create;
        try
          if Aspect <> DVASPECT_ICON then
          begin
            vOLEFile.GetNodeStreamByFilter('\S*Ole10Native', '', vBMPStream);
            vBMPStream.Position := 0;
            if vBMPStream.Size <> 0 then
              vBMPStream.Seek(4, soCurrent)
            else
            begin
              vOLEFile.GetNodeStreamByFilter('\CONTENTS', '', vBMPStream);
              vBMPStream.Position := 0;
            end;
            if vBMPStream.Size = 0 then
              Exit;
            if PWord(PByte(vBMPStream.Memory) + vBMPStream.Position)^ <> cnstBMPSign then
              Exit;
            FOLEBitmap := TBitmap.Create;
            try
              FOLEBitmap.LoadFromStream(vBMPStream);
            except
              FreeAndNil(FOLEBitmap);
              Exit;
            end;
          end
          else
          begin
            FOLEBitmap := TBitmap.Create;
            {$IFNDEF SG_FIREMONKEY}
            FOLEBitmap.PixelFormat := {$IFDEF SGFPC}pf24bit{$ELSE}pf8bit{$ENDIF};
            {$ENDIF}
            FOLEBitmap.Width := cnstOleIcoBmpSize;
            FOLEBitmap.Height := cnstOleIcoBmpSize;
            {$IFNDEF SG_FIREMONKEY}
            FOLEBitmap.Canvas.Brush.Style := bsSolid;
            FOLEBitmap.Canvas.FillRect(Rect(0, 0, cnstOleIcoBmpSize, cnstOleIcoBmpSize));
            FOLEBitmap.Canvas.Font.Color := clBlack;
            FOLEBitmap.Canvas.Font.Size := cnstOleFontSize;
            vTxtWidth := FOLEBitmap.Canvas.TextWidth(cnstOleStr);
            vTxtHeight := FOLEBitmap.Canvas.TextHeight(cnstOleStr);
            FOLEBitmap.Canvas.TextOut(cnstOleIcoBmpSize div 2 - vTxtWidth div 2,
              cnstOleIcoBmpSize div 2 - vTxtHeight div 2, cnstOleStr);
            {$ELSE}
            vRect := TRectF.Create(1, 1, cnstOleIcoBmpSize, cnstOleIcoBmpSize);
            FOLEBitmap.Canvas.Clear(TAlphaColors.White);
            FOLEBitmap.Canvas.BeginScene;
            FOLEBitmap.Canvas.Fill.Color := TAlphaColors.Black;
            FOLEBitmap.Canvas.Font.Size := cnstOleFontSize;
            FOLEBitmap.Canvas.Fill.Kind := TBrushKind.Solid;
            FOLEBitmap.Canvas.FillText(vRect, cnstOleStr, False, 100, [TFillTextFlag.RightToLeft],
              TTextAlign.Center, TTextAlign.Center);
            FOLEBitmap.Canvas.EndScene;
            {$ENDIF}
          end;
        finally
          vBMPStream.Free;
        end;
      end;
    finally
      vOLEFile.Free;
    end;
  finally
    vStream.Free;
  end;
{$ENDIF}
end;

function TsgDXFOle2Frame.GetEntType: TsgCADEntities;
begin
  Result := ceOle2Frame;
end;

function TsgDXFOle2Frame.GetFileName: string;
{$IFDEF SG_HAS_ACTIVEX}
var
  vOleLink: IOleLink;
  vTmpFileName: PWideChar;
{$ENDIF}
begin
  Result := '';
{$IFDEF SG_HAS_ACTIVEX}
  if IsLink and (FOleObject.QueryInterface(IOleLink, vOleLink) = S_OK) then
  try
    if vOleLink.GetSourceDisplayName(vTmpFileName) = S_OK then
    try
      Result := WideCharToString(vTmpFileName);
    finally
      CoTaskMemFree(vTmpFileName);
    end;
  finally
    vOleLink := nil;
  end;
{$ENDIF}
end;

function TsgDXFOle2Frame.GetIsLink: Boolean;
{$IFDEF SG_HAS_ACTIVEX}
var
  vStatus: {$IFDEF SGFPC}DWORD{$ELSE}Integer{$ENDIF};
{$ENDIF}
begin
  Result := False;
{$IFDEF SG_HAS_ACTIVEX}
  if FOleObject <> nil then
    if FOleObject.GetMiscStatus(DVASPECT_CONTENT, vStatus) = S_OK then
      Result := vStatus and OLEMISC_ISLINKOBJECT <> 0;
{$ENDIF}
end;

function TsgDXFOle2Frame.GetPoint1: TFPoint;
begin
  Result := FPoint1;
end;

function TsgDXFOle2Frame.GetPosition: TFPoint;
begin
  Result := Point;
end;

function TsgDXFOle2Frame.GetSize: TFPoint;
begin
  Result := AbsFPoint(SubFPoint(Point1, Point));
end;

procedure TsgDXFOle2Frame.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
      AHideList.Add(Integer(xmlLineWeight));
    end;
  end;
end;

procedure TsgDXFOle2Frame.SetPoint1(const Value: TFPoint);
begin
  FPoint1 := Value;
end;

procedure TsgDXFOle2Frame.SetPosition(const APoint: TFPoint);
var
  vDelta: TFPoint;
begin
  vDelta := SubFPoint(APoint, Point);
  Point := APoint;
  Point1 := AddFPoint(Point1, vDelta);
end;

procedure TsgDXFOle2Frame.SetSize(const APoint: TFPoint);
var
  vOldSize, vNewSize: TFPoint;
begin
  vOldSize := SubFPoint(Point1, Point);
  vNewSize := MultiplyFPoint(AbsFPoint(APoint), SignFPoint(vOldSize));
  Point1 := AddFPoint(Point, vNewSize);
end;

function TsgDXFOle2Frame.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  S: string;
begin
  Result := Inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlSize].Name).ValueData,
    GetSize, xmlForViewing in AParams.Mode);
  if IsFullProps(AParams.Mode) then
    if GetBinaryDataAsBase64(FBinaryData, S) then
      ANode.AddAttribNV(cnstXMLNames[xmlBinaryData].Name).ValueAsStr := S;
end;

procedure TsgDXFOle2Frame.ClearReferences;
begin
  inherited ClearReferences;
  DestroyOleObject;
end;

procedure TsgDXFOle2Frame.ConvertOleToBitmap(AOleObject: {$IFDEF SG_HAS_ACTIVEX}IOleObject{$ELSE}IUnknown{$ENDIF};
  const AWidth, AHeight: Double; ADrawingRect: TRect; const ABitmap: TBitmap);
var
  vRect: TRect;
  vSize: TPoint;
  vRatio: Double;

  {$IFDEF SG_HAS_ACTIVEX}

{$IFDEF SG_DELPHI_VCL}
  procedure DoDrawOleToBitmap(const ARect: TRect);
  begin
    ABitmap.PixelFormat := pf24bit;
    ABitmap.Width := ARect.Right - ARect.Left;
    ABitmap.Height := ARect.Bottom - ARect.Top;
    ABitmap.Canvas.Brush.Style := bsSolid;
    ABitmap.Canvas.Brush.Color := clWindow;
    ABitmap.Canvas.FillRect(ARect);
    OleDraw(AOleObject, FAspect, ABitmap.Canvas.Handle, ARect);
  end;
{$ENDIF}

  {$IFDEF SG_HAS_WINAPI_INTERFACE}
  procedure DoDrawOleToDIB(const ARect: TRect);
  var
    vDIBBitmap: TsgDIBBitmap32;
  {$IFDEF SG_FIREMONKEY}
    I: Integer;
  {$ENDIF}
  begin
    vDIBBitmap := TsgDIBBitmap32.Create(ARect.Right - ARect.Left, ARect.Bottom - ARect.Top);
    try
      FillChar(vDIBBitmap.Map.Data^, vDIBBitmap.Map.Height * vDIBBitmap.Map.BytesPerScanline, $FF);// white
      OleDraw(AOleObject, FAspect, vDIBBitmap.BufferHandle, ARect);
  {$IFDEF SG_FIREMONKEY}
      for I := 0 to vDIBBitmap.Map.Height * vDIBBitmap.Map.Width - 1 do
        PByteArray(@PIntegerArray(vDIBBitmap.Map.Data)^[I])^[3] := 255;
  {$ENDIF}
      ABitmap.Assign(vDIBBitmap.Map);
    finally
      vDIBBitmap.Free;
    end;
  end;
  {$ENDIF}

  {$ENDIF}

begin
  if AOleObject = nil then AOleObject := FOleObject;
  if GetOleExtents(AOleObject,FAspect, vSize)
    and ((vSize.X* vSize.Y) < cnstMaxImgSizeSqrt) then
  begin
    vRect := Rect(0,0, vSize.X, vSize.Y);
  end
  else
  begin
    vRect := Rect(0, 0, ADrawingRect.Right - ADrawingRect.Left,
      ADrawingRect.Bottom - ADrawingRect.Top);
    if (AWidth * AHeight) > cnstMaxImgSizeSqrt then
    begin
      if AHeight > AWidth then
      begin
        vRatio := AWidth / AHeight;
        vRect := Rect(0, 0, Floor(cnstMaxImgSize * vRatio), cnstMaxImgSize);
      end
      else
      begin
        vRatio := AHeight / AWidth;
        vRect := Rect(0, 0, cnstMaxImgSize, Floor(cnstMaxImgSize * vRatio));
      end;
    end;
  end;
{$IFDEF SG_HAS_ACTIVEX}
{$IFDEF SG_DELPHI_VCL}
  DoDrawOleToBitmap(vRect);
{$ELSE}
{$IFDEF SG_HAS_WINAPI_INTERFACE}
  DoDrawOleToDIB(vRect);
{$ELSE}
  DoDrawOleToBitmap(vRect);
{$ENDIF}
{$ENDIF}
{$ELSE}
  if FOLEBitmap <> nil then
    ABitmap.Assign(FOLEBitmap);
{$ENDIF}
end;

{ TsgCADGradientPolygon }

constructor TsgCADGradientPolygon.Create;
begin
  inherited Create;
  FGradientColor[0] := MakeColorCAD(acRGBColor, ConvertRGBtoColor(0,0,255));
  FGradientColor[1] := MakeColorCAD(acRGBColor, ConvertRGBtoColor(255,255,255));
  FGradientUseCenter := True;
end;

procedure TsgCADGradientPolygon.AssignEntity(Source: TsgDXFEntity);
var
  vGradientPolygon:TsgCADGradientPolygon absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADGradientPolygon then
  begin
    FGradientColor := vGradientPolygon.FGradientColor;
    FType := vGradientPolygon.FType;
    FGradientAngle := vGradientPolygon.FGradientAngle;
    FGradientUseCenter := vGradientPolygon.FGradientUseCenter;
  end;
end;

function TsgCADGradientPolygon.GetEntType: TsgCADEntities;
begin
  Result := ceGradientPolygon;
end;

function TsgCADGradientPolygon.GetHatchName: string;
begin
  if FType = gtNone then
    Result := inherited GetHatchName
  else
    Result := 'GRADIENT';
end;

function TsgCADGradientPolygon.IsEmptykBox(const AConverter: TsgDXFConverter): Boolean;
begin
  Result := inherited IsEmptykBox(AConverter);
  if not Result then
    Result := GetBoxType(FBox, fDoubleResolution) in [bxEmpty, bxX, bxY, bxZ];
end;

function TsgCADGradientPolygon.GetGradientAngle: TsgFloat;
begin
  Result := FGradientAngle;
end;

function TsgCADGradientPolygon.GetGradientColor(const AIndex: Byte): TColor;
begin
  Result := ConvertColorCADToRGB(GetGradientColorCAD(AIndex));
end;

function TsgCADGradientPolygon.GetGradientColorCAD(const AIndex: Byte): TsgColorCAD;
begin
  case AIndex of
    0, 1: Result := FGradientColor[AIndex];
  else
    Result := MakeColorCAD(acIndexColor, clDXFBlackWhite);
  end;
end;

function TsgCADGradientPolygon.GetGradientName: string;
begin
  case FType of
    gtCurved:           Result := cnstGradientName[0];
    gtCylinder:         Result := cnstGradientName[1];
    gtHemiSpherical:    Result := cnstGradientName[2];
    gtLinear:           Result := cnstGradientName[3];
    gtSpherical:        Result := cnstGradientName[4];
    gtInvCurved:        Result := cnstGradientName[5];
    gtInvCylinder:      Result := cnstGradientName[6];
    gtInvHemiSpherical: Result := cnstGradientName[7];
    gtInvSpherical:     Result := cnstGradientName[8];
    gtOther:            Result := 'UNKNOWN';
  else


  end;
end;

procedure TsgCADGradientPolygon.SetGradientAngle(const Value: TsgFloat);
var
  vValue: Double;
begin
  if sgModAngle(Value, vValue) then
    FGradientAngle := vValue;
end;

procedure TsgCADGradientPolygon.SetGradientColorCAD(const AIndex: Byte;
  const Value: TsgColorCAD);
begin
  case AIndex of
    0, 1: FGradientColor[AIndex] := Value;
  //else
    // None
  end;
end;

procedure TsgCADGradientPolygon.SetGradientName(const AName: string);
var
  I, vLen: Integer;
  vName: string;
begin
  vLen := Length(AName);
  while (vLen > 0) and (AName[vLen] = #0) do
    Dec(vLen);
  if vLen > 0 then
  begin
    vName := UpperCase(Copy(AName, 1, vLen));
    I := 0;
    while (I < 9) and (vName <> cnstGradientName[I]) do
      Inc(I);
    case I of
      0: FType := gtCurved;
      1: FType := gtCylinder;
      2: FType := gtHemiSpherical;
      3: FType := gtLinear;
      4: FType := gtSpherical;
      5: FType := gtInvCurved;
      6: FType := gtInvCylinder;
      7: FType := gtInvHemiSpherical;
      8: FType := gtInvSpherical;
    else
      FType := gtOther;
    end;
  end
  else
    FType := gtNone;
end;

function TsgCADGradientPolygon.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if FType <> gtNone then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlGradientTypeName].Name).ValueAsStr := GradientName;
    ANode.AddAttribNV(cnstXMLNames[xmlGradientAngle].Name).ValueAsDouble := GradientAngle;
    ANode.AddAttribNV(cnstXMLNames[xmlGradientOneColor].Name).ValueData.ValueAsColorCAD := GradientColorCAD[0];
    ANode.AddAttribNV(cnstXMLNames[xmlGradientTwoColor].Name).ValueData.ValueAsColorCAD := GradientColorCAD[1];
    ANode.AddAttribNV(cnstXMLNames[xmlGradientUseCenter].Name).ValueAsBool := GradientUseCenter;
  end;
end;

function TsgCADGradientPolygon.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlGradientAngle: GradientAngle := ANode.ValueAsDouble;
    xmlGradientOneColor: GradientColorCAD[0] := ANode.ValueData.ValueAsColorCAD;
    xmlGradientTwoColor: GradientColorCAD[1] := ANode.ValueData.ValueAsColorCAD;
    xmlGradientTypeName: GradientName := ANode.ValueAsStr;
    xmlGradientUseCenter: GradientUseCenter := ANode.ValueAsBool;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_PLUGINSHOST}
function TsgCADGradientPolygon.ExportToPluginsInternal(ANode: IsgNodeFrame): Integer;
begin
  Result := inherited ExportToPluginsInternal(ANode);
  ANode.ChildValues[sPlcKeyWords[plcGradientAngle].Name] := GradientAngle;
  ANode.ChildValues[sPlcKeyWords[plcGradientColor1].Name] := GradientColor[0];
  ANode.ChildValues[sPlcKeyWords[plcGradientColor2].Name] := GradientColor[1];
  ANode.ChildValues[sPlcKeyWords[plcGradientName].Name] := GradientName;
  ANode.ChildValues[sPlcKeyWords[plcGradientUseCenter].Name] := GradientUseCenter;
end;
{$ENDIF}

{ TsgDXFObjectEntity }

constructor TsgDXFObjectEntity.Create;
begin
  inherited Create;
  if FLinkID = nil then FLinkID := GetLinkClass.Create(Self);
  FLayerItem := TsgTableItem.Create;
  FMaterialItem := TsgTableItem.Create;
  LineCap := PS_ENDCAP_ROUND;
  LineJoin := PS_JOIN_ROUND;
  FGroup := nil;
end;

procedure TsgDXFObjectEntity.GroupClear;
begin
  if not GroupExists then Exit;
  if Assigned(Group) then
  begin
    if GroupHasAddedEntities then
      Group.Clear
    else
      Group.FEntities.Clear;
  end;
  Group.Free;
  FGroup := nil;
end;

function TsgDXFObjectEntity.CanHaveHandle: Boolean;
begin
  Result := True;
end;

function TsgDXFObjectEntity.GetAnnotative: Boolean;
begin
  Result := FAnnotative;
end;

procedure TsgDXFObjectEntity.SetAnnotative(AValue: Boolean);
begin
  FAnnotative := AValue;
end;

procedure TsgDXFObjectEntity.ClearReferences;
begin
  inherited ClearReferences;
  FLayerItem.Item := nil;
  FMaterialItem.Item := nil;
end;

procedure TsgDXFObjectEntity.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FLayerItem);
  FreeAndNil(FMaterialItem);
  FreeAndNil(FLinkID);
end;

function TsgDXFObjectEntity.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlLayerName:
      begin
        if Assigned(Converter) then
          Layer := Converter.GetLayerByNode(ANode);
        if not Assigned(Layer) then
        begin
          DoErrorXMLNode(AResult.Errors, False, ANode, xmlLayerName);
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFObjectEntity.GroupCreate(AConverter: TsgDXFConverter = nil): Boolean;
begin
  Result := GroupExists;
  if not Result then
    Exit
  else
  begin
    GroupClear;
    FGroup := TsgDXFGroup.Create;
    // do not ent.SetOwner(FGroup)
    FGroup.FEntities.OnNotify := nil;
    Result := GroupFill(AConverter);
  end;
end;

function TsgDXFObjectEntity.GroupFill(AConverter: TsgDXFConverter): Boolean;
var
  I: Integer;
  vEntity: TsgDXFEntity;
begin
  if Assigned(Group) then
  begin
    if Group.Count = 0 then
    begin
      for I := 0 to Count - 1 do
      begin
        vEntity := Self[I];
        if (vEntity.EntType <> ceEntity) and//skip internal entity in export
          ((vEntity.Handle <> cnstBadHandle) or (not vEntity.CanHaveHandle)) then
          Group.AddEntity(vEntity);
      end;
      Result := Group.Count > 0;
    end
    else
      Result := True;
  end
  else
    Result := False;
end;

procedure TsgDXFObjectEntity.AssignEntity(Source: TsgDXFEntity);
var
  vObjectEntity: TsgDXFObjectEntity absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFObjectEntity then
  begin
    FInternalFlags := vObjectEntity.InternalFlags;
    Layer := vObjectEntity.Layer; // use ptoperty for calc layer refcount
    FFlag := vObjectEntity.FFlag;
    FPenStyle := vObjectEntity.FPenStyle;
{$IFDEF SG_USEDXFSRC}
    FSrcEnd := vObjectEntity.FSrcEnd;
    FSrcStart := vObjectEntity.FSrcStart;
{$ENDIF}
    FMaterialItem.Item := vObjectEntity.FMaterialItem.Item;
  end;
end;

function TsgDXFObjectEntity.GetVisibility: Boolean;
begin
  Result := (FFlag and 128) = 0;
end;

procedure TsgDXFObjectEntity.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AChangeList) then
    begin
      AChangeList.Add(Integer(xmlLayerName));
    end;
  end;
end;

procedure TsgDXFObjectEntity.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
  SetConverter(AConverter);
  if not Assigned(Layer) then
    Layer := TsgDXFLayer(AConverter.Sections[csLayers].FindEntByName('0'));
end;

procedure TsgDXFObjectEntity.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFObjectEntity.SetVisibility(const Value: Boolean);
begin
  FFlag := (FFlag and 127) or (Byte(not Value) shl 7);
end;

function TsgDXFObjectEntity.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vName: string;
  vConv: TsgDXFConverter;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddAttribNV(cnstXMLNames[xmlLayerName].Name)
  else
    if Assigned(Layer) and (IsFullProps(AParams.Mode) or (Layer.NameID <> slrnZero)) then
    begin
      vName := Layer.Name;
      if xmFullXRefNames in AParams.Mode then
      begin
        vConv := Layer.Converter;
        while Assigned(vConv.FContainerXref) do
        begin
          vName := vConv.FContainerXref.Owner.Name + cnstXRefNameDelimiter + vName;
          vConv := vConv.FOwnerConverter;
        end;
      end;
      ANode.AddAttribNV(cnstXMLNames[xmlLayerName].Name).ValueAsStr := vName;
    end;
end;

procedure TsgDXFObjectEntity.UpdateBox;
begin
end;

function TsgDXFObjectEntity.GetLayer: TsgDXFLayer;
begin
  Result := TsgDXFLayer(FLayerItem.Item);
end;

procedure TsgDXFObjectEntity.SetLayer(const Value: TsgDXFLayer);
begin
  FLayerItem.Item := Value;
end;

function TsgDXFObjectEntity.GetConverter: TsgDXFConverter;
begin
  if Assigned(FConverter) then
    Result := FConverter
  else
    Result := inherited GetConverter;
end;

function TsgDXFObjectEntity.GetFlags: Integer;
begin
  Result := FFlag;
end;

function TsgDXFObjectEntity.GroupGet: TsgDXFGroup;
begin
  Result := FGroup;
end;

function TsgDXFObjectEntity.GetHandle: UInt64;
begin
  Result := FLinkID.Handle;
end;

function TsgDXFObjectEntity.GetInternalFlags: Word;
begin
  Result := FInternalFlags;
end;

procedure TsgDXFObjectEntity.SetConverter(const AConverter: TsgDXFConverter);
begin
  if FConverter <> AConverter then
  begin
    if Assigned(FConverter) then
    begin
{$IFDEF CONV_REFCOUNT}
      Dec(FConverter.FRefCount);
      FConverter.FRefEnts.Remove(Self);
{$ENDIF}
      FConverter.RemoveFromEntitiesWithGeneratedHandles(Self);
    end;
    FConverter := AConverter;
    if Assigned(FConverter) then
    begin
{$IFDEF CONV_REFCOUNT}
      Inc(FConverter.FRefCount);
      FConverter.FRefEnts.Add(Self);
{$ENDIF}
      if CanHaveHandle and (FLinkID.Handle = cnstBadHandle) then
        FConverter.AddEntitiesWithGeneratedHandles(Self);
    end;
  end;
end;

procedure TsgDXFObjectEntity.SetFlags(const Value: Integer);
begin
  FFlag := Value;
end;

procedure TsgDXFObjectEntity.SetHandle(const Value: UInt64);
begin
{$IFDEF SG_MODULE_LOG}
  inherited SetHandle(Value);
{$ENDIF}
//  if FHandle <> Value then
//  begin
//    if GetOwner() <> nil then
//      GetOwner().DeleteHandleItem(Self);
    FLinkID.Handle := Value;
//    if GetOwner() <> nil then
//      GetOwner().AddHandleItem(Self);
//  end;
end;

procedure TsgDXFObjectEntity.SetInternalFlags(const Value: Word);
begin
  FInternalFlags := Value;
end;

function TsgDXFObjectEntity.GetLineCap: Word;
begin
  Result := FPenStyle and PS_ENDCAP_MASK;
end;

function TsgDXFObjectEntity.GetLineJoin: Word;
begin
  Result := FPenStyle and PS_JOIN_MASK;
end;

function TsgDXFObjectEntity.GetLineWeightScaled: Boolean;
begin
  Result := (FFlag and 16) <> 0;
end;

function TsgDXFObjectEntity.GetMaterial: TsgDXFMaterial;
begin
  Result := TsgDXFMaterial(FMaterialItem.Item);
end;

procedure TsgDXFObjectEntity.SetLineCap(const Value: Word);
begin
  FPenStyle := (FPenStyle and (not PS_ENDCAP_MASK)) or (Value and PS_ENDCAP_MASK);
end;

procedure TsgDXFObjectEntity.SetLineJoin(const Value: Word);
begin
  FPenStyle := (FPenStyle and (not PS_JOIN_MASK)) or (Value and PS_JOIN_MASK);
end;

procedure TsgDXFObjectEntity.SetLineWeightScaled(Value: Boolean);
begin
  FFlag := (FFlag and 239) or (Integer(Value) shl 4);
end;

procedure TsgDXFObjectEntity.SetMaterial(const Value: TsgDXFMaterial);
begin
  FMaterialItem.Item := Value;
end;

procedure TsgDXFObjectEntity.SetOwner(const Value: TsgDXFEntity);
var
  vConv: TsgDXFConverter;
begin
  if Assigned(Value) then
    vConv := Value.Converter
  else
    vConv := nil;
  inherited SetOwner(Value);
  SetConverter(vConv);
end;

{$IFDEF SG_USEDXFSRC}
function TsgDXFObjectEntity.GetSrcEnd: PAnsiChar;
begin
  Result := FSrcEnd;
end;

function TsgDXFObjectEntity.GetSrcStart: PAnsiChar;
begin
  Result := FSrcStart;
end;

procedure TsgDXFObjectEntity.SetSrcEnd(const Value: PAnsiChar);
begin
  FSrcEnd := Value;
end;

procedure TsgDXFObjectEntity.SetSrcStart(const Value: PAnsiChar);
begin
  FSrcStart := Value;
end;
{$ENDIF}


  {  TsgDXFObjectEntityColor  }

function TsgDXFObjectEntityColor.GetColorCAD: TsgColorCAD;
begin
  Result := FColor;
end;

function TsgDXFObjectEntityColor.GetHLink;
begin
  Result := FHyperLink;
end;

procedure TsgDXFObjectEntityColor.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AChangeList) then
    begin
      AChangeList.Add(Integer(xmlColor));
    end;
  end;
end;

procedure TsgDXFObjectEntityColor.SetColorCAD(const Value: TsgColorCAD);
begin
  FColor := Value;
end;

procedure TsgDXFObjectEntityColor.SetHLink(const AValue: string);
begin
  FHyperLink := AValue;
end;

function TsgDXFObjectEntityColor.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vHyperLink: string;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsFullPropsOrXMLHelp(AParams.Mode) or (not IsEqualColorCAD(FColor, cnstColorCADByLayer)) then
    ANode.AddAttribNV(cnstXMLNames[xmlColor].Name).ValueData.ValueAsColorCAD := FColor;
  vHyperLink := HyperLink;
  if IsFullPropsOrXMLHelp(AParams.Mode) or (vHyperLink <> '') then
    ANode.AddAttribNV(cnstXMLNames[xmlHyperLink].Name).ValueData.ValueAsStr := vHyperLink;
end;

constructor TsgDXFObjectEntityColor.Create;
begin
  inherited Create;
  FColor := cnstDefHeadVarStruct.CEColor;
end;

function TsgDXFObjectEntityColor.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlColor: FColor := ANode.ValueData.ValueAsColorCAD;
    xmlHyperLink: HyperLink := ANode.ValueData.ValueAsStr;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure TsgDXFObjectEntityColor.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFObjectEntityColor then
    FColor := TsgDXFObjectEntityColor(Source).FColor;
end;


{TsgSVGInsert}

procedure TsgSVGInsert.AssignEntity(Source: TsgDXFEntity);
var
  vInsert: TsgSVGInsert absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgSVGInsert then
  begin
    if FPrevMatrix <> nil then
    begin
      Dispose(FPrevMatrix);
      FPrevMatrix := nil;
    end;
    if vInsert.FPrevMatrix <> nil then
    begin
      New(FPrevMatrix);
      FPrevMatrix^ := vInsert.FPrevMatrix^;
    end;
  end;
end;

procedure TsgSVGInsert.FreeReferences;
begin
  inherited FreeReferences;
  DisposeAndNil(FPrevMatrix);
end;

function TsgSVGInsert.GetInitMatrix: TFMatrix;
begin
  if FPrevMatrix <> nil then
    Result := FPrevMatrix^
  else
    Result := cnstIdentityMat;
end;

procedure TsgSVGInsert.InitializeMatrix;
begin
  FMatrix := GetInitMatrix;
end;

procedure TsgSVGInsert.SetInitMatrix(const AMatrix: TFMatrix);
begin
  if not CompareMem(@AMatrix, @cnstIdentityMat, SizeOf(AMatrix)) then
  begin
    if FPrevMatrix = nil then
      New(FPrevMatrix);
    FPrevMatrix^ := AMatrix;
  end;
end;

  {TsgSVGMText}

procedure TsgSVGMText.CopyItems(const ASource: TsgDXFEntity);
var
  vBlockName: string;
  vMText: TsgSVGMText absolute ASource;
  vSrc, vDst: TsgDXFEntity;
  I: Integer;
begin
  inherited CopyItems(ASource);
  if (ASource is TsgSVGMText) and (vMText.Block <> nil) then
  begin
    vBlockName := Block.Name;
    Block.Clear;
    Block.AssignEntity(vMText.Block);
    Block.Name := vBlockName;
    for I := 0 to vMText.Block.Count - 1 do
    begin
      vSrc := vMText.Block[I];
      vDst := TsgDXFEntityClass(vSrc.ClassType).Create;
      vDst.AssignEntity(vSrc);
      Block.AddEntity(vDst);
    end;
    DelayedLoadAttribs := Block.Count > 0;
  end;
end;

constructor TsgSVGMText.Create;
begin
  inherited Create;
  Block := TsgDXFBlock.Create;
  Block.Name := 'SVGMText_' + IntToHex(TsgNativeUInt(Block), 0);
  Point := cnstFPointZero;
end;

procedure TsgSVGMText.DoDelayedLoad(AConverter: TsgDXFConverter);
var
  I: Integer;
begin
  for I := 0 to Block.Count - 1 do
    AConverter.Loads(Block.Entities[I]);
end;

procedure TsgSVGMText.ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord);
begin
  // do nothing, SVGMText must use only self created block
end;

{ TsgDXFTolerance }

procedure TsgDXFTolerance.AssignEntity(Source: TsgDXFEntity);
var
  vTolerance: TsgDXFTolerance absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFTolerance then
  begin
    FDimlineColor := vTolerance.FDimlineColor;
    FDimStyleItem.Item := vTolerance.FDimStyleItem.Item;
    if vTolerance.FGAP = nil then
      DisposeAndNil(FGAP)
    else
    begin
      if FGAP = nil then
        New(FGAP);
      FGAP^ := vTolerance.FGAP^;
    end;
    if vTolerance.FDimScaleOverall = nil then
      DisposeAndNil(FDimScaleOverall)
    else
      SetDimScaleOverall(vTolerance.FDimScaleOverall^);
  end;
end;

function TsgDXFTolerance.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = sACADXDataAppName then
  begin
    AData.AddString(String_1001, sACADXDataAppName);
    AData.AddString(String_1000, cnstDStyle);
    AData.AddString(String_1002, '{');
    Result := True;
  end;
end;

procedure TsgDXFTolerance.ClearReferences;
begin
  inherited ClearReferences;
  FDimStyleItem.Item := nil;
end;

constructor TsgDXFTolerance.Create;
begin
  inherited Create;
  FDimlineColor := cnstDefaultEntityColor;// clByBlock;
  FDimStyleItem := TsgTableItem.Create;
end;

destructor TsgDXFTolerance.Destroy;
begin
  DisposeAndNil(FDimScaleOverall);
  DisposeAndNil(FGAP);
  inherited Destroy;
end;

procedure TsgDXFTolerance.EndExtData(const AData: TsgCADExtendedData);
begin
  AData.AddString(String_1002, '}');
end;

function TsgDXFTolerance.GetBlockOffset: TFPoint;
var
  vScaleTemp: Double;
begin
  Result := inherited GetBlockOffset;//Result := Block.Offset;
  vScaleTemp := GetDimScaleAct;
  Result.Y := Result.Y - FHeight * vScaleTemp;// DimStyle.Scale * DimScaleOverall;
end;

function TsgDXFTolerance.GetDimlineColor: TsgColorCAD;
begin
  Result := FDimlineColor;
end;

function TsgDXFTolerance.GetDimScaleAct: Double;
begin
  Result := DimStyle.Scale;
  if FDimScaleOverall <> nil then
    Result := FDimScaleOverall^;
  if Result = 0 then
    Result := 1;
end;

function TsgDXFTolerance.GetDimScaleOverall: Single;
begin
  if FDimScaleOverall <> nil then
    Result := FDimScaleOverall^
  else
    Result := 1;
end;

function TsgDXFTolerance.GetDimStyle: TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(FDimStyleItem.Item);
end;

function TsgDXFTolerance.GetEntType: TsgCADEntities;
begin
  Result := ceTolerance;
end;

function TsgDXFTolerance.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  if BeginExtData(AData, AAppID) then
  begin
    AData.AddInt16(Integer_1070, 176);
    AData.AddInt16(Integer_1070, ConvertColorCADToIndexColor(DimlineColor, False));
    if Assigned(Style) and (Style.Handle > 0) then
    begin
      AData.AddInt16(Integer_1070, 340);
      AData.AddInt64(String_1005, Style.Handle);
    end;
    AData.AddInt16(Integer_1070, 40);
    AData.AddDouble(Float_1040, DimScaleOverall);
    AData.AddInt16(Integer_1070, 140);
    AData.AddDouble(Float_1040, Height);
    EndExtData(AData);
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

procedure TsgDXFTolerance.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlRectWidth));
    end;
  end;
end;

function TsgDXFTolerance.GetDimGap: Double;
begin
  if FGAP = nil then
  begin
    if DimStyle <> nil then
      Result := DimStyle.TextOffset
    else
      Result := 0;
  end
  else
    Result := FGAP^;
end;

procedure TsgDXFTolerance.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFTolerance.LoadedInternal(AConverter: TsgDXFConverter);
var
  vScale: TFPoint;
begin
  if DimStyle = nil then
    DimStyle := AConverter.DimensionStyleByName(sStandardName);
  if Style = nil then
    Style := DimStyle.TextStyle;
  if Style = nil then
    Style := AConverter.StyleByName(sStandardName);
  if FHeight = 0 then
    FHeight := DimStyle.TextHeight;
  vScale := Scale;
  try
    Scale := PtXScalar(vScale, GetDimScaleAct);
    inherited LoadedInternal(AConverter);
  finally
    Scale := vScale;
  end;
end;

function TsgDXFTolerance.Parsing(const AConverter: TsgDXFConverter; AList: TsgEntitiesList;
  const AColor: TsgColorCAD; ASize: Double; const AAlign: Byte): Boolean;
var
  I: Integer;
{$IFNDEF SG_USEDWGVERSION}
  vVersion: Byte;
{$ENDIF}
begin
  if AList = nil then
  begin
    AList := TsgEntitiesList.Create;
{$IFNDEF SG_USEDWGVERSION}
    vVersion := AConverter.HeadVarStruct.Version;
    try
      if AConverter.HeadVarStruct.Version = Byte(acR14) then
        AConverter.FHeadVarStruct.Version := Byte(acR2000);
{$ELSE}
    try
      if (AConverter <> nil) and (AConverter.HeadVarStruct.Version = Ord(acR14)) then
        Result := inherited Parsing(AConverter, AList, DimlineColor, GAP)
      else
{$ENDIF}
        Result := inherited Parsing(AConverter, AList, DimlineColor, Height * 2, 0);
      for I := 0 to AList.Count - 1 do
        Block.AddEntity(AList[I]);
    finally
{$IFNDEF SG_USEDWGVERSION}
      AConverter.FHeadVarStruct.Version := vVersion;
{$ENDIF}
      AList.Free;
    end;
  end
  else
    Result := inherited Parsing(AConverter, AList, AColor, ASize, 0);
end;

procedure TsgDXFTolerance.SetDimlineColor(const Value: TsgColorCAD);
begin
  FDimlineColor := Value;
end;

procedure TsgDXFTolerance.SetDimScaleOverall(const Value: Single);
begin
  if FDimScaleOverall = nil then
    New(FDimScaleOverall);
  FDimScaleOverall^ := Value;
end;

procedure TsgDXFTolerance.SetDimStyle(const Value: TsgDXFDimensionStyle);
begin
  FDimStyleItem.Item := Value;
end;

procedure TsgDXFTolerance.SetDimGap(const Value: Double);
begin
  if Abs(Value) > fAccuracy then
  begin
    if FGAP = nil then
      New(FGAP);
    FGAP^ := Value;
  end
  else
  begin
    if FGAP <> nil then
    begin
      Dispose(FGAP);
      FGAP := nil;
    end;
  end;
end;

function TsgDXFTolerance.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsXMLHelp(AParams.Mode) then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlDimStyle].Name);
  end
  else
  begin
    if Assigned(Style) then
      ANode.AddAttribNV(cnstXMLNames[xmlDimStyle].Name).ValueAsStr := DimStyle.Name;
  end;
  if IsFullPropsOrXMLHelp(AParams.Mode) or (not IsEqualColorCAD(DimlineColor, cnstColorCADByBlock)) then
    ANode.AddAttribNV(cnstXMLNames[xmlDimClrD].Name).ValueData.ValueAsColorCAD := DimlineColor;
  if FDimScaleOverall <> nil then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlDimScaleOverall].Name).ValueData,
      FDimScaleOverall^, xmlForViewing in AParams.Mode);
  if FGAP <> nil then
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlDimGap].Name).ValueData,
      FGAP^, xmlForViewing in AParams.Mode);
end;

procedure TsgDXFTolerance.FreeReferences;
begin
  inherited FreeReferences;
  DisposeAndNil(FGAP);
  FreeAndNil(FDimStyleItem);
end;

function TsgDXFTolerance.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vStyle: TsgDXFDimensionStyle;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if (not Assigned(DimStyle)) and Assigned(Converter) then
    DimStyle := Converter.DimensionStyleByName(Converter.HeadVarStruct.DimStyle);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlDimStyle:
      begin
        if Assigned(Converter) then
        begin
          vStyle := Converter.GetDimStyleFromNode(ANode);
          if Assigned(vStyle) then
          begin
            DimStyle := vStyle;
            DimlineColor := DimStyle.DIMCLRD;
          end;
        end;
      end;
    xmlDimScaleOverall: SetDimScaleOverall(ANode.ValueAsDouble);
    xmlDimGap:          SetDimGap(ANode.ValueAsDouble);
    xmlDimClrD:         DimlineColor := ANode.ValueData.ValueAsColorCAD;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{$IFDEF SG_BTI}
{ TsgDXFPolyPolyLine }

procedure TsgCADPolyPolyline2D.AddLine(const Value: TsgLine; const AFlags: TsgCurveProperties);
begin
  AddCoords(Value.Point1.X, Value.Point1.Y, Value.Point2.X, Value.Point2.Y, AFlags);
end;

procedure TsgCADPolyPolyline2D.AddPoints(const AP1, AP2: TFPoint; const AFlags: TsgCurveProperties);
begin
  AddCoords(AP1.X, AP1.Y, AP2.X, AP2.Y, AFlags);
end;

procedure TsgCADPolyPolyline2D.AddArc(const Arc: TsgArcR; const AFlags: TsgCurveProperties);
begin
  AddArcCoords(Arc.Center.X, Arc.Center.Y, Arc.Radius, Arc.AngleS, Arc.AngleE, AFlags);
end;

procedure TsgCADPolyPolyline2D.AddArcCoords(const X, Y, R, A1, A2: Double; const AFlags: TsgCurveProperties);
var
  vCurve: PF2DCurveEx;
begin
  New(vCurve);
  FCurves.Add(vCurve);
  vCurve^.Flags := AFlags + [lpArc];
  vCurve^.Arc.Center.X := X;
  vCurve^.Arc.Center.Y := Y;
  vCurve^.Arc.Center.Z := 0;
  vCurve^.Arc.Radius := R;
  vCurve^.Arc.AngleS := A1;
  vCurve^.Arc.AngleE := A2;
end;

procedure TsgCADPolyPolyline2D.AddArcPoints(const AP: TFPoint; const R, A1, A2: Double; const AFlags: TsgCurveProperties);
begin
  AddArcCoords(AP.X, AP.Y, R, A1, A2, AFlags);
end;

procedure TsgCADPolyPolyline2D.AddCoords(const X1, Y1, X2, Y2: Double; const AFlags: TsgCurveProperties);
var
  vCurve: PF2DCurveEx;
begin
  New(vCurve);
  FCurves.Add(vCurve);
  vCurve^.Flags := AFlags - [lpArc];
  vCurve^.Line.Point1.X := X1;
  vCurve^.Line.Point1.Y := Y1;
  vCurve^.Line.Point2.X := X2;
  vCurve^.Line.Point2.Y := Y2;
end;

procedure TsgCADPolyPolyline2D.AssignEntity(Source: TsgDXFEntity);
var
  vPolyPolyLine: TsgCADPolyPolyline2D absolute Source;
  I: Integer;
  vCurve: PF2DCurveEx;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADPolyPolyline2D then
  begin
    ClearBox;
    ClearBoundary;
    if FCurves.Count > vPolyPolyLine.FCurves.Count then
    begin
      for I := FCurves.Count - vPolyPolyLine.FCurves.Count downto 0 do
        Dispose(FCurves.List[I]);
      FCurves.Count := vPolyPolyLine.FCurves.Count;
    end
    else
    begin
      while FCurves.Count < vPolyPolyLine.FCurves.Count do
      begin
        New(vCurve);
        FCurves.Add(vCurve);
      end;
    end;
    for I := FCurves.Count - 1 downto 0 do
      PF2DCurveEx(FCurves.List[I])^ := PF2DCurveEx(vPolyPolyLine.FCurves.List[I])^;
    if Assigned(vPolyPolyLine.Boundaries) then
    begin
      for I := 0 to vPolyPolyLine.Boundaries.Count - 1 do
      begin
        FBoundaries.Add(TF2DPointList.Create);
        TF2DPointList(FBoundaries.Last).Assign(TF2DPointList(vPolyPolyLine.Boundaries[I]));
      end;
    end;
  end;
end;

procedure TsgCADPolyPolyline2D.Clear(const ADoFree: Boolean = True);
begin
  ClearBox;
  ClearBoundary;
  ClearRecordList(FCurves, False);
  FCurves.Count := 0;
end;

procedure TsgCADPolyPolyline2D.ClearBoundary;
begin
  TsgObjectList.ClearList(FBoundaries);
end;

procedure TsgCADPolyPolyline2D.ClearBox;
begin
  if FBox <> nil then
  begin
    Dispose(FBox);
    FBox := nil;
  end;
end;

constructor TsgCADPolyPolyline2D.Create;
begin
  inherited Create;
  FCurves := TList.Create;
  FBoundaries := TsgObjectList.Create;
  FLineWeight := fLineWeightByBlock;
end;

procedure TsgCADPolyPolyline2D.DeleteCurve(const AIndex: Integer);
var
  vCurve: PF2DCurveEx;
begin
  vCurve := FCurves.List[Aindex];
  FCurves.Delete(AIndex);
  Dispose(vCurve);
end;

procedure TsgCADPolyPolyline2D.ClearReferences;
begin
  inherited ClearReferences;
  ClearRecordList(FCurves);
  ClearBoundary;
  if Assigned(FDotSingPts) then
    FDotSingPts.Clear;
end;

procedure TsgCADPolyPolyline2D.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FCurves);
  TsgObjectList.FreeList(FBoundaries);
  FreeAndNil(FDotSingPts);
end;

procedure TsgCADPolyPolyline2D.GetBoundary(const AList: TList);

  procedure AddPoint(const ACL: TList; const AP: PF2DPoint);
  var
    P: PFPoint;
  begin
    New(P);
    ACL.Add(P);
    P^.X := AP^.X;
    P^.Y := AP^.Y;
    P^.Z := 0;
  end;

  procedure InsertPoint(const ACL: TList; const AIndex: Integer; const AP: PF2DPoint);
  var
    P: PFPoint;
  begin
    New(P);
    ACL.Insert(AIndex, P);
    P^.X := AP^.X;
    P^.Y := AP^.Y;
    P^.Z := 0;
  end;

  function LinesFind(const ACL: TList; const AP: PF2DPoint; var AIndex: Integer; var APt: TF2DPoint): Boolean;
  var
    I, Cnt: Integer;
    L: PF2DCurveEx;
  begin
    Result := False;
    Cnt := ACL.Count - 1;
    for I := 0 to Cnt do
    begin
      L := ACL.List[I];
      if lpArc in L^.Flags then
      begin
      end
      else
      begin
        if IsEqualF2DPoints(AP^, L^.Line.Point1) then
        begin
          AIndex := I;
          APt :=  L^.Line.Point2;
          Result := True;
          Break;
        end
        else
          if IsEqualF2DPoints(AP^, L^.Line.Point2) then
          begin
            AIndex := I;
            APt :=  L^.Line.Point1;
            Result := True;
            Break;
          end;
      end;
    end;
  end;

  function GetVector(const AP1, AP2: PFPoint): TFPoint;
  begin
    Result.X := AP2^.X - AP1^.X;
    Result.Y := AP2^.Y - AP1^.Y;
    Result.Z := 0;
  end;

  function GetDistancePoly(const AList: TList): Double;
  begin
    Result := 0;
    if AList.Count > 0 then
      Result := DistanceFPoint2D(PFPoint(AList.List[0])^, PFPoint(AList.List[AList.Count - 1])^);
  end;

var
  vLines, vList, vPolylines: TList;
  vLine: PF2DCurveEx;
  vPt, vPtNew: TF2DPoint;
  vIndex: Integer;
  P: PFPoint;
  VB, V1, V2: TFPoint;
  L1, L2, L3: Double;

  procedure CreatePolyBy2Lists;
  var
    J, I: Integer;
    vAngle1, vAngle2: Double;
    vListEx1, vListEx2: TList;
  begin
    vListEx1 := TList(vPolylines.List[0]);
    vListEx2 := TList(vPolylines.List[1]);
    AList.Capacity := vListEx1.Count + vListEx2.Count + 1;
    AList.Count := vListEx1.Count + vListEx2.Count;
    CopyMemory(AList.List, @vListEx1.List[0], vListEx1.Count * SizeOf(Pointer));
    VB := GetVector(vListEx1.List[vListEx1.Count - 1], vListEx1.List[vListEx1.Count - 2]);
    V1 := GetVector(vListEx2.List[0], vListEx2.List[1]);
    V2 := GetVector(vListEx2.List[vListEx2.Count - 1], vListEx2.List[vListEx2.Count - 2]);
    vAngle1 := GetAngleOfVectors(VB, V1, True);
    vAngle2 := GetAngleOfVectors(VB, V2, True);
    if IsEqual(vAngle1,vAngle2) then
    begin
      P := vListEx1.List[vListEx1.Count - 1];
      if DistanceFPoint(PFPoint(vListEx2.List[0])^, P^) < DistanceFPoint(PFPoint(vListEx2.List[vListEx2.Count - 1])^, P^) then
        CopyMemory(@AList.List[vListEx1.Count], @vListEx2.List[0], vListEx2.Count * SizeOf(Pointer))
      else
      begin
        J := vListEx1.Count;
        for I := vListEx2.Count - 1 downto 0 do
        begin
          AList.List[J] := vListEx2.List[I];
          Inc(J);
        end;
      end;
    end
    else
    begin
      if vAngle1 < vAngle2 then
        CopyMemory(@AList.List[vListEx1.Count], @vListEx2.List[0], vListEx2.Count * SizeOf(Pointer))
      else
      begin
        J := vListEx1.Count;
        for I := vListEx2.Count - 1 downto 0 do
        begin
          AList.List[J] := vListEx2.List[I];
          Inc(J);
        end;
      end;
    end;
  end;

begin
  if FCurves.Count < 1 then Exit;
  vLines := TList.Create;
  try
    vLines.Capacity := FCurves.Count;
    vLines.Count := FCurves.Count;
    CopyMemory(vLines.List, @FCurves.List[0], FCurves.Count * SizeOf(Pointer));
    vPolylines := TList.Create;
    try
      repeat
        vList := TList.Create;
        vPolylines.Add(vList);
        vList.Capacity := FCurves.Count;
        vLine := vLines.List[0];
        if lpArc in vLine^.Flags then
        begin

        end
        else
        begin
          AddPoint(vList, @vLine^.Line.Point1);
          AddPoint(vList, @vLine^.Line.Point2);
          vLines.Delete(0);
          vPt := vLine^.Line.Point2;
          while LinesFind(vLines, @vPt, vIndex, vPtNew) do
          begin
            vPt := vPtNew;
            AddPoint(vList, @vPt);
            vLines.Delete(vIndex);
          end;
          if vLines.Count > 0 then
          begin
            vPt := vLine^.Line.Point1;
            while LinesFind(vLines, @vPt, vIndex, vPtNew) do
            begin
              vPt := vPtNew;
              InsertPoint(vList, 0, @vPt);
              vLines.Delete(vIndex);
            end;
          end;
        end;
      until vLines.Count = 0;
      case vPolylines.Count of
        1:
          begin
            vList := vPolylines.List[0];
            AList.Capacity := vList.Count + 1;
            AList.Count := vList.Count;
            CopyMemory(AList.List, @vList.List[0], vList.Count * SizeOf(Pointer));
          end;
        2:  CreatePolyBy2Lists;
        3:
          begin
            L1 := GetDistancePoly(vPolylines.List[0]);
            L2 := GetDistancePoly(vPolylines.List[1]);
            L3 := GetDistancePoly(vPolylines.List[2]);
            if L1 < L2 then
            begin
              if L1 < L3 then
              begin
                SwapPointers(vPolylines.List[0], vPolylines.List[2]);
                SwapSGFloats(L1, L3);
              end;
            end
            else
            begin
              if L2 < L3 then
              begin
                SwapPointers(vPolylines.List[1], vPolylines.List[2]);
                SwapSGFloats(L2, L3);
              end;
            end;
            if (Abs(L1) > fAccuracy) and (Abs(L2) > fAccuracy) then
              CreatePolyBy2Lists;
          end;
      else
        ClearRecordListOfList(vPolylines);
      end;
      if (AList.Count > 1) and not IsEqualFPoints(PFPoint(AList.List[0])^, PFPoint(AList.List[AList.Count - 1])^) then
      begin
        New(P);
        AList.Add(P);
        P^ := PFPoint(AList.List[0])^;
      end;
    finally
      FreeList(vPolylines);
    end;
  finally
    vLines.Free;
  end;
end;

function TsgCADPolyPolyline2D.CanDraw: Boolean;
begin
  Result := True;
end;

function TsgCADPolyPolyline2D.GetBox: TFRect;
begin
  if FBox <> nil then
    Result := FBox^
  else
    Result := cnstBadRect;
end;

function TsgCADPolyPolyline2D.GetDotSingPts: TFPointList;
begin
  Result := FDotSingPts;
end;

function TsgCADPolyPolyline2D.GetEntType: TsgCADEntities;
begin
  Result := cePolyPolyline2D;
end;

function TsgCADPolyPolyline2D.GetCurveFlags(const AIndex: Integer): TsgCurveProperties;
begin
  Result := PF2DCurveEx(FCurves.List[AIndex])^.Flags;
end;

function TsgCADPolyPolyline2D.GetArc(const AIndex: Integer): TsgArcR;
begin
  Result := PF2DCurveEx(FCurves.List[AIndex])^.Arc;
end;

function TsgCADPolyPolyline2D.GetLine(const AIndex: Integer): TsgLine;
var
  vCurve: PF2DCurveEx;
begin
  vCurve := FCurves.List[AIndex];
  Result.Point1.X := vCurve^.Line.Point1.X;
  Result.Point1.Y := vCurve^.Line.Point1.Y;
  Result.Point2.X := vCurve^.Line.Point2.X;
  Result.Point2.Y := vCurve^.Line.Point2.Y;
  Result.Point1.Z := 0;
  Result.Point2.Z := 0;
end;

function TsgCADPolyPolyline2D.GroupExists: Boolean;
begin
  Result := True;
end;

function TsgCADPolyPolyline2D.GroupFill(AConverter: TsgDXFConverter = nil): Boolean;
var
  I: Integer;
  vEntity: TsgDXFEntity;
  vArc: TsgArcR;
  vLine: TsgLine;

  procedure Loaded(E: TsgDXFEntity);
  begin
    E.Loaded(AConverter);
  end;

begin
  for I := 0 to CurvesCount - 1 do
  begin
    vEntity := nil;
    if CurveVisible[I] then
    begin
      if IsCurveArc(I) then
      begin
        vEntity := TsgDXFArc.Create;
        vArc := Arcs[I];
        TsgDXFArc(vEntity).Extrusion := cnstExtrusion;
        TsgDXFArc(vEntity).Point := vArc.Center;
        TsgDXFArc(vEntity).Radius := vArc.Radius;
        TsgDXFArc(vEntity).ZThick := 0;
        TsgDXFArc(vEntity).StartAngle := vArc.AngleS;
        TsgDXFArc(vEntity).EndAngle := vArc.AngleE;
      end
      else
      begin
        vLine := Lines[I];
        vEntity := TsgDXFLine.Create;
        TsgDXFLine(vEntity).Point := vLine.Point1;
        TsgDXFLine(vEntity).Point1 := vLine.Point2;
      end;
    end;
    if vEntity <> nil then
    begin
      vEntity.AssignEntity(Self);
      vEntity.LineType := LineType;
      Loaded(vEntity);
      Group.AddEntity(vEntity);
    end;
  end;
  Result := Group.Count > 0;
end;

function TsgCADPolyPolyline2D.GroupHasAddedEntities: Boolean;
begin
  Result := True;
end;

function TsgCADPolyPolyline2D.GetCurveJoin(const AIndex: Integer): Boolean;
begin
  Result := lpJoin in PF2DCurveEx(FCurves.List[AIndex])^.Flags ;
end;

function TsgCADPolyPolyline2D.GetCurvesCount: Integer;
begin
  Result := FCurves.Count;
end;

function TsgCADPolyPolyline2D.GetCurvesVisible(const AIndex: Integer): Boolean;
begin
  Result := lpVisible in PF2DCurveEx(FCurves.List[AIndex])^.Flags ;
end;

function TsgCADPolyPolyline2D.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgCADPolyPolyline2D.GetOwner: TsgDXFEntity;
begin
  Result := FOwner;
end;

function TsgCADPolyPolyline2D.GetPointsOfArc(const AIndex: Integer;
  const A3DPointsList: TFPointList; const AContext: TsgProxyBase2D;
  NumberPart: Integer): Integer;
var
  Arc: TsgArcR;
  vStart, vEnd: Double;
  I: Integer;
  vPnt: TFPoint;
  vGenerator: TsgGeneratorShapeEdge;
  vList: TFPointList;
begin
  Result := 0;
  if not (Assigned(AContext) or Assigned(A3DPointsList)) then
    Exit;
  Arc := Arcs[AIndex];
  if NumberPart < 3 then
    NumberPart := NumberOfCirclePartsByRadius(Converter, Arc.Radius);
  vStart := Arc.AngleS;
  vEnd := Arc.AngleE;
  if vStart > vEnd then
    vStart := vStart - Round(vStart / 360) * 360;
  if vEnd < vStart then
    vEnd := vEnd + 360;
  vList := TFPointList.Create;
  try
    vGenerator := TsgGeneratorShapeEdge.Create;
    try
      vGenerator.SetBaseList(vList);
      vGenerator.NumberCirclePart := NumberPart;
      vGenerator.IsImportMode := Converter.ImportMode = imImport;
      vGenerator.CreateCircularArc(Arc.Center, Arc.Radius, vStart, vEnd);
      Result := vList.Count - 1;
      for I := 0 to vList.Count - 1 do
      begin
        vPnt := vList[I];
        vPnt.Z := 0;
        if Assigned(AContext) then
          AContext.AddIntPoint(vPnt)
        else
          A3DPointsList.Add(vPnt);
      end;
    finally
      vGenerator.Free;
    end;
  finally
    vList.Free;
  end;
end;

function TsgCADPolyPolyline2D.IsLoaded: Boolean;
begin
  Result := FBox <> nil;
end;

function TsgCADPolyPolyline2D.IsCurveArc(const AIndex: Integer): Boolean;
begin
  Result := lpArc in PF2DCurveEx(FCurves.List[AIndex])^.Flags;
end;

procedure TsgCADPolyPolyline2D.LoadBoundary(AConverter: TsgDXFConverter);
var
  vCurvePolygon: TsgCADCurvePolygon;
begin
  if FBoundaries.Count > 0 then
    ClearBoundary;
  if FCurves.Count < 1 then Exit;
  vCurvePolygon := TsgCADCurvePolygon.Create;
  try
    LoadHatch(vCurvePolygon);
    vCurvePolygon.LoadedInternal(AConverter);
    if not IsBadRect(vCurvePolygon.Box) then
    begin
      FBoundaries.AssignList(vCurvePolygon.Boundaries, loCopy);
      vCurvePolygon.Boundaries.Count := 0;
    end;
  finally
    vCurvePolygon.Free;
  end;
end;

procedure TsgCADPolyPolyline2D.LoadHatch(const AHatch: TsgCADCurvePolygon;
  const AUseBoundaries: Boolean = False);
var
  I, J: Integer;
  vCurveLine: TsgLine;
  vCurveArc: TsgArcR;
  vBoundary: TF2DPointList;
  vBoundary2D: Tsg2DBoundaryList;
  vLine2D: Tsg2DLine;
  vArc2D: Tsg2DArc;
  vPoly2D: Tsg2DPolyline;
begin
  if AUseBoundaries then
  begin
    for I := 0 to Boundaries.Count - 1 do
    begin
      vBoundary := TF2DPointList(Boundaries[I]);
      if vBoundary.Count > 2 then
      begin
        vBoundary2D := AHatch.AddBoundaryList(7);
        vPoly2D := Tsg2DPolyline.Create;
        vBoundary2D.Add(vPoly2D);
        vPoly2D.Closed := True;
        for J := 0 to vBoundary.Count - 1 do
          vPoly2D.AddVertex(vBoundary[J]);
      end;
    end;
  end
  else
  begin
    vBoundary2D := AHatch.AddBoundaryList;
    for I := 0 to CurvesCount - 1 do
    begin
      if IsCurveArc(I) then
      begin
        vCurveArc := Arcs[I];
        vArc2D := Tsg2DArc.Create;
        vBoundary2D.Add(vArc2D);
        vArc2D.CenterPoint := MakeF2DPointFrom3D(vCurveArc.Center);
        vArc2D.Radius := vCurveArc.Radius;
        vArc2D.StartParam := vCurveArc.AngleS;
        vArc2D.EndParam := vCurveArc.AngleE;
        vArc2D.CounterClockWise := True;
      end
      else
      begin
        vCurveLine := Lines[I];
        vLine2D := Tsg2DLine.Create;
        vBoundary2D.Add(vLine2D);
        vLine2D.SetStartPoint(MakeF2DPointFrom3D(vCurveLine.Point1));
        vLine2D.SetEndPoint(MakeF2DPointFrom3D(vCurveLine.Point2));
      end;
    end;
  end;
end;

procedure TsgCADPolyPolyline2D.LoadedInternal(AConverter: TsgDXFConverter);
var
  I: Integer;
  vLine: TF2DLine;
  vArc: TsgArcR;
  vLineType: TsgDXFLineType;
  vLTScale: Single;
  vBox: TFRect;

  procedure ExpandFRect2DEx(var R: TFRect; const P: TF2DPoint);
  begin
    if R.Left > P.X then
      R.Left := P.X;
    if R.Top < P.Y then
      R.Top := P.Y;
    if R.Right < P.X then
      R.Right := P.X;
    if R.Bottom > P.Y then
      R.Bottom := P.Y;
  end;

begin
  inherited LoadedInternal(AConverter);
  FCurvesVisibleCount := 0;
  ClearBox;
  ClearBoundary;
  if DotSingPts <> nil then
  begin
    FDotSingPts.Free;
    FDotSingPts := nil;
  end;
  if Layer = nil then
    Layer := AConverter.LayerByName('0');
  if FCurves.Count > 0 then
  begin
    vBox := cnstBadRect;
    vBox.Z1 := 0;
    vBox.Z2 := 0;
    LoadBoundary(AConverter);
//    for I := 0 to FBoundary.Count - 1 do
//      ExpandFRect2D(vBox, PFPoint(FBoundary.List^[I])^);
    if (LineType = nil) or (LineType.Lines.IsSolid) then
    begin
      for I := FCurves.Count - 1 downto 0 do
      begin
        if CurveVisible[I] then
        begin
          Inc(FCurvesVisibleCount);
          if IsCurveArc(I) then
          begin
            vArc := PF2DCurveEx(FCurves.List[I])^.Arc;
            ArcExpandFRect2D(vBox, vArc, True);
          end
          else
          begin
            vLine := PF2DCurveEx(FCurves.List[I])^.Line;
            ExpandFRect2DEx(vBox, vLine.Point1);
            ExpandFRect2DEx(vBox, vLine.Point2);
          end;
        end;
      end;
    end
    else
    begin
      FDotSingPts := TFPointList.Create;
      FDotSingPts.Capacity := FCurves.Count shl 2 + 1;
      vLineType := LineType;
      vLTScale := vLineType.Lines.Scale;
      vLineType.Lines.Scale := vLTScale * AConverter.GetLTScale * FLineTypeScale;
      try
        for I := FCurves.Count - 1 downto 0 do
        begin
          if CurveVisible[I] then
          begin
            Inc(FCurvesVisibleCount);
            if IsCurveArc(I) then
            begin
              vArc := PF2DCurveEx(FCurves.List[I])^.Arc;
              ArcExpandFRect2D(vBox, vArc, True);
            end
            else
            begin
              vLine := PF2DCurveEx(FCurves.List[I])^.Line;
              ExpandFRect2DEx(vBox, vLine.Point1);
              ExpandFRect2DEx(vBox, vLine.Point2);
              vLineType.Lines.Line(MakeFPoint(vLine.Point1.X, vLine.Point1.Y, 0),
              MakeFPoint(vLine.Point2.X, vLine.Point2.Y, 0), FDotSingPts);
            end;
          end;
        end;
      finally
        vLineType.Lines.Scale := vLTScale;
      end;
    end;
    if not IsBadRect(vBox) then
    begin
      New(FBox);
      FBox^ := vBox;
    end;
  end;
end;

procedure TsgCADPolyPolyline2D.SetArc(const AIndex: Integer; const Value: TsgArcR);
begin
  PF2DCurveEx(FCurves.List[AIndex])^.Arc := Value;
  PF2DCurveEx(FCurves.List[AIndex])^.Arc.Center.Z := 0;
end;

procedure TsgCADPolyPolyline2D.SetCurveFlags(const AIndex: Integer; const Value: TsgCurveProperties);
begin
  PF2DCurveEx(FCurves.List[AIndex])^.Flags := Value;
end;

procedure TsgCADPolyPolyline2D.SetCurveJoin(const AIndex: Integer; const Value: Boolean);
var
  vCurve: PF2DCurveEx;
begin
  vCurve := FCurves.List[AIndex];
  if Value then
    vCurve.Flags := vCurve^.Flags + [lpJoin]
  else
    vCurve.Flags := vCurve^.Flags - [lpJoin];
end;

procedure TsgCADPolyPolyline2D.SetLines(const AIndex: Integer; const Value: TsgLine);
var
  vCurve: PF2DCurveEx;
begin
  vCurve := FCurves.List[AIndex];
  vCurve^.Line.Point1.X := Value.Point1.X;
  vCurve^.Line.Point1.Y := Value.Point1.Y;
  vCurve^.Line.Point2.X := Value.Point2.X;
  vCurve^.Line.Point2.Y := Value.Point2.Y;
end;

procedure TsgCADPolyPolyline2D.SetLineVisible(const AIndex: Integer; const Value: Boolean);
var
  vCurve: PF2DCurveEx;
begin
  vCurve := FCurves.List[AIndex];
  if Value then
    vCurve^.Flags := vCurve^.Flags + [lpVisible]
  else
    vCurve^.Flags := vCurve^.Flags - [lpVisible];
end;

procedure TsgCADPolyPolyline2D.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgCADPolyPolyline2D.SetHandle(const Value: UInt64);
begin
{$IFDEF SG_MODULE_LOG}
  inherited SetHandle(Value);
{$ENDIF}
end;

procedure TsgCADPolyPolyline2D.SetOwner(const Value: TsgDXFEntity);
begin
  FOwner := Value;
end;

{ TsgAttributeData }

constructor TsgAttributeData.Create;
begin
  inherited Create;
  //Point := cnstFPointZero;//default value is zero
  FValues := nil;
end;

destructor TsgAttributeData.Destroy;
begin
  FreeAndNil(FValues);
  inherited Destroy;
end;

procedure TsgAttributeData.Assign(const AData: TsgAttributeData);
begin
  AttribType := AData.AttribType;
  Name := AData.Name;
  Value := AData.Value;
  FFlags := AData.FFlags;
  Point := AData.Point;
  FreeAndNil(FValues);
  if (AttribType = atEnum) and Assigned(AData.FValues) then
  begin
    CreateValues;
    FValues.Assign(AData.FValues);
  end;
end;

function TsgAttributeData.CreateValues: TStringList;
begin
  if not Assigned(FValues) then
  begin
    FValues := TStringList.Create;
    FValues.LineBreak := cnstEnumValuesDelimiter;
  end;
  Result := FValues;
end;

procedure TsgAttributeData.FromNode(const ANode: TsgNode);
var
  vValues: TsgNodeSample;
  vValuesList: TStringList;
begin
  Name := ANode.GetAttributeByName(cnstBTIXMLNames[bxmlName].Name).ValueAsStr;
  Value := ANode.GetAttributeByName(cnstBTIXMLNames[bxmlValue].Name).ValueAsStr;
  Flags := GetAttributeInt(ANode, cnstBTIXMLNames[bxmlFlags].Name, 0);
  Point := GetAttributeFPoint(ANode, cnstBTIXMLNames[bxmlPoint].Name, cnstFPointZero);
  AttribType := TsgAttribType(ANode.GetAttributeByName(cnstBTIXMLNames[bxmlType].Name).ValueAsInt);
  vValues := ANode.GetChildByName(cnstBTIXMLNames[bxmlValues].Name);
  if Assigned(vValues) then
  begin
    vValuesList := TStringList.Create;
    try
      vValuesList.LineBreak := vValues.GetAttributeByName(cnstBTIXMLNames[bxmlDelimiter].Name).ValueAsStr;
      vValuesList.Text := vValues.TextData.ValueAsStr;
      CreateValues;
      Values.Assign(vValuesList);
    finally
      FreeAndNil(vValuesList);
    end;
  end;
end;

procedure TsgAttributeData.ToNode(const ANode: TsgNode);
var
  vValues: TsgNode;
begin
  ANode.AddAttribNV(cnstBTIXMLNames[bxmlName].Name).ValueAsStr := Name;
  ANode.AddAttribNV(cnstBTIXMLNames[bxmlValue].Name).ValueAsStr := Value;
  ANode.AddAttribNV(cnstBTIXMLNames[bxmlType].Name).ValueAsInt := Integer(AttribType);
  if not IsEqualFPoints(Point, cnstFPointZero) then
    ANode.AddAttribNV(cnstBTIXMLNames[bxmlPoint].Name).ValueAsFPoint := Point;
  if (AttribType = atEnum) and Assigned(Values) then
  begin
    vValues := ANode.AddChildNV(cnstBTIXMLNames[bxmlValues].Name);
    vValues.TextData.ValueAsText := Values.Text;
    vValues.AddAttribNV(cnstBTIXMLNames[bxmlDelimiter].Name, Values.LineBreak);
  end;
  ANode.AddAttribNV(cnstBTIXMLNames[bxmlFlags].Name).ValueAsInt64 := Flags;
end;

class function TsgAttributeData.GetFlags(const ADeletable, ARequiredField, AReadOnly: Boolean): Integer;
var
  vData: TsgAttributeData;
begin
  vData := TsgAttributeData.Create;
  try
    vData.SetDeletable(ADeletable);
    vData.SetRequiredField(ARequiredField);
    vData.SetReadOnly(AReadOnly);
    Result := vData.Flags;
  finally
    vData.Free
  end;
end;

function TsgAttributeData.GetFlagsInt: Integer;
begin
  Result := FFlags;
end;

function TsgAttributeData.GetDeletable: Boolean;
begin
  Result := FFlags and 1 = 0;
end;

function TsgAttributeData.GetRequiredField: Boolean;
begin
  Result := FFlags and 2 <> 0;
end;

function TsgAttributeData.GetReadOnly: Boolean;
begin
  Result := FFlags and 4 <> 0;
end;

function TsgAttributeData.GetVisible: Boolean;
begin
  Result := FFlags and 8 <> 0;
end;

procedure TsgAttributeData.SetFlagsInt(const AValue: Integer);
begin
  FFlags := AValue;
end;

procedure TsgAttributeData.SetDeletable(const AValue: Boolean);
begin
  FFlags := (FFlags and Integer($FFFFFFFE)) or Ord(not AValue);
end;

procedure TsgAttributeData.SetRequiredField(const AValue: Boolean);
begin
  FFlags := (FFlags and Integer($FFFFFFFD)) or (Ord(AValue) shl 1);
end;

procedure TsgAttributeData.SetReadOnly(const AValue: Boolean);
begin
  FFlags := (FFlags and Integer($FFFFFFFB)) or (Ord(AValue) shl 2);
end;

procedure TsgAttributeData.SetVisible(const AValue: Boolean);
begin
  FFlags := (FFlags and Integer($FFFFFFF7)) or (Ord(AValue) shl 3);
end;

{ TsgAttrib }

procedure TsgAttrib.AssignEntity(Source: TsgDXFEntity);
var
  vAttrib: TsgAttrib absolute Source;
  vTypeValue: TsgAttribType;
begin
  vTypeValue := TypeValue;
  inherited AssignEntity(Source);
  if Source is TsgAttrib then
  begin
    FClassifierName := vAttrib.FClassifierName;
    FIdValue := vAttrib.IdValue;
    FBTIFlags := vAttrib.FBTIFlags;
    TypeValue := vAttrib.TypeValue;
    //FOwner := vAttrib.FOwner;
    VertexDataFree;
    if vAttrib.FVertexData <> nil then
    begin
      FVertexData := CreateVertexData;
      FVertexData^ := vAttrib.FVertexData^;
    end;
  end
  else
    TypeValue := vTypeValue;
end;

function TsgAttrib.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = GetAppID then
  begin
    AData.AddString(String_1001, AAppID);
    AData.AddString(String_1002, '{');
    Result := True;
  end;
end;

procedure TsgAttrib.EndExtData(const AData: TsgCADExtendedData);
begin
  AData.AddString(String_1002, '}');
end;

procedure TsgAttrib.FromData(const AData: TsgAttributeData);
var
  vFileName: string;
begin
  Tag := AData.Name;
  TypeValue := AData.AttribType;
  RequiredField := AData.RequiredField;
  Deletable := AData.Deletable;
  IsReadOnly := AData.IsReadOnly;
  NotAppear := not AData.Visible;
  Point := AData.Point;
  case TypeValue of
    atEnum:
      begin
        if IsValueLinkOfFile then
        begin
          vFileName := AData.Values[0];
          GetAttributeValuesByFileName(vFileName, Values);
        end;
        IndexValue := 0;
      end;
    atXMLLink:
      begin
        ClassifierName := AData.Value;//always before id
        //vAttrib.IdValue := GetClassifiers.GetClassifierId(vAttrib.ClassifierName, '');
        IdValue := '';
      end;
  else
    Value := AData.Value;
  end;
end;

function TsgAttrib.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
//var
//  vHandle: Int64;
begin
  if BeginExtData(AData, AAppID) then
  begin
    AData.AddInt16(Integer_1070, Word_280);
    AData.AddInt16(Integer_1070, Ord(TypeValue));
    AData.AddInt16(Integer_1070, Word_281);
    AData.AddInt16(Integer_1070, Ord(FBTIFlags));
    AData.AddInt16(Integer_1070, String_430);
    AData.AddString(String_1000, FClassifierName);
    AData.AddInt16(Integer_1070, String_431);
    AData.AddString(String_1000, FIdValue);
    if FVertexData <> nil then
    begin
      AData.AddInt(Integer_1070, Integer_72);
      AData.AddInt(Integer_1070, FVertexData^.Index);
      AData.AddInt(Integer_1070, Integer_73);
      AData.AddInt(Integer_1070, FVertexData^.State);
    end;
    EndExtData(AData);
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

procedure TsgAttrib.SetExtData(const AData: TsgCADExtendedData);
var
  I: Integer;
  vClassifierName, vIdValue: string;
  vCode: SmallInt;

  function NextInt(var ACode: SmallInt; AValue: Integer): Boolean;
  begin
    Result := True;
    case ACode of
      Word_280:     TypeValue := TsgAttribType(AData.DataInt16[I]);
      Word_281:     FBTIFlags := AData.DataInt16[I];
      Integer_72:
        begin
          if FVertexData <> nil then
          begin
            FVertexData^.Index := AData.DataInt[I];
            FVertexData^.Vertex := nil;
          end;
        end;
      Integer_73:
        begin
          if FVertexData <> nil then
            FVertexData^.State := AData.DataInt[I];
        end;
    else
      Result := False;
    end;
    ACode := 0;
  end;

  function NextStr(var ACode: SmallInt; AValue: string): Boolean;
  begin
    Result := True;
    case ACode of
      String_430:  vClassifierName := AData.DataString[I];
      String_431:  vIdValue := AData.DataString[I];
    else
      Result := False;
    end;
    ACode := 0;
  end;


  function NextInt64(var ACode: SmallInt; AValue: Int64): Boolean;
  begin
    Result := False;
    ACode := 0;
  end;

begin
  inherited SetExtData(AData);
  if IsEqualExtDataName(AData, GetAppID){$IFDEF SG_BTI}or IsEqualExtDataName(AData, cnstInventory){$ENDIF}then
  begin
    vIdValue := '';;
    vClassifierName := '';
    I := 0;
    vCode := 0;
    while I < AData.DataCount do
    begin
      case AData.DataType[I] of
        edtInt16:
          begin
            if (AData.DataCode[I] = Integer_1070) and (vCode = 0) then
              vCode := AData.DataInt16[I]
            else
              NextInt(vCode, AData.DataInt16[I]);
          end;
        edtInt:
          begin
            if (AData.DataCode[I] = Integer_1070) and (vCode = 0) then
              vCode := AData.DataInt16[I]
            else
              NextInt(vCode, AData.DataInt[I]);
          end;
        edtString:
          begin
            if (AData.DataCode[I] = String_1000) and (vCode = 0) then
              vCode := AData.DataInt16[I]
            else
              NextStr(vCode, AData.DataString[I]);
          end;
        edtInt64:
          begin
            if (AData.DataCode[I] = String_1005) and (vCode = 0) then
              vCode := AData.DataInt16[I]
            else
              NextInt64(vCode, AData.DataInt64[I]);
          end;
      end;
      Inc(I);
    end;
    if (TypeValue = atXMLLink) then
    begin
      if (Length(vClassifierName) > 0) then
      begin
        ClassifierName := vClassifierName;
        IdValue  := vIdValue;
      end
      else
        TypeValue := atString;
    end
  end;
end;

function TsgAttrib.IsValueLinkOfFile: Boolean;
begin
  Result := False;
  if (Values.Count = 1) and (AnsiPos(cnstBackSlash, Values[0]) > 0) then
    Result := True;
end;

constructor TsgAttrib.Create;
begin
  inherited Create;
  FType := atString;
end;

destructor TsgAttrib.Destroy;
begin
  VertexDataFree;
  inherited Destroy;
end;

class function TsgAttrib.CreateVertexData: sgConsts.PsgAttribVertex;
begin
  New(Result);
  Result^.Index := -1;
  Result^.Vertex := nil;
  Result^.State := 0;
end;

procedure TsgAttrib.VertexDataFree;
begin
  if FVertexData <> nil then
  begin
    FVertexData.Vertex := nil;
    DisposeAndNil(FVertexData);
  end;
end;

function TsgAttrib.GetAttribIndex: Integer;
var
  vExData: TsgExtendedBlockData;
  vTag: string;
begin
  vExData := ExBlockData;
  vTag := AnsiUpperCase(Tag);
  for Result := 0 to vExData.AttributesCount - 1 do
    if (AnsiUpperCase(vExData.Attributes[Result].Name) = vTag) and
      (vExData.Attributes[Result].AttribType = TypeValue) then
      Exit;
  Result := -1;
end;

function TsgAttrib.GetExBlockData: TsgExtendedBlockData;
var
  vEntClass: TsgEntClass;
begin
  Result := nil;
  if Assigned(FOwnerInsert) then
  begin
    vEntClass := FOwnerInsert.EntClass;
    if (vEntClass.EG = gtBTI) and (vEntClass.ET.BTI <> btiLabel) then
      Result := FOwnerInsert.GetExtendedBlockData;
  end;
end;

function TsgAttrib.GetIndexValue: Integer;
begin
  case FType of
   atEnum:
     Result := Values.IndexOf(Value);
  else
    Result := -1;
  end;
end;

function TsgAttrib.GetValues: TStringList;
var
  vExData: TsgExtendedBlockData;
  vAttribIndex: Integer;
begin
  Result := nil;
  vExData := ExBlockData;
  if Assigned(vExData) then
  begin
    vAttribIndex := AttribIndex;
    if (vAttribIndex <> -1) and (vExData.AttributesCount > 0) and
      (vExData.Attributes[vAttribIndex].AttribType = atEnum) then
      Result := vExData.Attributes[vAttribIndex].Values;
  end;
end;

function TsgAttrib.GetDeletable: Boolean;
begin
  Result := FBTIFlags and 1 = 0;
end;

function TsgAttrib.GetReadOnly: Boolean;
begin
  Result := FBTIFlags and 2 <> 0;
end;

function TsgAttrib.GetRequiredField: Boolean;
begin
  Result := FBTIFlags and 4 <> 0;
end;

procedure TsgAttrib.SetClassifierName(const AName: string);
begin
  FClassifierName := AName;
end;

procedure TsgAttrib.SetValueInternal(const AValue: string);
begin
  inherited SetValue(AValue);
end;

procedure TsgAttrib.SetDeletable(const AValue: Boolean);
begin
  FBTIFlags := (FBTIFlags and $FFFFFFFE) or Cardinal(not AValue);
end;

procedure TsgAttrib.SetReadOnly(const AValue: Boolean);
begin
  FBTIFlags := (FBTIFlags and $FFFFFFFD) or (Cardinal(AValue) shl 1);
end;

procedure TsgAttrib.SetRequiredField(const AValue: Boolean);
begin
  FBTIFlags := (FBTIFlags and $FFFFFFFB) or (Cardinal(AValue) shl 2);
end;

procedure TsgAttrib.SetIdValue(const AID: string);
{$IFDEF SG_BTI}
var
  vAttribIndex: Integer;
  vAttribData: TsgAttributeData;
  vExData: TsgExtendedBlockData;
  vValue: string;
{$ENDIF}
begin
  //if FIdValue <> AID then
  begin
    FIdValue := AID;
    if FType = atXMLLink then
    begin
      vValue := FIdValue;
{$IFDEF SG_BTI}
      if Length(ClassifierName) = 0 then//restore name
      begin
        vExData := ExBlockData;
        if Assigned(vExData) then
        begin
          vAttribIndex := AttribIndex;
          if (vAttribIndex > -1) then
          begin
            vAttribData := vExData.Attributes[vAttribIndex];
            if vAttribData.AttribType = FType then
              ClassifierName := vAttribData.Value;
          end;
        end;
      end;
      if Length(ClassifierName) > 0 then
        vValue := GetClassifiers.GetClassifierValue(ClassifierName, vValue);
{$ENDIF}
      SetValueInternal(vValue);
    end;
  end;
end;

 procedure TsgAttrib.SetValueInsp(const AValue: string);
{$IFDEF SG_BTI}
var
  vId: string;
{$ENDIF}
 begin
{$IFDEF SG_BTI}
   if (FType = atXMLLink) and (Length(ClassifierName) > 0) then
   begin
     vId := GetClassifiers.GetClassifierId(ClassifierName, AValue);
     if Length(vId) > 0 then
       FIdValue := vId;
   end;
{$ENDIF}
   SetValueInternal(AValue);
 end;

function TsgAttrib.GetIdValueIndex: Integer;
{$IFDEF SG_BTI}
var
  vItem: TsgClassifierItem;
  vValues: TStringList;
  I: Integer;
begin
  Result := -1;
  if (FType = atXMLLink) and (Length(ClassifierName) > 0) then
  begin
    vValues := TStringList.Create;
    try
      GetClassifiers.GetClassifierValues(ClassifierName, vValues);
      for I := 0 to vValues.Count - 1 do
      begin
        vItem := TsgClassifierItem(vValues.Objects[I]);
        if vItem.ID = FIdValue then
        begin
          Result := I;
          Break;
        end;
      end;
     finally
      vValues.Free;
    end;
  end;
{$ELSE}
begin
  Result := inherited GetIdValueIndex;
{$ENDIF}
end;

function TsgAttrib.GetLinkVertex: TObject;
begin
  Result := nil;
{$IFDEF SG_BTI}
  if FVertexData <> nil then
    Result := FVertexData^.Vertex;
{$ENDIF}
end;

function TsgAttrib.GetOwnerInsert: TsgDXFInsert;
begin
  Result := FOwnerInsert;
end;

function TsgAttrib.GetLinkIndex: Integer;
begin
  Result := -1;
{$IFDEF SG_BTI}
  if FVertexData <> nil then
    Result := FVertexData^.Index;
{$ENDIF}
end;

function TsgAttrib.GetLinkState: Integer;
begin
  Result := -1;
{$IFDEF SG_BTI}
  if FVertexData <> nil then
    Result := FVertexData^.State;
{$ENDIF}
end;

procedure TsgAttrib.SetLinkVertex(const AValue: TObject);
begin
{$IFDEF SG_BTI}
  if FVertexData <> nil then
    FVertexData^.Vertex := AValue;
{$ENDIF}
end;

procedure TsgAttrib.SetOwnerInsert(const AValue: TsgDXFInsert);
begin
  FOwnerInsert := AValue;
end;

procedure TsgAttrib.SetLinkIndex(const AValue: Integer);
begin
{$IFDEF SG_BTI}
  if FVertexData <> nil then
    FVertexData^.Index := AValue;
{$ENDIF}
end;

procedure TsgAttrib.SetLinkState(const AValue: Integer);
begin
{$IFDEF SG_BTI}
  if FVertexData <> nil then
    FVertexData^.State := AValue;
{$ENDIF}
end;

procedure TsgAttrib.SetTypeValue(const AValue: TsgAttribType);
begin
  inherited SetTypeValue(AValue);
  case TypeValue of
    atVertex:
      begin
        if FVertexData = nil then
          FVertexData := CreateVertexData;
      end;
  else
    VertexDataFree;
  end;
end;

procedure TsgAttrib.SetIdValueByIndex(const AIndexInValues: Integer);
{$IFDEF SG_BTI}
var
  vItem: TsgClassifierItem;
  vValues: TStringList;
begin
  if (FType = atXMLLink) and (Length(ClassifierName) > 0) then
  begin
    vValues := TStringList.Create;
    try
      GetClassifiers.GetClassifierValues(ClassifierName, vValues);
      if (AIndexInValues < vValues.Count) and (AIndexInValues > -1) then
      begin
        vItem := TsgClassifierItem(vValues.Objects[AIndexInValues]);
        FIdValue := vItem.ID;
        SetValueInternal(vItem.Value);
      end;
     finally
      vValues.Free;
    end;
  end;
{$ELSE}
begin
  inherited SetIdValueByIndex(AIndexInValues);
{$ENDIF}
end;

procedure TsgAttrib.SetIndexValue(const AIndex: Integer);
begin
   Value := Values[AIndex];
end;

{ TsgGroup }

function TsgGroup.AddBlock(const AConverter: TsgDXFConverter): Boolean;
var
  vName, vBlockName: string;
  vIndex: TsgNativeUInt;
begin
  if Block = nil then
    CreateBlock;
  if (AConverter <> nil) and (Length(Block.Name) = 0) then
  begin
    vName := ShortName;
    vIndex := TsgNativeUInt(Block) - 1;
    repeat
      Inc(vIndex);
      vBlockName := vName + IntToStr(vIndex);
    until AConverter.BlockByName(vBlockName) = nil;
    Block.Name := vBlockName;
    AddBlockInConverter(AConverter);
  end;
  Result := Length(Block.Name) > 0;
end;

procedure TsgGroup.AddBlockInConverter(const AConverter: TsgDXFConverter);
begin
  AConverter.Sections[csBlocks].AddEntity(Block);
end;

constructor TsgGroup.Create;
begin
  inherited Create;
  CreateBlock;
end;

procedure TsgGroup.CreateBlock;
var
  vBlock: TsgDXFBlock;
  vClass: TsgDXFEntityClass;
begin
  vClass := GetClassOfBlock;
  if Assigned(vClass) then
    vBlock := TsgDXFBlock(vClass.Create)
  else
    vBlock := TsgDXFBlock.Create;
  vBlock.SetFlags(1);
  Block := vBlock;
end;

destructor TsgGroup.Destroy;
begin
  //FreeBlock;
  inherited Destroy;
end;

function TsgGroup.FreeBlock: Boolean;
var
  vBlock: TsgDXFBlock;
  vConverter: TsgDXFConverter;
begin
  Result := (Block <> nil) and CanFreeBlock(Converter);
  if Result then
  begin
    vBlock := Block;
    vConverter := Converter;
    Block := nil;
    if Assigned(vConverter) then
      vConverter.DeleteBlock(vBlock, False);
    vBlock.Free;
  end;
end;


function TsgGroup.CanFreeBlock(AConverter: TsgDXFConverter): Boolean;
begin
  Result := (AConverter = nil) or (AConverter.Status in
    [stDefault, stEditing]);
end;

function TsgGroup.CanLoading(AConverter: TsgDXFConverter): Boolean;
begin
  Result := (AConverter <> nil) and (AConverter.Status = stDefault);
end;

procedure TsgGroup.ClearBlock;
begin
  if Block <> nil then
    Block.Clear(True);
end;

function TsgGroup.GetClassOfBlock: TsgDXFEntityClass;
begin
  Result := nil;
end;

procedure TsgGroup.ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord);
begin
  // not implement
end;

function TsgGroup.ReMoveBlock(const AConverter: TsgDXFConverter): Boolean;
begin
  Result := False;
  if (AConverter <> nil) and (Block <> nil) and AConverter.DeleteBlock(Block, False) then
  begin
    SetConverter(nil);
    Block.Name := '';
    Result := True;
  end;
end;


function TsgGroup.ShortName: string;
begin
  Result := '*G';
end;

{ TsgLabel }

procedure TsgLabel.AssignEntity(Source: TsgDXFEntity);
var
  vLabel: TsgLabel absolute Source;
  vBlock: TsgDXFBlock;
begin
  vBlock := Block;
  try
    inherited AssignEntity(Source);
  finally
    Block := vBlock;
  end;
  if Source is TsgLabel then
  begin
    FEntOwner := vLabel.FEntOwner;
    CopyFrom(vLabel);
  end;
end;

procedure TsgLabel.CopyFrom(Source: TsgLabel);
begin
  if Block <> nil then
    Block.Clear(True);
  ColorCAD := Source.ColorCAD;
  FFlags := Source.FFlags;
  FTextLeft := Source.FTextLeft;
  FTextRight := Source.FTextRight;
  FTextTop := Source.FTextTop;
  FTextBottom := Source.FTextBottom;
  Style := Source.Style;
  FHeight := Source.FHeight;
  FTextOffset := Source.FTextOffset;
end;

procedure TsgLabel.AddBlockInConverter(const AConverter: TsgDXFConverter);
begin
  FConvWithBlockAdded := AConverter;
  inherited AddBlockInConverter(AConverter);
end;

function TsgLabel.BeginExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
  if AAppID = GetAppID then
  begin
    AData.AddString(String_1001, AAppID);
    //AData.AddString(String_1000, Copy(ClassName, 4, MaxInt));
    AData.AddString(String_1002, '{');
    AData.AddInt16(Integer_1070, Integer_70);
    AData.AddInt(Integer_1071, GetEntTypeEx);
    Result := True;
  end;
end;

procedure TsgLabel.EndExtData(const AData: TsgCADExtendedData);
begin
   AData.AddString(String_1002, '}');
end;

function TsgLabel.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  if BeginExtData(AData, AAppID) then
  begin
    AData.AddInt16(Integer_1070, Integer_290);
    AData.AddInt16(Integer_1070, Ord(ShowSplitter));
    AData.AddInt16(Integer_1070, Integer_291);
    AData.AddInt16(Integer_1070, Ord(ShowFrame));
    AData.AddInt16(Integer_1070, Integer_400);
    AData.AddInt16(Integer_1070, Align);
    AData.AddInt16(Integer_1070, Float_140);
    AData.AddDouble(Float_1041, Height);
    AData.AddInt16(Integer_1070, Float_141);
    AData.AddDouble(Float_1041, TextOffset);
    if Style <> nil then
    begin
      AData.AddInt16(Integer_1070, String_430);
      AData.AddString(String_1000, Style.Name);
    end;
    AData.AddInt16(Integer_1070, String_431);
    AData.AddString(String_1000, TextLeft);
    AData.AddInt16(Integer_1070, String_432);
    AData.AddString(String_1000, TextRight);
    AData.AddInt16(Integer_1070, String_433);
    AData.AddString(String_1000, TextTop);
    AData.AddInt16(Integer_1070, String_434);
    AData.AddString(String_1000, TextBottom);
    EndExtData(AData);
    Result := True;
  end
  else
    Result := inherited GetExtData(AData, AAppID);
end;

procedure TsgLabel.SetExtData(const AData: TsgCADExtendedData);
var
  I: Integer;
  vCode: SmallInt;

  vLabelAlign: Integer;
  vLabelStrings: array [0..4] of string;
  vLabelHeight, vLabelTextOffset: Double;
  vLabelShowSplitter, vLabelShowFrame: Boolean;

  function NextString(var ACode: SmallInt; const AValue: string): Boolean;
  begin
    Result := True;
    case ACode of
      // begin only for TsgLabel
      String_430..String_434:
        vLabelStrings[ACode - String_430] := AValue;
      // end
    else
      Result := False;
    end;
    ACode := 0;
  end;

  function NextDouble(var ACode: SmallInt; const AData: TsgCADExtendedData; var J: Integer): Boolean;
  begin
    Result := True;
    case ACode of
      Float_140:  vLabelHeight := AData.DataDouble[J];
      Float_141:  vLabelTextOffset := AData.DataDouble[J];
    else
      Result := False;
    end;
    ACode := 0;
  end;

  function NextInt(var ACode: SmallInt; const AValue: Integer): Boolean;
  begin
    Result := True;
    case ACode of
      // begin only for TsgLabel
      Integer_290: vLabelShowSplitter := AValue <> 0;
      Integer_291: vLabelShowFrame := AValue <> 0;
      Integer_400: vLabelAlign := AValue;
      // end
    else
      Result := False;
    end;
    ACode := 0;
  end;

begin
  vLabelShowFrame := False;
  I := 0;
  vCode := 0;
  while I < AData.DataCount do
  begin
    case AData.DataType[I] of
      edtInt16:
        begin
          if (AData.DataCode[I] = 1070) and (vCode = 0) then
            vCode := AData.DataInt16[I]
          else
            NextInt(vCode, AData.DataInt16[I]);
        end;
      edtInt:
        begin
          if (AData.DataCode[I] = 1070) and (vCode = 0) then
            vCode := AData.DataInt16[I]
          else
            NextInt(vCode, AData.DataInt[I]);
        end;
      edtDouble: NextDouble(vCode, AData, I);
      edtString: NextString(vCode, AData.DataString[I]);
    end;
    Inc(I);
  end;

  Align := vLabelAlign;
  Height := vLabelHeight;
  TextOffset := vLabelTextOffset;
  ShowSplitter := vLabelShowSplitter;
  ShowFrame := vLabelShowFrame;
  Style := Converter.StyleByName(Trim(vLabelStrings[0]));
  TextLeft := vLabelStrings[1];
  TextRight := vLabelStrings[2];
  TextTop := vLabelStrings[3];
  TextBottom := vLabelStrings[4];
end;

function TsgLabel.ImportParamsFromBlockPattern(const APattern: TsgDXFBlock;
  const AScale: Double = 1): Boolean;
begin
  Result := Assigned(APattern);
end;

function TsgLabel.ExportParamsToBlockPattern(const APattern: TsgDXFBlock): Boolean;
begin
  Result := Assigned(APattern);
end;

function TsgLabel.EntName: string;
begin
  Result := GetClassEntName(Self, 3);
end;

constructor TsgLabel.Create;
begin
  inherited Create;
  FTextStyleItem := TsgTableItem.Create;
  ShowSplitter := True;
  Align := 5;
end;

procedure TsgLabel.ClearReferences;
var
  vConverter: TsgDXFConverter;
  vBlock: TsgDXFBlock;
  vClear: Boolean;
begin
  vClear := DoClearReferences(vConverter, vBlock);
  try
    if not vClear then
    begin
      vConverter := FConvWithBlockAdded;
      if (not Assigned(vConverter)) and Assigned(vBlock) then
        vConverter := vBlock.Converter;
    end;
    inherited ClearReferences;
    FTextStyleItem.Item := nil;
  finally
    FreeBlockInternal(vConverter, vBlock);
  end;
end;

procedure TsgLabel.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FTextStyleItem);
end;

destructor TsgLabel.Destroy;
begin
  inherited Destroy;
end;

{$IFDEF DEBUG}
function TsgLabel.DoSetBlockAfter(const ASetBlock: TsgDXFBlock): Integer;
begin
  Result := inherited DoSetBlockAfter(ASetBlock);
end;

function TsgLabel.DoSetBlockBefore(const ASetBlock: TsgDXFBlock): Integer;
begin
  Result := inherited DoSetBlockBefore(ASetBlock);
end;

procedure TsgLabel.SetConverter(const AConverter: TsgDXFConverter);
begin
  inherited SetConverter(AConverter);
end;
{$ENDIF}

function TsgLabel.CreateText(const AText: string; const AConverter: TsgDXFConverter;
  const AMText: Boolean = False): TsgDXFCustomVertex;
var
  vText: TsgDXFText absolute Result;
begin
  if AMText then
  begin
    Result := TsgDXFMText.Create;
    TsgDXFMText(Result).Text := AText;
    SetMTextPropsFromOwner(TsgDXFMText(Result));
  end
  else
  begin
    Result := TsgDXFText.Create;
    SetEntiyPropsFromOwner(Result);
    vText.Point := cnstFPointZero;
    vText.Style := Style;
    vText.Height := FHeight;
    vText.Text := AText;
    vText.ApplyStyle(Style);
//    Result.ObliqueAngle := FStyle.ObliqueAngle;//This in TsgDXFText.ApplyStyle
//    Result.XScale := FStyle.WidthFactor;
  end;
  Result.Loaded(AConverter);
end;

function TsgLabel.GenerateLabel(const AConverter: TsgDXFConverter): Boolean;
// -----------------------------
// |        TextTop            |
// | TextLeft ------ TextRight |
// |       TextBottom          |
// -----------------------------
var
  vTexts: array[1..4] of TsgDXFCustomVertex;//TsgDXFText;
  I: Integer;
  vLine: TsgLine;
  vEntLine: TsgDXFLine;
  vEntPolyline: TsgDXFLWPolyline;
  X3, X4, vLen, vLeft, vRight: Double;
  vBox: TFRect;
  vText, vTextLeft, vTextRight: string;
  vIsMText: Boolean;

  function GetEntWidth(const AEnt: TsgDXFEntity): Double;
  begin
    if IsBadRect(AEnt.Box) then
      Result := 0
    else
      Result := AEnt.Box.Right - AEnt.Box.Left;
  end;

  function GetEntHeight(const AEnt: TsgDXFEntity): Double;
  begin
    if IsBadRect(AEnt.Box) then
      Result := 0
    else
      Result := AEnt.Box.Top - AEnt.Box.Bottom;
  end;

begin
  Block.Clear(True);
  Block.Offset := cnstFPointZero;
  FillChar(vTexts, SizeOf(vTexts), 0);
  vIsMText := IsMText;
  vText := GetTextTopShow;
  if Length(vText) > 0 then
  begin
    vTexts[3] := CreateText(vText, AConverter, vIsMText);
    X3 := GetEntWidth(vTexts[3]);
  end
  else
    X3 := 0;
  vText := GetTextBottomShow;
  if Length(vText) > 0 then
  begin
    vTexts[4] := CreateText(vText, AConverter, vIsMText);
    X4 := GetEntWidth(vTexts[4]);
  end
  else
    X4 := 0;
  vLen := Max(X3, X4);
  if (vLen < fAccuracy) and ShowSplitter then
    vLen := FHeight * 6;
  vLine.Point1 := MakeFPoint(-vLen * 0.5, 0, 0);
  vLine.Point2 := MakeFPoint( vLen * 0.5, 0, 0);
  vLeft  := MaxDouble;
  vRight :=-MaxDouble;
  if vTexts[3] <> nil then
  begin
    vTexts[3].Point := MakeFPoint(vLine.Point1.X + (vLen - X3) * 0.5, TextOffset, 0);
    Block.AddEntity(vTexts[3]);
    vTexts[3].Loaded(AConverter);
    if vLeft > vTexts[3].Box.Left then
      vLeft := vTexts[3].Box.Left;
    if vRight < vTexts[3].Box.Right then
      vRight := vTexts[3].Box.Right;
  end;
  if vTexts[4] <> nil then
  begin
    vTexts[4].Point := MakeFPoint(vLine.Point1.X + (vLen - X4) * 0.5, - TextOffset - GetEntHeight(vTexts[4]), 0);
    Block.AddEntity(vTexts[4]);
    vTexts[4].Loaded(AConverter);
    if vLeft > vTexts[4].Box.Left then
      vLeft := vTexts[4].Box.Left;
    if vRight < vTexts[4].Box.Right then
      vRight := vTexts[4].Box.Right;
  end;
  if vLeft < vRight then
  begin
    vLine.Point1.X := vLeft;
    vLine.Point2.X := vRight;
  end;
  vTextLeft := GetTextLeftShow;
  if Length(vTextLeft) > 0 then
  begin
    vTexts[1] := CreateText(vTextLeft, AConverter, vIsMText);
    vTexts[1].Point := MakeFPoint(vLine.Point1.X - GetEntWidth(vTexts[1]) - TextOffset,
      vLine.Point1.Y - GetEntHeight(vTexts[1]) * 0.5, 0);
    Block.AddEntity(vTexts[1]);
    vTexts[1].Loaded(AConverter);
  end;
  vTextRight := GetTextRightShow;
  if Length(vTextRight) > 0 then
  begin
    vTexts[2] := CreateText(vTextRight, AConverter, vIsMText);
    vTexts[2].Point := MakeFPoint(vLine.Point2.X + TextOffset,
      vLine.Point1.Y - GetEntHeight(vTexts[2]) * 0.5, 0);
    Block.AddEntity(vTexts[2]);
    vTexts[2].Loaded(AConverter);
  end;
  vEntLine := nil;
  if ShowSplitter and (Block.Count > 0) then
  begin
    vEntLine := TsgDXFLine.Create;
    Block.AddEntity(vEntLine);
    SetEntiyPropsFromOwner(vEntLine);
    vEntLine.Point  := vLine.Point1;
    vEntLine.Point1 := vLine.Point2;
    vEntLine.Loaded(AConverter);
  end;
  if ShowFrame and (Block.Count > 0) then
  begin
    vBox := cnstBadRect;
    for I := 0 to Block.Count - 1do
      UnionFRect(vBox, Block.Entities[I].Box);
    InflateFRect(@vBox, TextOffset, TextOffset, 0);
    if Assigned(vEntLine) then
    begin
      if Length(vTextLeft) = 0 then
        vEntLine.Point := MakeFPoint(vBox.Left, vEntLine.Point.Y);
      if Length(vTextRight) = 0 then
        vEntLine.Point1 := MakeFPoint(vBox.Right, vEntLine.Point1.Y);
      if (Length(vTextLeft) = 0) or (Length(vTextRight) = 0) then
        vEntLine.Loaded(AConverter);
    end;
    vEntPolyline := TsgDXFLWPolyline.Create;
    Block.AddEntity(vEntPolyline);
    SetEntiyPropsFromOwner(vEntPolyline);
    vEntPolyline.Closed := True;
    AddVertexInPolyline(vEntPolyline, MakeFPoint(vBox.Left, vBox.Top));
    AddVertexInPolyline(vEntPolyline, MakeFPoint(vBox.Right, vBox.Top));
    AddVertexInPolyline(vEntPolyline, MakeFPoint(vBox.Right, vBox.Bottom));
    AddVertexInPolyline(vEntPolyline, MakeFPoint(vBox.Left, vBox.Bottom));
    vEntPolyline.Loaded(AConverter);
  end;
  Block.Offset := cnstFPointZero;
  Block.Loaded(AConverter);
  Result :=  Block.Count > 0;
end;

function TsgLabel.GetAlign: Byte;
begin
  Result := FFlags and 15;
end;

function TsgLabel.GetActualBlockRecord: TsgDXFBlockRecord;
begin
  Result := BlockRecord;
end;

function TsgLabel.GetEntClassEx: TsgEntClass;
begin
  Result.EG := gtBTI;
  Result.ET.BTI := GetBTITypeByEntTypeEx(GetEntTypeEx);
end;

function TsgLabel.GetClassOfBlock: TsgDXFEntityClass;
begin
  Result := TsgBlockOfLabel;
end;

function TsgLabel.GetEntType: TsgCADEntities;
begin
  Result := inherited GetEntType;
end;

function TsgLabel.GetEntTypeEx: Integer;
begin
  Result := cnstLabel;
end;

function TsgLabel.GetHeight: TsgFloat;
begin
  Result := FHeight;
end;

function TsgLabel.GetTextLeft: string;
begin
  Result := FTextLeft;
end;

function TsgLabel.GetTextLeftShow: string;
begin
  Result := GetTextLeft;
end;

function TsgLabel.GetTextRight: string;
begin
  Result := FTextRight;
end;

function TsgLabel.GetTextRightShow: string;
begin
  Result := GetTextRight;
end;

function TsgLabel.GetTextTop: string;
begin
  Result := FTextTop;
end;

function TsgLabel.GetTextTopShow: string;
begin
  Result := GetTextTop;
end;

function TsgLabel.GetTextBottom: string;
begin
  Result := FTextBottom;
end;

function TsgLabel.GetTextBottomShow: string;
begin
  Result := GetTextBottom;
end;

function TsgLabel.IsMText: Boolean;
begin
  Result := False;
end;

function TsgLabel.GetShowSplitter: Boolean;
begin
  Result := (FFlags and 16) <> 0;
end;

function TsgLabel.GetShowFrame: Boolean;
begin
  Result := (FFlags and 32) <> 0;
end;

function TsgLabel.GetStyle: TsgDXFStyle;
begin
  Result := TsgDXFStyle(FTextStyleItem.Item);
end;

function TsgLabel.GetTextOffset: TsgFloat;
begin
  Result := FTextOffset;
end;

procedure TsgLabel.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgLabel.LoadedInternal(AConverter: TsgDXFConverter);
var
  X, Y, vDX, vDY: Double;
  vOffset: TFPoint;
  vCanLoading: Boolean;
begin
  FBox := cnstBadRect;
  if CanLoading(AConverter) then
  begin
    vCanLoading := True;
    AddBlock(AConverter);
  end
  else
  begin
    vCanLoading := (AConverter <> nil) and (AConverter.Status = stEditing);
    if vCanLoading and (not Assigned(Block)) then
      CreateBlock;
  end;
  if vCanLoading then
  begin
    if Layer = nil then
      Layer := Converter.LayerByName('0');
    if Style = nil then
      Style := Converter.StyleByName(sStandardName);
    if GenerateLabel(AConverter) then
    begin
      Block.IsLoaded := False;
      Block.Loaded(AConverter);
      X := Block.Box.Right - Block.Box.Left;
      Y := Block.Box.Top - Block.Box.Bottom;
      vDX := (Abs(Block.Box.Right) - Abs(Block.Box.Left)) * 0.5;
      vDY := (Abs(Block.Box.Top) - Abs(Block.Box.Bottom)) * 0.5;
      vOffset := Block.Offset;
      case Align of
        0, 1, 4, 7: vOffset.X := vOffset.X - X * 0.5 + vDX;
        2, 5, 8:    vOffset.X := vOffset.X + vDX;
        3, 6, 9:    vOffset.X := vOffset.X + X * 0.5 + vDX;
      end;
      case Align of
        0, 1, 2, 3: vOffset.Y := vOffset.Y + Y * 0.5 + vDY;
        4, 5, 6:    vOffset.Y := vOffset.Y + vDY;
        7, 8, 9:    vOffset.Y := vOffset.Y - Y * 0.5 + vDY;
      end;
      Block.Offset := vOffset;
      FBox := Block.Box;
      CalculateMatrix;
      if not IsBadRect(FBox) then
        TransRectCorners(FBox, FMatrix);
    end;
  end;
end;

procedure TsgLabel.SetAlign(const Value: Byte);
begin
  FFlags := (FFlags and 240) or (Value and 15);
end;

procedure TsgLabel.SetHeight(const Value: TsgFloat);
begin
  FHeight := Value;
end;

procedure TsgLabel.SetHeightExternal(const AValue: Double);
begin
  SetHeight(AValue);
  if Assigned(FOwnerInsert) then
    FOwnerInsert.SetBtiProps(cnsBti_AreaHeight, @AValue);
end;

procedure TsgLabel.SetTextLeft(const Value: string);
begin
  FTextLeft := Value;
end;

procedure TsgLabel.SetTextRight(const Value: string);
begin
  FTextRight := Value;
end;

procedure TsgLabel.SetTextTop(const Value: string);
begin
  FTextTop := Value;
end;

procedure TsgLabel.SetTextBottom(const Value: string);
begin
  FTextBottom := Value;
end;

procedure TsgLabel.SetShowSplitter(const Value: Boolean);
begin
  FFlags := (FFlags and 239) or (Byte(Value) shl 4);
end;

procedure TsgLabel.SetShowFrame(const Value: Boolean);
begin
  FFlags := (FFlags and 223) or (Byte(Value) shl 5);
end;

procedure TsgLabel.SetStyle(const Value: TsgDXFStyle);
begin
  FTextStyleItem.Item := Value;
end;

procedure TsgLabel.SetTextOffset(const Value: TsgFloat);
begin
  FTextOffset := Abs(Value);
end;

procedure TsgLabel.SetEntiyPropsFromOwner(const AEntity: TsgDXFEntity);
begin
  AEntity.Layer := Layer;
  AEntity.ColorCAD := cnstColorCADByBlock;
  AEntity.LineWeight := fLineWeightByBlock;
  AEntity.LineTypeScale := LineTypeScale;
end;


procedure TsgLabel.SetMTextPropsFromOwner(const AMText: TsgDXFMText);
begin
  SetEntiyPropsFromOwner(AMText);
  AMText.Point := cnstFPointZero;
  AMText.Style := Style;
  AMText.Height := FHeight;
  AMText.Style := Style;
  AMText.Align := 7;
end;

function TsgLabel.ShortName: string;
begin
  Result := GetBlockShortNameByEntTypeEx(GetEntTypeEx);
end;

{ TsgAreaFigure }

procedure TsgAreaFigure.Assign(const AObj: TObject);
var
  vObj: TsgAreaFigure absolute AObj;
begin
  if AObj is TsgAreaFigure then
  begin
    FFlags := vObj.FFlags;
    FType := vObj.FType;
    FKoef := vObj.FKoef;
    FName := vObj.FName;
    CopyMemory(@FParams[0], @vObj.FParams[0], SizeOf(vObj.FParams));
    FFlags := vObj.FFlags;
    FEpsilon := vObj.FEpsilon;
  end;
end;

constructor TsgAreaFigure.Create;
begin
  FType := ftFigure;
  FKoef := 1;
  Sign := 1;
  FEpsilon := 0;
end;

destructor TsgAreaFigure.Destroy;
begin
//  FType := ftFigure;
  inherited Destroy;
end;

function TsgAreaFigure.GetArea: Double;
var
  vP, vRadius, vHeight: Double;
begin
  case FType of
    ftRect:                    Result := A * B;
    ftSquare:                  Result := Sqr(A);
    ftQuadrangle:              Result := 0.5 * C * D * Sin(A * fPiDividedBy180);
    ftParallelogram:           Result := B * H;
    ftRhomb:                   Result := C * D * 0.5;
    ftTrapezium:               Result := (A + B) * H * 0.5;
    ftTriangle:
      begin
        vP := (A + B + C)* 0.5;
        Result := vP * (vP - A) * (vP - B) * (vP - C);
        if Result > fAccuracy then
          Result := Sqrt(Result)
        else
          Result := -1;
      end;
    ftTriangleRightAngled:    Result := A * B * 0.5;
    ftTriangleByHippuran:
      begin
        vP :=  Sqr(C)- Sqr(A);
        if vP > fAccuracy then
          Result := A * Sqrt(vP) * 0.5
        else
          Result := -1;
      end;
    ftCircleByLength:         Result := Sqr(L) / cnstPiMul4;
    ftCircleByRadius:         Result := cnstPi * Sqr(R);
    ftSectorByAngleAndRadius: Result := Sqr(R) * A * fPiDividedBy180;
    ftSegmentByChordAndLength:
      begin
        Result := -1;
        if (A > fAccuracy) and (L > fAccuracy) then
        begin
          vHeight := GetHeightByChordAndLength(A, L);
          if vHeight > fAccuracy then
          begin
            vRadius := GetRadiusByChordAndHeight(A, vHeight);
            if vRadius > fAccuracy then
              Result := 0.5 * (L * vRadius - A * (vRadius - vHeight))
          end;
        end;
      end;
    ftSegmentByChordAndHeight:
      begin
        Result := -1;
        if (A > fAccuracy) and (H > fAccuracy) then
        begin
          vRadius := GetRadiusByChordAndHeight(A, H);
          if vRadius > fAccuracy then
            Result := 0.5 * (GetAngleByChordAndRadius(A, vRadius) * Sqr(vRadius) - A * (vRadius - H));
        end;
      end;
    ftContour:  Result := S;
  else
    Result := 0;
  end;
  if Result > fAccuracy then
    Result := Sqr(FKoef) * Result;
end;

function TsgAreaFigure.ToXML(const AParentNode: TsgNode;
  const AMode: TsgXMLModes = cnstDefaultXMLMode): TsgNode;
var
  vParams: TsgXMLParams;
begin
  vParams := CreateXMLParams(AMode);
  Result := ToXMLWithParams(AParentNode, vParams);
end;

function TsgAreaFigure.ToXMLWithParams(const AParentNode: TsgNode;
  const AParams: TsgXMLParams): TsgNode;
var
  I: Integer;
  vParams: TsgNode;
begin
  Result := AParentNode.AddChildNV(cnstBTIXMLNames[bxmlAreaFigure].Name);
  Result.AddAttribNV(cnstBTIXMLNames[bxmlType].Name).ValueData.ValueAsInt := Integer(FType);
  Result.AddAttribNV(cnstBTIXMLNames[bxmlName].Name).ValueData.ValueAsText := FName;
  Result.AddAttribNV(cnstBTIXMLNames[bxmlFlags].Name).ValueData.ValueAsByte := FFlags;
  Result.AddAttribNV(cnstBTIXMLNames[bxmlKoef].Name).ValueData.ValueAsDouble := FKoef;
  if FEpsilon <> 0 then
    Result.AddAttribNV(cnstBTIXMLNames[bxmlEpsilon].Name).ValueData.ValueAsDouble := FEpsilon;
  vParams := Result.AddChildNV(cnstBTIXMLNames[bxmlDoubleArray].Name);
  for I := Low(FParams) to High(FParams) do
    vParams.AddChildNV(cnstBTIXMLNames[bxmlItem].Name).TextData.ValueAsDouble := FParams[I];
end;

function TsgAreaFigure.FromXML(const ANode: TsgNodeSample;
  const AResult: IsgResultNode = nil): Integer;
var
  I: Integer;
  vArray: TsgNodeSample;
begin
  Result := cnstXML_OK;
  FType := TsgFigureType(GetAttributeInt(ANode, cnstBTIXMLNames[bxmlType].Name, Integer(FType)));
  FName := GetAttributeStr(ANode, cnstBTIXMLNames[bxmlName].Name, FName);
  FFlags := GetAttributeInt(ANode, cnstBTIXMLNames[bxmlFlags].Name, FFlags);
  FKoef := GetAttributeFloat(ANode, cnstBTIXMLNames[bxmlKoef].Name, FKoef);
  FEpsilon := GetAttributeFloat(ANode, cnstBTIXMLNames[bxmlEpsilon].Name, 0);
  vArray := ANode.GetChildByName(cnstBTIXMLNames[bxmlDoubleArray].Name);
  if Assigned(vArray) then
  begin
    for I := Low(FParams) to High(FParams) do
      FParams[I] := vArray.ChildNodes[I].TextData.ValueAsDouble;
  end;
end;

function TsgAreaFigure.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
var
  J: Integer;
begin
  AData.AddInt16(Integer_1070, Integer_170);
  AData.AddInt16(Integer_1070, Ord(FType));
  AData.AddInt16(Integer_1070, String_439);
  AData.AddString(String_1000, FName);
  AData.AddInt16(Integer_1070, Word_289);
  AData.AddInt16(Integer_1070, FFlags);
  AData.AddInt16(Integer_1070, Float_239);
  AData.AddDouble(Float_1041, FKoef);
  AData.AddDouble(Float_1043, FEpsilon);
  AData.AddInt16(Integer_1070, FloatRepeated_49);
  for J := Low(FParams) to High(FParams) do
    AData.AddDouble(Float_1042, FParams[J]);
  Result := True;
end;

function TsgAreaFigure.GetAreaStr(const APrecition: Integer;
  const ASeparator: Char = ','): string;
begin
  Result := AreaToStr(Area, APrecition, GetDecimalSeparator);
end;

function TsgAreaFigure.GetFormula(const APrecition: Integer;
  const ASeparator: Char = ','): string;
const
  sAD = ' + ';
  sCP = '; ';
  sDV = ' / ';
  sML = ' * ';
  sSB = ' - ';
  sPI = 'Pi';
  s1Div2 = '0.5';
  sSS = '(';
  sSE = ')';
  sSQ = '=';

  procedure SetParam(const AValue: Double; var Rez: string);
  begin
    Rez := DoubleToStrVisualRound_(AValue * FKoef, APrecition, ASeparator);
  end;

  function Param(const AIndex: Integer): string;
  begin
    case AIndex of
      0:  SetParam(A, Result);
      1:  SetParam(B, Result);
      2:  SetParam(C, Result);
      3:  SetParam(D, Result);
      4:  SetParam(H, Result);
      5:  SetParam(L, Result);
      6:  SetParam(R, Result);
      7:  SetParam(S, Result);      
    else
      Result := DoubleToStrF(A, 2, ASeparator);
    end;
  end;

  function AddSqr(const AIndex: Integer): string;
  begin
    Result := sSqr + sSS + Param(AIndex) + sSE;
  end;

begin
  case FType of
    ftRect:                     Result := Param(0) + sML + Param(1);
    ftSquare:                   Result := AddSqr(0);
    ftQuadrangle:               Result := s1Div2 + sML + Param(2) + sML + Param(3) + sML + sSin + sSS + Param(7) + sSE;
    ftParallelogram:            Result := Param(1) + sML + Param(4);
    ftRhomb:                    Result := s1Div2 + sML + Param(2) + sML + Param(3);
    ftTrapezium:                Result := s1Div2 + sML + sSS + Param(0) + sAD + Param(1) + sSE + sML + Param(4);

    ftTriangle:                 Result := sGeron + sSS + Param(0) + sCP + Param(1) + sCP + Param(2) + sSE;
    ftTriangleRightAngled:      Result := s1Div2 + sML + Param(0) + sML + Param(1);
    ftTriangleByHippuran:       Result := s1Div2 + sML + Param(0) + sML + sSqrt + sSS + AddSqr(2) + sSB + AddSqr(0) + sSE;

    ftCircleByLength:           Result := AddSqr(5) + sDV + sSS + '4' + sML + sPI + sSE;
    ftCircleByRadius:           Result := sPI + sML + AddSqr(6);

    ftSectorByAngleAndRadius:   Result := AddSqr(6) + sML + sRadin + sSS + Param(7)  + sSE;
    ftSegmentByChordAndLength:  Result := sSegmentAL + sSS + Param(0) + sCP + Param(5) + sSE;
    ftSegmentByChordAndHeight:  Result := sSegmentAH + sSS + Param(0) + sCP + Param(4) + sSE;
    ftContour:                  Result := cnstAreaFigues[ftContour] +  sSS + Param(7) + sSE;
  else
    Result := sUNKNOWN;
  end;
end;

function TsgAreaFigure.GetInfo(const APrecition: Integer;
  const ASeparator: Char = ','): string;

  procedure SetParam(const AName: string; const AValue: Double; var Rez: string);
  begin
    Rez := ' ' + AName + ' = ' +
      DoubleToStrVisualRound_(AValue * FKoef, APrecition, ASeparator);
  end;

  function Param(const AIndex: Integer): string;
  begin
    case AIndex of
      0:  SetParam('A', A, Result);//A
      1:  SetParam('B', B, Result);//B
      2:  SetParam('C', C, Result);//C
      3:  SetParam('D', D, Result);//D
      4:  SetParam('H', H, Result);//H
      5:  SetParam('L', L, Result);//L
      6:  SetParam('R', R, Result);//R
      7:  SetParam('S', S, Result);//S      
    else
      Result := ' a = ' + DoubleToStrF(A, 2, ASeparator)//a
    end;
  end;

begin
  Result := Name;
  case FType of
    ftRect:                     Result := Result + Param(0) + Param(1);
    ftSquare:                   Result := Result + Param(0);
    ftQuadrangle:               Result := Result + Param(2) + Param(3) + Param(7);
    ftParallelogram:            Result := Result + Param(1) + Param(4);
    ftRhomb:                    Result := Result + Param(2) + Param(3);
    ftTrapezium:                Result := Result + Param(0) + Param(1) + Param(4);

    ftTriangle:                 Result := Result + Param(0) + Param(1) + Param(2);
    ftTriangleRightAngled:      Result := Result + Param(0) + Param(1);
    ftTriangleByHippuran:       Result := Result + Param(0) + Param(2);

    ftCircleByLength:           Result := Result + Param(5);
    ftCircleByRadius:           Result := Result + Param(6);

    ftSectorByAngleAndRadius:   Result := Result + Param(6) + Param(7);
    ftSegmentByChordAndLength:  Result := Result + Param(0) + Param(5);
    ftSegmentByChordAndHeight:  Result := Result + Param(0) + Param(4);
    ftContour:                  Result := Result + Param(7);
  end;
end;

function TsgAreaFigure.GetName: string;
begin
  if Length(FName) = 0 then
    Result := cnstAreaFigues[FType]
  else
    Result := FName;
end;

function TsgAreaFigure.GetPerimeter: Double;
var
  vRadius, vAngle: Double;
begin
  case FType of
    ftRect:                    Result := (A + B) * 2;
    ftSquare:                  Result := A * 4;
    ftRhomb:
      begin
        Result := Sqr(C) + Sqr(D);
        if Result > fAccuracy then
          Result := 2 * Sqrt(Result)
        else
          Result := 0
      end;
    ftTriangle:               Result := A + B + C;
    ftTriangleRightAngled:
      begin
        Result := Sqr(A) + Sqr(B);
        if Result > fAccuracy then
          Result := A + B + Sqrt(Result)
        else
          Result := A + B;
      end;
    ftTriangleByHippuran:
      begin
        Result :=  Sqr(C) - Sqr(A);
        if Result > fAccuracy then
          Result := A + C + Sqrt(Result)
        else
          Result := C + A;
      end;
    ftCircleByLength:         Result := L;
    ftCircleByRadius:         Result := cnstPiMul2 * R;
    ftSectorByAngleAndRadius: Result := R * (A * fPiDividedBy180 + 2);
    ftSegmentByChordAndLength:Result := A + L;
    ftSegmentByChordAndHeight:
      begin
        Result := 0;
        if (A > fAccuracy) and (H > fAccuracy) then
        begin
          vRadius := GetRadiusByChordAndHeight(A, H);
          if vRadius > fAccuracy then
          begin
            vAngle := GetAngleByChordAndRadius(A, vRadius);
            Result := A + R * vAngle;  
          end;
        end;
      end;
    ftContour: Result := P;
  else
    Result := 0;
  end;
  Result := FKoef * Result;
end;

function TsgAreaFigure.GetSign: Integer;
begin
  case FFlags and 3 of
    1:  Result := -1;
    2:  Result := +1;
  else
    Result := 0;
  end;
end;

procedure TsgAreaFigure.SetKoef(const Value: Double);
begin
  FKoef := Abs(Value);
end;

procedure TsgAreaFigure.SetEpsilon(const Value: Double);
begin
  FEpsilon := Abs(Value);
end;

procedure TsgAreaFigure.SetSign(const Value: Integer);
begin
  FFlags := FFlags and 252;
  if Value > 0 then
    FFlags := FFlags or 2
  else
    if Value < 0 then
      FFlags := FFlags or 1;
end;

{ TsgExtendedBlockData }

procedure TsgExtendedBlockData.Assign(const Source: TsgExtendedBlockData;
  const AMode: Integer = 0);
type
  TsgTypeValue = (tvBoolean, tvByte, tvInteger, tvDouble, tvExtended,
    tvNativeUInt, tvF2DRect, tvColorCAD);

  procedure SetValue(var Pointer1, Pointer2: Pointer; const AType: TsgTypeValue);
  begin
    if Pointer2 <> nil then
    begin
      case AType of
        tvBoolean:
          begin
            if Pointer1 = nil then
              New(PBoolean(Pointer1));
            PBoolean(Pointer1)^ := PBoolean(Pointer2)^;
          end;
        tvByte:
          begin
            if Pointer1 = nil then
              New(PByte(Pointer1));
            PByte(Pointer1)^ := PByte(Pointer2)^;
          end;
        tvInteger:
          begin
            if Pointer1 = nil then
              New(PInteger(Pointer1));
            PInteger(Pointer1)^ := PInteger(Pointer2)^;
          end;
        tvDouble:
          begin
            if Pointer1 = nil then
              New(PDouble(Pointer1));
            PDouble(Pointer1)^ := PDouble(Pointer2)^;
          end;
        tvNativeUInt:
          begin
            if Pointer1 = nil then
              New(PsgNativeUInt(Pointer1));
            PsgNativeUInt(Pointer1)^ := PsgNativeUInt(Pointer2)^;
          end;
        tvF2DRect:
          begin
            if Pointer1 = nil then
              New(PF2DRect(Pointer1));
            PF2DRect(Pointer1)^ := PF2DRect(Pointer2)^;
          end;
        tvColorCAD:
          begin
            if Pointer1 = nil then
              New(PsgColorCAD(Pointer1));
            PsgColorCAD(Pointer1)^ := PsgColorCAD(Pointer2)^;
          end;
      else
        if Pointer1 = nil then
          New(PExtended(Pointer1));
        PExtended(Pointer1)^ := PExtended(Pointer2)^;
      end;
    end
    else
      if Pointer1 <> nil then
      begin
        Dispose(Pointer1);
        Pointer1 := nil;
      end;
  end;

  procedure AssignAttribs;
  var
    I: Integer;
    vSource, vDest: TsgAttributeData;
  begin
    ClearAttribs;
    for I := 0 to Source.FAttribs.Count - 1 do
    begin
      vSource := Source.FAttribs[I];
      if Assigned(vSource) then
      begin
        vDest := TsgAttributeData.Create;
        vDest.Assign(vSource);
        FAttribs.Add(vDest);
      end;
    end;
  end;

var
  I: Integer;
begin
  FFlags := Source.FFlags;
  SetValue(Pointer(FAlignment), Pointer(Source.FAlignment), tvBoolean);
  SetValue(Pointer(FCarvingMode), Pointer(Source.FCarvingMode), tvByte);
  SetValue(Pointer(FFillColor), Pointer(Source.FFillColor), tvColorCAD);
  LineType := Source.LineType;//SetValue(Pointer(FLineType), Pointer(Source.FLineType), tvNativeUInt);//By PPointer
  SetValue(Pointer(FIsCircular), Pointer(Source.FIsCircular), tvBoolean);
  SetValue(Pointer(FBoundaryVisible), Pointer(Source.FBoundaryVisible), tvBoolean);
  SetValue(Pointer(FLength), Pointer(Source.FLength), tvDouble);
  SetValue(Pointer(FSegmentsCount), Pointer(Source.FSegmentsCount), tvInteger);
  SetValue(Pointer(FSegmentWidths), Pointer(Source.FSegmentWidths), tvF2DRect);
  SetValue(Pointer(FTypeSnapEntities), Pointer(Source.FTypeSnapEntities), tvInteger);
  SetValue(Pointer(FWidth), Pointer(Source.FWidth), tvDouble);
  SetValue(Pointer(FInsUnits), Pointer(Source.FInsUnits), tvByte);
  Parent := Source.Parent;
  FValueMask := Source.FValueMask;
  for I := Low(FLabelText) to High(FLabelText) do
    FLabelText[I] := Source.FLabelText[I];
  FLabelFlags := Source.FLabelFlags;
  AssignAttribs;
  // ver 11.0
  FEditorFlags := Source.FEditorFlags;
  FSegmentsMode := Source.FSegmentsMode;
  FSegmentsLength:= Source.FSegmentsLength;
  FSegmentBegin := Source.FSegmentBegin;
  FSegmentEnd := Source.FSegmentEnd;
  FSegmentGap := Source.FSegmentGap;
  FFlightOfSteps := Source.FFlightOfSteps;
  FGapAngle := Source.FGapAngle;
  FAreaFlags := Source.FAreaFlags;
  FComplexFlags := Source.FComplexFlags;
  FElementFlags := Source.FElementFlags;
  FCategory := Source.FCategory;
  FSign := Source.FSign;
  FName := Source.FName;
  FLayer := Source.FLayer;
end;

function TsgExtendedBlockData.CopyProps(const Source: TsgExtendedBlockData;
  const AConverter: TsgDXFConverter): Boolean;
var
  vStrXml, vDescriptions, vEntDescription: string;
begin
  Result := False;
  vStrXml := Source.GetXML('', '');
  if System.Length(vStrXml) > 0 then
  begin
    ClearAttribs;
    if SetXML(vStrXml, AConverter, vDescriptions, vEntDescription, nil) then
      Result := True;
  end;
end;

function TsgExtendedBlockData.GetXML(const ADescriptions: string;
  const AEntDescription: string): string;
var
  vXMLParser: TsgParser;
  FRootOut, vNode, vAttribut, vNodeLabel: TsgNode;
  I: Integer;
begin
  vXMLParser := TsgParser.Create;
  try
    FRootOut := TsgNode(vXMLParser.CreateRootNode.AddChildNV(cnstBTIExtData));
    FRootOut.AddAttribNV(cnstVersion).ValueData.ValueAsVersion := cnstBTIExtDataVersion;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlFlags].Name). TextData.ValueAsInt := FFlags;
    if FInsUnits <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlInsUnits].Name).TextData.ValueAsInt := Integer(InsUnits);
    if FFillColor <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlFillColor].Name).TextData.ValueAsInt := FillColor;
    if FCarvingMode <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlCarvingMode].Name).TextData.ValueAsInt := CarvingMode;
    if FIsCircular <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlIsCircular].Name).TextData.ValueAsBool := IsCircular;
    if FTypeSnapEntities <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlTypeSnapEntities].Name).TextData.ValueAsInt := TypeSnapEntities;
    if FSegmentsCount <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSegmentsCount].Name).TextData.ValueAsInt := SegmentsCount;
    if FAlignment <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlAlignment].Name).TextData.ValueAsBool := Alignment;
    if FBoundaryVisible <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlBoundaryVisible].Name).TextData.ValueAsBool := BoundaryVisible;
    if FLength <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlLength].Name).TextData.ValueAsDouble := Length;
    if FWidth <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlWidth].Name).TextData.ValueAsDouble := Width;
    if FSegmentWidths <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSegmentWidths].Name).TextData.ValueAsF2DRect := SegmentWidths;
    if Assigned(Parent) then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlParent].Name).TextData.ValueAsText := Parent.Name;
    if LineType <> nil then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlLineType].Name).TextData.ValueAsText := LineType.Name
    else
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlLineType].Name).TextData.ValueAsText := sContinuous;
    if System.Length(FValueMask) > 0  then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlValueMask].Name).TextData.ValueAsText := ValueMask;
    vNodeLabel := FRootOut.AddChildNV(cnstBTIXMLNames[bxmlLabel].Name);
    vNodeLabel.AddAttribNV(cnstBTIXMLNames[bxmlFlags].Name).ValueAsInt := FLabelFlags;
    for I := Low(FLabelText) to High(FLabelText) do
      vNodeLabel.AddChildNV(cnstBTIXMLNames[bxmlItem].Name).TextData.ValueAsText := FLabelText[I];
    if AttributesCount > 0 then
    begin
      vNode := FRootOut.AddChildNV(cnstBTIXMLNames[bxmlAttributes].Name);
      for I := 0 to AttributesCount - 1 do
      begin
        vAttribut := vNode.AddChildNV(cnstBTIXMLNames[bxmlAttribut].Name);
        Attributes[I].ToNode(vAttribut);
      end;
    end;
    if System.Length(ADescriptions) > 0 then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlDescriptions].Name).TextData.ValueAsText := ADescriptions;
    if System.Length(AEntDescription) > 0 then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlEntDescription].Name).TextData.ValueAsText := ADescriptions;
    //ver 1.0
    if FEditorFlags <> 0 then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlEditorFlags].Name).TextData.ValueAsInt := FEditorFlags;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlDiffWidths].Name).TextData.ValueAsBool := DiffWidths;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSegmentsByLength].Name).TextData.ValueAsBool := SegmentsByLength;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSegmentsLength].Name).TextData.ValueAsDouble := SegmentsLength;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlStairs].Name).TextData.ValueAsBool := IsStairs;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSegmentBegin].Name).TextData.ValueAsDouble := SegmentBegin;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSegmentEnd].Name).TextData.ValueAsDouble := SegmentEnd;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSegmentGap].Name).TextData.ValueAsDouble := FSegmentGap;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlFlightOfSteps].Name).TextData.ValueAsInt := Byte(FFlightOfSteps);
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlGapAngle].Name).TextData.ValueAsDouble := FGapAngle;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlElementFlags].Name).TextData.ValueAsInt := FElementFlags;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlAreaFlags].Name).TextData.ValueAsInt := FAreaFlags;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlSign].Name).TextData.ValueAsInt := FSign;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlName].Name).TextData.ValueAsStr := FName;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlLayer].Name).TextData.ValueAsStr := FLayer;
    FRootOut.AddChildNV(cnstBTIXMLNames[bxmlComplexFlags].Name).TextData.ValueAsInt := FComplexFlags;
    if FCategory <> 0 then
      FRootOut.AddChildNV(cnstBTIXMLNames[bxmlCategory].Name).TextData.ValueAsInt := FCategory;
    Result := vXMLParser.SaveToString;
  finally
    vXMLParser.Free;
  end;
end;

function TsgExtendedBlockData.SetXML(const AXML: string; AConv: TsgDXFConverter;
  var ADescriptions: string; var AEntDescription: string;
  const AVersion: PsgVersion): Boolean;
var
  vXMLParser: TsgParser;
  FRootOut: TsgNode;
  vAttributes, vNodeAttr: TsgNodeSample;
  I, J: Integer;
  vVersion: TsgVersion;
  vName, vValue: string;
  vChild, vLabel: TsgNodeSample;
  vNodeType: TsgBTIXMLType;
  vCheckVersion: Boolean;
  vXDataProcs: TsgXDataProcs;
begin
  Result := False;
  ADescriptions := '';
  AEntDescription := '';
  vXMLParser := TsgParser.Create;
  try
    if not vXMLParser.LoadFromString(AXML) then
      Exit;
    FRootOut := TsgNode(vXMLParser.ROOT.NodeByName[cnstXML].GetChildByName(cnstBTIExtData));
    if Assigned(FRootOut) then
    begin
      FEditorFlags := 0;
      FElementFlags := 0;
      FAreaFlags := 0;
      FComplexFlags := 0;
      FCategory := 0;
      FLabelFlags := -1;
      for J := Low(FLabelText) to High(FLabelText) do
        FLabelText[J] := vValue;
      FLabelText[1] := cnstParamType[ptValue];
      FLabelText[3] := cnstParamType[ptArea];
      vVersion := FRootOut.GetAttributeByName(cnstVersion).ValueData.ValueAsVersion;
      if AVersion <> nil then
        AVersion^ := vVersion;
      vCheckVersion := vVersion.Major <= cnstBTIExtDataVersion.Major;
//      if vCheckVersion then
      begin
        for I := 0 to FRootOut.ChildNodesCount - 1 do
        begin
          vChild := FRootOut.ChildNodes[I];
          vNodeType := sgConsts.GetXMLBTITypeEx(vChild.Name);
          case vNodeType.Id of
            bxmlFlags: FFlags := vChild.TextData.ValueAsInt;
            bxmlAlignment: Alignment := vChild.TextData.ValueAsBool;
            bxmlCarvingMode: CarvingMode := vChild.TextData.ValueAsInt;
            bxmlFillColor: FillColor := vChild.TextData.ValueAsInt;
            bxmlIsCircular: IsCircular := vChild.TextData.ValueAsBool;
            bxmlBoundaryVisible: BoundaryVisible := vChild.TextData.ValueAsBool;
            bxmlLength: Length := vChild.TextData.ValueAsDouble;
            bxmlSegmentsCount: SegmentsCount := vChild.TextData.ValueAsInt;
            bxmlSegmentWidths: SegmentWidths := vChild.TextData.ValueAsF2DRect;
            bxmlTypeSnapEntities: TypeSnapEntities := vChild.TextData.ValueAsInt;
            bxmlWidth: Width := vChild.TextData.ValueAsDouble;
            bxmlValueMask: ValueMask := vChild.TextData.ValueAsText;
            bxmlLabel:
              begin
                vLabel := vChild;
                FLabelFlags := vLabel.GetAttributeByName(cnstBTIXMLNames[bxmlFlags].Name).ValueAsInt;
                for J := Low(FLabelText) to High(FLabelText) do
                begin
                  vValue := '';
                  if J < vLabel.ChildNodesCount then
                    vValue := vLabel.ChildNodes[J].TextData.ValueAsText;
                  FLabelText[J] := vValue;
                end;
              end;
            bxmlInsUnits: InsUnits := TsgInsUnits(vChild.TextData.ValueAsInt);
            bxmlLineType:
              begin
                if Assigned(AConv) then
                begin
                  vName := vChild.TextData.ValueAsText;
                  LineType := AConv.LTypeByName(vName);
                end;
              end;
            bxmlParent:
              begin
                vName := vChild.TextData.ValueAsText;
                FParentName := vName;
              end;
            bxmlDescriptions: ADescriptions := vChild.TextData.ValueAsText;
            bxmlEntDescription: AEntDescription := vChild.TextData.ValueAsText;
            bxmlAttributes:
              begin
                vAttributes := vChild;
                for J := 0 to vAttributes.ChildNodesCount - 1 do
                begin
                  vNodeAttr := vAttributes.ChildNodes[J];
                  AddAttribute(vNodeAttr);
                end;
              end;
//ver 1.0
            bxmlEditorFlags:       FEditorFlags := vChild.TextData.ValueAsInt;
            bxmlDiffWidths:        DiffWidths := vChild.TextData.ValueAsBool;
            bxmlSegmentsByLength:  SegmentsByLength := vChild.TextData.ValueAsBool;
            bxmlSegmentsLength:    SegmentsLength := vChild.TextData.ValueAsDouble;
            bxmlStairs:            IsStairs := vChild.TextData.ValueAsBool;
            bxmlSegmentBegin:      SegmentBegin := vChild.TextData.ValueAsDouble;
            bxmlSegmentEnd:        SegmentEnd := vChild.TextData.ValueAsDouble;
            bxmlSegmentGap:        SegmentGap := vChild.TextData.ValueAsDouble;
            bxmlFlightOfSteps:     FlightOfSteps := TsgFlightOfSteps(vChild.TextData.ValueAsInt);
            bxmlGapAngle:          GapAngle := vChild.TextData.ValueAsDouble;
            bxmlElementFlags:      FElementFlags := vChild.TextData.ValueAsInt;
            bxmlAreaFlags:         FAreaFlags := vChild.TextData.ValueAsInt;
            bxmlSign:              FSign := vChild.TextData.ValueAsInt;
            bxmlName:              FName := vChild.TextData.ValueAsStr;
            bxmlLayer:             FLayer := vChild.TextData.ValueAsStr;
            bxmlComplexFlags:      FComplexFlags := vChild.TextData.ValueAsInt;
            bxmlCategory:          FCategory := vChild.TextData.ValueAsInt;
          end;
        end;
        Result := True;
      end;
      if not vCheckVersion then
      begin
        vXDataProcs := AConv.XDataProcs;
        if Assigned(vXDataProcs) then
        begin
          if vXDataProcs.Warning(AConv, cnstWarningMsgType_InvalidVersion) <> cnstWarning_OK then
            raise EsgInvalidVersion.Create(cnstInvalidVersionBTIEntities);
        end;
      end;
    end;
  finally
    vXMLParser.Free;
  end;
end;

function TsgExtendedBlockData.AddAttribute(const AName, AValue: string;
  const AFlags: Integer; AType: TsgAttribType; ValuesList: TStringList = nil;
  const ASort: Boolean = False): TsgAttributeData;
var
  AttrData: TsgAttributeData absolute Result;
begin
  AttrData := TsgAttributeData.Create;
  try
    AttrData.AttribType := AType;
    AttrData.Flags := AFlags;
    AttrData.Name := AName;
    AttrData.Value := AValue;
    case AttrData.AttribType of
      atString, atInteger, atDouble, atPoint: ;
      atEnum:
        if ValuesList <> nil then
        begin
          AttrData.CreateValues;
          AttrData.Values.Assign(ValuesList);
          if ASort then
            AttrData.Values.Sort;
        end;
    end;
  finally
    FAttribs.Add(AttrData);
  end;
end;

function TsgExtendedBlockData.AddAttribute(const ANode: TsgNodeSample;
  const ASort: Boolean = False): TsgAttributeData;
var
  AttrData: TsgAttributeData absolute Result;
begin
  AttrData := TsgAttributeData.Create;
  try
    AttrData.FromNode(TsgNode(ANode));
    if ASort then
      AttrData.Values.Sort;
  finally
    FAttribs.Add(AttrData);
  end;
end;

function TsgExtendedBlockData.AddAttributeWithCorrecting(const AName, AValue: string;
  const AFlags: Integer; const AType: TsgAttribType;
  const AVisible: PBoolean; const APoint: PFPoint;
  const AClassifierData: TStringList = nil): TsgAttributeData;
var
  vValue: string;
  vAttribValues: TStringList;
  vClassifierData: TStringList;
begin
  Result := nil;
  vValue := AValue;
  case AType of
    atString, atSoftLink, atInteger, atDouble, atXMLLink:
      begin
        case AType of
          atInteger: vValue := CheckStringInteger(vValue);
          atDouble:  vValue := CheckStringDouble(vValue);
          atXMLLink:
            begin
              vClassifierData := AClassifierData;
              try
                if not Assigned(vClassifierData) then
                begin
                  vClassifierData := TStringList.Create;
                  GetClassifiers.GetClassifiers(vClassifierData);
                end;
                if (not Assigned(vClassifierData)) or (vClassifierData.IndexOf(vValue) = -1) then
                  vValue := '';
              finally
                if vClassifierData <> AClassifierData then
                  vClassifierData.Free;
              end;
            end;
        end;
        Result := AddAttribute(AName, vValue, AFlags, AType, nil);
      end;
    atPoint:
      begin
        vValue := CheckStringFPoint(vValue);
        Result := AddAttribute(AName, vValue, AFlags, AType, nil);
      end;
    atEnum:
      begin
        vAttribValues := TStringList.Create;
        try
          vAttribValues.LineBreak := cnstEnumValuesDelimiter;
          vAttribValues.Text := vValue;
          Result := AddAttribute(AName, '', AFlags, atEnum, vAttribValues);
        finally
          vAttribValues.Free;
        end;
      end;
    atMText:
      begin
        vValue := SetTextStr(vValue);
        Result := AddAttribute(AName, vValue, AFlags, AType, nil);
      end;
  end;
  if Assigned(Result) then
  begin
    if AVisible <> nil then
      Result.Visible := AVisible^;
    if APoint <> nil then
      Result.Point := APoint^;
  end;
end;

procedure TsgExtendedBlockData.ClearAttribs;
begin
  while FAttribs.Count > 0 do
    DeleteAttribute(0);
end;

constructor TsgExtendedBlockData.Create;
begin
  inherited Create;
  FAttribs := TList.Create;
  FLineTypeItem := TsgTableItem.Create;
  FLabelFlags := -1;
  FSegmentGap := cnstDefaultGapSegment;
  FGapAngle := cnstDefaultGapAngle;
end;

procedure TsgExtendedBlockData.DeleteAttribute(AIndex: Integer;
  const ADoFree: Boolean = True);
var
  P: TsgAttributeData;
begin
  P := FAttribs[AIndex];
  FAttribs.Delete(AIndex);
  if ADoFree and (P <> nil) then
    P.Free;
end;

function TsgExtendedBlockData.IndexOfAttribName(const AName: string): Integer;
begin
  Result := -1;
  if Assigned(FAttribs) then
  begin
    Result := 0;
    while (Result < FAttribs.Count) and (TsgAttributeData(FAttribs.List[Result]).Name <> AName) do
      Inc(Result);
    if Result >= FAttribs.Count then
      Result := -1;
  end;
end;

destructor TsgExtendedBlockData.Destroy;
begin
  ClearAttribs;
  FAttribs.Free;
  DisposeAndNil(FCarvingMode);
  DisposeAndNil(FInsUnits);
  DisposeAndNil(FIsCircular);
  DisposeAndNil(FLength);
  DisposeAndNil(FSegmentsCount);
  DisposeAndNil(FSegmentWidths);
  DisposeAndNil(FTypeSnapEntities);
  DisposeAndNil(FWidth);
  DisposeAndNil(FFillColor);
  DisposeAndNil(FBoundaryVisible);
  LineType := nil;
  FreeAndNil(FLineTypeItem);
  inherited Destroy;
end;

function TsgExtendedBlockData.GetAlignment: Boolean;
begin
  if FAlignment <> nil then
    Result := FAlignment^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetAlignment
    else
      Result := True;
end;

function TsgExtendedBlockData.GetArea: Boolean;
begin
  Result := FFlags in [cnstArea, cnstComplexArea];
end;

function TsgExtendedBlockData.GetAttribute(AIndex: Integer): TsgAttributeData;
begin
  Result := TsgAttributeData(FAttribs[AIndex]);
end;

function TsgExtendedBlockData.GetAttributesCount: Integer;
begin
  Result := FAttribs.Count;
end;

function TsgExtendedBlockData.GetBlockPatternName: string;
begin
  Result := FName;
end;

function TsgExtendedBlockData.GetBroad: Boolean;
begin
  Result := FFlags in [cnstComplexBroad, cnstElementBroad, cnstElementCarved];
end;

function TsgExtendedBlockData.GetBoundaryVisible: Boolean;
begin
  if FBoundaryVisible <> nil then
    Result := FBoundaryVisible^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetBoundaryVisible
    else
      Result := False;
end;

function TsgExtendedBlockData.GetCarvingMode: Byte;
begin
  if FCarvingMode <> nil then
    Result := FCarvingMode^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetCarvingMode
    else
      Result := 2;
end;

function TsgExtendedBlockData.GetCircular: Boolean;
begin
  if FIsCircular <> nil then
    Result := FIsCircular^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetCircular
    else
      Result := False;
end;

function TsgExtendedBlockData.GetComplex: Boolean;
begin
  Result := FFlags in [cnstComplex, cnstComplexBroad, cnstComplexLinear, cnstComplexArea];
end;

function TsgExtendedBlockData.GetContour: Boolean;
begin
  Result := FAreaFlags and 1 <> 0;
end;

function TsgExtendedBlockData.GetDiffWidths: Boolean;
begin
  Result := FSegmentsMode and 4 <> 0;
end;

function TsgExtendedBlockData.GetFillColor: TColor;
var
  vColorCAD: TsgColorCAD;
begin
  vColorCAD := GetFillColorCAD;
  if (vColorCAD.Active = acRGBColor) and (vColorCAD.Color = clEmpty) then
    Result := clEmpty
  else
    Result := ConvertColorCADToRGB(vColorCAD);
end;

function TsgExtendedBlockData.GetFillColorCAD: TsgColorCAD;
begin
  if FFillColor <> nil then
    Result := FFillColor^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetFillColorCAD
    else
      Result := cnstColorCADEmpty;
end;

function TsgExtendedBlockData.GetFlightOfSteps: TsgFlightOfSteps;
begin
  Result := FFlightOfSteps;
end;

function TsgExtendedBlockData.GetGapAngle: Double;
begin
  Result := FGapAngle;
end;

function TsgExtendedBlockData.GetWidthOwner: Boolean;
begin
  Result := (FElementFlags and 1) = 0;
end;

function TsgExtendedBlockData.GetInsUnits: TsgInsUnits;
begin
  if FInsUnits <> nil then
    Result := TsgInsUnits(FInsUnits^)
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetInsUnits
    else
      Result := TsgInsUnits(cnstSGHeadVarStruct.InsUnits);
end;

function TsgExtendedBlockData.GetLayer: string;
begin
  if System.Length(FLayer) > 0 then
    Result := FLayer
  else  
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetLayer
    else
    begin
      Result := cnstSGHeadVarStruct.CLayer;
      if System.Length(Result) = 0 then
        Result := cnstBlockPatternLayer;
    end;
end;

function TsgExtendedBlockData.GetLength: Double;
begin
  if FLength <> nil then
    Result := FLength^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetLength
    else
      Result := fAccuracy;
end;

function TsgExtendedBlockData.GetLineType: TsgDXFLineType;
begin
  if FLineTypeItem.Item <> nil then
    Result := TsgDXFLineType(FLineTypeItem.Item)
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetLineType
    else
      Result := nil;
end;

function TsgExtendedBlockData.GetValueMask: string;
begin
  Result := FValueMask;
  if FValueMask = '' then
  begin
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetValueMask
    else
    begin
      case GetBTITypeByEntTypeEx(Flags) of
        btiArea, btiComplexArea:  Result := cnstDefaultValueMask;
      end;
    end;
  end;
end;

function TsgExtendedBlockData.GetLabelFlags: Integer;
begin
  Result := FLabelFlags;
end;

function TsgExtendedBlockData.GetLabelText(const AIndex: Integer): string;
begin
   Result := '';
  if AIndex <= High(FLabelText) then
    Result := FLabelText[AIndex];
end;

function TsgExtendedBlockData.GetSegmentsCount: Integer;
begin
  if FSegmentsCount <> nil then
    Result := FSegmentsCount^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
        Result := TsgExtendedBlockData(Parent.GetExtendedData).GetSegmentsCount
      else
        Result := 0;
end;

function TsgExtendedBlockData.GetSegmentsLength: Double;
begin
  Result := FSegmentsLength;
end;

function TsgExtendedBlockData.GetSegmentBegin: Double;
begin
  Result := FSegmentBegin;
end;

function TsgExtendedBlockData.GetSegmentEnd: Double;
begin
  Result := FSegmentEnd;
end;

function TsgExtendedBlockData.GetSegmentGap: Double;
begin
  Result := FSegmentGap;
end;

function TsgExtendedBlockData.GetSegmentsByLength: Boolean;
begin
  Result := FSegmentsMode and 2 <> 0;
end;

function TsgExtendedBlockData.GetSegmentWidths: TF2DRect;
var
  W: Double;
begin
  if FSegmentWidths  <> nil then
    Result := FSegmentWidths^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetSegmentWidths
      else
      begin
        W := Width * 0.5;
        Result := MakeF2DRect(W, W, W, W);
      end;
end;

function TsgExtendedBlockData.GetSign: Integer;
begin
  case FSign of
    1:  Result := 0;
    2:  Result:= -1;
  else
    Result := 1;
  end;
end;

function TsgExtendedBlockData.GetSize: TF2DPoint;
begin
  Result.X := Length;
  Result.Y := Width;
end;

function TsgExtendedBlockData.GetStairs: Boolean;
begin
  Result := FSegmentsMode and 1 <> 0;
end;

function TsgExtendedBlockData.GetStaggeredView: Integer;
begin
  Result := FComplexFlags and 3;//used 2 bites
end;

function TsgExtendedBlockData.GetTypeSnapEntities: Integer;
begin
  if FTypeSnapEntities <> nil then
    Result := FTypeSnapEntities^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetTypeSnapEntities
    else
      Result := -1;
end;

function TsgExtendedBlockData.GetWidth: Double;
begin
  if FWidth <> nil then
    Result := FWidth^
  else
    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
      Result := TsgExtendedBlockData(Parent.GetExtendedData).GetWidth
    else
      Result := fAccuracy;
end;

function TsgExtendedBlockData.GetDeletable: Boolean;
begin
  Result := FEditorFlags and 1 = 0;
end;

function TsgExtendedBlockData.GetEditable: Boolean;
begin
  Result := FEditorFlags and 2 = 0;
end;

function TsgExtendedBlockData.GetVertexMode: Byte;
begin
  Result := (FAreaFlags shr 4) and $F;
end;

function TsgExtendedBlockData.GetCategory: Byte;
begin
  Result := FCategory;
end;

//function TsgExtendedBlockData.HasSegmentWidths: Boolean;
//begin
//  if FSegmentWidths  <> nil then
//    Result := True
//  else
//    if (Parent <> nil) and (Parent.GetExtendedData <> nil) then
//        Result := TsgExtendedBlockData(Parent.GetExtendedData).HasSegmentWidths
//      else
//        Result := False;
//end;

procedure TsgExtendedBlockData.SetAlignment(const Value: Boolean);
begin
  if FAlignment = nil then
    New(FAlignment);
  FAlignment^ := Value;
end;

procedure TsgExtendedBlockData.SetBlockPatternName(const Value: string);
begin
  FName := Value;
end;

procedure TsgExtendedBlockData.SetBoundaryVisible(const AValue: Boolean);
begin
  if FBoundaryVisible = nil then
    New(FBoundaryVisible);
  FBoundaryVisible^ := AValue;
end;

procedure TsgExtendedBlockData.SetCarvingMode(const Value: Byte);
begin
  if FCarvingMode = nil then
    New(FCarvingMode);
  FCarvingMode^ := Value;
end;

procedure TsgExtendedBlockData.SetDiffWidths(const Value: Boolean);
begin
  FSegmentsMode := (FSegmentsMode and 251) or (Integer(Value) shl 2);
end;

procedure TsgExtendedBlockData.SetCircular(const Value: Boolean);
begin
  if FIsCircular = nil then
    New(FIsCircular);
  FIsCircular^ := Value;
end;

procedure TsgExtendedBlockData.SetContour(const Value: Boolean);
begin
  FAreaFlags := (FAreaFlags and Integer($FFFFFFFE)) or Ord(Value);
end;

procedure TsgExtendedBlockData.SetFillColor(const Value: TColor);
begin
  if Value = clEmpty then
    SetFillColorCAD(MakeColorCAD(acRGBColor, clEmpty))
  else
    SetFillColorCAD(ConvertColortoColorCAD(Value));
end;

procedure TsgExtendedBlockData.SetFillColorCAD(const Value: TsgColorCAD);
begin
  if FFillColor = nil then
    New(FFillColor);
  FFillColor^ := Value;
end;

procedure TsgExtendedBlockData.SetFlightOfSteps(const Value: TsgFlightOfSteps);
begin
  FFlightOfSteps := Value;
end;

procedure TsgExtendedBlockData.SetGapAngle(const Value: Double);
begin
  FGapAngle := Value;
end;

procedure TsgExtendedBlockData.SetInsUnits(const Value: TsgInsUnits);
begin
  if FInsUnits = nil then
    New(FInsUnits);
  FInsUnits^ := Byte(Value);
end;

procedure TsgExtendedBlockData.SetLayer(const Value: string);
begin
  FLayer := Value;
end;

procedure TsgExtendedBlockData.SetLength(const Value: Double);
begin
  if FLength = nil then
    New(FLength);
  FLength^ := Value;
end;

procedure TsgExtendedBlockData.SetLineType(const Value: TsgDXFLineType);
begin
  FLineTypeItem.Item := Value;
end;

procedure TsgExtendedBlockData.SetValueMask(const Value: string);
begin
  FValueMask := Value;
end;

procedure TsgExtendedBlockData.SetLabelFlags(const Value: Integer);
begin
  FLabelFlags := Value;
end;

procedure TsgExtendedBlockData.SetLabelText(const AIndex: Integer; const Value: string);
begin
  if AIndex <= High(FLabelText) then
   FLabelText[AIndex] := Value;
end;

procedure TsgExtendedBlockData.SetSegmentsCount(const Value: Integer);
begin
  if FSegmentsCount = nil then
    New(FSegmentsCount);
  FSegmentsCount^ := Value;
  if FSegmentsCount^ < 1 then
    DisposeAndNil(FSegmentWidths);
end;

procedure TsgExtendedBlockData.SetSegmentsLength(const Value: Double);
begin
  FSegmentsLength := Value;
end;

procedure TsgExtendedBlockData.SetSegmentBegin(const Value: Double);
begin
  FSegmentBegin := Value;
end;

procedure TsgExtendedBlockData.SetSegmentEnd(const Value: Double);
begin
  FSegmentEnd := Value;
end;

procedure TsgExtendedBlockData.SetSegmentGap(const Value: Double);
begin
  FSegmentGap := Value;
end;

procedure TsgExtendedBlockData.SetSegmentsByLength(const Value: Boolean);
begin
  FSegmentsMode := (FSegmentsMode and 253) or (Integer(Value) shl 1);
end;

procedure TsgExtendedBlockData.SetSegmentWidths(const Value: TF2DRect);
begin
  if FSegmentWidths = nil then
    New(FSegmentWidths);
  FSegmentWidths^ := Value;
end;

procedure TsgExtendedBlockData.SetSign(const AValue: Integer);
begin
  if AValue > 0 then
    FSign := 0
  else
    if AValue = 0 then
      FSign := 1
    else
      FSign := 2;
end;

procedure TsgExtendedBlockData.SetSize(const Value: TF2DPoint);
begin
  Length := Value.X;
  Width := Value.Y;
end;

procedure TsgExtendedBlockData.SetStairs(const Value: Boolean);
begin
  FSegmentsMode := (FSegmentsMode and 254) or Integer(Value);
end;

procedure TsgExtendedBlockData.SetStaggeredView(const AValue: Integer);
var
  vValue: Integer;
begin
  vValue := 0;
  if (AValue >= 0) and (AValue <= 3) then
    vValue := AValue;
  FComplexFlags := (FComplexFlags and Integer($FFFFFFFC)) or vValue;
end;

procedure TsgExtendedBlockData.SetParent(const AValue: TsgDXFBlock);
begin
  FParent := AValue;
end;

procedure TsgExtendedBlockData.SetParentName(const AValue: string);
begin
  FParentName := AValue;
end;

procedure TsgExtendedBlockData.SetTypeSnapEntities(const Value: Integer);
begin
  if FTypeSnapEntities = nil then
    New(FTypeSnapEntities);
  FTypeSnapEntities^ := Value;
end;

procedure TsgExtendedBlockData.SetWidth(const Value: Double);
begin
  if FWidth = nil then
    New(FWidth);
  FWidth^ := Value;
end;

procedure TsgExtendedBlockData.SetWidthOwner(const AValue: Boolean);
begin
  FElementFlags := (FElementFlags and Integer($FFFFFFFE)) or Ord(not AValue);
end;

procedure TsgExtendedBlockData.SetDeletable(const AValue: Boolean);
begin
  FEditorFlags := (FEditorFlags and $FFFE) or Integer(not AValue);
end;

procedure TsgExtendedBlockData.SetEditable(const AValue: Boolean);
begin
  FEditorFlags := (FEditorFlags and $FFFD) or (Integer(not AValue) shl 1);
end;

procedure TsgExtendedBlockData.SetVertexMode(const AValue: Byte);
begin
  FAreaFlags := (FAreaFlags and $FFFFFF0F) or ((AValue shl 4) and $F0);
end;

procedure TsgExtendedBlockData.SetCategory(const AValue: Byte);
begin
  FCategory := AValue;
end;

{$ENDIF}
{ TsgMLineStyle }

constructor TsgMLineStyle.Create;
begin
  inherited Create;
  FEntries := TsgEntitiesList(TsgEntitiesList.CreateList(ListNotify));
end;

procedure TsgMLineStyle.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FEntries);
end;

function TsgMLineStyle.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
end;

procedure TsgMLineStyle.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  ClearEntCollection(FEntries, ADoFree);
end;

function TsgMLineStyle.GetCount: Integer;
begin
  Result := FEntries.Count;
end;

function TsgMLineStyle.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := GetEntry(AIndex);
end;

function TsgMLineStyle.GetEntry(Index: Integer): TsgMLineEntry;
begin
  Result := TsgMLineEntry(FEntries[Index]);
end;

procedure TsgMLineStyle.NewEntry(AOffset: Double; AColor: TsgColorCAD; ALType: TsgDXFLineType);
var
  M: TsgMLineEntry;
begin
  M := TsgMLineEntry.Create;
  M.Offset := AOffset;
  M.ColorCAD := AColor;
  M.LineType := ALType;
  FEntries.Add(M);
end;

function TsgMLineStyle.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
end;

function TsgMLineStyle.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := AEntity is TsgMLineEntry;
  if Result then
    FEntries.Insert(AIndex, AEntity);
end;

procedure TsgMLineStyle.AssignEntity(Source: TsgDXFEntity);
var
  M: TsgMLineStyle absolute Source;
  E: TsgMLineEntry;
  I: Integer;
begin
  inherited AssignEntity(Source);
  if Source is TsgMLineStyle then
  begin
    Flags := M.Flags;
    Clear;
    for I := 0 to M.Count - 1 do
    begin
      E := M[I];
      NewEntry(E.Offset, E.ColorCAD, E.LineType);
    end;
  end;
end;

{ TsgMVertex }

constructor TsgMVertex.Create;
begin
  inherited Create;
  FParams := TsgObjectList.Create;
end;

procedure TsgMVertex.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FParams);
end;

function TsgMVertex.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
var
  I: Integer;
  vParamNode: TsgNodeSample;
  vList: TsgSingleList;
  vValueStr: string;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlPoint:      Point := ANode.ValueAsFPoint;
    xmlDirection:  Direction := ANode.ValueAsFPoint;
    xmlMiter:      Miter := ANode.ValueAsFPoint;
    xmlPatterns:
      begin
        vList := nil;
        try
          TsgObjectList.ClearList(FParams);
          for I := 0 to ANode.ChildNodesCount - 1 do
          begin
            vParamNode := ANode.ChildNodes[I];
            if SameText(vParamNode.Name, cnstXMLNames[xmlPattern].Name) then
            begin
              vValueStr := GetAttributeStr(vParamNode, cnstXMLNames[xmlValue].Name, '');
              if Length(vValueStr) > 0 then
              begin
                vList := NewList;
                vList.FromStr(vValueStr, cnstCommaPoint);
              end;
            end;
          end;
        finally
          if Assigned(vList) then
            Complete;
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgMVertex.GetPCount(Index: Integer): Integer;
begin
  Result := TsgSingleList(FParams[Index]).Count;
end;

function TsgMVertex.GetParam(I1,I2: Integer): Single;
begin
  Result := TsgSingleList(FParams[I1])[I2];
end;

function TsgMVertex.GetParamsCount: Integer;
begin
  Result := FParams.Count;
end;

function TsgMVertex.GetParamsList: TsgObjectList;
begin
  Result := FParams;
end;

procedure TsgMVertex.SetDirection(const AValue: TFPoint);
begin
  FDirection := AValue;
end;

procedure TsgMVertex.SetMiter(const AValue: TFPoint);
begin
  FMiter := AValue;
end;

procedure TsgMVertex.SetParam(I1,I2: Integer; Value: Single);
begin
  TsgSingleList(FParams[I1])[I2] := Value;
end;

procedure TsgMVertex.SetPoint(const AValue: TFPoint);
begin
  FPoint := AValue;
end;

function TsgMVertex.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vList: TsgSingleList;
  vParamsNode, vParamNode: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlPoint].Name).ValueData,
    FPoint, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlDirection].Name).ValueData,
    FDirection, xmlForViewing in AParams.Mode);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlMiter].Name).ValueData,
    FMiter, xmlForViewing in AParams.Mode);
  vParamsNode := ANode.AddChildNV(cnstXMLNames[xmlPatterns].Name);
  vParamsNode.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := ParamsCount;
  for I := 0 to ParamsCount - 1 do
  begin
    vParamNode := vParamsNode.AddChildNV(cnstXMLNames[xmlPattern].Name);
    vList := TsgSingleList(FParams[I]);
    if Assigned(vList) then
    begin
      vParamNode.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := vList.Count;
      vParamNode.AddAttribNV(cnstXMLNames[xmlValue].Name).ValueAsStr := vList.ToStr(cnstCommaPoint);
    end;
  end;
end;

procedure TsgMVertex.Add(Value: Single);
begin
  TsgSingleList(FParams.Last).Add(Value);
end;

procedure TsgMVertex.ClearReferences;
begin
  inherited ClearReferences;
  TsgObjectList.ClearList(FParams);
end;

procedure TsgMVertex.Complete;
var
  L: TsgSingleList;
begin
  if FParams.Count = 0 then
    Exit;
  L := TsgSingleList(FParams.Last);
  while L.Count < 2 do
    L.Add(0);
end;

function TsgMVertex.NewList: TsgSingleList;
begin
  Complete;
  Result := TsgSingleList.Create;
  FParams.Add(Result);
end;

procedure TsgMVertex.AssignEntity(Source: TsgDXFEntity);
var
  V: TsgMVertex absolute Source;
  I: Integer;
  vDst, vSrc: TsgSingleList;
begin
  inherited AssignEntity(Source);
  if Source is TsgMVertex then
  begin
    Point := V.Point;
    Miter := V.Miter;
    Direction := V.Direction;
    TsgObjectList.ClearList(FParams);
    for I := 0 to V.ParamsCount - 1 do
    begin
      vSrc := TsgSingleList(V.ParamsList[I]);
      vDst := TsgSingleList.Create;
      vDst.Assign(vSrc);
      ParamsList.Add(vDst);
    end;
  end;
end;

{ TsgCADMLine }

procedure TsgCADMLine.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  ClearEntCollection(FItems, ADoFree);
end;

procedure TsgCADMLine.CopyItems(const ASource: TsgDXFEntity);
var
  vSrc, vDst: TsgDXFEntity;
  I: Integer;
begin
  inherited CopyItems(ASource);
  for I := 0 to TsgCADMLine(ASource).ItemsCount - 1 do
  begin
    vSrc := TsgCADMLine(ASource).Items[I];
    vDst := TsgDXFEntityClass(vSrc.ClassType).Create;
    vDst.AssignEntity(vSrc);
    FItems.Add(vDst);
  end;
end;

constructor TsgCADMLine.Create;
begin
  inherited Create;
  FLineTypeScale := 1;
  FStartPoint := cnstFPointZero;
  FItems := TsgEntitiesList(TsgEntitiesList.CreateList(ListNotify));
  Block := TsgDXFBlock.Create;
end;

function TsgCADMLine.GetCount: Integer;
begin
  Result := GetItemsCount;
end;

function TsgCADMLine.GetItemsCount: Integer;
begin
  Result := FItems.Count;
end;

function TsgCADMLine.GetJustify: Byte;
begin
  Result := FJustify;
end;

function TsgCADMLine.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := GetItem(AIndex);
end;

function TsgCADMLine.GetEntType: TsgCADEntities;
begin
  Result := ceMLine;
end;

function TsgCADMLine.GetItem(Index: Integer): TsgMVertex;
begin
  Result := TsgMVertex(FItems[Index]);
end;

function TsgCADMLine.GetScaleFactor: Double;
begin
  Result := FScaleFactor;
end;

function TsgCADMLine.GetStyle: TsgMLineStyle;
begin
  Result := FStyle;
end;

procedure TsgCADMLine.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlAngle));
      AHideList.Add(Integer(xmlBlockName));
      AHideList.Add(Integer(xmlJustify));
      AHideList.Add(Integer(xmlLength));
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlLineTypeScale));
      AHideList.Add(Integer(xmlPoint));
      AHideList.Add(Integer(xmlFPointScale));
    end;
  end;
end;

function TsgCADMLine.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgCADMLine.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := AEntity is TsgMVertex;
  if Result then  
    FItems.Insert(AIndex, AEntity);
end;

procedure TsgCADMLine.SetPoint(AValue: TFPoint);
begin
  // do not Offset MLINE
end;

procedure TsgCADMLine.SetScaleFactor(const Value: Double);
begin
  FScaleFactor := Value;
end;

procedure TsgCADMLine.SetStyle(const Value: TsgMLineStyle);
begin
  FStyle := Value;
end;

function TsgCADMLine.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlPoint].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlBlockName].Name);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlStartPoint].Name).ValueData,
    StartPoint, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlScale].Name).ValueData,
    ScaleFactor, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlExtrusion].Name).ValueAsFPoint := Extrusion;
  ANode.AddAttribNV(cnstXMLNames[xmlJustify].Name).ValueAsInt := FJustify;
  if Assigned(Style) then
    ANode.AddAttribNV(cnstXMLNames[xmlStyleName].Name).ValueAsStr := Style.Name;
end;

function TsgCADMLine.ToXMLGeoData(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := cnstXML_OK;
end;

procedure TsgCADMLine.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FItems);
end;

function TsgCADMLine.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vConv: TsgDXFConverter;
  vStyle: TsgMLineStyle;
begin
  if AType.Id in [xmlPoint, xmlBlockName, xmlAngle, xmlFPointScale] then
  begin
    Result := cnstXML_OK;
    Exit;
  end;
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlStartPoint: StartPoint := ANode.ValueAsFPoint;
    xmlScale:  ScaleFactor := ANode.ValueAsDouble;
    xmlJustify: Justify := ANode.ValueAsInt;
    xmlStyleName:
      begin
        vConv := Converter;
        if Assigned(vConv) and (vConv.Sections[csMLineStyles] <> nil) then
        begin
          vStyle := TsgMLineStyle(vConv.Sections[csMLineStyles].FindEntByName(ANode.ValueAsStr));
          if Assigned(vStyle) then
            Style := vStyle;
        end;
      end
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure TsgCADMLine.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

procedure TsgCADMLine.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgCADMLine.LoadedInternal(AConverter: TsgDXFConverter);
var
  I,J,K,Cnt: Integer;
  PL: TsgDXFPolyline;
  MV: TsgMVertex;
  V: TsgDXFVertex;
  P: TFPoint;

  procedure NewPL;
  begin
    PL := TsgDXFPolyline.Create;
    Block.AddEntity(PL);
    PL.ColorCAD := FStyle[I].ColorCAD;
    PL.LineType := FStyle[I].LineType;
    PL.Layer := Layer;
    PL.Extrusion := Extrusion;
    PL.LineTypeScale := LineTypeScale;
    PL.LineWeight := LineWeight;
    PL.Closed := FFlags and 2 <> 0;
    PL.SetPLineGen(True);
    PL.Polyline3D := True;
  end;
  procedure EndPL;
  begin
    PL.Loaded(AConverter);
  end;
  function VPoint(const P1,P2: TFPoint; Scale: Double): TFPoint;
  begin
    Result.X := P1.X + Scale * P2.X;
    Result.Y := P1.Y + Scale * P2.Y;
    Result.Z := P1.Z + Scale * P2.Z;
  end;
begin
  if FStyle=nil then
    Exit;
  // Take the value up the stack
  if not Assigned(LineType) then
    LineType := TsgDXFLineType(AConverter.CustomEntByName(sByBlock, csLTypes));
  ColorCAD := MakeColorCAD(acIndexColor, clDXFByBlock);
  Block.Clear(True);
  for I := 0 to FStyle.Count - 1 do
  begin
    NewPL;
    for J := 0 to ItemsCount - 1 do
    begin
      MV := Items[J];
      Cnt := MV.PCounts[I] - 1;
      P := VPoint(MV.FPoint, MV.FMiter, MV[I,0]);
      for K := 1 to Cnt do
      begin
        V := TsgDXFVertex.Create;
        V.FPoint := VPoint(P, MV.FDirection, MV[I,K]);
        PL.AddEntity(V);
        if K=Cnt then
          Break;
        if K and 1 <> 0 then
          Continue;
        EndPL;
        NewPL;
      end;
    end;
    EndPL;
  end;
  if FStyle.FFlags and 1 <> 0 then
  begin
    SetFill;
    Block.Entities[0].Loaded(AConverter);
  end;
  inherited LoadedInternal(AConverter);
end;

procedure TsgCADMLine.ReferenceBlockRecord(ABlockRecord: TsgDXFBlockRecord);
begin
  // do nothing, MLine must use only self block
end;

procedure TsgCADMLine.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  FItems[AIndex] := AEntity;
end;

procedure TsgCADMLine.SetFill;
var
  FFill: TsgCADPolyPolygon;
  I,J: Integer;
  vPoints: TF2DPointList;
  MV: TsgMVertex;
  vPoint2D: TF2DPoint;
  PC,PMax,PMin: Single;
begin
  FFill := TsgCADPolyPolygon.Create;
  Block.InsertEntity(0, FFill);
  FFill.ColorCAD := FStyle.ColorCAD;
  vPoints := TF2DPointList.Create;
  FFill.Boundaries.Add(vPoints);
  for I := 0 to ItemsCount - 1 do
  begin
    MV := Items[I];
    if MV.ParamsCount = 0 then
      Continue;
    PMax := -1E30;
    PMin := 1E30;
    for J := 0 to MV.ParamsCount - 1 do
    begin
      PC := MV[J,0];
      if PMax < PC then
        PMax := PC;
      if PMin > PC then
        PMin := PC;
    end;
    vPoint2D.X := MV.FPoint.X + PMax * MV.FMiter.X;
    vPoint2D.Y := MV.FPoint.Y + PMax * MV.FMiter.Y;
    vPoints.Insert(I,vPoint2D);
    vPoint2D.X := MV.FPoint.X + PMin * MV.FMiter.X;
    vPoint2D.Y := MV.FPoint.Y + PMin * MV.FMiter.Y;
    vPoints.Insert(I+1,vPoint2D);
  end;
end;

procedure TsgCADMLine.SetJustify(const Value: Byte);
begin
  FJustify := Value;
end;

procedure TsgCADMLine.AssignEntity(Source: TsgDXFEntity);
var
  M: TsgCADMLine absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADMLine then
  begin
    Style := M.Style;
    Flags := M.Flags;
    Justify := M.Justify;
  end;
end;

{ TsgCADHelix }

procedure TsgCADHelix.AssignEntity(Source: TsgDXFEntity);
var
  H: TsgCADHelix absolute Source;
begin
  inherited AssignEntity(Source);
  if not (Source is TsgCADHelix) then
    Exit;
  Start := H.Start;
  Radius := H.Radius;
  Turns := H.Turns;
  TurnHeight := H.TurnHeight;
  Clockwise := H.Clockwise;
end;

function TsgCADHelix.GetEntType: TsgCADEntities;
begin
  Result := ceHelix;
end;

procedure TsgCADHelix.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlPoint));
      AHideList.Add(Integer(xmlStart));
      AHideList.Add(Integer(xmlTurnHeight));
    end;
  end;
end;

procedure TsgCADHelix.LoadedInternal(AConverter: TsgDXFConverter);
var
  A,R,DA,DR,DZ: Double;
  S,C: Extended;
  N: Integer;
  P: TFPoint;
  vPartsCount: Integer;
//  Knot: Single;
begin
  vPartsCount := 16;
  if (FQuality > 0) and (FQuality <= 16) then
    vPartsCount := vPartsCount * FQuality;
  Controls.Clear(False);
  Fit.Clear(False);
  Knots.Clear(False);
  P.X := Start.X - Point.X;
  P.Y := Start.Y - Point.Y;
  P.Z := Start.Z;
  R := Sqrt(P.X * P.X + P.Y * P.Y);
  A := ArcTan2(P.Y, P.X);
  N := Ceil(vPartsCount * Turns);
  DR := (Radius - R) / N;
  DZ := Turns * TurnHeight / N;
  DA := 2 * Pi * Turns / N;
  if Clockwise then
    DA := -DA;
  while N >= 0 do
  begin
    SinCos(A,S,C);
    P.X := Point.X + R*C;
    P.Y := Point.Y + R*S;
    Fit{Controls}.Add(P);
    A := A + DA;
    R := R + DR;
    P.Z := P.Z + DZ;
    Dec(N);
  end;
(*    Knot := 0.0;
  FKnots.Add(Pointer(Knot));
  FKnots.Add(Pointer(Knot));
  for I := 1 to FControls.Count-1 do
  begin      // Knots
    Knot := Knot + DistanceF(PFPoint(FControls[I])^, PFPoint(FControls[I-1])^);
    FKnots.Add(Pointer(Knot));
  end;
  FKnots.Add(Pointer(Knot));
  FKnots.Add(Pointer(Knot));
  FKnots.Add(Pointer(Knot)); *)
  inherited LoadedInternal(AConverter);
end;

procedure TsgCADHelix.SetQuality(const Value: Integer);
begin
  if Value > 0 then
    FQuality := Value;
end;

function TsgCADHelix.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlStart].Name).ValueData,
    Start, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlRadius].Name).ValueData,
    Radius, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlTurns].Name).ValueData,
    Turns, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlTurnHeight].Name).ValueData,
    TurnHeight, xmlForViewing in AParams.Mode);
  ANode.AddAttribNV(cnstXMLNames[xmlClockwise].Name).ValueAsBool := Clockwise;
end;

function TsgCADHelix.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlStart: Start := ANode.ValueAsFPoint;
    xmlRadius: Radius := ANode.ValueAsDouble;
    xmlTurns: Turns := ANode.ValueAsDouble;
    xmlTurnHeight: TurnHeight := ANode.ValueAsDouble;
    xmlClockwise: Clockwise := ANode.ValueAsBool;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{ TBufferedStream }

constructor TBufferedStream.Create(AStream: TStream; ABufSize: Integer);
begin
  inherited Create;
  FStream := AStream;
  FBufSize := 4096;
  while FBufSize < ABufSize do Inc(FBufSize,FBufSize);
  GetMem(FBuffer,FBufSize);
  FBufPtr := FBuffer;
  FBufEnd := FBuffer;
end;

destructor TBufferedStream.Destroy;
begin
  Overflow;
  FreeMem(FBuffer);
  inherited Destroy;
end;

function TBufferedStream.Overflow: Boolean;
var
  N: TsgNativeInt;
begin
  N := TsgNativeInt(FBufPtr) - TsgNativeInt(FBufEnd);
  Result := (N <= 0) or (N = FStream.Write(FBufEnd^, N));
  FBufPtr := FBuffer;
  FBufEnd := FBuffer;
end;

function TBufferedStream.Underflow: Boolean;
begin
  Overflow;
  FBufEnd := FBuffer + FStream.Read(FBuffer^, FBufSize);
  Result := FBufEnd > FBuffer;
end;

function TBufferedStream.GetByte(var Buffer): Boolean;
begin
  Result := (FBufPtr < FBufEnd) or Underflow;
  if not Result then Exit;
  PAnsiChar(@Buffer)^ := FBufPtr^;
  Inc(FBufPtr);
end;

function TBufferedStream.PutByte(const Buffer): Boolean;
begin
  Result := (FBufPtr < FBuffer+FBufSize) or Overflow;
  if not Result then Exit;
  FBufPtr^ := PAnsiChar(@Buffer)^;
  Inc(FBufPtr);
end;

{$IFNDEF SGDEL_6}
function TBufferedStream.Seek(Offset: Longint; Origin: Word): Longint;
{$ELSE}
function TBufferedStream.Seek(const Offset: Int64; Origin: TSeekOrigin): Int64;
{$ENDIF}
begin
  Overflow;
  Result := FStream.Seek(Offset,Origin);
end;

function TBufferedStream.Read(var Buffer; Count: Longint): Longint;
var
  P: PAnsiChar;
begin
  P := PAnsiChar(@Buffer);
  Result := 0;
  while (Count > 0) and GetByte(P^) do begin
    Inc(P);
    Inc(Result);
    Dec(Count);
  end;
end;

function TBufferedStream.Write(const Buffer; Count: Longint): Longint;
var
  P: PAnsiChar;
begin
  P := PAnsiChar(@Buffer);
  Result := 0;
  while (Count > 0) and PutByte(P^) do begin
    Inc(P);
    Inc(Result);
    Dec(Count);
  end;
end;

function CompareRegClass(Self: Pointer; const Value1, Value2: Pointer): Integer;
begin
  Result := PsgRegClass(Value1)^.RID -  PsgRegClass(Value2)^.RID;
end;

procedure ExternalEntitiesCreate;
begin
  if ExternalEntities <> nil then Exit;
  ExternalEntities := TsgStringList.Create;
  ExternalEntities.Duplicates := dupIgnore;
  ExternalEntities.Sorted := True;
  ExternalEntities.CaseSensitive := False;
end;

procedure ExternalEntitiesFree;
var
  I: Integer;
  vClasses: TsgList;
begin
  if ExternalEntities = nil then Exit;
  for I := 0 to ExternalEntities.Count - 1 do
  begin
    vClasses := TsgList(ExternalEntities.Objects[I]);
    if vClasses <> nil then
    begin
      ExternalEntities.Objects[I] := nil;;
      vClasses.ClearTypeList(ptvRecord);
      vClasses.Free;
    end;
  end;
  ExternalEntities.Free;
  ExternalEntities := nil;
end;

function CreateInsert(const ABlock: TsgDXFBlock; const APos,AScale: TFPoint;
  const ARotation: Double): TsgDXFInsert;
begin
  Result := TsgDXFInsert.Create;
  Result.Block := ABlock;
  Result.Point := APos;
  Result.Scale := AScale;
  Result.Angle := ARotation;
end;

function CreateRegEntity(const AGroup: string; const ID: Integer; const AConv: TsgDXFConverter; var AExtData: TsgCADExtendedData): TsgDXFEntity;
var
  I: Integer;
  vClass: TClass;
  vClasses: TsgList;
  vRegClass: TsgRegClass;
begin
  Result := nil;
  if ExternalEntities = nil then Exit;
  I := ExternalEntities.IndexOf(AGroup);
  if I > -1 then
  begin
    vRegClass.RID := ID;
    vClasses := TsgList(ExternalEntities.Objects[I]);
    I := vClasses.IndexOf(@vRegClass);
    if I > -1 then
    begin
      vClass := PsgRegClass(vClasses.Items[I])^.RClass;
      Result := TsgDXFEntityClass(vClass).Create;
      Result.SetConverter(AConv);
      Result.SetExtData(AExtData);
    end;
  end;
end;

procedure RegisterEntityClass(const AGroup: string; const ID: Integer; const AClass: TClass);
var
  I: Integer;
  vClasses: TsgList;
  vProcCompare: Pointer;
  vObjProcCompare: TsgObjProcCompare absolute vProcCompare;
  vRegClass: PsgRegClass;
begin
  if ExternalEntities = nil then
    ExternalEntitiesCreate;
  I := ExternalEntities.IndexOf(AGroup);
  if I > -1 then
    vClasses := TsgList(ExternalEntities.Objects[I])
  else
  begin
    vProcCompare := @CompareRegClass;
    vClasses := TsgList.Create;
    ExternalEntities.AddObject(AGroup, vClasses);
    vClasses.ProcCompare := vObjProcCompare;
    vClasses.Duplicates := dupIgnore;
    vClasses.Sorted := True;
  end;
  I := vClasses.Count;
  New(vRegClass);
  try
    vRegClass^.RID := ID;
    vRegClass^.RClass := AClass;
    vClasses.Add(vRegClass);
  finally
    if vClasses.Count = I then
      Dispose(vRegClass);
  end;
end;

procedure UnRegisterEntityClass(const AGroup: string; const ID: Integer);
var
  I, J: Integer;
  vClasses: TsgList;
  vRegClass: TsgRegClass;
begin
  if ExternalEntities = nil then Exit;
  I := ExternalEntities.IndexOf(AGroup);
  if I > -1 then
  begin
    vRegClass.RID := ID;
    vClasses := TsgList(ExternalEntities.Objects[I]);
    J := vClasses.IndexOf(@vRegClass);
    if J > -1 then
    begin
      vClasses.Delete(J);
      if vClasses.Count = 0 then
      begin
        ExternalEntities.Objects[I] := nil;
        vClasses.Free;
        ExternalEntities.Delete(I);
        if ExternalEntities.Count = 0 then
        begin
          ExternalEntities.Free;
          ExternalEntities := nil;
        end;
      end;
    end;
  end;
end;

{ TsgMLineEntry }

procedure TsgMLineEntry.ClearReferences;
begin
  inherited ClearReferences;
  FLineTypeItem.Item := nil;
end;

constructor TsgMLineEntry.Create;
begin
  inherited Create;
  FLineTypeItem := TsgTableItem.Create;
end;

procedure TsgMLineEntry.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FLineTypeItem);
end;

function TsgMLineEntry.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlOffset: Offset := ANode.ValueAsDouble;
    xmlColor:  ColorCAD := ANode.ValueData.ValueAsColorCAD;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgMLineEntry.GetColorCAD: TsgColorCAD;
begin
  Result := FColor;
end;

function TsgMLineEntry.GetLineType: TsgDXFLineType;
begin
  Result := TsgDXFLineType(FLineTypeItem.Item);
end;

procedure TsgMLineEntry.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgMLineEntry.SetColorCAD(const Value: TsgColorCAD);
begin
  FColor := Value;
end;

procedure TsgMLineEntry.SetLineType(const AValue: TsgDXFLineType);
begin
  FLineTypeItem.Item := AValue;
end;

function TsgMLineEntry.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlOffset].Name).ValueAsDouble := Offset;
  ANode.AddAttribNV(cnstXMLNames[xmlColor].Name).ValueData.ValueAsColorCAD := ColorCAD;
end;

{ TsgCreatorSegments }

procedure TsgCreatorSegments.MakeSegments(const APoints: TFPointList;
  const ACenter: PFPoint);
var
  I, vPointsCount: Integer;
  vStartWidth, vEndWidth, vDeltaWidth: Double;
  vP0, vP1, vP2: TFPoint;
  vPts, vPtsCurrent, vPtsFirst: TsgIndexes4;
  vPtsLinear: Boolean;
begin
  vPtsLinear := ACenter = nil;
  vPts := cnstIndexesNoInit;
  vPtsCurrent := vPts;
  vPtsFirst := vPts;
  vP0 := APoints[0];
  I := 0;
  vPointsCount := APoints.Count - 1;//for pre last
  if UseAsSolid then
    vDeltaWidth := (FEndWidth - FStartWidth) / vPointsCount
  else
  begin
    if FSegmentLength <> 0 then
      vDeltaWidth := (FEndWidth - FStartWidth) / FSegmentLength
    else
      vDeltaWidth := 0;
  end;
  while I < vPointsCount do
  begin
    vP1 := APoints.List[I];
    vP2 := APoints.List[I + 1];
    if UseAsSolid then
    begin
      vStartWidth := FStartWidth + I * vDeltaWidth;
      vEndWidth := FStartWidth + (I + 1) * vDeltaWidth;
    end
    else
    begin
      vStartWidth := FStartWidth + DistanceFPoint(vP0, vP1) * vDeltaWidth;
      vEndWidth := FStartWidth + DistanceFPoint(vP0, vP2) * vDeltaWidth;
    end;
    Inc(I, 1 + Integer(not UseAsSolid));//make empty dash
    vPts := AddSegment(ACenter, @vP1, @vP2, vStartWidth, vEndWidth);
    if (not FIsPolyLineSolid) or (vPointsCount = 1) or (vPts[0] > cnstEmptyPoints) then
    begin
      vPtsCurrent := vPts;
      if vPtsFirst[0] = cnstNoInitPoints then
        vPtsFirst := vPtsCurrent;
    end;
  end;
  if FIsPolyLineSolid or FMakeCrossSegments then
    CrossingSegments(FSegmentLastLinear, vPtsLinear, FSegmentLast, vPtsFirst);
  FSegmentLast := vPtsCurrent;
  FSegmentLastLinear := vPtsLinear;
  if FSegmentFirst[0] = cnstNoInitPoints then
  begin
    FSegmentFirst := vPtsFirst;
    FSegmentFirstLinear := vPtsLinear;
  end;
end;

procedure TsgCreatorSegments.LoadPoinstBySegment(const AClosed: Boolean;
  const ACenter: PFPoint);
var
  vScale: TFPoint;
begin
  try
    LoadPointsAndCalcParams;
    if UseAsSolid then
      MakeSegments(FPoints, ACenter)
    else
    begin
      if FDottedSingPts = nil then
      begin
        FDottedSingPts := TFPointList.Create;
        FCounts := TsgIntegerList.Create;
      end;
      FDottedSingPts.Clear(False);
      FCounts.Count := 1;
      FCounts[0] := FPoints.Count;
      if Assigned(FMatrix) then
      begin
        vScale := ExtractMatrixAbsoluteScale(FMatrix^);
        ScaleList(FPoints, vScale);
      end;
      FPolyLine.FArrowsLines.Vertexes(FPoints, FCounts, FDottedSingPts, False);
      if Assigned(FMatrix) then
      begin
        vScale := ReverseScale(vScale);
        ScaleList(FPoints, vScale);
        ScaleList(FDottedSingPts, vScale);
      end;
      if (FDottedSingPts.Count <= iMaxNumDottedLines)
       and (FDottedSingPts.Count <> 0) then
        MakeSegments(FDottedSingPts, ACenter)
      else
      begin
        FIsManyDottedPoints := True;
        FreeAndNil(FDottedSingPts);
        FreeAndNil(FCounts);
        MakeSegments(FPoints, ACenter);
      end;
    end;
    if FIsPolyLineSolid and AClosed then
      CrossingSegments(FSegmentLastLinear, FSegmentFirstLinear,  FSegmentLast,
        FSegmentFirst);
  finally
    ClearPFPoints;
  end;
end;

procedure TsgCreatorSegments.LoadPointsAndCalcParams;
var
  vPoint1, vPoint2: PFPoint;
  I: Integer;
begin
  vPoint2 := nil;
  FSegmentLength := 0;
  for I := 1 to FPointsCount do
  begin
    vPoint1 := GetPFPoint(FPolyPoints, FPointsIndex);
    if vPoint2 <> nil then
      FSegmentLength := FSegmentLength + DistanceFPoint(vPoint1^, vPoint2^);
    AddPFPoint(vPoint1);
    Inc(FPointsIndex);
    vPoint2 := vPoint1;
  end;
  vPoint1 := GetPFPoint(FPolyPoints, FPointsIndex);
  AddPFPoint(vPoint1);
  if vPoint2 <> nil then
    FSegmentLength := FSegmentLength + DistanceFPoint(vPoint1^, vPoint2^);
  if FPoints.Count = 2 then
  begin
    FSegmentSinCos := GetFPointSinCosByFPoints(FPoints.List[0],
      FPoints.List[1]);
    FPointSinCosRot90(FSegmentSinCos);
  end
  else
    FSegmentSinCos := cnstFPointZero;
end;

procedure TsgCreatorSegments.AddPFPoint(const APoint: PFPoint);
begin
  if FPolyExtrusion <> nil then
  begin
    FPoints.Add(APoint^);
    DoPreExtrusion(FPoints.List^[FPoints.Count-1], FPolyExtrusion^);
  end
  else
    FPoints.Add(APoint^);
end;

function TsgCreatorSegments.AddSegment(const APC, AP1, AP2: PFPoint;
  const AW1, AW2: Double): TsgIndexes4;
var
  I: Integer;
  vSegment: TsgPoints4;
begin
  Result := cnstIndexesEmpty;
  if FIsPolyLineSolid and IsEqualFPoints(AP1^, AP2^) then//ignore point
  begin
    if APC = nil then//fix in future version
    begin
      //FillChar(Result, Sizeof(Result), 0)
    end;
  end
  else
  begin
    if APC = nil then
      vSegment := GetSegmentLinear(AP1^, AP2^, AW1, AW2)
    else
      vSegment := GetSegmentCircular(APC^, AP1^, AP2^, AW1, AW2);
    for I := 0 to 3 do
    begin
      FArrows.Add(vSegment[I]);
      Result[I] := FPolyLine.FArrows.Count - 1;
    end;
  end;
end;

procedure TsgCreatorSegments.CheckGlobalWidth;
var
  I: Integer;
  vGlobalWdt: Boolean;
  vVertex: TsgDXFVertex;
  vStartWidth: Double;
begin
  if (VertexesCount > 0) and (Vertexes[0].StartWidth > 0) then
  begin
    vGlobalWdt := True;
    vStartWidth := Vertexes[0].StartWidth;
    vVertex := nil;
    for I := 0 to VertexesCount - 2 do
    begin
      vVertex := Vertexes[I];
      vGlobalWdt := (vVertex.StartWidth = vVertex.EndWidth) and
        (vVertex.StartWidth = vStartWidth) and vGlobalWdt;
      vStartWidth := vVertex.StartWidth;
      if not vGlobalWdt then
        Break;
    end;
    if vGlobalWdt and (vVertex <> nil) then
      FPolyLine.FGlobalW := vVertex.StartWidth;
  end
  else
    if FPolyLine.FGlobalW = 0 then
      FPolyLine.FGlobalW := FPolyLine.FStartW;
end;

procedure TsgCreatorSegments.ClearPFPoints;
begin
  if FPolyExtrusion <> nil then
    FPoints.Clear(False)
  else
    FPoints.Count := 0;
end;

constructor TsgCreatorSegments.Create(const APolyline: TsgDXFLWPolyline;
  const ALines: TsgLines; const AMatrix: PFMatrix);
begin
  inherited Create;
  FMatrix := AMatrix;
  FPoints := TFPointList.Create;
  FIsPolyLineSolid := True;
  FIsPolylineClosed := False;
  FPolyExtrusion := nil;
  FPolyLine := APolyline;
  if FPolyLine <> nil then
  begin
    FPolyPoints := FPolyLine.FPolyPoints;
    FPolyCounts := FPolyLine.FPointsCounts;
    FIsPolylineClosed := FPolyLine.Closed;
    FMakeCrossSegments := FPolyLine.IsPathEvacuation;
    FPolyExtrusion := FPolyLine.FExtrusion;
    FPolyLine.FArrowsLines := ALines;
    if Assigned(FPolyLine.FArrowsLines) and (not FPolyLine.FArrowsLines.IsSolid) then
      FIsPolyLineSolid := False;
  end;
end;

procedure TsgCreatorSegments.CrossingSegments(const AIsLinear1,
  AIsLinear2: Boolean; const APts1, APts2: TsgIndexes4);
begin
  if (APts1[0] <> APts2[0]) and
    (APts1[0] > cnstEmptyPoints) and (APts2[0] > cnstEmptyPoints) then
    begin
      if AIsLinear1 then
      begin
        if AIsLinear2 then
          JoinSegments(APts1, APts2)
        else
          ExtendSegments(True, APts1, APts2);
      end
      else
      begin
        if AIsLinear2 then
          ExtendSegments(False, APts2, APts1);
      end;
    end;
end;

destructor TsgCreatorSegments.Destroy;
begin
  FPolyLine := nil;
  FDottedSingPts.Free;
  FreeAndNil(FCounts);
  ClearPFPoints;
  FreeAndNil(FPoints);
  inherited Destroy;
end;

function TsgCreatorSegments.DistanceIndexes(const I1, I2: Integer): Double;
begin
  Result := Sqrt(DistanceIndexesSqr(I1, I2));
end;

function TsgCreatorSegments.DistanceIndexesSqr(const I1, I2: Integer): Extended;
begin
  Result := DistanceFPointSqr(FArrows[I1], FArrows[I1]);
end;

procedure TsgCreatorSegments.ExtendSegments(const AIsFirstLine: Boolean;
  const APtsLine, APtsCircle: TsgIndexes4);
var
  vCross1, vCross2: TFPoint;
  vActPtsLine, vActPtsCircle: TsgIndexes4;
begin
  SetActiveEdges(AIsFirstLine, APtsLine, vActPtsLine);
  SetActiveEdges(not AIsFirstLine, APtsCircle, vActPtsCircle);
  if IsCrossIndexes(vActPtsCircle[0], vActPtsCircle[3],
    vActPtsLine[0], vActPtsLine[1], @vCross1) and
     IsCrossIndexes(vActPtsCircle[0], vActPtsCircle[3],
    vActPtsLine[3], vActPtsLine[2], @vCross2) then
  begin
    if IsCorrectExtendedAngle(vCross1, FArrows[vActPtsLine[0]], FArrows[vActPtsCircle[0]]) and
       IsCorrectExtendedAngle(vCross2, FArrows[vActPtsLine[3]], FArrows[vActPtsCircle[3]]) then
    begin
      SetPFPoint2DValue(vActPtsLine[0], vCross1);
      SetPFPoint2DValue(vActPtsLine[3], vCross2);
    end;
  end;
end;

function TsgCreatorSegments.GetCenterIndexes(
  const AIndexes: TsgIndexes4): TsgLine;
begin
  Result.Point1 := MiddleFPoint(FArrows[AIndexes[0]], FArrows[AIndexes[3]]);
  Result.Point2 := MiddleFPoint(FArrows[AIndexes[1]], FArrows[AIndexes[2]]);
end;

function TsgCreatorSegments.GetPFPoint(const APoints: TFPointList;
  var AIndex: Integer): PFPoint;
begin
  if AIndex >= APoints.Count then
    AIndex := 0;
  Result := @APoints.List[AIndex];
end;

function TsgCreatorSegments.GetPolyPoint(AIndex: Integer): TFPoint;
begin
  if AIndex >= FPolyPoints.Count then
    AIndex := 0;
  Result := FPolyPoints.List[AIndex];
end;

function TsgCreatorSegments.GetSegment(const AP1, AP2,
  AD1, AD2: TFPoint): TsgPoints4;
begin
  Result[0] := AddFPoint(AP1, AD1);
  Result[1] := AddFPoint(AP2, AD2);
  Result[2] := SubFPoint(AP2, AD2);
  Result[3] := SubFPoint(AP1, AD1);  
end;

function TsgCreatorSegments.GetSegmentLinear(const AP1, AP2: TFPoint;
  const AW1, AW2: Double): TsgPoints4;
var
  vDelta1, vDelta2, vSinCos: TFPoint;
begin
  if FSegmentSinCos.X = FSegmentSinCos.Y then//load incorrect points
  begin
    vSinCos := GetFPointSinCosByFPoints(AP1, AP2);
    FPointSinCosRot90(vSinCos);
  end
  else
    vSinCos := FSegmentSinCos;
  vDelta1 := MakeFPoint(AW1 * vSinCos.X, AW1 * vSinCos.Y, 0);
  vDelta2 := MakeFPoint(AW2 * vSinCos.X, AW2 * vSinCos.Y, 0);
  Result := GetSegment(AP1, AP2, vDelta1, vDelta2);
end;

function TsgCreatorSegments.GetSegmentCircular(const APC, AP1, AP2: TFPoint;
  const AW1, AW2: Double): TsgPoints4;
var
  vDelta1, vDelta2: TFPoint;
  vAngle, vSin, vCos: Extended;
begin
  vAngle := GetAngleByPoints(APC, AP1, True);
  SinCos(vAngle, vSin, vCos);
  vDelta1 := MakeFPoint(-AW1 * vCos, -AW1 * vSin, 0);
  vAngle := GetAngleByPoints(APC, AP2, True);
  SinCos(vAngle, vSin, vCos);
  vDelta2 := MakeFPoint(-AW2 * vCos, -AW2 * vSin, 0);
  Result := GetSegment(AP1, AP2, vDelta1, vDelta2);
end;

function TsgCreatorSegments.GetStartAndEndWidths(const AVertex: TsgDXFVertex;
  var AStartWidth, AEndWidth: Double): Boolean;
begin
  Result := not IsNillWidth(AVertex);
  if Result then
  begin
    if FPolyLine.FGlobalW = 0 then
    begin
      AStartWidth := AVertex.StartWidth;
      AEndWidth := AVertex.EndWidth;
    end
    else
    begin
      AStartWidth := FPolyLine.FGlobalW;
      AEndWidth := FPolyLine.FGlobalW;
    end;
  end;
end;

function TsgCreatorSegments.GetVertex(const AIndex: Integer): TsgDXFVertex;
var
  vVertexFirst: Integer;
begin
  if AIndex >= VertexesCount then
  begin
    vVertexFirst := VertexFirst;
    if vVertexFirst >= FPolyLine.FEntities.Count then
      vVertexFirst := 0;
    Result := TsgDXFVertex(FPolyLine.FEntities.List[vVertexFirst]);
  end
  else
    Result := TsgDXFVertex(FPolyLine.FEntities.List[AIndex]);
end;

function TsgCreatorSegments.GetVertexesCount: Integer;
begin
  if FVertexCount < 0 then
  begin
    FVertexCount := FPolyLine.FEntities.Count;
    while (FVertexCount > 0) and (FPolyCounts[FVertexCount - 1] = -1) do
      Dec(FVertexCount);
  end;
  Result := FVertexCount;
end;

function TsgCreatorSegments.GetVertexFirst: Integer;
begin
  if FVertexFirst < 0 then
  begin
    FVertexFirst := 0;
    while (FVertexFirst < VertexesCount) and (FPolyCounts[FVertexCount - 1] = -1) do
      Inc(FVertexFirst);
  end;
  Result := FVertexFirst;
end;

function TsgCreatorSegments.IsCorrectExtendedAngle(const APB,
  AP1, AP2: TFPoint): Boolean;
const
  cnstExtendedMinAngle = 14.5;
var
  vAngle: Double;
begin
  Result := False;
  vAngle := GetAngleOfLinesEx(APB, AP1, AP2);
  if (vAngle >= cnstExtendedMinAngle) then
    Result := True;
end;

function TsgCreatorSegments.IsCorrectJoinAngle(const APB,
  AP1, AP2: TFPoint): Boolean;
const
  cnstJoinMinAngle = 29;
  cnstJoinMaxAngle = 170;
var
  vAngle: Double;
begin
  Result := False;
  vAngle := GetAngleOfLinesEx(APB, AP1, AP2);
  if (vAngle > cnstJoinMinAngle) then
    Result := True;
end;

function TsgCreatorSegments.IsCrossIndexes(const I11, I12, I21, I22: Integer;
  const ACross: PFPoint): Boolean;
begin
  Result := IsCrossLinesPts(FArrows[I11], FArrows[I12], FArrows[I21],
    FArrows[I22], ACross, fExtendedResolution);
end;

function TsgCreatorSegments.IsNillWidth(const AVertex: TsgDXFVertex): Boolean;
begin
  Result := (FPolyLine.FGlobalW = 0) and (AVertex.StartWidth = 0) and
    (AVertex.EndWidth = 0);
end;

procedure TsgCreatorSegments.JoinSegments(const APts1, APts2: TsgIndexes4);
var
  vCross1, vCross2: TFPoint;
  vLine1, vLine2: TsgLine;
  vWidth1, vWidth2: Extended;
begin
  vLine1 := GetCenterIndexes(APts1);
  vLine2 := GetCenterIndexes(APts2);
  if IsParalleniarLines(vLine1, vLine2) then
  begin
    vWidth1 := DistanceIndexesSqr(APts1[1], APts1[2]);
    vWidth2 := DistanceIndexes(APts2[0], APts2[3]);
    if vWidth1 <= vWidth2 then// variant: ->
      Exit;
  end;
  if IsCrossIndexes(APts1[0], APts1[1], APts2[0], APts2[1], @vCross1) and
     IsCrossIndexes(APts1[3], APts1[2], APts2[3], APts2[2], @vCross2) then
  begin
    if IsCorrectJoinAngle(vCross1, FArrows[APts1[0]], FArrows[APts2[1]]) and
       IsCorrectJoinAngle(vCross2, FArrows[APts1[3]], FArrows[APts2[2]]) then
    begin
      if not (IsEqualFPoints(FArrows[APts1[0]], vCross1) or
              IsEqualFPoints(FArrows[APts1[3]], vCross2)) then
      begin
        SetPFPoint2DValue(APts1[1], vCross1);
        SetPFPoint2DValue(APts1[2], vCross2);

        SetPFPoint2DValue(APts2[0], vCross1);
        SetPFPoint2DValue(APts2[3], vCross2);
      end;
    end;
  end;
end;

procedure TsgCreatorSegments.LoadSegments(const AsSolid: Boolean = False);
var
  I, vLastIndexVertex: Integer;
  vStartWidth, vEndWidth, vRadius: Double;
  vBulgeCenter: TFPoint;
  vCenter, vPoint: PFPoint;
  V0, V1: TsgDXFVertex;
begin
  if (FPolyLine = nil) or (FPolyPoints = nil) or (FPolyCounts = nil) or
    (FPolyLine.Count < 1) then Exit;
  FIsManyDottedPoints := AsSolid;
  FVertexCount := -1;
  FVertexFirst := -1;
  CheckGlobalWidth;
  FPointsIndex := 0;
  FSegmentFirst := cnstIndexesNoInit;
  FSegmentLast := cnstIndexesNoInit;
  vLastIndexVertex := VertexesCount - 2 + Integer(FIsPolylineClosed);
  if FPolyLine.FArrows = nil then
    FPolyLine.FArrows := TFPointList.Create;
  if UseAsSolid then
    FPolyLine.FArrowsLines := nil;
  FArrows := FPolyLine.FArrows;
  FArrows.Clear;
  try
    for I := VertexFirst to vLastIndexVertex do
    begin
      FPointsCount := FPolyCounts[I];
      if FPointsCount = -1 then
        Continue;
      V0 := Vertexes[I];
      if GetStartAndEndWidths(V0, vStartWidth, vEndWidth) then
      begin
        FStartWidth := 0.5 * vStartWidth;
        FEndWidth := 0.5 * vEndWidth;
        vCenter := nil;
        if FPointsCount > 1 then
        begin
          V1 := Vertexes[I + 1];
          vBulgeCenter := GetCenterOfBulge(V0.Point, V1.Point, V0.Bulge);
          vRadius := DistanceFPoint(vBulgeCenter, PolyPoints[FPointsIndex]);
          if vRadius > fDoubleResolution then
          begin
            if FStartWidth > vRadius then
              FStartWidth := vRadius;
            if FEndWidth > vRadius then
              FEndWidth := vRadius;
          end;
          vCenter := @vBulgeCenter;
        end;
        LoadPoinstBySegment(FIsPolylineClosed and (I = vLastIndexVertex), vCenter);
      end
      else
      begin
        FSegmentLast[0] := cnstNoInitPoints;
        Inc(FPointsIndex, FPointsCount);
      end;
    end;
    if (FPolyLine.FArrows <> nil) and (FPolyExtrusion <> nil) then
    begin
      for I := 0 to FPolyLine.FArrows.Count - 1 do
      begin
        vPoint := @FPolyLine.FArrows.List[I];
        DoExtrusion(vPoint^, FPolyExtrusion^);
      end;
    end;
  except
    if FPolyLine.FArrows <> nil then
      FPolyLine.FArrows.Clear(True);
    raise;
  end;
end;

// 0,3 - active points
procedure TsgCreatorSegments.SetActiveEdges(const AIsFirst: Boolean;
  const APts: TsgIndexes4; var AActPts: TsgIndexes4);
begin
  if AIsFirst then
  begin
    AActPts[0] := APts[1];
    AActPts[1] := APts[0];
    AActPts[3] := APts[2];
    AActPts[2] := APts[3];
  end
  else
    AActPts := APts;
end;  

procedure TsgCreatorSegments.SetPFPoint2DValue(const AIndex: Integer;
  const AValue: TFPoint);
var
  vPoint: PFPoint;
begin
  vPoint := @FArrows.List[AIndex];
  vPoint^.X := AValue.X;
  vPoint^.Y := AValue.Y;
end;

function TsgCreatorSegments.UseAsSolid: Boolean;
begin
  Result := FIsPolyLineSolid or FIsManyDottedPoints;
end;

{ TsgDXFField }

procedure TsgDXFField.AssignEntity(Source: TsgDXFEntity);
var
  I: Integer;
  vField, vNewChildField: TsgDXFField;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFField then
  begin
    vField := TsgDXFField(Source);
    FCache.AssignData(vField.Cache);
    FDataSet.AssignData(vField.DataSet);
    FChildFields.Clear;
    for I := 0 to vField.Count - 1 do
    begin
      vNewChildField := TsgDXFField.Create;
      vNewChildField.AssignEntity(vField.ChildFields[I]);
      FChildFields.Add(vNewChildField);
      if Assigned(vField.Owner) then
        vField.Owner.AddEntity(vNewChildField);
    end;
    FEvaluatorID := vField.EvaluatorID;
    FExpression := vField.Expression;
    FFieldCode := vField.FieldCode;
    FFormat2Digits := vField.Format2Digits;
    FObjectIDs.Assign(vField.ObjectIDs);
    FOverflowFieldCode := vField.OverflowFieldCode;
  end;
end;

procedure TsgDXFField.ClearReferences;
begin
  inherited ClearReferences;
  FChildFields.Clear;
  TsgCADExtendedDataAccess(FCache).ClearData;
  TsgCADExtendedDataAccess(FDataSet).ClearData;
  FObjectIDs.Clear;
end;

constructor TsgDXFField.Create;
begin
  inherited Create;
  FChildFields := TList.Create;
  FCache := TsgCADExtendedData.Create(TsgDWGVersion(cnstDefHeadVarStruct.Version));
  FDataSet := TsgCADExtendedData.Create(TsgDWGVersion(cnstDefHeadVarStruct.Version));
  FObjectIDs := TsgInt64List.Create;
end;

function TsgDXFField.EntName: string;
begin
  Result := inherited EntName + ' ' + FFieldCode;
end;

procedure TsgDXFField.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FChildFields);
  FreeAndNil(FCache);
  FreeAndNil(FDataSet);
  FreeAndNil(FObjectIDs);
end;

procedure TsgDXFField.GenerateFieldCode;
begin
  FFieldCode := '';
  if Pos('Ac', FEvaluatorID) = 1 then
    FFieldCode := '\' + FEvaluatorID;
  if FFieldCode <> '' then
    FFieldCode := FFieldCode + ' ';
  if FEvaluatorID = cnstAcExpr then
    FFieldCode := FFieldCode + '(' + FExpression + ')'
  else
    FFieldCode := FFieldCode + FExpression;
  if FFormat2Digits then
    FFieldCode := FFieldCode + ' ' + cnstFormat2Digits;
  if FOverflowFieldCode <> '' then
    FFieldCode := FFieldCode + ' "' + FOverflowFieldCode + '"';
end;

procedure TsgDXFField.LoadedInternal(AConverter: TsgDXFConverter);
var
  vPos: Integer;
begin
  inherited LoadedInternal(AConverter);
  if FFieldCode <> '' then
  begin
    FExpression := Trim(FFieldCode);
    vPos := Pos('"' + FOverflowFieldCode + '"', FExpression);
    if vPos > 0 then
    begin
      Delete(FExpression, vPos, MaxInt);
      FExpression := TrimRight(FExpression);
    end;
    vPos := Pos(cnstFormat2Digits, FExpression);
    if vPos = Length(FExpression) - 1 then
    begin
      Delete(FExpression, vPos, MaxInt);
      FExpression := TrimRight(FExpression);
      FFormat2Digits := True;
    end;
    vPos := Pos(FEvaluatorID, FFieldCode);
    if vPos > 0 then
      FExpression := TrimLeft(
        Copy(FExpression, vPos + Length(FEvaluatorID), MaxInt));
    FExpression := ClearBrackets(FExpression);
  end
  else
    GenerateFieldCode;
end;

{ TsgDXFOwneredItem }

constructor TsgDXFOwneredItem.Create;
begin
  inherited Create;
  FLinkID := GetLinkClass.Create(Self);
end;

procedure TsgDXFOwneredItem.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFOwneredItem then
  begin
    FLinkID.Description := TsgDXFOwneredItem(Source).FLinkID.Description;
    FLinkID.Name := TsgDXFOwneredItem(Source).FLinkID.Name;
  end;
end;

function TsgDXFOwneredItem.CanHaveHandle: Boolean;
begin
  Result := True;
end;

procedure TsgDXFOwneredItem.ClearReferences;
begin
  inherited ClearReferences;
  SetOwner(nil);
end;

function TsgDXFOwneredItem.EntName: string;
begin
  Result := FLinkID.Name;
  if Result = '' then
    Result := inherited EntName;
end;

function TsgDXFOwneredItem.GetAnnotative: Boolean;
begin
  Result := FAnnotative;
end;

procedure TsgDXFOwneredItem.SetAnnotative(AValue: Boolean);
begin
  FAnnotative := AValue;
end;

procedure TsgDXFOwneredItem.SetDescription(const AValue: string);
begin
  FLinkID.Description := AValue;
end;

procedure TsgDXFOwneredItem.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FLinkID);
end;

function TsgDXFOwneredItem.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlName: Name := ANode.ValueAsStr;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFOwneredItem.GetConverter: TsgDXFConverter;
begin
  Result := inherited GetConverter;
end;

function TsgDXFOwneredItem.GetDescription: string;
begin
  Result := FLinkID.Description;
end;

function TsgDXFOwneredItem.GetHandle: UInt64;
begin
  Result := FLinkID.Handle;
end;

function TsgDXFOwneredItem.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgNamedItem;
end;

function TsgDXFOwneredItem.GetName: string;
begin
  Result := FLinkID.Name;
end;

function TsgDXFOwneredItem.GetNamedItem: TObject;
begin
  Result := FLinkID;
end;

function TsgDXFOwneredItem.GetOwner: TsgDXFEntity;
begin
  if Assigned(FLinkID) and Assigned(FLinkID.Owner) then
    Result := TsgDXFEntity(TsgOwneredItem(FLinkID.Owner).Ancestor)
  else
    Result := nil;
end;

function TsgDXFOwneredItem.GetStrValue: string;
begin
  Result := FLinkID.Name;
end;

procedure TsgDXFOwneredItem.SetHandle(const Value: UInt64);
begin
  FLinkID.Handle := Value;
end;

procedure TsgDXFOwneredItem.SetName(const AName: string);
begin
  FLinkID.Name := AName;
end;

procedure TsgDXFOwneredItem.SetOwner(const AValue: TsgDXFEntity);
begin
  if Assigned(AValue) then
    FLinkID.Owner := AValue.GetNamedItem
  else
    FLinkID.Owner := nil;
end;

function TsgDXFOwneredItem.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlName].Name).Value := Name;
end;

{ TsgDXFFieldList }

procedure TsgDXFFieldList.ListNotify(const Obj: TObject; Action: TListNotification);
var
  I: Integer;
begin
  inherited ListNotify(Obj, Action);
  if Action in [lnExtracted, lnDeleted] then
    for I := Count - 1 downto 0 do
      if Entities[I] is TsgDXFField then
        TsgDXFField(Entities[I]).ChildFields.Remove(Obj);
end;

{ TsgAcadTableGenerator }

function TsgAcadTableGenerator.AddLineData(const AHorz: Boolean;
  const ACell: TsgAcadTableCell; const ABorder,
  ASpan: Integer): PCellBorderLineData;
begin
  New(Result);
  Result^.ID := 0;
  Result^.Cell := ACell;
  Result^.Border := ABorder;
  Result^.Span := ASpan;
  TList(FData[FIndex[AHorz] - FRange.Start[AHorz]])[FIndex[not AHorz] - FRange.Start[not AHorz]] := Result;
end;

constructor TsgAcadTableGenerator.Create(const AConv: TsgDXFConverter;
  const AAcadTable: TsgDXFAcadTable);
begin
  FAcadTable := AAcadTable;
  FConv := AConv;
  FRange.R := Classes.Rect(0, 0, FAcadTable.NumCols - 1, FAcadTable.NumRows - 1);
  FData := TList.Create;
end;

constructor TsgAcadTableGenerator.CreateRanged(const AConv: TsgDXFConverter;
  const AAcadTable: TsgDXFAcadTable; const ARange: TRect);
begin
  Create(AConv, AAcadTable);
  FRange.R := ARange;
end;

destructor TsgAcadTableGenerator.Destroy;
begin
  FreeRecordListOfList(FData);
  inherited Destroy;
end;

function TsgAcadTableGenerator.GenerateBlock: TsgDXFBlock;
const
  cnstFldIdx = '_FldIdx';

var
  vCell: TsgAcadTableCell;
  I, J, C, R: Integer;
  vSolids: TsgObjectList;
  vMTextes: TsgObjectList;
  vLines: TsgObjectList;
  vField: TsgDXFField;

  procedure LoadsAndAdd(const AList: TsgObjectList);
  var
    K, C: Integer;
  begin
    C := AList.Count - 1;
    for K := 0 to C do
    begin
      FConv.DoCreate(TsgDXFEntity(AList.List[K]));
      FConv.Loads(TsgDXFEntity(AList.List[K]));
      Result.AddEntity(TsgDXFEntity(AList.List[K]));
    end;
  end;

  function CreateSolid(const ACell: TsgAcadTableCell;
    const ARect: TFRect): TsgDXFSolid;
  begin
    Result := TsgDXFSolid.Create;
    Result.ColorCAD := ACell.FillColor;
    Result.Layer := FAcadTable.Layer;
    Result.Point := ARect.TopLeft;
    Result.Point1 := MakeFPoint(ARect.Right, ARect.Top, 0);
    Result.Point2 := MakeFPoint(ARect.Left, ARect.Bottom, 0);
    Result.Point3 := ARect.BottomRight;
  end;

begin
  Result := nil;
  if FAcadTable.IsBlockInternal then
  begin
    if Assigned(FAcadTable.Block) then
    begin
      FAcadTable.Block.Clear(True);
      Result := FAcadTable.Block;
      FAcadTable.Block := nil;
    end
    else
      Result := FAcadTable.CreateBlock(FConv);

    // generate table objects
    vSolids := TsgObjectList.Create;
    vMTextes := TsgObjectList.Create;
    vLines := TsgObjectList.Create;
    try
      // for each cell
      R := 0;
      while R < FAcadTable.NumRows do
      begin
        C := 0;
        while C < FAcadTable.NumCols do
        begin
          vCell := FAcadTable.Cell[C, R];
          if vCell.IsBaseCell then
          begin
            Inc(C, vCell.MergedWidth - 1);
            // create solid entities
            if vCell.BkColorOn then
              vSolids.Add(CreateSolid(vCell, vCell.GetMergedRect));
            // create MText entities
            vField := vCell.Field;
            if Assigned(vField) then
            begin
              I := Pos(cnstFldIdx, vField.FieldCode);
              if I > 0 then
              begin
                Val(Copy(vField.FieldCode, I + Length(cnstFldIdx) + 1, MaxInt), I, J);
                vField := TsgDXFField(vField.ChildFields[I]);
                if vField.Cache.HasCode(301, @I) then
                  vCell.Text := vField.Cache.DataString[I];
                vMTextes.Add(CreateMText(vCell, False, False));
              end;
            end
            else
              if vCell.IsTextType and (vCell.Text <> '') then
                vMTextes.Add(CreateMText(vCell, False, False));
          end;
          Inc(C);
        end;
        Inc(R);
      end;

      GenerateLines(vLines, True);
      GenerateLines(vLines, False);

      LoadsAndAdd(vSolids);
      LoadsAndAdd(vMTextes);
      LoadsAndAdd(vLines);
      FConv.Loads(Result);
    finally
      vSolids.Free;
      vMTextes.Free;
      vLines.Free;
    end;
  end;
end;

procedure TsgAcadTableGenerator.GenerateLines(const ALines: TsgObjectList;
  const AHoresontal: Boolean);
const
  cnstDefPointsID = -1;

type
  TFRectEx = packed record
    case Integer of
      0: (R: TFRect);
      1: (Start: array[Boolean] of TsgFloat; Z1: TsgFloat;
          Finish: array[Boolean] of TsgFloat; Z2: TsgFloat);
  end;

var
  J, vSpan, vID: Integer;
  H, vHorz, vNotH: Boolean;
  vCells: array[Boolean] of TsgAcadTableCell;
  vBorder: array[Boolean] of Integer;
  vIsTopCell: Boolean;
  vLineData, vLineData1: PCellBorderLineData;
  vR: TFRectEx;

  function CreateLine(const AColor: TsgColorCAD; const ALineWeight: Double;
    const AVisibility: Boolean; const APoint, APoint1: TFPoint): TsgDXFLine; overload;
  begin
    Result := TsgDXFLine.Create;
    Result.ColorCAD := AColor;
    Result.LineWeight := ALineWeight;
    Result.Point := APoint;
    Result.Point1 := APoint1;
    //Result.Visibility := AVisibility;
  end;

  function CreateLine(ALineData: PCellBorderLineData;
    const APoint, APoint1: TFPoint): TsgDXFLine; overload;
  begin
    Result := CreateLine(ALineData^.Cell.BorderColor[ALineData^.Border],
      ALineData^.Cell.BorderLineWeight[ALineData^.Border],
      ALineData^.Span <= 0, APoint, APoint1);
    if ALineData^.ID = cnstDefPointsID then
    begin
      Result.Layer := FConv.LayerByName(sLayerDefPoints);
      Result.ColorCAD := MakeColorCAD(acIndexColor, clDXFGray);
    end;
  end;

  function IsBorderEq(AData1, AData2: PCellBorderLineData): Boolean;
  begin
    Result := AData1^.Cell.IsBorderEqEx(AData1^.Border, AData2^.Cell, AData2^.Border);
  end;

  function IsLineVisibility(AData: PCellBorderLineData): Boolean;
  begin
    Result := AData^.Cell.BorderVisible[AData^.Border] and (AData^.Span <= 0);
  end;

begin
  // if AHoresontal = true, then generate top and bottom border for each row
  // if AHoresontal = false, then generate left and right border for each col
  H := AHoresontal;
  vNotH := not H;
  vHorz := H or vNotH;
  FSgn[H] := 1;
  FSgn[vNotH] := -1;
  if H then
  begin
    vBorder[False] := 5; // top border line style
    vBorder[True] := 2; // bottom border line style
  end
  else
  begin
    vBorder[False] := 4; // left border line style
    vBorder[True] := 1; // right border line style
  end;
  // generate top/left and bottom/right border for each row
  ClearRecordListOfList(FData, False);
  for J := FRange.Start[H] to FRange.Finish[H] + 1 do
    TList(FData[FData.Add(TList.Create)]).Count := FRange.Finish[vNotH] - FRange.Start[vNotH] + 1;

  FIndex[vNotH] := FRange.Start[vNotH];
  while FIndex[vNotH] < FRange.Finish[vNotH] + 1 do
  begin
    FIndex[H] := FRange.Start[H];
    AddLineData(H, Cell[H, 0], vBorder[False], 0);
    Inc(FIndex[H]);
    while FIndex[H] < FRange.Finish[H] + 1 do
    begin
      vIsTopCell := True;
      vCells[vIsTopCell] := Cell[H, 0]; // top or left cell
      vCells[not vIsTopCell] := Cell[H, 1]; // bottom or right cell
      if H then
        vSpan := vCells[not vIsTopCell].SpanY
      else
        vSpan := vCells[not vIsTopCell].SpanX;
      if not vCells[vIsTopCell].BorderVisible[vBorder[not vIsTopCell]] and
         vCells[not vIsTopCell].BorderVisible[vBorder[vIsTopCell]] then
        vIsTopCell := False;
      AddLineData(H, vCells[vIsTopCell], vBorder[not vIsTopCell], vSpan);
      Inc(FIndex[H]);
    end;
    AddLineData(H, Cell[H, 1], vBorder[True], 0);
    Inc(FIndex[vNotH]);
  end;
  vID := 1;
  FIndex[H] := FRange.Start[H];
  if FRange.Finish[H] - FRange.Start[H] >= 0 then
    while FIndex[H] <= FRange.Finish[H] + 1 do
    begin
      FIndex[vNotH] := FRange.Start[vNotH];
      vLineData := ActiveCellBorderLineData[H];
      if IsLineVisibility(vLineData) then
        vLineData^.ID := vID
      else
        if vLineData^.Span > 0 then
          vLineData^.ID := 0
        else
          vLineData^.ID := cnstDefPointsID;
      Inc(FIndex[vNotH]);
      while FIndex[vNotH] < FRange.Finish[vNotH] + 1 do
      begin
        vLineData1 := ActiveCellBorderLineData[H];
        if IsLineVisibility(vLineData) and IsLineVisibility(vLineData1) then
          if IsBorderEq(vLineData, vLineData1) then
            vLineData1^.ID := vLineData^.ID
          else
          begin
            vID := vLineData^.ID;
            Inc(vID);
            vLineData1^.ID := vID;
          end
        else
          if IsLineVisibility(vLineData1) then
          begin
            Inc(vID);
            vLineData1^.ID := vID;
            vLineData := vLineData1;
          end
          else
          begin
            if vLineData1^.Span <= 0 then
            begin
              vLineData1^.ID := cnstDefPointsID;
              vLineData := vLineData1;
            end
          end;
        Inc(FIndex[vNotH]);
      end;
      Inc(vID);
      Inc(FIndex[H]);
    end;

  vR := TFRectEx(MakeFRect2D(0, 0, 0, 0));
  FIndex[H] := FRange.Start[H];
  if FRange.Finish[H] - FRange.Start[H] >= 0 then
    while FIndex[H] <= FRange.Finish[H] + 1 do
    begin
      FIndex[vNotH] := FRange.Start[vNotH];
      vR.Start[H] := vR.Finish[H];
      vR.Start[vNotH] := 0;
      vR.Finish[vNotH] := 0;
      repeat
        if ActiveCellBorderLineData[H]^.ID = 0 then
        begin
          vR.Finish[vNotH] := vR.Finish[vNotH] + FSgn[H] * Sizes[vNotH];
          vR.Start[vNotH] := vR.Finish[vNotH];
          Inc(FIndex[vNotH]);
        end
        else
        begin
          vLineData := ActiveCellBorderLineData[H];
          while (FIndex[vNotH] < FRange.Finish[vNotH] + 1) and
            (ActiveCellBorderLineData[H]^.ID = vLineData^.ID) and
            (ActiveCellBorderLineData[H]^.ID <> 0) do
          begin
            vR.Finish[vNotH] := vR.Finish[vNotH] + FSgn[H] * Sizes[vNotH];
            Inc(FIndex[vNotH]);
          end;
          ALines.Add(CreateLine(vLineData,
            MakeFPoint(FSgn[vHorz] * vR.Start[not vHorz], FSgn[vHorz] * vR.Start[vHorz], 0),
            MakeFPoint(FSgn[vHorz] * vR.Finish[not vHorz], FSgn[vHorz] * vR.Finish[vHorz], 0)));
          if FIndex[vNotH] < FRange.Finish[vNotH] + 1 then
            vR.Start[vNotH] := vR.Finish[vNotH];
        end;
      until FIndex[vNotH] >= FRange.Finish[vNotH] + 1;
      if FIndex[H] < FRange.Finish[H] + 1 then
        vR.Finish[H] := vR.Finish[H] + FSgn[vNotH] * Sizes[H];
      Inc(FIndex[H]);
    end;
end;

function TsgAcadTableGenerator.GetActiveCellBorderLineData(
  AHorz: Boolean): PCellBorderLineData;
begin
  Result := TList(FData[FIndex[AHorz] - FRange.Start[AHorz]])[FIndex[not AHorz] - FRange.Start[not AHorz]];
end;

function TsgAcadTableGenerator.GetCell(AHorz: Boolean; ADec: Integer): TsgAcadTableCell;
begin
  if AHorz then
    Result := FAcadTable.Cell[FIndex[not AHorz], FIndex[AHorz] - ADec]
  else
    Result := FAcadTable.Cell[FIndex[AHorz] - ADec, FIndex[not AHorz]];
end;

function TsgAcadTableGenerator.GetSizes(AHorz: Boolean): Double;
begin
  Result := FAcadTable.Sizes[AHorz, FIndex[AHorz]];
end;

function TsgAcadTableGenerator.CreateMText(const ACell: TsgAcadTableCell;
  const ADoCreate, ALoad: Boolean): TsgDXFMText;
var
  vRect: TFRect;
  vPoint: TFPoint;
begin
  Result := TsgDXFMText.Create;
  Result.Hyphenation := True;
  Result.Height := ACell.TextHeight;
  Result.Text := ACell.Text;
  Result.Align := ACell.CellAlignment;
  Result.Style := ACell.TextStyle;
  Result.ColorCAD := ACell.TextColor;
  Result.Angle := ACell.Rotation;
  vRect := ACell.GetMergedRect;
  InflateFRect(@vRect, - FAcadTable.Properties.HorzCellMargin,
    - FAcadTable.Properties.VertCellMargin, 0);
  //Result.RectHeight := vRect.Top - vRect.Bottom;
  Result.RectWidth := vRect.Right - vRect.Left;
  vPoint := AlignByBox(ACell.CellAlignment, vRect, ACell.TextHeight);
  Result.Point := vPoint;
  FConv.Loads(Result);
  vPoint := AlignByBox(ACell.CellAlignment, Result.Box, ACell.TextHeight);
  Result.Point := AddFPoint(Result.Point, SubFPoint(Result.Point, vPoint));
  if ADoCreate then
    FConv.DoCreate(Result);
  if ALoad then
    FConv.Loads(Result);
end;

{ TsgCADWipeoutVariables }

constructor TsgCADWipeoutVariables.Create;
begin
  inherited Create;
  FDisplayImageFrame := cnstWipeoutVariablesDisplayImageFrame;
  Name := cntClassDXFWIPEOUTVARIABLES;
end;

{ TsgCADRasterVariables }

constructor TsgCADRasterVariables.Create;
begin
  inherited Create;
  FDisplayImageFrame := cnstRasterVariablesDisplayImageFrame;
  Name := sRasterVariables;
end;

{ TsgCADDataLink }

constructor TsgCADDataLink.Create;
begin
  inherited Create;
  FFileName := '';
end;

function GetClassXDataProcs: TsgClassXDataProcs;
begin
{$IFDEF SG_BTI}
  Result := XDataProc__;
{$ELSE}
  Result := nil;
{$ENDIF}
end;

procedure SetClassXDataProcs(const AXDataProcs: TsgClassXDataProcs);
begin
{$IFDEF SG_BTI}
  XDataProc__ := AXDataProcs;
{$ENDIF}
end;

{ TsgDXFSeqend }

function TsgDXFSeqend.GetEntType: TsgCADEntities;
begin
  Result := ceSeqEnd;
end;

{ TsgDXFBlockRecord }

function TsgDXFBlockRecord.AddDestroyNotification(
  const ANotify: TNotifyEvent): Integer;
begin
  if not Assigned(FDestroyNotifications) then
    FDestroyNotifications := TsgNotifyEventsList.Create;
  Result := FDestroyNotifications.Add(ANotify);
end;

function TsgDXFBlockRecord.AddEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := FBlock.AddEntity(AEntity);
end;

procedure TsgDXFBlockRecord.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
{$IFDEF SG_BLOCK_PREVIEW}
  if Source is TsgDXFBlockRecord then
    FPreview.Assign(TsgDXFBlockRecord(Source).Preview);
{$ENDIF}
end;

procedure TsgDXFBlockRecord.AuthEnvironDestroing(Sender: TObject);
begin
//  if Sender = FAuthEnviron then
    FAuthEnviron := nil;
end;

procedure TsgDXFBlockRecord.ClearReferences;
begin
  inherited ClearReferences;
{$IFDEF SG_BLOCK_PREVIEW}
  if Assigned(FPreview) then FPreview.Graphic := nil;
{$ENDIF}
  if Assigned(FAuthEnviron) then
  begin
    FAuthEnviron.RemoveDestroyNotification(AuthEnvironDestroing);
    FAuthEnviron := nil;
  end;
end;

constructor TsgDXFBlockRecord.Create;
begin
  if FBlock = nil then
  begin
    FBlock := TsgDXFBlock(TsgDXFBlock.NewInstance);
    FBlock.FBlockRecord := Self;
    FBlock.Create;
  end;
  inherited Create;
  TsgBlockItem(FBlock.FLinkID).FBlockRecordLinkID := FLinkID;
  //raise Exception.Create('Cannot create ' + ClassName + ' directly');
{$IFDEF SG_BLOCK_PREVIEW}
  FPreview := TPicture.Create;
{$ENDIF}
end;

function TsgDXFBlockRecord.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FBlock.DeleteEntity(AIndex);
end;

destructor TsgDXFBlockRecord.Destroy;
begin
  NotifyDestroing;
  if Assigned(FBlock) then
  begin
    FBlock.FBlockRecord := nil;
    FreeAndNil(FBlock);
  end;
  inherited Destroy;
end;

function TsgDXFBlockRecord.EntName: string;
begin
  Result := Name;
  if Result = '' then
    Result := inherited EntName;
end;

procedure TsgDXFBlockRecord.ExchangeEntity(AIndex1, AIndex2: Integer);
begin
  FBlock.ExchangeEntity(AIndex1, AIndex2);
end;

procedure TsgDXFBlockRecord.FreeReferences;
begin
  inherited FreeReferences;
{$IFDEF SG_BLOCK_PREVIEW}
  FreeAndNil(FPreview);
{$ENDIF}
end;

function TsgDXFBlockRecord.GetBlockRepBTagBlockRecord: TsgDXFBlockRecord;
const
  cnstAcDbBlockRepETag = 'AcDbBlockRepBTag';
var
  vConverter: TsgDXFConverter;
  vAcDbBlockRepETag: TsgDXFEntity;
  vEEDItems: TsgObjectCollection;
  vData: TsgCADExtendedData;
  I: Integer;
begin
  Result := Self;
  vConverter := Converter;
  if Assigned(vConverter) and Assigned(vConverter.Sections[csAppID]) then
  begin
    vAcDbBlockRepETag := vConverter.Sections[csAppID].FindEntByName(cnstAcDbBlockRepETag);
    if Assigned(vAcDbBlockRepETag) then
    begin
      vEEDItems := vConverter.EEDItems[Handle];
      if Assigned(vEEDItems) then
      begin
        I := vEEDItems.IndexOf(vAcDbBlockRepETag.Handle);
        if I >= 0 then
        begin
          vData := TsgCADExtendedData(vEEDItems.Objects[I]);
          if vData.HasCode(Integer_1070, @I) and (vData.DataInt16[I] = 1) and
            (I + 1 < vData.DataCount) and (vData.DataType[I + 1] = edtInt64) then
          begin
            Result := TsgDXFBlockRecord(vConverter.BlockRecordByHandle(vData.DataInt64[I + 1]));
            if Result = nil then
              Result := Self;
          end;
        end;
      end;
    end;
  end;
end;

function TsgDXFBlockRecord.GetDescription: string;
begin
  Result := FLinkID.Description;
end;

function TsgDXFBlockRecord.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgDescriptedNamedItem;
end;

function TsgDXFBlockRecord.GetAcAuthEnvironBlockRecord: TsgDXFBlockRecord;
begin
  if Assigned(FAuthEnviron) then
    Result := FAuthEnviron
  else
    Result := Self;
end;

function TsgDXFBlockRecord.IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := FBlock.IndexOfEntity(AEntity);
end;

function TsgDXFBlockRecord.IndexOfName(const AName: string): Integer;
begin
  Result := FBlock.IndexOfName(AName);
end;

function TsgDXFBlockRecord.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := FBlock.InsertEntity(AIndex, AEntity);
end;

procedure TsgDXFBlockRecord.NotifyDestroing;
begin
  if Assigned(FDestroyNotifications) then
  begin
    while FDestroyNotifications.Count > 0 do
    try
      if Assigned(FDestroyNotifications.List^[FDestroyNotifications.Count - 1]) then
        FDestroyNotifications.List^[FDestroyNotifications.Count - 1](Self);
    finally
      FDestroyNotifications.Delete(FDestroyNotifications.Count - 1);
    end;
    FreeAndNil(FDestroyNotifications);
  end;
end;

function TsgDXFBlockRecord.RemoveDestroyNotification(
  const ANotify: TNotifyEvent): Integer;
begin
  Result := -1;
  if Assigned(FDestroyNotifications) then
  begin
    Result := FDestroyNotifications.Remove(ANotify);
    if FDestroyNotifications.Count = 0 then
      FreeAndNil(FDestroyNotifications);
  end;
end;

procedure TsgDXFBlockRecord.SetDescription(const AValue: string);
begin
  FLinkID.Description := AValue;
end;

{ TsgDXFPlotSettings }

procedure TsgDXFPlotSettings.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFPlotSettings then
  begin
    FData := TsgDXFPlotSettings(Source).FData;
    SetUnprintableMargin(FData.UnprintableMargin);
  end;
end;

constructor TsgDXFPlotSettings.Create;
begin
  inherited Create;
  FData := cnstDefaultPlotSettingsData;
  SetUnprintableMargin(FData.UnprintableMargin);
end;

function TsgDXFPlotSettings.GetCadMargins: TF2DRect;
var
  vMargins: TF2DRect;
begin
  vMargins := UnprintableMargin;
  case PlotRotation of
    pr90DegreesCounterCW:
      Result := MakeF2DRect(vMargins.Top, vMargins.Right, vMargins.Bottom, vMargins.Left);
    prUpsideDown:
      Result := MakeF2DRect(vMargins.Right, vMargins.Bottom, vMargins.Left, vMargins.Top);
    pr90DegreesCW:
      Result := MakeF2DRect(vMargins.Bottom, vMargins.Left, vMargins.Top, vMargins.Right);
    else
      Result := vMargins;
  end;
  Result.TopLeft := Pt2XScalar(Result.TopLeft, CustomPrintScaleKoef);
  Result.BottomRight := Pt2XScalar(Result.BottomRight, CustomPrintScaleKoef);
end;

function TsgDXFPlotSettings.GetCadOffset: TF2DPoint;
begin
  Result := Pt2XScalar(PlotOrigin, -CustomPrintScaleKoef);
  case PlotRotation of
    pr90DegreesCounterCW, pr90DegreesCW:
      SwapDoubles(Result.X, Result.Y);
  end;
end;

function TsgDXFPlotSettings.GetCustomPrintScale: TsgPlotScale;
begin
  Result.Numerator := NumeratorOfCustomPrintScale;
  Result.Denomenator := DenominatorOfCustomPrintScale;
end;

function TsgDXFPlotSettings.GetCustomPrintScaleKoef: Double;
var
  vNumValue: Double;
begin
  vNumValue := NumeratorOfCustomPrintScale;
  if PlotPaperUnits = ppuInches then
    vNumValue := vNumValue * cnstMMPerInch;
  if vNumValue <> 0 then
    Result := DenominatorOfCustomPrintScale / vNumValue
  else
    Result := 1;
end;

function TsgDXFPlotSettings.GetIsCenter: Boolean;
begin
  Result := plfPlotCentered in PlotLayoutFlags;
end;

function TsgDXFPlotSettings.GetIsFitToPaper: Boolean;
begin
  Result := (plfUseStandardScale in PlotLayoutFlags) and (StandardScaleType = 0);
end;

function TsgDXFPlotSettings.GetIsLandscapePaper: Boolean;
begin
  Result := PlotPaperSize.X > PlotPaperSize.Y;
end;

function TsgDXFPlotSettings.GetLandScape: Boolean;
begin
  Result := IsLandscapePaper;
  if PlotRotation in [pr90DegreesCounterCW, pr90DegreesCW] then
    Result := not Result;
end;

function TsgDXFPlotSettings.GetMagrinsArea: TFRect;
var
  vMarginsSize, vStartPoint: TF2DPoint;
  vMargins: TF2DRect;
begin
  vMarginsSize.X := PlotPaperSize.X * CustomPrintScaleKoef;
  vMarginsSize.Y := PlotPaperSize.Y * CustomPrintScaleKoef;
  case PlotRotation of
    pr90DegreesCounterCW, pr90DegreesCW:
      SwapDoubles(vMarginsSize.X, vMarginsSize.Y);
  end;
  vMargins := GetCadMargins;
  vMarginsSize.X := vMarginsSize.X - (vMargins.Left + vMargins.Right);
  vMarginsSize.Y := vMarginsSize.Y - (vMargins.Top + vMargins.Bottom);
  vStartPoint := GetStartPoint;
  Result.TopLeft := MakeFPointFrom2D(vStartPoint);
  Result.BottomRight := AddFPoint2D(Result.TopLeft, MakeFPointFrom2D(vMarginsSize));
end;

function TsgDXFPlotSettings.GetName: string;
begin
  Result := inherited GetName;
end;

function TsgDXFPlotSettings.GetPaperArea: TFRect;
var
  vStartPoint: TF2DPoint;
  vPaperSize: TF2DPoint;
  vCadmargins: TF2DRect;
begin
  vPaperSize := Pt2XScalar(PlotPaperSize, CustomPrintScaleKoef);
  case PlotRotation of
    pr90DegreesCounterCW, pr90DegreesCW:
      SwapDoubles(vPaperSize.X, vPaperSize.Y);
  end;
  vCadmargins := GetCadMargins;
  vStartPoint := GetStartPoint;
  vStartPoint.X := vStartPoint.X - GetCadMargins.Left;
  vStartPoint.Y := vStartPoint.Y - GetCadMargins.Bottom;
  Result.TopLeft := MakeFPointFrom2D(vStartPoint);
  Result.BottomRight := AddFPoint(Result.TopLeft, MakeFPointFrom2D(vPaperSize));
end;

function TsgDXFPlotSettings.GetPlotData: PsgPlotSettingsData;
begin
  Result := @FData;
end;

function TsgDXFPlotSettings.GetPlotFrameArea: TFRect;
begin
  Result.Left := PlotWindowAreaMin.X;
  Result.Top := PlotWindowAreaMin.Y;
  Result.Right := PlotWindowAreaMax.X;
  Result.Bottom := PlotWindowAreaMax.Y;
  Result.Z1 := 0;
  Result.Z2 := 0;
end;

function TsgDXFPlotSettings.GetPrintableArea: TFRect;
var
  vFrameArea: TFRect;
  vMarginArea: TFRect;

  procedure FlipRect(var ARect: TFRect);
  begin
    if ARect.Left > ARect.Right then
      SwapDoubles(ARect.Left, ARect.Right);
    if ARect.Bottom > ARect.Top then
      SwapDoubles(ARect.Top, ARect.Bottom);
  end;

begin
  vMarginArea := GetMagrinsArea;
  if (PlotType = ptWindowSpecified) then
  begin
    vFrameArea := GetPlotFrameArea;
    FlipRect(vFrameArea);
    FlipRect(vMarginArea);
    Result.Left := Max(vFrameArea.Left, vMarginArea.Left);
    Result.Top := Min(vFrameArea.Top, vMarginArea.Top);
    Result.Right := Min(vFrameArea.Right, vMarginArea.Right);
    Result.Bottom := Max(vFrameArea.Bottom, vMarginArea.Bottom);
    Result.Z1 := 0;
    Result.Z2 := 0;
  end
  else
    Result := vMarginArea;
end;

function TsgDXFPlotSettings.GetRotatedMargin: TF2DRect;
begin
  case PlotRotation of
    pr90DegreesCounterCW:
      Result := MakeF2DRect(UnprintableMargin.Bottom, UnprintableMargin.Left,
        UnprintableMargin.Top, UnprintableMargin.Right);
    prUpsideDown:
      Result := MakeF2DRect(UnprintableMargin.Right, UnprintableMargin.Bottom,
        UnprintableMargin.Left, UnprintableMargin.Top);
    pr90DegreesCW:
      Result := MakeF2DRect(UnprintableMargin.Top, UnprintableMargin.Right,
        UnprintableMargin.Bottom, UnprintableMargin.Left);
    else
      Result := UnprintableMargin;
  end;
end;

function TsgDXFPlotSettings.GetStartPoint: TF2DPoint;
var
  vPaperOffset: TF2DPoint;
begin
  if PlotPaperUnits = ppuInches then
  begin
    vPaperOffset.X := - PaperImageOrigin.X / cnstMMPerInch;
    vPaperOffset.Y := - PaperImageOrigin.Y / cnstMMPerInch;
  end
  else
  begin
    vPaperOffset.X := - PaperImageOrigin.X;
    vPaperOffset.Y := - PaperImageOrigin.Y;
  end;
  Result := AddF2DPoint(GetCadOffset, vPaperOffset);
end;

function TsgDXFPlotSettings.PlotSettingsDataToXMLNode(
  const AData: PsgPlotSettingsData; const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  vPLFlag: TsgPlotLayoutFlag;
  vFlags: UInt64;
  vViewMode: Boolean;
begin
  Result := cnstXML_OK;
  vViewMode := xmlForViewing in AParams.Mode;
  ANode.AddAttribNV(cnstXMLNames[xmlPageSetupName].Name).ValueData.ValueAsText := AData^.PageSetupName;
  ANode.AddAttribNV(cnstXMLNames[xmlPrintOrConfigName].Name).ValueData.ValueAsText := AData^.PrintOrConfigName;
  vFlags := 0;
  for vPLFlag := Low(TsgPlotLayoutFlag) to High(TsgPlotLayoutFlag) do
    if vPLFlag in AData^.PlotLayoutFlags then
      vFlags := vFlags or Integer(1 shl Byte(vPLFlag));
  ANode.AddAttribNV(cnstXMLNames[xmlPlotLayoutFlags].Name).ValueAsInt64{ValueAsHandle} := vFlags;
  ANode.AddAttribNV(cnstXMLNames[xmlPlotPaperUnits].Name).ValueAsInt := Integer(AData^.PlotPaperUnits);
  ANode.AddAttribNV(cnstXMLNames[xmlStandardScaleType].Name).ValueAsInt := AData^.StandardScaleType;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlNumeratorOfCustomPrintScale].Name).ValueData, AData^.NumeratorOfCustomPrintScale, vViewMode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlDenominatorOfCustomPrintScale].Name).ValueData, AData^.DenominatorOfCustomPrintScale, vViewMode);
  ANode.AddAttribNV(cnstXMLNames[xmlPaperSizeName].Name).ValueData.ValueAsText := AData^.PaperSize;
  ANode.AddAttribNV(cnstXMLNames[xmlPlotViewName].Name).ValueData.ValueAsText := AData^.PlotViewName;
  SetDataValueAsF2DRect(ANode.AddAttribNV(cnstXMLNames[xmlUnprintableMargin].Name).ValueData, AData^.UnprintableMargin, vViewMode);
  SetDataValueAsF2DPoint(ANode.AddAttribNV(cnstXMLNames[xmlPlotPaperSize].Name).ValueData, AData^.PlotPaperSize, vViewMode);
  SetDataValueAsF2DPoint(ANode.AddAttribNV(cnstXMLNames[xmlPlotOrigin].Name).ValueData, AData^.PlotOrigin, vViewMode);
  SetDataValueAsF2DPoint(ANode.AddAttribNV(cnstXMLNames[xmlPlotWindowAreaMin].Name).ValueData, AData^.PlotWindowAreaMin, vViewMode);
  SetDataValueAsF2DPoint(ANode.AddAttribNV(cnstXMLNames[xmlPlotWindowAreaMax].Name).ValueData, AData^.PlotWindowAreaMax, vViewMode);
  ANode.AddAttribNV(cnstXMLNames[xmlPlotRotation].Name).ValueAsInt := Integer(AData^.PlotRotation);
  ANode.AddAttribNV(cnstXMLNames[xmlPlotType].Name).ValueAsInt := Integer(AData^.PlotType);
  ANode.AddAttribNV(cnstXMLNames[xmlCurrentStyleSheet].Name).ValueData.ValueAsText := AData^.CurrentStyleSheet;
  ANode.AddAttribNV(cnstXMLNames[xmlShadePlotMode].Name).ValueAsInt := AData^.ShadePlotMode;
  ANode.AddAttribNV(cnstXMLNames[xmlShadePlotResolutionLevel].Name).ValueAsInt := AData^.ShadePlotResolutionLevel;
  ANode.AddAttribNV(cnstXMLNames[xmlShadePlotCustomDPI].Name).ValueAsInt := AData^.ShadePlotCustomDPI;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlFloatingPointScaleFactor].Name).ValueData, AData^.FloatingPointScaleFactor, vViewMode);
  SetDataValueAsF2DPoint(ANode.AddAttribNV(cnstXMLNames[xmlPaperImageOrigin].Name).ValueData, AData^.PaperImageOrigin, vViewMode);
end;

function TsgDXFPlotSettings.PlotSettingsDataFromXMLNode(
  const AData: PsgPlotSettingsData; const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
var
  vFlags: UInt64;
  vEnum: Integer;
  vPLFlag: TsgPlotLayoutFlag;
begin
  Result := cnstXML_OK;
  case AType.Id of
    xmlPageSetupName:      AData^.PageSetupName := ANode.ValueData.ValueAsText;
    xmlPrintOrConfigName:  AData^.PrintOrConfigName := ANode.ValueData.ValueAsText;
    xmlPlotLayoutFlags:
      begin
        vFlags := ANode.ValueAsInt64{ValueAsHandle};
        AData^.PlotLayoutFlags := [];
        for vPLFlag := Low(TsgPlotLayoutFlag) to High(TsgPlotLayoutFlag) do
          if vFlags and (1 shl Byte(vPLFlag)) <> 0 then
            Include(AData^.PlotLayoutFlags, vPLFlag);
      end;
    xmlPlotPaperUnits:
      begin
        vEnum := ANode.ValueAsInt;
        if (vEnum >= Integer(Low(TsgPlotPaperUnits))) and (vEnum <= Integer(High(TsgPlotPaperUnits)))  then
          AData^.PlotPaperUnits := TsgPlotPaperUnits(vEnum);
      end;
    xmlStandardScaleType:             AData^.StandardScaleType := ANode.ValueAsInt;
    xmlNumeratorOfCustomPrintScale:   AData^.NumeratorOfCustomPrintScale := ANode.ValueAsDouble;
    xmlDenominatorOfCustomPrintScale: AData^.DenominatorOfCustomPrintScale := ANode.ValueAsDouble;
    xmlPaperSizeName:                 AData^.PaperSize := ANode.ValueData.ValueAsText;
    xmlPlotViewName:                  AData^.PlotViewName := ANode.ValueData.ValueAsText;
    xmlUnprintableMargin:             AData^.UnprintableMargin := ANode.ValueData.ValueAsF2DRect;
    xmlPlotPaperSize:                 AData^.PlotPaperSize := ANode.ValueData.ValueAsF2DPoint;
    xmlPlotOrigin:                    AData^.PlotOrigin := ANode.ValueData.ValueAsF2DPoint;
    xmlPlotWindowAreaMin:             AData^.PlotWindowAreaMin := ANode.ValueData.ValueAsF2DPoint;
    xmlPlotWindowAreaMax:             AData^.PlotWindowAreaMax := ANode.ValueData.ValueAsF2DPoint;
    xmlPlotRotation:
      begin
        vEnum := ANode.ValueAsInt;
        if (vEnum >= Integer(Low(TsgPlotRotation))) and (vEnum <= Integer(High(TsgPlotRotation)))  then
          AData^.PlotRotation := TsgPlotRotation(vEnum);
      end;
    xmlPlotType:
      begin
        vEnum := ANode.ValueAsInt;
        if (vEnum >= Integer(Low(TsgPlotType))) and (vEnum <= Integer(High(TsgPlotType)))  then
          AData^.PlotType := TsgPlotType(vEnum);
      end;
    xmlCurrentStyleSheet:             AData^.CurrentStyleSheet := ANode.ValueData.ValueAsText;
    xmlShadePlotMode:                 AData^.ShadePlotMode := ANode.ValueAsInt;
    xmlShadePlotResolutionLevel:      AData^.ShadePlotResolutionLevel := ANode.ValueAsInt;
    xmlShadePlotCustomDPI:            AData^.ShadePlotCustomDPI := ANode.ValueAsInt;
    xmlFloatingPointScaleFactor:      AData^.FloatingPointScaleFactor := ANode.ValueAsDouble;
    xmlPaperImageOrigin:              AData^.PaperImageOrigin := ANode.ValueData.ValueAsF2DPoint;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure TsgDXFPlotSettings.RecalcScale(const APrinter, APaper: string;
  const AOffset: TF2DPoint; const AUnits: TsgPlotPaperUnits; const ALandscape,
  AFit: Boolean; const AExtents, ADisplay: TFRect; const AIndexFormat: Integer;
  const AFormats: TStrings; const APlotScale: PsgPlotScale;
  const CalcMargins: TsgCalcMargins
  );
var
  vPlotScale: TsgPlotScale;
  vPaperFormat: PPaperFormat;
  vOffset: TF2DPoint;
begin
  PrintOrConfigName := APrinter;
  if PrintOrConfigName = cnstPrinterNone then
    PrintOrConfigName := cnstNoneDevice;
  if (AIndexFormat > -1) and (AIndexFormat < AFormats.Count) then
  begin
    PlotPaperSize := GetPaperSizesFromBox(AIndexFormat, AFormats);
    PaperSize := APaper;
    vPaperFormat := PPaperFormat(AFormats.Objects[AIndexFormat]);
  end
  else
    vPaperFormat := nil;
  PageSetupName := '';
  PlotRotation := prNoRotation;
  UnprintableMargin := CalcMargins(APrinter, vPaperFormat);
  case AUnits of
    ppuMM:
      PlotPaperUnits := ppuMM;
  else
    PlotPaperUnits := ppuInches;
  end;
  LandScape := ALandscape;
  if AFit then
  begin
    vPlotScale := CalculatePlotScale(AExtents, ADisplay);
    if Assigned(APlotScale) then
      APlotScale^ := vPlotScale;
  end
  else
  begin
    if Assigned(APlotScale) then
      vPlotScale := APlotScale^
    else
    begin
      vPlotScale.Numerator := NumeratorOfCustomPrintScale;
      vPlotScale.Denomenator := DenominatorOfCustomPrintScale;
    end;
  end;
  NumeratorOfCustomPrintScale := vPlotScale.Numerator;
  DenominatorOfCustomPrintScale := vPlotScale.Denomenator;
  if FloatingPointScaleFactor = 0 then
    FloatingPointScaleFactor := 1;
  SetPaperImageOriginPoint(AExtents, ADisplay);
  if plfPlotCentered in PlotLayoutFlags then
    vOffset := FillCentringOffset(AExtents, ADisplay)
  else
    vOffset := AOffset;
  PlotOrigin := vOffset;
end;

function TsgDXFPlotSettings.CalculatePlotScale(const AExtents: TFRect;
  const ADisplay: TFRect): TsgPlotScale;

  function InternalCalcFitScale(ARect: TFRect): TsgPlotScale;
  begin
    Result := CalcFitScale(ARect, UnprintableMargin,
      PlotPaperSize, PlotRotation in [pr90DegreesCounterCW, pr90DegreesCW],
      PlotPaperUnits = ppuMM);
  end;

begin
  case PlotType of
    ptWindowSpecified:
      Result := InternalCalcFitScale(PlotFrameArea);
    ptDrawingExtents:
      Result := InternalCalcFitScale(AExtents);
    ptLastScreenDisplay :
      Result := InternalCalcFitScale(ADisplay);
    else
      Result := InternalCalcFitScale(AExtents);
  end;
end;

procedure TsgDXFPlotSettings.SetPaperImageOriginPoint(const AExtents, ADisplay: TFRect);
var
  vRect: TFRect;
begin
  if PlotType <> ptLayoutInformation then
  begin
    case PlotType of
      ptLastScreenDisplay:
        vRect := ADisplay;
      ptDrawingExtents:
        vRect := AExtents;
      ptWindowSpecified:
         vRect := PlotFrameArea;
    end;
    PaperImageOrigin := GetPaperImageOriginPoint(PlotPaperUnits = ppuMM,
      PlotType, vRect);
  end;
end;

procedure TsgDXFPlotSettings.SetUnprintableMargin(const Value: TF2DRect);
begin
  if cnstUnprintableMarginEmpty then
    FData.UnprintableMargin := cnstF2DRectZero
  else
    FData.UnprintableMargin := Value;
end;

function TsgDXFPlotSettings.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  PlotSettingsDataToXMLNode(@FData, ANode, AParams);
end;

//for internal using - move extents
procedure TsgDXFPlotSettings.UpdateExtents(const AExtents: TFRect);
var
  vPaperSize: TF2DRect;
//  vPlotOrigin: TF2DPoint;
  vInside: Boolean;
  vPlotScale: TsgPlotScale;
begin
  if IsBadRect(AExtents) then Exit;
  vPaperSize := MakeF2dRectFromFRect(PlotPaperArea);
  if vPaperSize.Top < vPaperSize.Bottom then
    SwapDoubles(vPaperSize.Top, vPaperSize.Bottom);
  vInside := IsRectInRectF2D(MakeF2dRectFromFRect(AExtents), vPaperSize);
  if vInside then
  begin
//    PlotLayoutFlags := PlotLayoutFlags - [plfUseStandardScale, plfPlotCentered];
//    StandardScaleType := 0;
//    NumeratorOfCustomPrintScale := 1;
//    DenominatorOfCustomPrintScale := 1;
//    vPlotOrigin := MakeF2DPoint(AExtents.Left, AExtents.Bottom);
//    if not IsLandscapePaper then
//      SwapDoubles(vPlotOrigin.X, vPlotOrigin.Y);
//    PlotOrigin := vPlotOrigin;
//    PaperImageOrigin := SubF2DPoint(cnstF2DPointZero, PlotOrigin);
  end
  else
  begin//invalid matrixes
    UnprintableMargin := cnstUnprintableMargins;
    vPlotScale := CalculatePlotScale(AExtents, GetPaperArea);
    NumeratorOfCustomPrintScale := vPlotScale.Numerator;
    DenominatorOfCustomPrintScale := vPlotScale.Denomenator;
    PlotLayoutFlags := PlotLayoutFlags + [plfUseStandardScale, plfPlotCentered];
    PlotOrigin := CalculateCentringOffset(AExtents);
    SetPaperImageOriginPoint(AExtents, cnstFRectZero);
  end;
end;

function TsgDXFPlotSettings.FillCentringOffset(const AExtents, ADisplay: TFRect): TF2DPoint;
begin
  case PlotType of
    ptWindowSpecified:
      Result := CalculateCentringOffset(PlotFrameArea);
    ptDrawingExtents:
      Result := CalculateCentringOffset(AExtents);
    ptLastScreenDisplay :
      Result := CalculateCentringOffset(ADisplay);
    else
      Result := CalculateCentringOffset(AExtents);
  end;
end;

function TsgDXFPlotSettings.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result = cnstXML_UNSUPPORTED then
    Result := PlotSettingsDataFromXMLNode(@FData, AType, ANode, AIsChild, AResult);
end;

function TsgDXFPlotSettings.CalculateCentringOffset(const AExtents: TFRect): TF2DPoint;
var
  vSourceHeight, vSourceWidth, vWidht, vHeight: Double;
  vHorMarginsWidth, vHorMarginsHeight: Double;
begin
  vHorMarginsWidth := UnprintableMargin.Left +
    UnprintableMargin.Right;
  vHorMarginsHeight := UnprintableMargin.Top +
    UnprintableMargin.Bottom;
  vSourceWidth := PlotPaperSize.X - vHorMarginsWidth;
  vSourceHeight := PlotPaperSize.Y - vHorMarginsHeight;
  if CustomPrintScaleKoef <> 0 then
  begin
    vWidht := Abs(AExtents.Left - AExtents.Right) / CustomPrintScaleKoef;
    vHeight := Abs(AExtents.Top - AExtents.Bottom) / CustomPrintScaleKoef;
    if PlotRotation in [pr90DegreesCounterCW, pr90DegreesCW] then
      SwapDoubles(vWidht, vHeight);
    Result.X := (vSourceWidth - vWidht) / 2;
    Result.Y := (vSourceHeight - vHeight) / 2;
  end
  else
  begin
    Result.X := 0;
    Result.Y := 0;
  end;
end;

procedure TsgDXFPlotSettings.ResetForDefaultValue(ADefaultValue: PsgPlotSettingsData = nil);
begin
  if Assigned(ADefaultValue) then
    FData := ADefaultValue^
  else
    FData := sgDefaultPlotSettingsData;
end;

procedure TsgDXFPlotSettings.SetCustomPrintScale(const AValue: TsgPlotScale);
begin
  NumeratorOfCustomPrintScale := AValue.Numerator;
  DenominatorOfCustomPrintScale := AValue.Denomenator;
end;

function TsgDXFPlotSettings.SetDefaultValueByExtents(const ABox: TFRect;
  const ANeedSaveSize: Boolean = False): Boolean;
const
  cnstMM: Boolean = True;
var
  vMargins: TF2DRect;
  vName: string;
  vLandScape: Boolean;
begin
  Result := False;
  vName := '';
  PlotType := ptDrawingExtents;
  PlotLayoutFlags := PlotLayoutFlags + [plfUseStandardScale];
  StandardScaleType := 0;
  PrintOrConfigName := cnstNoneDevice;
  PlotPaperUnits := ppuMM;
  if ANeedSaveSize then
  begin
    PlotPaperSize := MakeF2DPointFrom3D(AbsFPoint2D(SubFPoint2D(ABox.TopLeft, ABox.BottomRight)));
    vMargins := cnstF2DRectZero;
    vName := cnstNoneDevice;
  end
  else
    PlotPaperSize := GetPrinterActualPaperSize(ABox, vName, @vMargins);
  PaperSize := vName;
  vLandScape := GetLandScale(PlotPaperSize);
  if vLandScape xor GetLandScale(GetSizeFRect2D(ABox)) then
    PlotRotation := pr90DegreesCounterCW;
  UnprintableMargin := vMargins;
  PlotOrigin := cnstF2DPointZero;
  if IsBadRect(ABox) then
  begin
    DenominatorOfCustomPrintScale := 1;
    NumeratorOfCustomPrintScale := 1;
  end
  else
  begin
     CustomPrintScale := CalcFitScale(ABox, vMargins,
      PlotPaperSize, PlotRotation = pr90DegreesCounterCW, cnstMM);
    PaperImageOrigin := MakeF2DPoint(-ABox.Left, -ABox.Bottom);
    Result := True;
  end;
end;

procedure TsgDXFPlotSettings.SetLandScape(const AValue: Boolean);
begin
  if IsLandscapePaper then
  begin
    if AValue then
      PlotRotation := prNoRotation
    else
      PlotRotation := pr90DegreesCW;
  end
  else
  begin
    if AValue then
      PlotRotation := pr90DegreesCW
    else
      PlotRotation := prNoRotation;
  end;
end;

procedure TsgDXFPlotSettings.SetName(const AName: string);
begin
  inherited SetName(AName);
  FData.PageSetupName := Name;
end;

{ TsgDXFDictionaryVar }

procedure TsgDXFDictionaryVar.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFDictionaryVar then
  begin
    FValue := TsgDXFDictionaryVar(Source).FValue;
    FIntVal := TsgDXFDictionaryVar(Source).FIntVal;
  end;
end;

constructor TsgDXFDictionaryVar.Create;
begin
  inherited Create;
  Name := cnstDictionaryVar;
end;

function TsgDXFDictionaryVar.EntName: string;
begin
  Result := GetName;
  if Result = '' then
    Result := inherited EntName;
end;

function TsgDXFDictionaryVar.GetValue: string;
begin
  Result := FValue;
end;

procedure TsgDXFDictionaryVar.SetValue(const AValue: string);
begin
  FValue := AValue;
end;

function TsgDXFDictionaryVar.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlDictionaryValue].Name).ValueAsStr := Value;
end;

function TsgDXFDictionaryVar.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlDictionaryValue: Value := ANode.ValueAsStr;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{ TsgDXFDimensionStyleProperties }

procedure TsgDXFDimensionProperties.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  FPropertiesInit := [];
  SetOwnerStyleInternal(nil);
  if Source is TsgDXFDimensionProperties then
  begin
    SetOwnerStyleInternal(TsgDXFDimensionProperties(Source).GetOwnerStyleInternal);
    FPropertiesInit := TsgDXFDimensionProperties(Source).FPropertiesInit;
  end;
end;

procedure TsgDXFDimensionProperties.ClearReferences;
begin
  inherited ClearReferences;
  SetOwnerStyleInternal(nil);
end;

constructor TsgDXFDimensionProperties.Create;
begin
  inherited Create;
  FOwnerStyleItem := TsgTableItem.Create;
end;

procedure TsgDXFDimensionProperties.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FOwnerStyleItem);
end;

function TsgDXFDimensionProperties.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vDimVal: TsgDimNameVal;
begin
  if AType.Id = xmlName then
    Result := cnstXML_OK
  else
  begin
    Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
    if (Result = cnstXML_OK) and (not (AType.Id in [xmlUndefined, xmlDimAlt, xmlDimAltF, xmlDimAPost])) then
    begin
      for vDimVal := Low(cnstDimXmlId) to High(cnstDimXmlId) do
      begin
        if AType.Id = cnstDimXmlId[vDimVal] then
        begin
          Include(FPropertiesInit, vDimVal);
          Break;
        end;
      end;
    end;
  end;
end;

function TsgDXFDimensionProperties.GetActualStyle(const ANameValue: TsgDimNameVal;
  const ASetValue: Boolean = False): TsgDXFDimensionStyle;
begin
  if ASetValue then
    Include(FPropertiesInit, ANameValue);
  if (OwnerStyle = nil) or (ANameValue in FPropertiesInit) then
  begin
    Result := inherited GetActualStyle(ANameValue)
  end
  else
    if Assigned(OwnerStyle) then
      Result := OwnerStyle.GetActualStyle(ANameValue)
    else
      Result := inherited GetActualStyle(ANameValue)
end;

function TsgDXFDimensionProperties.GetConverter: TsgDXFConverter;
begin
  Result := inherited GetConverter;
  if not Assigned(Result) and Assigned(OwnerStyle) and (OwnerStyle <> Self) then
    Result := OwnerStyle.Converter;
end;

{ TsgDXFDimensionStyleProperties }
function TsgDXFDimensionProperties.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;

  function GetRefHandle(const AEntity: TsgDXFEntity): UInt64;
  begin
    if AEntity <> nil then
      Result := AEntity.Handle
    else
      Result := cnstBadHandle;
  end;

  function GetBlockRecordHandle(const ABlock: TsgDXFBlock): UInt64;
  begin
    Result := cnstBadHandle;
    if ABlock <> nil then
      Result := ABlock.BlockRecord.Handle;
  end;

  procedure AddFloat(AName: TsgDimNameVal; ACode: Integer; AValue: Double);
  begin
    if AName in FPropertiesInit then
    begin
      AData.AddInt16(Integer_1070, ACode);
      AData.AddDouble(Float_1040, AValue);
    end;
  end;

  procedure AddInt16(AName: TsgDimNameVal; ACode: Integer; AValue: Integer);
  begin
    if AName in FPropertiesInit then
    begin
      AData.AddInt16(Integer_1070, ACode);
      AData.AddInt16(Integer_1070, AValue);
    end;
  end;

  procedure AddInt64(AName: TsgDimNameVal; ACode: Integer; AValue: UInt64);
  begin
    if AName in FPropertiesInit then
    begin
      AData.AddInt16(Integer_1070, ACode);
      AData.AddInt64(String_1005, AValue);
    end;
  end;

  procedure AddText(AName: TsgDimNameVal; ACode: Integer; AValue: string);
  begin
    if AName in FPropertiesInit then
    begin
      AData.AddInt16(Integer_1070, ACode);
      AData.AddString(String_1000, AValue);
    end;
  end;

begin
  Result := False;
  if Assigned(AData) and (FPropertiesInit <> []) then
  try
    BeginExtData(AData, AAppID);
    AddFloat(vnDIMSCALE,  Float_40,     Scale);
    AddFloat(vnDIMASZ,    Float_41,     ArrowSize);
    AddFloat(vnDIMEXO,    Float_42,     ExtLineOffset);
    AddFloat(vnDIMEXE,    Float_44,     ExtLineExt);
    AddInt16(vnDIMTIH,    Integer_73,   Ord(DIMTIH));
    AddInt16(vnDIMTOH,    Integer_74,   Ord(DIMTOH));
    AddInt16(vnDIMSE1,    Integer_75,   Ord(DIMSE1));
    AddInt16(vnDIMSE2,    Integer_76,   Ord(DIMSE2));
    AddInt16(vnDIMTAD,    Integer_77,   Ord(TextPosVert));
    AddFloat(vnDIMTXT,    Float_140,    TextHeight);
    AddFloat(vnDIMCEN,    Float_141,    SizeCenterMark);
    AddFloat(vnDIMLFAC,   Float_144,    DIMLFAC);
    AddFloat(vnDIMGAP,    Float_147,    TextOffset);
    AddInt16(vnDIMSAH,    Integer_173,  Ord(DIMSAH));
    AddInt16(vnDIMTIX,    Integer_174,  DIMTIX);
    AddInt16(vnDIMCLRD,   Integer_176,  ConvertColorCADToIndexColor(DIMCLRD, False));
    AddInt16(vnDIMCLRE,   Integer_177,  ConvertColorCADToIndexColor(DIMCLRE, False));
    AddInt16(vnDIMCLRT,   Integer_178,  ConvertColorCADToIndexColor(DIMCLRT, False));
    AddInt16(vnDIMDEC,    Integer_271,  DIMDEC);
    AddInt16(vnDIMSD1,    Word_281,     Ord(DIMSD1));
    AddInt16(vnDIMSD2,    Word_282,     Ord(DIMSD2));
    AddInt64(vnDIMTXSTY,  340,          GetRefHandle(TextStyle));
    AddInt64(vnDIMLRBLK,  341,          GetBlockRecordHandle(DIMLDRBLK));
    AddInt64(vnDIMBLK,    342,          GetBlockRecordHandle(DIMBLK));
    AddInt64(vnDIMBLK1,   343,          GetBlockRecordHandle(DIMBLK1));
    AddInt64(vnDIMBLK2,   344,          GetBlockRecordHandle(DIMBLK2));
    AddInt16(vnDIMLWD,    371,          ConvertLineWeightToDXF(DIMLWD));
    AddInt16(vnDIMLWE,    372,          ConvertLineWeightToDXF(DIMLWE));
    AddText(vnDIMPOST,   Text_3,        DIMPOST);
    AddFloat(vnDIMTP,    Float_47,      DIMTP);
    AddFloat(vnDIMTM,    Float_48,      DIMTM);
    AddInt16(vnDIMLUNIT, Integer_277,   GetDimLimitUnitsByte(DIMLUNIT));
    AddInt16(vnDIMDSEP,  Integer_278,   Ord(DIMDSEP));
    Result := True;
  finally
    EndExtData(AData);
  end;
end;

procedure TsgDXFDimensionProperties.SetExtData(const AData: TsgCADExtendedData);

  function GetEntityByHandle(const AHandle: UInt64;
    const ASection: TConvSection): TsgDXFEntity;
  var
    vSection: TsgDXFGroup;
  begin
    Result := nil;
    if AHandle <> cnstBadHandle then
    begin
      vSection := nil;
      if Assigned(Converter) then
        vSection := Converter.Sections[ASection];
      if Assigned(vSection) then
        Result := vSection.FindEntByHandle(AHandle);
    end;
  end;

  function GetStyleByHandle(const AHandle: UInt64): TsgDXFStyle;
  begin
    Result := TsgDXFStyle(GetEntityByHandle(AHandle, csStyles));
  end;

  function GetBlockByHandle(const AHandle: UInt64): TsgDXFBlock;
  begin
    Result := TsgDXFBlock(GetEntityByHandle(AHandle, csBlocks));
  end;

var
  I: Integer;
  vCode: SmallInt;
  vInt64Value: Uint64;
  vInt16Value: Integer;
  vDoubleValue, vLineWeight: Double;
  vTextValue: string;
begin
  inherited SetExtData(AData);
  if AData.IsEqualSubName(cnstDStyle) then
  begin
    FPropertiesInit := [];
    I := 1;
    vCode := -1;
    while I < AData.DataCount do
    begin
      if vCode > -1 then
      begin
        case AData.DataCode[I] of
          String_1000:
            begin
              vTextValue := AData.DataString[I];
              case vCode of
                Text_3: DIMPOST := vTextValue;
              end;
            end;
          String_1005:
            begin
              vInt64Value := AData.DataInt64[I];
              case vCode of
                340:  TextStyle := GetStyleByHandle(vInt64Value);
                341:  DIMLDRBLK := GetBlockByHandle(vInt64Value);
                342:  DIMBLK := GetBlockByHandle(vInt64Value);
                343:  DIMBLK1 := GetBlockByHandle(vInt64Value);
                344:  DIMBLK2 := GetBlockByHandle(vInt64Value);
              end;
            end;
          Float_1040:
            begin
              vDoubleValue := AData.DataDouble[I];
              case vCode of
                Float_40:  Scale := vDoubleValue;
                Float_41:  ArrowSize := vDoubleValue;
                Float_42:  ExtLineOffset := vDoubleValue;
                Float_44:  ExtLineExt := vDoubleValue;
                Float_47:  DIMTP := vDoubleValue;
                Float_48:  DIMTM := vDoubleValue;
                Float_141: SizeCenterMark := vDoubleValue;
                Float_140: TextHeight := Abs(vDoubleValue);
                Float_144: DIMLFAC := Abs(vDoubleValue);
                Float_147: TextOffset := vDoubleValue;
              end;
            end;
          Integer_1070:
            begin
              vInt16Value := AData.DataInt16[I];
              case vCode of
                Integer_73:   DIMTIX := vInt16Value;
                Integer_74:   DIMTOH := vInt16Value = 1;
                Integer_75:   DIMSE1 := vInt16Value = 1;
                Integer_76:   DIMSE2 := vInt16Value = 1;
                Integer_77:   TextPosVert := TsgDimTextPosVert(vInt16Value);
                Integer_173:  DIMSAH := vInt16Value = 1;
                Integer_174:  DIMTIX := vInt16Value;
                Integer_176:  DIMCLRD := MakeColorCAD(acIndexColor, vInt16Value);
                Integer_177:  DIMCLRE := MakeColorCAD(acIndexColor, vInt16Value);
                Integer_178:  DIMCLRT := MakeColorCAD(acIndexColor, vInt16Value);
                Integer_271:  DIMDEC := vInt16Value;
                Integer_277:  DIMLUNIT := GetDimLimitUnitsType(vInt16Value);
                Integer_278:  DIMDSEP := Char(vInt16Value);
                Word_281:     DIMSD1 := vInt16Value = 1;
                Word_282:     DIMSD2 := vInt16Value = 1;
                371, 372:
                  begin
                    vLineWeight := 0;
                    if ConvertDXFToLineWeight(vInt16Value, vLineWeight) then
                    begin
                      if vCode = 371 then
                        DIMLWD := vLineWeight
                      else
                        DIMLWE := vLineWeight;
                  end;
                end;
              end;
            end;
        end;
        vCode := -1;
      end
      else
      begin
        case AData.DataCode[I] of
          Integer_1070:  vCode := AData.DataInt16[I];
        end;
      end;
      Inc(I);
    end;
  end;
end;

function TsgDXFDimensionProperties.GetOwnerStyle: TsgDXFDimensionStyle;
begin
  Result := GetOwnerStyleInternal;
end;

function TsgDXFDimensionProperties.GetOwnerStyleInternal: TsgDXFDimensionStyle;
begin
  Result := TsgDXFDimensionStyle(FOwnerStyleItem.Item);
end;

function TsgDXFDimensionProperties.GetPropertiesInit: TsgDimNameVals;
begin
  Result := FPropertiesInit;
end;

procedure TsgDXFDimensionProperties.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlLineWeight));
      AHideList.Add(Integer(xmlFlags));
      AHideList.Add(Integer(xmlLineTypeName));
      AHideList.Add(Integer(xmlDimBlk));
      AHideList.Add(Integer(xmlDimRBlk));
      AHideList.Add(Integer(xmlDimAlt));
      AHideList.Add(Integer(xmlDimAltF));
      AHideList.Add(Integer(xmlDimAPost));
      AHideList.Add(Integer(xmlDimAsz));
      AHideList.Add(Integer(xmlDimSah));
      AHideList.Add(Integer(xmlDimCen));
      AHideList.Add(Integer(xmlDimDec));
      AHideList.Add(Integer(xmlDimLwD));
      AHideList.Add(Integer(xmlDimLwE));
      AHideList.Add(Integer(xmlDimPost));
      AHideList.Add(Integer(xmlDimScale));
      AHideList.Add(Integer(xmlBox));
      AHideList.Add(Integer(xmlDimTih));
      AHideList.Add(Integer(xmlDimTp));
      AHideList.Add(Integer(xmlDimTm));
      AHideList.Add(Integer(xmlDimLUnit));
      AHideList.Add(Integer(xmlDimDSep));
    end;
  end;
end;

procedure TsgDXFDimensionProperties.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgDXFDimensionProperties.OwnerStyleDestroyed(Sender: TObject);
begin
  if Assigned(FOwnerStyleItem) and (FOwnerStyleItem.Item = Sender) then
  begin
    FOwnerStyleItem.ItemObj.ObjRelease;
    FOwnerStyleItem.FItem := nil;
  end;
end;

procedure TsgDXFDimensionProperties.SetOwnerStyle(const AValue: TsgDXFDimensionStyle);
begin
  FPropertiesInit := [];
  SetOwnerStyleInternal(nil);
  if AValue <> nil then
  begin
    AssignEntity(AValue);
    SetOwnerStyleInternal(AValue);
  end;
end;

procedure TsgDXFDimensionProperties.SetOwnerStyleInternal(const AValue: TsgDXFDimensionStyle);
begin
  if FOwnerStyleItem.Item <> AValue then
  begin
    if Assigned(FOwnerStyleItem.Item) then
      FOwnerStyleItem.Item.RemoveDestroyNotification(OwnerStyleDestroyed);
    FOwnerStyleItem.Item := AValue;
    if Assigned(FOwnerStyleItem.Item) then
      FOwnerStyleItem.Item.AddDestroyNotification(OwnerStyleDestroyed);
  end;
end;

{ TsgDXFBlockRecords }

function TsgDXFBlockRecords.AddEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := -1;
  if Assigned(Blocks) then
    Result := Blocks.AddEntity(TsgDXFBlockRecord(AEntity).Block);
end;

procedure TsgDXFBlockRecords.Clear(const ADoFree: Boolean);
begin
//  if Assigned(Blocks) then
//    Blocks.Clear(ADoFree); ??
end;

constructor TsgDXFBlockRecords.Create;
begin
  inherited Create;
  Name := cnstTableBLOCK_RECORD;
end;

function TsgDXFBlockRecords.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := nil;
  if Assigned(Blocks) then
  begin
    Result := TsgDXFBlock(Blocks[AIndex]).BlockRecord;
    Blocks.DeleteEntity(AIndex);
  end;
end;

procedure TsgDXFBlockRecords.ExchangeEntity(AIndex1, AIndex2: Integer);
begin
  if Assigned(Blocks) then
    Blocks.ExchangeEntity(AIndex1, AIndex2);
end;

function TsgDXFBlockRecords.GetBlocks: TsgDXFGroup;
begin
  if not Assigned(FBlocks) then
    if Assigned(Converter) then
    begin
      FBlocks := Converter.Sections[csBlocks];
      TsgBlockrecordsItem(FLinkID).FBlocks := TsgOwneredItem(FBlocks.GetNamedItem);
    end;
  Result := FBlocks;
end;

function TsgDXFBlockRecords.GetCount: Integer;
begin
  Result := 0;
  if Assigned(Blocks) then
    Result := Blocks.Count
end;

function TsgDXFBlockRecords.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := nil;
  if Assigned(Blocks) then
    Result := TsgDXFBlock(Blocks[AIndex]).BlockRecord;
end;

function TsgDXFBlockRecords.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgBlockrecordsItem;
end;

function TsgDXFBlockRecords.GetName: string;
begin
  Result := cnstTableBLOCK_RECORD;
end;

function TsgDXFBlockRecords.IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := -1;
  if Assigned(Blocks) then
    Result := Blocks.IndexOfEntity(TsgDXFBlockRecord(AEntity).Block);
end;

function TsgDXFBlockRecords.IndexOfName(const AName: string): Integer;
begin
  Result := -1;
  if Assigned(Blocks) then
    Result := Blocks.IndexOfName(AName);
end;

function TsgDXFBlockRecords.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
begin
  Result := False;
  if Assigned(Blocks) then
    Result := Blocks.InsertEntity(AIndex, TsgDXFBlockRecord(AEntity).Block);
end;

procedure TsgDXFBlockRecords.Link(AConverter: TsgDXFConverter);
var
  I: Integer;
begin
  inherited Link(AConverter);
  Blocks := AConverter.Sections[csBlocks];// update TsgBlockrecordsItem(FLinkID).FBlocks
  for I := 0 to Count - 1 do
    AConverter.UpdateAcAuthEnvironBlockRecord(TsgDXFBlockRecord(Entities[I]));
end;

procedure TsgDXFBlockRecords.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  Blocks := AConverter.Sections[csBlocks];// update TsgBlockrecordsItem(FLinkID).FBlocks
end;

procedure TsgDXFBlockRecords.SetBlocks(const Value: TsgDXFGroup);
begin
  if FBlocks <> Value then
  begin
    FBlocks := Value;
    if Assigned(FBlocks) then
      TsgBlockrecordsItem(FLinkID).FBlocks := TsgOwneredItem(FBlocks.GetNamedItem)
    else
      TsgBlockrecordsItem(FLinkID).FBlocks := nil;
  end;
end;

procedure TsgDXFBlockRecords.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  if Assigned(Blocks) and Assigned(AEntity) then
    Blocks.SetEntity(AIndex, TsgDXFBlockRecord(AEntity).Block);
end;

{TsgBrepModSupport}

class procedure TsgBrepModSupport.ExtractShape(AShape: TsgModTopoShape;
  var AParams: TsgBrepModIterateParams;  const AProc: TsgModBrepIterateProc);
{$IFNDEF SG_NO_USE_KERNEL3D}  
var
  I, J: Integer;
  vShape, vSubShape: TsgModTopoShape;
  vColorAttrib, vColorAttribOld: TsgModAttribColorBase;
  vDataOld: Pointer;
begin
  if AShape.IsProcessed = True then
    Exit;
  AShape.IsProcessed := True;
  vColorAttribOld := AParams.ShapeColor;
  vDataOld := AParams.Data;
  try
    vColorAttrib := AShape.QueryColorAttrib;
    if Assigned(vColorAttrib) then
      AParams.ShapeColor := vColorAttrib;

    case AShape.GetShapeType of
      btShape, btShell, btSolid, btWire: AProc(AShape, AParams);
      btEdge: AProc(AShape, AParams);
      btFace:
      begin
        AParams.CurrentFace := TsgModTopoFace(AShape);
        AProc(AShape, AParams);
        TsgModTopoFace(AShape).ClearIsProcessed(True);
        for J := 0 to AShape.SubShapesCount - 1 do
        begin
           vSubShape := TsgModTopoFace(AShape).SubShape[J];
           case vSubShape.GetShapeType of
             btWire: ExtractShape(TsgModTopoWire(vSubShape), AParams, AProc);
             btEdge: AProc(TsgModTopoEdge(vSubShape), AParams);
           end;
        end;
        TsgModTopoFace(AShape).IsProcessed := True;
        AParams.CurrentFace := nil;
        Exit;
      end;
    end;

    //Shape
    //if AShape.GetShapeType <> btFace then
    begin
      for I := 0 to AShape.SubShapesCount - 1 do
      begin
        vShape := AShape.Subshape[I];
        ExtractShape(vShape, AParams, AProc);
      end;
    end;
  finally
    AParams.ShapeColor := vColorAttribOld;
    AParams.Data := vDataOld;
  end;
{$ELSE}
begin
{$ENDIF}  
end;

class function TsgBrepModSupport.GetBox(const AEntity: TsgModEntity): TFRect;
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  vBox: TF3DInterval;
begin
  Result := cnstBadRect;
  if Assigned(AEntity) and AEntity.InheritsFrom(TsgModVisibleEntity) then
  begin
    vBox := TsgModVisibleEntity(AEntity).BoundingBox(nil);
    Result := ConvertBox(vBox);
  end;
{$ELSE}
begin
  Result := cnstBadRect;
{$ENDIF}
end;

class procedure TsgBrepModSupport.ExtractPartCompound(ACompound: TsgModPartCompound;
  var AParams: TsgBrepModIterateParams; const AProc: TsgModBrepIterateProc);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  I: Integer;
  vInsert: TsgModPartInstance;
  vShape: TsgModTopoShape;
  vMatrixOld: TsgMatrix4d;
  vColorAttrib, vColorAttribOld: TsgModAttribColorBase;
  vDataOld: Pointer;

begin
  if not Assigned(ACompound) then
    Exit;
  vColorAttribOld := AParams.PartColor;
  vDataOld := AParams.Data;
  try
    vColorAttrib := ACompound.QueryColorAttrib;
    if Assigned(vColorAttrib) then
      AParams.PartColor := vColorAttrib;

    //Shapes
    for I := 0 to ACompound.ShapesCount - 1 do
      ACompound.Shape[I].IsProcessed := False;
    for I := 0 to ACompound.ShapesCount - 1 do
    begin
      vShape := ACompound.Shape[I];
      if vShape.IsFree then
        ExtractShape(vShape, AParams, AProc);
    end;

    //Parts
    vMatrixOld := AParams.Matrix;
    try
      for I := 0 to ACompound.InsertCount - 1 do
      begin
        vInsert := ACompound.Insert[I];
        AParams.Matrix := MatrixMultiplyFast(vInsert.FullMatrix, vMatrixOld); //!!
        AProc(vInsert, AParams);
        AProc(vInsert.Compound, AParams);
        ExtractPartCompound(vInsert.Compound, AParams, AProc)
      end;
    finally
      AParams.Matrix := vMatrixOld;
    end;
  finally
    AParams.PartColor := vColorAttribOld;
    AParams.Data := vDataOld;
  end;
{$ELSE}
begin
{$ENDIF}  
end;

{ TsgBrepModEntity }

procedure TsgBrepModEntity.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgBrepModEntity then
  begin
    FCompound := TsgBrepModEntity(Source).FCompound;
    FIsGenerateGroup := TsgBrepModEntity(Source).FIsGenerateGroup;
    FIsGenerate3DFaceByGroup := TsgBrepModEntity(Source).FIsGenerate3DFaceByGroup;
  end;
end;

constructor TsgBrepModEntity.Create;
begin
  inherited Create;
  FIsGenerateGroup := False;
  FIsGenerate3DFaceByGroup := False;
end;

destructor TsgBrepModEntity.Destroy;
begin
{$IFNDEF SG_NO_USE_KERNEL3D}
//  FCompound.sgRelease;
{$ENDIF}
  if Assigned(Converter) then
    Converter.FAcisNumber := -1;
  inherited Destroy;
end;

function TsgBrepModEntity.GroupExists: Boolean;
begin
  Result := FIsGenerateGroup;
end;

function TsgBrepModEntity.Is3dObject: Integer;
begin
  Result := 2;
end;

procedure TsgBrepModEntity.LoadTriangle(const AFace: TsgModTopoFace; const AParams: TsgBrepModIterateParams);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  I, vTemp: Integer;
  vMesh: TsgModMeshTriangles;
  vTriangle: TsgModMeshTriangleNode;
  vVertex: TsgModMeshSurfaceVertex;
  vPntCnt: Integer;
  vVertexList: TFPointList;
  vInd: Integer;
  V: TsgVector3d;
  vFace: TsgDXF3dFace;
  vIndexArr: array[1..3] of Integer;
begin
  vMesh := TsgModMeshTriangles(AFace.Mesh);

  if not Assigned(vMesh) then
    Exit;

  vPntCnt := 0;
  vMesh.EnumeratePoints(vPntCnt);
  if vPntCnt = 0 then
    Exit;

  vVertexList := TFPointList.Create;
  try
    vVertexList.Count := vPntCnt;
    vVertex := vMesh.FirstVertex;
    while Assigned(vVertex) do
    begin
      vInd := vVertex.VertexIndex;
      V := PointTransform(vVertex.Point, AParams.Matrix);
      vVertexList.Items[vInd] := V;
      vVertex := vVertex.Next;
    end;
    vTriangle := vMesh.FirstTriangle;
    while Assigned(vTriangle) do
    begin

      for I := 1 to 3 do
        vIndexArr[I] := vTriangle.Vertex[I].VertexIndex;

      if (vIndexArr[1] = vIndexArr[2]) or
         (vIndexArr[1] = vIndexArr[3]) or
         (vIndexArr[2] = vIndexArr[3])then
      begin
        vTriangle := vTriangle.Next;
        Continue;
      end;

      vFace := TsgDXF3dFace.Create;
      vFace.AssignEntity(Self);
      //vFace.Flags := $F;

      if vMesh.MaterialOrientation = bsoReversed then
      begin
        vTemp := vIndexArr[1];
        vIndexArr[1] := vIndexArr[3];
        vIndexArr[3] := vTemp;
      end;

      vFace.Point := vVertexList.Items[vIndexArr[1]];
      vFace.Point1 := vVertexList.Items[vIndexArr[2]];
      vFace.Point2 := vVertexList.Items[vIndexArr[3]];
      vFace.Point3 := vFace.Point2;
      vFace.Loaded(Converter);
      Group.AddEntity(vFace);
      vTriangle := vTriangle.Next;
    end;

  finally
    vVertexList.Free;
  end;
{$ELSE}
begin
{$ENDIF}
end;

procedure TsgBrepModEntity.LoadModPolyline(const APoly: TsgModMeshPolyline;
  const AParams: TsgBrepModIterateParams);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  vNode: TsgModMeshPolylineNode;
  vVertex: TsgDXFVertex;
  vPolyline: TsgDXFPolyline;
begin
  if not Assigned(APoly) then
    Exit;
  vNode := APoly.FirstNode;
  if not Assigned(vNode) then
    Exit;
  vPolyline := TsgDXFPolyline.Create;
  vPolyline.Polyline3D := True;
  vPolyline.List.Capacity := APoly.NodeCount;
  while Assigned(vNode) do
  begin
    vVertex := TsgDXFVertex.Create;
    vVertex.Point := PointTransform(vNode.Point, AParams.Matrix);
    vVertex.Loaded(Converter);
    vPolyline.AddEntity(vVertex);
    vNode := vNode.Next;
  end;
  vPolyline.AssignEntity(Self);
  vPolyline.Loaded(Converter);
  Group.AddEntity(vPolyline);
{$ELSE}
begin
{$ENDIF}
end;

procedure TsgBrepModEntity.LoadIsoLines(const AFace: TsgModTopoFace;
  const AParams: TsgBrepModIterateParams);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  I: Integer;
begin
  for I := 0 to AFace.IsoLines.Count - 1 do
    LoadModPolyline(TsgModMeshPolyline(AFace.IsoLines[I]), AParams);
{$ELSE}
begin
{$ENDIF}
end;

procedure TsgBrepModEntity.LoadModEntity(const AEnt: TsgModEntity;
  var AParams: TsgBrepModIterateParams);
begin
{$IFNDEF SG_NO_USE_KERNEL3D}
  case AEnt.GetEntType of
    mtTopology:
    begin
      case TsgModTopoEdge(AEnt).GetShapeType of
        btEdge:
        begin
          LoadModPolyline(TsgModTopoEdge(AEnt).ExtractFirstPolyline, AParams);
        end;
        btFace:
        begin
          if IsGenerate3DFaceByGroup then
            LoadTriangle(TsgModTopoFace(AEnt), AParams);
          LoadIsoLines(TsgModTopoFace(AEnt), AParams);
        end;
      end;
    end;
  end;
{$ENDIF}  
end;

function TsgBrepModEntity.GroupFill(AConverter: TsgDXFConverter): Boolean;
var
  vBrepModParams: TsgBrepModIterateParams;
begin
  vBrepModParams.Matrix := {$IFNDEF SG_NO_USE_KERNEL3D}IdentityMatrix4d{$ELSE}cnstIdentityMat{$ENDIF};
  vBrepModParams.PartColor := nil;
  vBrepModParams.ShapeColor := nil;
  DrawIterateCompound(LoadModEntity, vBrepModParams);
  Result := Group.Count > 0;
end;

function TsgBrepModEntity.GroupHasAddedEntities: Boolean;
begin
  Result := True;
end;

procedure TsgBrepModEntity.LoadedInternal(AConverter: TsgDXFConverter);
var
  vModLinDeflection: Double;
begin
  vModLinDeflection := {$IFNDEF SG_NO_USE_KERNEL3D}cnstModLinDeflection{$ELSE}0{$ENDIF};
  if Assigned(AConverter) then
  begin
    AConverter.FAcisNumber := -1;
    vModLinDeflection := AConverter.MeshQuality;
  end;
  MeshLinPrecision := vModLinDeflection;
  inherited LoadedInternal(AConverter);
end;

procedure TsgBrepModEntity.SetCompound(ACompound: TsgModPartCompound);
begin
{$IFNDEF SG_NO_USE_KERNEL3D}
//  ACompound.sgAddRef;
//  FCompound.sgRelease;
{$ENDIF}
  FCompound := ACompound;
end;

procedure TsgBrepModEntity.SetMeshLinPrecision(const Value: Double);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  vModeller: TsgModeller;
  vMContext: TsgShapePerformContext;
begin
  if Assigned(FCompound) then
  begin
    vModeller := Converter.QueryModeller(True);
    vModeller.InitTesselateContext(vMContext);
    vMContext.MeshLinPrecision := Value;
    vMContext.ModOptions := vMContext.ModOptions + [poIsoLines(*,poWireframe*)];
    FCompound.ClearIsProcessed(True);//FCompound.ClearIsProcessed(False);
    FCompound.PerformBranch(vMContext);
  end;
{$ELSE}
begin
{$ENDIF}
end;

function TsgBrepModEntity.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
end;

{$IFNDEF SG_NO_USE_KERNEL3D}
const
  cnstXMLShapeCmd = 'Shape';
  cnstXMLShapeTriangle = 'triangle';
  cnstXMLShapeRectangle = 'rectangle';
  cnstXMLShapeBox = 'box';
  cnstXMLShapeDisc = 'disc';
  cnstXMLShapeCylinder = 'cylinder';
  cnstXMLShapeCone = 'cone';
  cnstXMLShapeSphere = 'sphere';
  cnstXMLShapeTorus = 'torus';
  cnstXMLShapePoint1 = 'Point1';
  cnstXMLShapePoint2 = 'Point2';
  cnstXMLShapePoint3 = 'Point3';

  cnstXMLShapePosition = 'Position';
  cnstXMLShapeRotateX = 'Rotate_X';
  cnstXMLShapeRotateY = 'Rotate_Y';
  cnstXMLShapeRotateZ = 'Rotate_Z';
  cnstXMLShapeHeight = 'Height';
  cnstXMLShapeWidth = 'Width';
  cnstXMLShapeDepth = 'Depth';
  cnstXMLShapeRadius = 'Radius';
  cnstXMLShapeTubeRadius = 'Tube_Radius';
  cnstXMLShapeInnerRadius = 'Inner_Radius';
  cnstXMLShapeTopRadius = 'Top_Radius';
  cnstXMLShapeAngle = 'Angle';
  cnstXMLShapeHeightAngle = 'Height_Angle';

function TsgBrepModEntity.BuildTriangle(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vPoint1, vPoint2, vPoint3: TsgNodeSample;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vPoint1 := nil; vPoint2 := nil; vPoint3 := nil;
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapePoint1 then
      vPoint1 := vItem
    else if vItem.Name = cnstXMLShapePoint2 then
      vPoint2 := vItem
    else if vItem.Name = cnstXMLShapePoint3 then
      vPoint3 := vItem
    ;
  end;
  if not (Assigned(vPoint1) and Assigned(vPoint2) and Assigned(vPoint3)) then
    Exit;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    vTool.Triangle(vPoint1.ValueAsFPoint, vPoint2.ValueAsFPoint, vPoint3.ValueAsFPoint);
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function BuildBasisFromXML(const ANode: TsgNodeSample): TsgMatrix4d;
var
  I: Integer;
  vPos: TsgVector3d;
  vAngleX, vAngleY, vAngleZ: Double;
  vItem: TsgNodeSample;

  procedure InternalRotate(const AAxis: TsgVector3d; const AAngle: Double);
  var
    vMatrix: TsgMatrix4d;
  begin
    if AAngle = 0 then
      Exit;
    sgMFunctions.RotationMatrix(AAxis, sgFunction.Radian(AAngle), vMatrix);
    Result := sgMFunctions.MatrixMultiplySafe(Result, vMatrix);
  end;

begin
  Result := IdentityMatrix4d;
  vPos := NullVector3d; vAngleX := 0; vAngleY := 0; vAngleZ := 0;
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapePosition then
      vPos := vItem.ValueAsFPoint
    else if vItem.Name = cnstXMLShapeRotateX then
      vAngleX := vItem.ValueAsDouble
    else if vItem.Name = cnstXMLShapeRotateY then
      vAngleY := vItem.ValueAsDouble
    else if vItem.Name = cnstXMLShapeRotateZ then
      vAngleZ := vItem.ValueAsDouble
  end;
  InternalRotate(ZVector3d, vAngleZ);
  InternalRotate(YVector3d, vAngleY);
  InternalRotate(XVector3d, vAngleX);
  Result.W.Point3D := vPos;
end;

function TsgBrepModEntity.BuildRectangle(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vBasis: TsgMatrix4d;
  vWidth, vHeight: TsgNodeSample;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vWidth := nil; vHeight := nil;
  vBasis := BuildBasisFromXML(ANode);
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapeWidth then
      vWidth := vItem
    else if vItem.Name = cnstXMLShapeHeight then
      vHeight := vItem
    ;
  end;
  if not Assigned(vWidth) then
    Exit;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    if Assigned(vHeight) then
      vTool.Rectangle(vWidth.ValueAsDouble, vHeight.ValueAsDouble, vBasis)
    else
      vTool.Rectangle(vWidth.ValueAsDouble, vWidth.ValueAsDouble, vBasis);
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function TsgBrepModEntity.BuildDisc(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vBasis: TsgMatrix4d;
  vInnerRadius, vAngle, vRadius: TsgNodeSample;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vInnerRadius := nil; vAngle := nil; vRadius := nil;
  vBasis := BuildBasisFromXML(ANode);
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapeRadius then
      vRadius := vItem
    else if vItem.Name = cnstXMLShapeAngle then
      vAngle := vItem
    else if vItem.Name = cnstXMLShapeInnerRadius then
      vInnerRadius := vItem
    ;
  end;
  if not Assigned(vRadius) then
    Exit;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    if Assigned(vAngle) then
    begin
      if Assigned(vInnerRadius) then
        vTool.RingSector(vRadius.ValueAsDouble, vInnerRadius.ValueAsDouble, sgFunction.Radian(vAngle.ValueAsDouble), vBasis)
      else
        vTool.DiscSector(vRadius.ValueAsDouble, sgFunction.Radian(vAngle.ValueAsDouble), vBasis);
    end
    else
    begin
      if Assigned(vInnerRadius) then
        vTool.Ring(vRadius.ValueAsDouble, vInnerRadius.ValueAsDouble, vBasis)
      else
        vTool.Disc(vRadius.ValueAsDouble, vBasis);
    end;
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function TsgBrepModEntity.BuildCylinder(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  vClosed: Boolean;
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vBasis: TsgMatrix4d;
  vAngle, vHeight, vRadius: TsgNodeSample;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vAngle := nil; vHeight := nil; vRadius := nil;
  vBasis := BuildBasisFromXML(ANode);
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapeRadius then
      vRadius := vItem
    else if vItem.Name = cnstXMLShapeHeight then
      vHeight := vItem
    else if vItem.Name = cnstXMLShapeAngle then
      vAngle := vItem
    ;
  end;
  if not (Assigned(vRadius) and Assigned(vHeight)) then
    Exit;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vClosed := (GetEntType = ce3DSolid);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    if Assigned(vAngle) then
      vTool.CylinderSector(vRadius.ValueAsDouble, vHeight.ValueAsDouble,
        sgFunction.Radian(vAngle.ValueAsDouble), vClosed, vClosed, vBasis)
    else
      vTool.Cylinder(vRadius.ValueAsDouble, vHeight.ValueAsDouble, vClosed, vBasis);
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function TsgBrepModEntity.BuildCone(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  vClosed: Boolean;
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vBasis: TsgMatrix4d;
  vTopRadius, vAngle, vHeight, vRadius: TsgNodeSample;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vBasis := BuildBasisFromXML(ANode);
  vTopRadius := nil; vAngle := nil; vHeight := nil; vRadius := nil;
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapeRadius then
      vRadius := vItem
    else if vItem.Name = cnstXMLShapeHeight then
      vHeight := vItem
    else if vItem.Name = cnstXMLShapeAngle then
      vAngle := vItem
    else if vItem.Name = cnstXMLShapeTopRadius then
      vTopRadius := vItem
    ;
  end;
  if not (Assigned(vRadius) and Assigned(vHeight)) then
    Exit;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vClosed := (GetEntType = ce3DSolid);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    if Assigned(vTopRadius) then
    begin
      if Assigned(vAngle) then
        vTool.TruncatedConeSector(vRadius.ValueAsDouble, vTopRadius.ValueAsDouble,
          vHeight.ValueAsDouble, sgFunction.Radian(vAngle.ValueAsDouble),
          vClosed, vClosed, vBasis)
      else
        vTool.TruncatedCone(vRadius.ValueAsDouble, vTopRadius.ValueAsDouble,
          vHeight.ValueAsDouble, vClosed, vBasis);
    end
    else
    begin
      if Assigned(vAngle) then
        vTool.ConeSector(vRadius.ValueAsDouble, vHeight.ValueAsDouble,
        sgFunction.Radian(vAngle.ValueAsDouble), vClosed, vClosed, vBasis)
      else
        vTool.Cone(vRadius.ValueAsDouble, vHeight.ValueAsDouble,
          vClosed, vBasis);
    end;
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function TsgBrepModEntity.BuildSphere(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  vClosed: Boolean;
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vBasis: TsgMatrix4d;
  vTheta, vAngle, vRadius: TsgNodeSample;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vBasis := BuildBasisFromXML(ANode);
  vTheta := nil; vAngle := nil; vRadius := nil;
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapeRadius then
      vRadius := vItem
    else if vItem.Name = cnstXMLShapeAngle then
      vAngle := vItem
    else if vItem.Name = cnstXMLShapeHeightAngle then
      vTheta := vItem
    ;
  end;
  if not Assigned(vRadius) then
    Exit;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vClosed := (GetEntType = ce3DSolid);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    if Assigned(vTheta) then
    begin
      if Assigned(vAngle) then
        vTool.BuildHemiSphereSector(vRadius.ValueAsDouble,
          sgFunction.Radian(vTheta.ValueAsDouble), sgFunction.Radian(vAngle.ValueAsDouble),
          vClosed, vClosed, vBasis)
      else
        vTool.HemiSphere(vRadius.ValueAsDouble, sgFunction.Radian(vTheta.ValueAsDouble),
          vClosed, vBasis);
    end
    else
    begin
      if Assigned(vAngle) then
        vTool.SphereSector(vRadius.ValueAsDouble, sgFunction.Radian(vAngle.ValueAsDouble),
          vClosed, vBasis)
      else
        vTool.Sphere(vRadius.ValueAsDouble, vBasis);
    end;
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function TsgBrepModEntity.BuildTorus(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  vClosed: Boolean;
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vBasis: TsgMatrix4d;
  vTheta, vAngle, vTubeRadius, vRadius: TsgNodeSample;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vBasis := BuildBasisFromXML(ANode);
  vTheta := nil; vAngle := nil; vTubeRadius := nil; vRadius := nil;
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapeRadius then
      vRadius := vItem
    else if vItem.Name = cnstXMLShapeTubeRadius then
      vTubeRadius := vItem
    else if vItem.Name = cnstXMLShapeAngle then
      vAngle := vItem
    else if vItem.Name = cnstXMLShapeHeightAngle then
      vTheta := vItem
    ;
  end;
  if not (Assigned(vRadius) and Assigned(vTubeRadius)) then
    Exit;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vClosed := (GetEntType = ce3DSolid);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    if Assigned(vTheta) then
    begin
      if Assigned(vAngle) then
        vTool.TorusSectorUV(vRadius.ValueAsDouble, vTubeRadius.ValueAsDouble,
          sgFunction.Radian(vAngle.ValueAsDouble), sgFunction.Radian(vTheta.ValueAsDouble),
          vClosed, vClosed, vBasis)
      else
        vTool.TorusSectorV(vRadius.ValueAsDouble, vTubeRadius.ValueAsDouble,
          sgFunction.Radian(vAngle.ValueAsDouble), vClosed, vBasis);
    end
    else
    begin
      if Assigned(vAngle) then
        vTool.TorusSectorU(vRadius.ValueAsDouble, vTubeRadius.ValueAsDouble,
          sgFunction.Radian(vAngle.ValueAsDouble), vClosed, vBasis)
      else
        vTool.Torus(vRadius.ValueAsDouble, vTubeRadius.ValueAsDouble, vBasis);
    end;
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function TsgBrepModEntity.BuildBox(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  I: Integer;
  vItem: TsgNodeSample;
  vModeller: TsgModeller;
  vTool: TsgModToolShapeBuilder;
  vBasis: TsgMatrix4d;
  vW, vH, vD: Double;
begin
  Result := cnstXML_ERROR;
  vModeller := Converter.QueryModeller(True);
  if not Assigned(vModeller) then
    Exit;
  vBasis := BuildBasisFromXML(ANode);
  vD := 0; vH := 0; vW := 0;
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vItem := ANode.AttributeNodes[I];
    if vItem.Name = cnstXMLShapeWidth then
      vW := vItem.ValueAsDouble
    else if vItem.Name = cnstXMLShapeHeight then
      vH := vItem.ValueAsDouble
    else if vItem.Name = cnstXMLShapeDepth then
      vD := vItem.ValueAsDouble
    ;
  end;
  if vW = 0 then
    Exit;
  if vH = 0 then
    vH := vW;
  if vD = 0 then
    vD := vW;
  if not Assigned(FCompound) then
    FCompound := TsgModPartCompound.Create(vModeller);
  vTool := TsgModToolShapeBuilder.Create(FCompound);
  try
    vTool.Box(vW, vD, vH, vBasis);
  finally
    FreeAndNil(vTool);
  end;
  Result := cnstXML_OK;
end;

function TsgBrepModEntity.FromXML(const ANode: TsgNodeSample; const AResult: IsgResultNode): Integer;
var
  I: Integer;
  vType: TsgCADEntities;
  vAttr: TsgNodeSample;
  vXMLType: TsgXMLType;
  //vPathKey: UInt64;
begin
  vAttr := ANode.GetAttributeByName(cnstXMLShapeCmd);
  if not Assigned(vAttr) then
  begin
    Result := inherited FromXML(ANode, AResult);
    Exit;
  end;

  vType := GetEntType;
  if (vAttr.Value = cnstXMLShapeBox) and (vType = ce3DSolid) then
    Result := BuildBox(ANode, AResult)
  else if (vAttr.Value = cnstXMLShapeCylinder) and (vType <> ceRegion) then
    Result := BuildCylinder(ANode, AResult)
  else if (vAttr.Value = cnstXMLShapeCone) and (vType <> ceRegion) then
    Result := BuildCone(ANode, AResult)
  else if (vAttr.Value = cnstXMLShapeSphere) and (vType <> ceRegion) then
    Result := BuildSphere(ANode, AResult)
  else if (vAttr.Value = cnstXMLShapeTorus) and (vType <> ceRegion) then
    Result := BuildTorus(ANode, AResult)
  else if (vAttr.Value = cnstXMLShapeTriangle) and (vType <> ce3dSolid) then
    Result := BuildTriangle(ANode, AResult)
  else if (vAttr.Value = cnstXMLShapeRectangle) and (vType <> ce3dSolid) then
    Result := BuildRectangle(ANode, AResult)
  else if (vAttr.Value = cnstXMLShapeDisc)  and (vType <> ce3dSolid) then
    Result := BuildDisc(ANode, AResult)
  else
    Result := cnstXML_ERROR;
  if Result = cnstXML_ERROR then
    Exit;

  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vAttr := ANode.AttributeNodes[I];
    vXMLType := GetXMLType(vAttr.Name);
    inherited FromXMLNode(vXMLType, vAttr, False, AResult);
  end;

  {vPathKey := GetAttributeHandle(ANode, sgConsts.cnstXMLNames[xmlPathKey].Name);
  vAttr := ANode.GetAttributeByName(sgConsts.cnstXMLNames[xmlVisible3D].Name);
  if Assigned(vAttr) then
      SetVisibleRepresentation(vPathKey, vAttr.ValueAsBool);

  vAttr := ANode.GetAttributeByName(sgConsts.cnstXMLNames[xmlAlphaBlend].Name);
  if Assigned(vAttr) then
    SetAlphaBlendRepresentation(vPathKey, vAttr.ValueAsInt);

  vAttr := ANode.GetAttributeByName('CustomColor');
  if Assigned(vAttr) then
    SetCustomColorRepresentation(vPathKey, vAttr.ValueData.ValueAsColor);}

  EntityLoaded;
end;

{$ENDIF}

procedure TsgBrepModEntity.ToXMLSubEntities(const AParentNode: TsgNode;
  const AParams: TsgXMLParams);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  vSubEntities: TsgNode;
  vParams: TsgXMLParams;
begin
  vParams := AParams;
  vSubEntities := GetSubEntitiesNode(AParentNode, vParams);
  if Assigned(vSubEntities) then
    if Assigned(FCompound) then
    begin
      FCompound.ToXMLWithParams(vSubEntities, vParams);
    end;
{$ELSE}
begin
{$ENDIF}
end;

function TsgBrepModEntity.GetBox: TFRect;
begin
  Result := TsgBrepModSupport.GetBox(FCompound);
end;

function TsgBrepModEntity.GetSubEntitiesNode(const AParentNode: TsgNode;
  var AParams: TsgXMLParams; const AHasSubEntities: Boolean): TsgNode;
begin
  Result := nil;
  if (xmAddSubEntities in AParams.Mode) and (AHasSubEntities or (FCompound <> nil)) then
  begin
    if not (xmNoSubEntitiesNode in AParams.Mode) then
      Result := AParentNode.AddChildNV(cnstXMLNames[xmlSubEntities].Name)
    else
      Result := AParentNode;
//    if xmOnlyChildNodes in AParams.Mode then
//      Exclude(AParams.Mode, xmAddSubEntities);
  end;
end;

procedure TsgBrepModEntity.DrawIterateCompound(const AProc: TsgModBrepIterateProc;
  var AParams: TsgBrepModIterateParams);
begin
  TsgBrepModSupport.ExtractPartCompound(Compound, AParams, AProc);
end;

class function TsgBrepModEntity.FindColor(const AColorAttrib: TsgModAttribColorBase): TColor;
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  vColor: TsgColor;
begin
  if AColorAttrib.inheritsFrom(TsgModAttribColorFloat) then
    vColor := RGBFromFloat(TsgModAttribColorFloat(AColorAttrib).RGBA)
  else if AColorAttrib.inheritsFrom(TsgModAttribColorInt) then
    vColor := TsgModAttribColorInt(AColorAttrib).Color;
  Result := TColor(vColor.Color);
{$ELSE}
begin
  Result := clNone;
{$ENDIF}
end;

class function TsgBrepModEntity.FindColor(const AParams: TsgBrepModIterateParams; const AColorAttrib: TsgModAttribColorBase): TColor;
begin

  Result := AParams.CADColor;
  if Assigned(AColorAttrib) then
    Result := FindColor(AColorAttrib)
  else if Assigned(AParams.ShapeColor) then
    Result := FindColor(AParams.ShapeColor)
  else if Assigned(AParams.PartColor) then
    Result := FindColor(AParams.PartColor);
end;

function TsgBrepModEntity.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := 0;
end;

{ TsgBrepModAcis}


procedure TsgBrepModAcis.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
end;

procedure TsgBrepModAcis.ClearReferences;
begin
  inherited ClearReferences;
end;

constructor TsgBrepModAcis.Create;
begin
  inherited Create;
end;

destructor TsgBrepModAcis.Destroy;
begin
  FAcisStream.Free;
  inherited Destroy;
end;

procedure TsgBrepModAcis.AssignEntity(Source: TsgDXFEntity);
var
  vACIS: TsgBrepModAcis absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgBrepModAcis then
  begin
    if Assigned(TsgBrepModAcis(Source).FAcisStream) then
    begin
      FCompound := nil;
      LoadFromStream(TsgBrepModAcis(Source).FAcisStream)
    end
    else
      Clear;
  end;
end;

function TsgBrepModAcis.QueryAcisStream: TMemoryStream;
begin
  if not Assigned(FAcisStream) then
    FAcisStream := TMemoryStream.Create;
  Result := FAcisStream;
end;

{$IFDEF SG_DEBUG_OUTPUT}
var
  gACISCnt: Integer;
{$ENDIF}
procedure TsgBrepModAcis.LoadedInternal(AConverter: TsgDXFConverter);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  vModeller: TsgModeller;
  vImporter: TsgModImportACIS;
begin
  if not Assigned(FCompound) then
    if Assigned(Converter) and Assigned(FAcisStream) and (FAcisStream.Size > 0) then
    begin
{$IFDEF SG_DEBUG_OUTPUT}
      FAcisStream.SaveToFile(gDebugOutputPath + 'ACIS' + IntToStr(gACISCnt) + '__' + EntName + IntToStr(Handle) + '.fsat');
{$ENDIF}
      vModeller := Converter.QueryModeller(True);
      vImporter := TsgModImportACIS.Create(vModeller);
      try
        //vImporter.OnModellerMsg := AConverter.DoModellerMsg;
        FAcisStream.Position := 0;
        FCompound := vImporter.LoadFromStream(FAcisStream);
      finally
{$IFDEF SG_INTERNAL_TEST_AB3DKERNEL}
        if Assigned(vImporter.Parser) then
          GlobalBrepParser.Add(vImporter.Parser);
{$ELSE}
        vImporter.DropParser;
{$ENDIF}
        vImporter.Free;
      end;
{$IFDEF SG_DEBUG_OUTPUT}
      Inc(gACISCnt);
{$ENDIF}
    end;
  inherited LoadedInternal(AConverter);
{$ELSE}
begin
  inherited LoadedInternal(AConverter);
{$ENDIF}
end;

procedure TsgBrepModAcis.LoadFromStream(const AStream: TStream);
begin
  Clear;
  FreeAndNil(FAcisStream);
  FAcisStream := TMemoryStream.Create;
  FAcisStream.LoadFromStream(AStream);
end;

{ TsgBrepIges }

function TsgBrepIges.GetEntType: TsgCADEntities;
begin
  Result := ceIges;
end;

{ TsgBrepStep }

function TsgBrepStep.GetEntType: TsgCADEntities;
begin
  Result := ceStep;
end;

{ TsgBrepBrep }

function TsgBrepBrep.GetEntType: TsgCADEntities;
begin
  Result := ceBrep;
end;

{ TsgBrepParasolid }

function TsgBrepParasolid.GetEntType: TsgCADEntities;
begin
  Result := ceParasolid;
end;

{ TsgBrepInventor }

function TsgBrepInventor.GetEntType: TsgCADEntities;
begin
  Result := ceInventor;
end;

{ TsgStackObject }

procedure TsgStackObject.Clear;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    if List[I] <> nil then
      TsgDXFEntity(List[I]).Free;
  inherited Clear;
end;

function TsgStackObject.Pop: TsgDXFEntity;
begin
  Result := nil;
  if Count > 0 then
  begin
    Result := TsgDXFEntity(List[Count - 1]);
    Count := Count - 1;
  end;
end;

procedure TsgStackObject.Push(const AObject: TsgDXFEntity);
begin
  Add(Pointer(AObject));
end;


{ TsgFlatPoly3D }

procedure TsgFlatPoly3D.AddPoint(const X, Y, Z: Double);
var
  P: TFPoint;
begin
  P.X := X;
  P.Y := Y;
  P.Z := Z;
  TFPointList(FPoints).Add(P);
end;

function TsgFlatPoly3D.GetEntType: TsgCADEntities;
begin
  Result := ceFlatPoly3D;
end;

function TsgFlatPoly3D.GetPointsSignleList: TsgSingleList;
begin
  Result := nil;
end;

function TsgFlatPoly3D.GetPointsClass: TClass;
begin
  Result := TFPointList;
end;

function TsgFlatPoly3D.GetXY(Index: Integer): TFPoint;
begin
  Result :=  TFPointList(FPoints)[Index];
end;

function TsgFlatPoly3D.PCount: Integer;
begin
  Result := FPoints.Count;
end;

procedure TsgFlatPoly3D.SetXY(Index: Integer; const Value: TFPoint);
begin
   TFPointList(FPoints)[Index] := Value;
end;

{ TsgFlatBasePoly }

procedure TsgFlatPoly.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgFlatPoly then
     FLineWeight := TsgFlatPoly(Source).LineWeight;
end;

function TsgFlatPoly.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgFlatPoly.GetThicknessInt: Double;
begin
  Result := cnstThicknessDefault;
end;

function TsgFlatPoly.GroupFill(AConverter: TsgDXFConverter): Boolean;
var
  I, J, vCount, vIndex: Integer;
  vEntity: TsgDXFEntity;
  vVertex: TsgDXFVertex;
  vVertexes: TList;
  vPolyline3D: Boolean;

  procedure Loaded(E: TsgDXFEntity);
  begin
    E.Loaded(AConverter);
  end;

begin
  vVertexes := TList.Create;
  try
    vIndex := 0;
    for I := 0 to Counts.Count - 1 do
    begin
      vEntity := nil;
      vCount := Counts[I];
      if vCount > 2 then
      begin
        vPolyline3D := False;
        for J := vIndex to (vIndex + vCount - 1) do
        begin
          vVertex := TsgDXFVertex.Create;
          vVertex.Point := XY[J];
          Loaded(vVertex);
          vVertexes.Add(vVertex);
          if vVertex.Point.Z <> 0 then
            vPolyline3D := True;
        end;
        if vPolyline3D then
        begin
          vEntity := TsgDXFPolyline.Create;
          TsgDXFPolyline(vEntity).Polyline3D := True;
        end
        else
          vEntity := TsgDXFLWPolyline.Create;
        for J := 0 to vVertexes.Count - 1 do
          vEntity.AddEntity(vVertexes[J]);
        vVertexes.Count := 0;
      end
      else
        if vCount = 2 then
        begin
          vEntity := TsgDXFLine.Create;
          TsgDXFLine(vEntity).Point := XY[vIndex];
          TsgDXFLine(vEntity).Point1 := XY[vIndex + 1];
        end;
      if vEntity <> nil then
      begin
        vEntity.AssignEntity(Self);
        Loaded(vEntity);
        Group.AddEntity(vEntity);
      end;
      Inc(vIndex, vCount);
    end;
    Result := Group.Count > 0;
  finally
    FreeList(vVertexes);
  end;
end;

procedure TsgFlatPoly.PoinsToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams);
var
  vNodePoints: TsgNode;
  I, J, vCount, vIndex: Integer;
  vPoints: TsgBaseList;
  vIs3D: Boolean;
  vPoint: TFPoint;
begin
  vIs3D := not (GetEntType in [ceFlatPoly]);
  if vIs3D then
    vPoints := TFPointList.Create
  else
    vPoints := TF2DPointList.Create;
  try
    vIndex := 0;
    ANode.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := Counts.Count;
    for I := 0 to Counts.Count - 1 do
    begin
      vPoints.Count := 0;
      vCount := Counts[I];
      for J  := vIndex to (vIndex + vCount - 1) do
      begin
        vPoint := XY[J];
        if vIs3D then
          TFPointList(vPoints).Add(vPoint)
        else
          TF2DPointList(vPoints).Add(vPoint.Point2D);
      end;
      vNodePoints := ANode.AddChildNV(cnstXMLNames[xmlVertexes].Name);
      if vPoints.Count > 0 then
        vPoints.ToXML(vNodePoints, cnstXMLNames[xmlPoint].Name);
      Inc(vIndex, vCount);
    end;
  finally
    vPoints.Free;
  end;
end;

procedure TsgFlatPoly.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgFlatPoly.SetThicknessInt(const AValue: Double);
begin
end;

{ TsgFlarEnity2D }

procedure TsgFlatEntity2D.AddPoint(const X, Y, Z: Double);
begin
  TsgSingleList(FPoints).Add(X);
  TsgSingleList(FPoints).Add(Y);
end;

function TsgFlatEntity2D.GetPointsSignleList: TsgSingleList;
begin
  Result := TsgSingleList(FPoints);
end;

function TsgFlatEntity2D.GetPointsClass: TClass;
begin
  Result := TsgSingleList;
end;

procedure TsgFlatEntity2D.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlCount));
      AHideList.Add(Integer(xmlLineTypeName));
    end;
  end;
end;

function TsgFlatEntity2D.GetXY(Index: Integer): TFPoint;
begin
  Inc(Index,Index);
  Result.X := TsgSingleList(FPoints)[Index];
  Result.Y := TsgSingleList(FPoints)[Index+1];
  Result.Z := 0.0;
end;

function TsgFlatEntity2D.PCount: Integer;
begin
  Result := FPoints.Count div 2;
end;

procedure TsgFlatEntity2D.SetXY(Index: Integer; const Value: TFPoint);
var
  S: Single;
begin
  Inc(Index,Index);
  S := Value.X;
  TsgSingleList(FPoints)[Index] := S;
  S := Value.Y;
  TsgSingleList(FPoints)[Index+1] := S;
end;

{ TsgDXFSectionTables }

constructor TsgDXFSectionTables.Create;
begin
  inherited Create;
  Name := cnstSectionTABLES;
end;

function TsgDXFSectionTables.IsTablesBelongSection(ATable: TConvSection): Boolean;
begin
  Result := False;
  case ATable of
    csLTypes, csLayers, csStyles,
    csDimStyles, csBlockRecords, csVPorts:
      Result := True;
  end;
end;

{ TsgDXFSectionObjects }

constructor TsgDXFSectionObjects.Create;
begin
  inherited Create;
  Name := cnstSectionOBJECTS;
end;

function TsgDXFSectionObjects.IsTablesBelongSection(
  ATable: TConvSection): Boolean;
begin
  Result := False;
  case ATable of
    csMLineStyles, csImageDefs,
    csLayouts, csTableStyles:
      Result := True;
  end;
end;

{ TsgDXFSectionBlocks }

function TsgDXFSectionBlocks.AddItem(const AItem: TObject): Integer;
var
  BlockRecord: TsgDXFEntity;
  BlockRecordsLinkID: TsgOwneredItem;
begin
  Result := -1;
  if Assigned(Converter) and Assigned(Converter.FBlockRecords) then
  begin
    BlockRecordsLinkID := TsgOwneredItem(Converter.FBlockRecords.GetNamedItem);
    BlockRecord := TsgDXFBlock(TsgOwneredItem(AItem).Ancestor).BlockRecord;
    Result := BlockRecordsLinkID.AddItem(BlockRecord.GetNamedItem);
  end;
end;

constructor TsgDXFSectionBlocks.Create;
begin
  inherited Create;
  Name := cnstSectionBLOCKS;
end;

function TsgDXFSectionBlocks.DeleteItem(const AItem: TObject): Integer;
var
  BlockRecord: TsgDXFEntity;
  BlockRecordsLinkID: TsgOwneredItem;
begin
  Result := -1;
  if Assigned(Converter) and Assigned(Converter.FBlockRecords) then
  begin
    BlockRecordsLinkID := TsgOwneredItem(Converter.FBlockRecords.GetNamedItem);
    BlockRecord := TsgDXFBlock(TsgOwneredItem(AItem).Ancestor).BlockRecord;
    Result := BlockRecordsLinkID.RemoveItem(BlockRecord.GetNamedItem);
  end;
end;

function TsgDXFSectionBlocks.FindEntByName(const AName: string): TsgDXFEntity;
begin
  if Assigned(Converter) and Assigned(Converter.FBlockRecords) then
  begin
    Result := Converter.FBlockRecords.FindEntByName(AName);
    if Assigned(Result) then
      Result := TsgDXFBlockRecord(Result).Block;
  end
  else
    Result := inherited FindEntByName(AName);
end;

procedure TsgDXFSectionBlocks.ListNotify(const Obj: TObject; Action: TListNotification);
var
  Block: TsgDXFBlock absolute Obj;
begin
  case Action of
    lnAdded:
      begin
        inherited ListNotify(Obj, Action);
      end;
    lnDeleted, lnExtracted:
      begin
        Block.BlockRecord.Dictionary := nil;
        inherited ListNotify(Obj, Action);
      end;
  end;
end;

{ TsgDXFDictionary }

function TsgDXFDictionary.GetValue: string;
begin
  Result := '';
end;

procedure TsgDXFDictionary.SetValue(const AValue: string);
begin
end;

function TsgDXFDictionary.Item(Index: Variant): TsgDXFEntity;
var
  vVarType: TVarType;
begin
  Result := nil;
  vVarType := VarType(Index);
  if vVarType in [varInt64, varUInt64] then
    Result := FindEntByHandle({$IFDEF SGDEL_6}Index{$ELSE}sgVarAsUInt64(Index){$ENDIF})
  else
    if {$IFDEF SGDEL_6}VarIsStr{$ELSE}sgVarIsStr{$ENDIF}(Index) then
      Result := FindEntByName(Index)
    else
      if {$IFDEF SGDEL_6}VarIsOrdinal{$ELSE}sgVarIsOrdinal{$ENDIF}(Index) then
        Result := Entities[Index];
end;

{ TsgDXFInsertXRef }

procedure TsgDXFInsertXRef.LoadedInternal(AConverter: TsgDXFConverter);
var
  vCADFile: TsgCADImage;
  vPic: TPicture;
begin
  inherited LoadedInternal(AConverter);
  if FOwner = nil then
    Exit;
  vPic := TPicture.Create;
  try
    vPic.LoadFromFile(FNameFile);
    if not (vPic.Graphic is TsgCADImage) then
    begin
      Exit;
    end;
    vCADFile := TsgCADImageClass(vPic.Graphic.ClassType).Create;
    vCADFile.Assign(vPic.Graphic);
    FRealInsert := Converter.AddXRef(vCADFile, FNameFile,
      Point, Scale, Angle, TsgDXFLayout(FOwner));
  finally
    vPic.Free;
  end;
end;

{ TsgDXFSectionHeader }

constructor TsgDXFSectionHeader.CreateByConverter(
  const AConverter: TsgDXFConverter);
begin
  inherited CreateByConverter(AConverter);
  Name := cnstXMLNames[xmlHeader].Name;
  FAccess := TsgDXFEntitySample.Create;
  FAccess.Loaded(AConverter);
end;

destructor TsgDXFSectionHeader.Destroy;
begin
  FreeAndNil(FAccess);
  inherited;
end;

function TsgDXFSectionHeader.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  vHeader: PsgHeadVarStruct;
  vLayout: TsgDXFLayout;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.Clear;
  vHeader := GetPHeadVarStruct(IsXMLHelp(AParams.Mode));
  if vHeader <> nil then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlName].Name).ValueAsStr := Name;
    ANode.AddAttribNV(cnstXMLNames[xmlACADVer].Name).ValueAsStr := sgDWGVerToString(TsgDWGVersion(vHeader^.Version));
    ANode.AddAttribNV(cnstXMLNames[xmlCodePage].Name).ValueAsStr := sgDXFCodePageName(vHeader^.CodePage);
    ANode.AddAttribNV(cnstXMLNames[xmlTextStyle].Name).ValueAsStr := vHeader^.TextStyle;
    ANode.AddAttribNV(cnstXMLNames[xmlCLayer].Name).ValueAsStr := vHeader^.CLayer;
    ANode.AddAttribNV(cnstXMLNames[xmlCELType].Name).ValueAsStr := vHeader^.CELType;
    ANode.AddAttribNV(cnstXMLNames[xmlCEColor].Name).ValueData.ValueAsColorCAD := vHeader^.CEColor;
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlCELTScale].Name).ValueData,
      vHeader^.CELTScale, xmlForViewing in AParams.Mode);
    ANode.AddAttribNV(cnstXMLNames[xmlCELWeight].Name).ValueAsInt := ConvertLineWeightToDXF(vHeader^.CELWeight);
    ANode.AddAttribNV(cnstXMLNames[xmlDimStyle].Name).ValueAsStr := vHeader^.DimStyle;
    ANode.AddAttribNV(cnstXMLNames[xmlDimTextStyle].Name).ValueAsStr := vHeader^.DimTextStyle;
    ANode.AddAttribNV(cnstXMLNames[xmlDimAssoc].Name).ValueData.ValueAsByte := vHeader^.DimAssoc;

    ToXMLNodeDimProps(vHeader^.DimProps, ANode, AParams);
    if IsEqualFPoints(vHeader^.ExtMin, vHeader^.ExtMax) and
      IsEqualFPoints(vHeader^.ExtMin, cnstFPointZero) and
      Assigned(FConverter) and
      (FConverter.GetLayoutsCount > 0) then
    begin
      vLayout := FConverter.Layouts[0];
      SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlExtMim].Name).ValueData,
        MakeFPoint(vLayout.ExtMin.X, vLayout.ExtMax.Y), xmlForViewing in AParams.Mode);
      SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlExtMax].Name).ValueData,
        MakeFPoint(vLayout.ExtMax.X, vLayout.ExtMin.Y), xmlForViewing in AParams.Mode);
    end
    else
    begin
      SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlExtMim].Name).ValueData,
        vHeader^.ExtMin, xmlForViewing in AParams.Mode);
      SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlExtMax].Name).ValueData,
        vHeader^.ExtMax, xmlForViewing in AParams.Mode);
    end;
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlFilletRadius].Name).ValueData,
      vHeader^.FilletRadius, xmlForViewing in AParams.Mode);
    ANode.AddAttribNV(cnstXMLNames[xmlFillMode].Name).ValueAsBool := vHeader^.FillMode;
    ANode.AddAttribNV(cnstXMLNames[xmlLwDisplay].Name).ValueAsBool := vHeader^.LwDisplay <> 0;
    ANode.AddAttribNV(cnstXMLNames[xmlInsUnits].Name).ValueAsInt := vHeader^.InsUnits;
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLTScale].Name).ValueData,
      vHeader^.LTScale, xmlForViewing in AParams.Mode);
    ANode.AddAttribNV(cnstXMLNames[xmlMeasurement].Name).ValueAsInt := Ord(vHeader^.Measurement);
    ANode.AddAttribNV(cnstXMLNames[xmlPointDisplayMode].Name).ValueAsInt := Ord(vHeader^.PointDisplayMode);
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlPointDisplaySize].Name).ValueData,
      vHeader^.PointDisplaySize, xmlForViewing in AParams.Mode);
    SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlTextSize].Name).ValueData,
      vHeader^.TextSize, xmlForViewing in AParams.Mode);
    ANode.AddAttribNV(cnstXMLNames[xmlTileMode].Name).ValueAsInt := vHeader^.TileMode;
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSORG].Name).ValueData,
      vHeader^.UCSORG, xmlForViewing in AParams.Mode);
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSXDir].Name).ValueData,
      vHeader^.UCSXDir, xmlForViewing in AParams.Mode);
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlUCSYDir].Name).ValueData,
      vHeader^.UCSYDir, xmlForViewing in AParams.Mode);
    SetDataValueAsFPoint(ANode.AddAttribNV(cnstXMLNames[xmlInsBase].Name).ValueData,
      vHeader^.InsBase, xmlForViewing in AParams.Mode);
    ANode.AddAttribNV(cnstXMLNames[xmlAttributeMode].Name).ValueAsInt := Ord(vHeader^.AttMode);
  end;
end;

class function TsgDXFSectionHeader.ToXMLNodeDimProps(const AProps: TsgDimStyle;
  const ANode: TsgNode; const AParams: TsgXMLParams;
  const AInit: TsgDimNameVals = []): Integer;

  function AddDimAttrib(const ADimVal: TsgDimNameVal;
    const AType: TsgDataType; const AValue: Pointer): TsgNodeSample;
  begin
    Result := nil;
    if (AInit = []) or (ADimVal in AInit) then
    begin
      Result := ANode.AddAttribNV(cnstXMLNames[cnstDimXmlId[ADimVal]].Name);
      if AType <> dtUndefined then
        Result.ValueData.SetValueTyped(AType, AValue);
    end;
  end;

  procedure AddDimAttribInt(const ADimVal: TsgDimNameVal; const AValue: Integer);
  begin
    AddDimAttrib(ADimVal, dtInteger, @AValue);
  end;

  procedure AddDimAttribStr(const ADimVal: TsgDimNameVal; const AValue: string);
  var
    vAttrib: TsgNodeSample;
  begin
    vAttrib := AddDimAttrib(ADimVal, dtUndefined, nil);
    if Assigned(vAttrib) then
      vAttrib.ValueAsStr := AValue;
  end;

begin
  Result := cnstXML_OK;
  AddDimAttrib(vnDimAlt, dtBool, @AProps.Alt);
  AddDimAttrib(vnDimAltF, dtDouble, @AProps.AltF);
  AddDimAttrib(vnDimAPost, dtString, @AProps.APost);
  AddDimAttrib(vnDimAsz, dtDouble, @AProps.Asz);
  AddDimAttrib(vnDimSah, dtBool, @AProps.Sah);
  AddDimAttrib(vnDimCen, dtDouble, @AProps.Cen);
  AddDimAttrib(vnDimClrD, dtColorCAD, @AProps.ClrD);
  AddDimAttrib(vnDimClrE, dtColorCAD, @AProps.ClrE);
  AddDimAttrib(vnDimClrT, dtColorCAD, @AProps.ClrT);
  AddDimAttrib(vnDimSD1, dtBool, @AProps.SD1);
  AddDimAttrib(vnDimSD2, dtBool, @AProps.SD2);
  AddDimAttrib(vnDimSE1, dtBool, @AProps.SE1);
  AddDimAttrib(vnDimSE2, dtBool, @AProps.SE2);
  AddDimAttrib(vnDimDec, dtInteger, @AProps.Dec);
  AddDimAttrib(vnDimExe, dtDouble, @AProps.Exe);
  AddDimAttrib(vnDimExo, dtDouble, @AProps.Exo);
  AddDimAttrib(vnDimGap, dtDouble, @AProps.Gap);
  AddDimAttrib(vnDimLFac, dtDouble, @AProps.LFac);
  AddDimAttrib(vnDimLwD, dtDouble, @AProps.LwD);
  AddDimAttrib(vnDimLwE, dtDouble, @AProps.LwE);
  AddDimAttrib(vnDimPost, dtString, @AProps.Post);
  AddDimAttrib(vnDimScale, dtDouble, @AProps.Scale);
  AddDimAttrib(vnDimTad, dtInteger, @AProps.Tad);
  AddDimAttrib(vnDimTih, dtBool, @AProps.Tih);
  AddDimAttrib(vnDimTix, dtInteger, @AProps.Tix);
  AddDimAttrib(vnDimToh, dtBool, @AProps.Toh);
  AddDimAttrib(vnDimTxt, dtDouble, @AProps.Txt);
  AddDimAttrib(vnDimTp, dtDouble, @AProps.Tp);
  AddDimAttrib(vnDimTm, dtDouble, @AProps.Tm);
  AddDimAttribInt(vnDimLUnit, GetDimLimitUnitsByte(AProps.LUnit));
  AddDimAttribInt(vnDimDSep, Ord(AProps.DSep));
  AddDimAttrib(vnDimFrac, dtInteger, @AProps.Frac);
end;

function TsgDXFSectionHeader.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vIntVal: Integer;
  vDoubleVal: TsgFloat;
  vStrVal: string;
  vByteVal: Byte;
  vDXFTable: TsgDXFTable;
  vStyle: TsgDXFStyle;
  vDimStyle: TsgDXFDimensionStyle;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlACADVer: begin end;//ANode.ValueAsStr := sgDWGVerToString(TsgDWGVersion(FConverter.GetPHeadVarStruct^.Version));
    xmlCodePage: begin end;//ANode.ValueAsStr := sgDXFCodePageName(FConverter.GetPHeadVarStruct^.CodePage);
    xmlTextStyle,xmlCLayer,xmlCELType:
      begin
        vStrVal := ANode.ValueAsStr;
        case AType.Id of
          xmlTextStyle:  vDXFTable := FConverter.FStyles;
          xmlCLayer:     vDXFTable := FConverter.FLayers;
          xmlCELType:    vDXFTable := FConverter.FLTypes;
        else
          vDXFTable := nil;
        end;
        if Assigned(vDXFTable) and Assigned(vDXFTable.FindEntByName(vStrVal)) then
          case AType.Id of
            xmlTextStyle:  FConverter.GetPHeadVarStruct^.TextStyle := vStrVal;
            xmlCLayer:     FConverter.GetPHeadVarStruct^.CLayer := vStrVal;
            xmlCELType:    FConverter.GetPHeadVarStruct^.CELType := vStrVal;
          end
        else
          Result := cnstXML_ERROR;
      end;
    xmlCEColor: FConverter.GetPHeadVarStruct^.CEColor := ANode.ValueData.ValueAsColorCAD;
    xmlDimStyle:
      begin
        vStrVal := ANode.ValueAsStr;
        vDimStyle := TsgDXFDimensionStyle(FConverter.Sections[csDimStyles].FindEntByName(vStrVal));
        if Assigned(vDimStyle) then
        begin
          FAccess.DimStyle := vDimStyle;
          //FConverter.GetPHeadVarStruct^.DimStyle := vStrVal;
        end
        else
          Result := cnstXML_ERROR;
      end;
    xmlDimTextStyle:
      begin
        vStrVal := ANode.ValueAsStr;
        vStyle := TsgDXFStyle(FConverter.Sections[csStyles].FindEntByName(vStrVal));
        if Assigned(vStyle) then
        begin
          FAccess.DimStyle.TextStyle := vStyle;
          FConverter.GetPHeadVarStruct^.DimTextStyle := vStrVal;
        end
        else
          Result := cnstXML_ERROR;
      end;
    xmlDimAssoc:
      begin
        vByteVal := ANode.ValueData.ValueAsByte;
        if vByteVal < 3 then//autocad has 0, 1, 2 modes
          FConverter.GetPHeadVarStruct^.DimAssoc := vByteVal
        else
          Result := cnstXML_ERROR;
      end;
    xmlCELWeight:
      begin
        if TryStrToInt(ANode.ValueAsStr, vIntVal) then
        begin
          if ConvertDXFToLineWeight(vIntVal, vDoubleVal) then
            FConverter.GetPHeadVarStruct^.CELWeight := vDoubleVal
          else
            Result := cnstXML_ERROR;
        end
        else
          Result := cnstXML_ERROR;
      end;
    xmlExtMim: FConverter.GetPHeadVarStruct^.ExtMin := ANode.ValueAsFPoint;
    xmlExtMax: FConverter.GetPHeadVarStruct^.ExtMax := ANode.ValueAsFPoint;
    xmlCELTScale,xmlFilletRadius,xmlLTScale,xmlPointDisplaySize,
      xmlTextSize:
      begin
        if sgTryStrToFloat(ANode.ValueAsStr, vDoubleVal) then
          case AType.Id of
            xmlCELTScale,xmlLTScale:
              if vDoubleVal > 0 then
                case AType.Id of
                  xmlCELTScale: FConverter.GetPHeadVarStruct^.CELTScale := vDoubleVal;
                  xmlLTScale: FConverter.GetPHeadVarStruct^.LTScale := vDoubleVal;
                end
              else
                Result := cnstXML_ERROR;
            xmlFilletRadius: FConverter.GetPHeadVarStruct^.FilletRadius := vDoubleVal;
            xmlPointDisplaySize: FConverter.GetPHeadVarStruct^.PointDisplaySize := vDoubleVal;
            xmlTextSize:     FConverter.GetPHeadVarStruct^.TextSize := vDoubleVal;
          end
        else
          Result := cnstXML_ERROR;
      end;
    xmlMeasurement: FConverter.GetPHeadVarStruct^.Measurement := Boolean(ANode.ValueAsInt);
    xmlInsUnits,xmlPointDisplayMode,xmlTileMode:
      begin
        if TryStrToInt(ANode.ValueAsStr, vIntVal) then
          case AType.Id of
            xmlInsUnits:
              begin
                if (vIntVal >= 0) and (vIntVal <= 20) then
                  FConverter.GetPHeadVarStruct^.InsUnits := vIntVal
                else
                  Result := cnstXML_ERROR;
              end;
            xmlPointDisplayMode:
              case vIntVal of
                0..4, 32..36, 64..68, 96..100:
                  FConverter.GetPHeadVarStruct^.PointDisplayMode := vIntVal;
              else
                Result := cnstXML_ERROR;
              end;
            xmlTileMode: FConverter.GetPHeadVarStruct^.TileMode := vIntVal;
          end
        else
          Result := cnstXML_ERROR;
      end;
    xmlUCSORG: FConverter.GetPHeadVarStruct^.UCSORG := ANode.ValueAsFPoint;
    xmlUCSXDir: FConverter.GetPHeadVarStruct^.UCSXDir := ANode.ValueAsFPoint;
    xmlUCSYDir: FConverter.GetPHeadVarStruct^.UCSYDir := ANode.ValueAsFPoint;
    xmlInsBase: FConverter.GetPHeadVarStruct^.InsBase:= ANode.ValueAsFPoint ;
    xmlAttributeMode: FConverter.GetPHeadVarStruct^.AttMode := TsgAttributeMode(ANode.ValueAsInt);
    xmlFillMode: FConverter.GetPHeadVarStruct^.FillMode := ANode.ValueAsBool;
    xmlLwDisplay: FConverter.GetPHeadVarStruct^.LwDisplay := Ord(ANode.ValueAsBool);
  else
    Result := cnstXML_UNSUPPORTED;
  end;
  if Result = cnstXML_UNSUPPORTED then
  begin
    Result := FromXMLNodeDimProps(FConverter.GetPHeadVarStruct^.DimProps,
      AType, ANode, AIsChild, AResult);
    FAccess.DimStyle.UpdateDimProps(FConverter.GetPHeadVarStruct^.DimProps);
  end;
end;

class function TsgDXFSectionHeader.FromXMLNodeDimProps(var AProps: TsgDimStyle;
  const AType: TsgXMLType; const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vDoubleValue: Double;
  vIntegerValue: Integer;
  vBooleanValue,vIsSet: Boolean;
  vStrValue: string;
begin
  Result := cnstXML_OK;
  case AType.Id of
    xmlDimAltF,xmlDimAsz,xmlDimCen,xmlDimExe,xmlDimExo,xmlDimGap,xmlDimLFac,
      xmlDimLwD,xmlDimLwE,xmlDimScale,xmlDimTxt:
      begin
        if sgTryStrToFloat(ANode.ValueAsStr, vDoubleValue) then
        begin
          case AType.Id of
            xmlDimAltF: AProps.AltF := vDoubleValue;
            xmlDimAsz:
              begin
                if vDoubleValue >= 0 then
                  AProps.Asz := vDoubleValue
                else
                  Result := cnstXML_ERROR;
              end;
            xmlDimCen: AProps.Cen := vDoubleValue;
            xmlDimExe:
              begin
                if vDoubleValue >= 0 then
                  AProps.Exe := vDoubleValue
                else
                  Result := cnstXML_ERROR;
              end;
            xmlDimExo:
              begin
                if vDoubleValue >= 0 then
                  AProps.Exo := vDoubleValue
                else
                  Result := cnstXML_ERROR;
              end;
            xmlDimGap: AProps.Gap := vDoubleValue;
            xmlDimLFac: AProps.LFac := vDoubleValue;
            xmlDimLwD: AProps.LwD := vDoubleValue;
            xmlDimLwE: AProps.LwE := vDoubleValue;
            xmlDimScale: AProps.Scale := vDoubleValue;
            xmlDimTxt: AProps.Txt := vDoubleValue;
          end;
        end
        else
          Result := cnstXML_ERROR;
      end;
    xmlDimDec,xmlDimTad,xmlDimTix:
      begin
        if TryStrToInt(ANode.ValueAsStr, vIntegerValue) then
          case AType.Id of
            xmlDimDec:
              begin
                if (vIntegerValue >= 0) and (vIntegerValue <= 8) then
                  AProps.Dec := vIntegerValue
                else
                  Result := cnstXML_ERROR;
              end;
            xmlDimTad: AProps.Tad := vIntegerValue;
            xmlDimTix: AProps.Tix := vIntegerValue;
          end
        else
          Result := cnstXML_ERROR;
      end;

    xmlDimAlt,xmlDimSah,xmlDimSD1,xmlDimSD2,xmlDimSE1,xmlDimSE2,xmlDimTih,xmlDimToh:
      begin
        vStrValue := ANode.ValueAsStr;
        vIsSet := False;
        if not TryStrToBool(vStrValue, vBooleanValue) then
        begin
          if TryStrToInt(vStrValue, vIntegerValue) then
            if vIntegerValue in [0,1] then
            begin
              vBooleanValue := vIntegerValue = 1;
              vIsSet := True;
            end;
        end
        else
          vIsSet := True;
        if vIsSet then
        begin
          case AType.Id of
            xmlDimAlt:   AProps.Alt := vBooleanValue;
            xmlDimSah:   AProps.Sah := vBooleanValue;
            xmlDimSD1:   AProps.SD1 := vBooleanValue;
            xmlDimSD2:   AProps.SD2 := vBooleanValue;
            xmlDimSE1:   AProps.SE1 := vBooleanValue;
            xmlDimSE2:   AProps.SE2 := vBooleanValue;
            xmlDimTih:   AProps.Tih:= vBooleanValue;
            xmlDimToh:   AProps.Toh := vBooleanValue;
          end;
        end
        else
          Result := cnstXML_ERROR;
      end;

    xmlDimAPost: AProps.APost := ANode.ValueAsStr;
    xmlDimClrD:  AProps.ClrD := ANode.ValueData.ValueAsColorCAD;
    xmlDimClrE:  AProps.ClrE := ANode.ValueData.ValueAsColorCAD;
    xmlDimClrT:  AProps.ClrT := ANode.ValueData.ValueAsColorCAD;
    xmlDimPost:  AProps.Post := ANode.ValueAsStr;
    xmlDimTp:    AProps.Tp := ANode.ValueAsDouble;
    xmlDimTm:    AProps.Tm := ANode.ValueAsDouble;
    xmlDimLUnit: AProps.LUnit := GetDimLimitUnitsType(ANode.ValueAsInt);
    xmlDimDSep:  AProps.DSep := Char(ANode.ValueAsInt);
    xmlDimFrac:
       begin
         if TryStrToInt(ANode.ValueAsStr, vIntegerValue) then
         begin
           if (vIntegerValue >= 0) and (vIntegerValue <= 2) then
             AProps.Frac := vIntegerValue
           else
             Result := cnstXML_ERROR;
         end;
       end
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFSectionHeader.GetPHeadVarStruct(const AGetDefault: Boolean = True): PsgHeadVarStruct;
begin
  if AGetDefault then
    Result := @cnstDefHeadVarStruct
  else
    Result := nil;
  if Assigned(FConverter) then
    Result := FConverter.PHeadVarStruct;
end;

{ TsgDXFSectionForXMLExport }

function TsgDXFSectionForXMLExport.AddItem(const AItem: TObject): Integer;
begin
  Result := -1;
end;

constructor TsgDXFSectionForXMLExport.CreateByConverter(const AConverter: TsgDXFConverter);
begin
  inherited Create;
  SetConverter(AConverter);
end;

function TsgDXFSectionForXMLExport.DeleteItem(const AItem: TObject): Integer;
begin
  Result := -1;
end;

function TsgDXFSectionForXMLExport.FindEntByName(
  const AName: string): TsgDXFEntity;
var
  I: Integer;
begin
  Result := nil;
  I := IndexOfName(AName);
  if I >= 0 then
    Result := Entities[I];
end;

procedure TsgDXFSectionForXMLExport.Link(AConverter: TsgDXFConverter);
begin
  // for do not use sortlist
  SetConverter(AConverter);
end;

{ TsgBTIExtendedDefault }

procedure TsgBTIExtendedDefault.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgBTIExtendedDefault then
  begin
    FTemplateElementCarvedScale := TsgBTIExtendedDefault(Source).FTemplateElementCarvedScale;
  end;
end;

constructor TsgBTIExtendedDefault.Create;
begin
  inherited Create;
  Reset;
end;

function TsgBTIExtendedDefault.GetTemplateElementCarvedScale: Double;
begin
  Result := FTemplateElementCarvedScale;
end;

procedure TsgBTIExtendedDefault.Reset;
begin
  FTemplateElementCarvedScale := 1.0;
end;

procedure TsgBTIExtendedDefault.SetTemplateElementCarvedScale(const Value: Double);
begin
  if Value > 0 then
    FTemplateElementCarvedScale := Value;
end;

{ TsgInventoryDefault }

procedure TsgInventoryDefault.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgInventoryDefault then
  begin
    FNumberArea := TsgInventoryDefault(Source).FNumberArea;
    FNumberComplexArea := TsgInventoryDefault(Source).FNumberComplexArea;
    FLetterNumberArea := TsgInventoryDefault(Source).FLetterNumberArea;
    FLetterNumberCompexArea := TsgInventoryDefault(Source).FLetterNumberCompexArea;
  end;
end;

function TsgInventoryDefault.GetCadastralNumber: Integer;
begin
  Result := FCadastralNumber;
end;

function TsgInventoryDefault.GetAttribHeight: Double;
begin
  Result := FAttribHeight;
end;

function TsgInventoryDefault.GetLetterNumberArea: string;
begin
  Result := LetterNumbers[False];
end;

function TsgInventoryDefault.GetLetterNumberComplexArea: string;
begin
  Result := LetterNumbers[True];
end;

function TsgInventoryDefault.GetLetterNumbers(const AComplex: Boolean): string;
begin
  if AComplex then
    Result := FLetterNumberCompexArea
  else
    Result := FLetterNumberArea;
end;

function TsgInventoryDefault.GetNumberArea: Integer;
begin
  Result := Numbers[False];
end;

function TsgInventoryDefault.GetNumberComplexArea: Integer;
begin
  Result := Numbers[True];
end;

function TsgInventoryDefault.GetNumbers(const AComplex: Boolean): Integer;
begin
  if AComplex then
    Result := FNumberComplexArea
  else
    Result := FNumberArea;
end;

procedure TsgInventoryDefault.Reset;
begin
  inherited Reset;
  FNumberArea := 1;
  FNumberComplexArea := 1;
  FLetterNumberArea := '';
  FLetterNumberCompexArea := '';
  FCadastralNumber := 1;
  FAttribHeight := 2.8;
end;

procedure TsgInventoryDefault.SetCadastralNumber(const AValue: Integer);
begin
  FCadastralNumber := AValue;
end;

procedure TsgInventoryDefault.SetAttribHeight(const AValue: Double);
begin
  FAttribHeight := AValue;
end;

procedure TsgInventoryDefault.SetLetterNumberArea(const AValue: string);
begin
  LetterNumbers[False] := AValue;
end;

procedure TsgInventoryDefault.SetLetterNumberComplexArea(const AValue: string);
begin
  LetterNumbers[True] := AValue;
end;

procedure TsgInventoryDefault.SetLetterNumbers(const AComplex: Boolean;
  const AValue: string);
begin
  if AComplex then
    FLetterNumberCompexArea := AValue
  else
    FLetterNumberArea := AValue;
end;

procedure TsgInventoryDefault.SetNumberArea(const AValue: Integer);
begin
  Numbers[False] := AValue;
end;

procedure TsgInventoryDefault.SetNumberComplexArea(const AValue: Integer);
begin
  Numbers[True] := AValue;
end;

procedure TsgInventoryDefault.SetNumbers(const AComplex: Boolean;
  const AValue: Integer);
begin
  if AComplex then
    FNumberComplexArea := AValue
  else
    FNumberArea := AValue;
end;

{ TsgEvacuationDefault }

procedure TsgEvacuationDefault.AssignEntity(Source: TsgDXFEntity);
var
  vDefault: TsgEvacuationDefault absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgEvacuationDefault then
  begin
    FPathEvacucationColor := vDefault.FPathEvacucationColor;
    FPathEvacucationWidth := vDefault.FPathEvacucationWidth;
    FPathEvacucationLineTypeScale := vDefault.FPathEvacucationLineTypeScale;
  end;
end;

function TsgEvacuationDefault.GetPathEvacColor: TsgColorCAD;
begin
  Result := FPathEvacucationColor;
end;

function TsgEvacuationDefault.GetPathEvacLayer: string;
begin
  Result := sLayerPathEvacuation;
end;

function TsgEvacuationDefault.GetPathEvacLineTypeScale: Double;
begin
  Result := FPathEvacucationLineTypeScale;
end;

function TsgEvacuationDefault.GetPathEvacWidth: Double;
begin
  Result := FPathEvacucationWidth;
end;

procedure TsgEvacuationDefault.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
end;

procedure TsgEvacuationDefault.Reset;
begin
  inherited Reset;
  FPathEvacucationColor := cnstColorCADByPathEvacuation;
  FPathEvacucationLineTypeScale := 1;
  FPathEvacucationWidth := 0.18;
end;

procedure TsgEvacuationDefault.SetPathEvacColor(const Value: TsgColorCAD);
begin
  FPathEvacucationColor := Value;
end;

procedure TsgEvacuationDefault.SetPathEvacLineTypeScale(const Value: Double);
begin
  if Value <> 0 then
    FPathEvacucationLineTypeScale := Value;
end;

procedure TsgEvacuationDefault.SetPathEvacWidth(const Value: Double);
begin
  FPathEvacucationWidth := Value;
end;

{ TsgDXFEntitySampleCustom }

procedure TsgDXFEntitySampleCustom.AfterChange(const AType: TsgPropertyType);
begin
  if Assigned(FOnAfterChange) then
    FOnAfterChange(Self, AType);
end;

procedure TsgDXFEntitySampleCustom.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFEntitySampleCustom then
    SetConverter(TsgDXFEntitySampleCustom(Source).FConverter);
end;

procedure TsgDXFEntitySampleCustom.BeforeChange(const AType: TsgPropertyType);
begin
  if Assigned(FOnBeforeChange) then
    FOnBeforeChange(Self, AType);
end;

constructor TsgDXFEntitySampleCustom.Create;
begin
  inherited Create;
end;

function TsgDXFEntitySampleCustom.GetActiveHeadVar: PsgHeadVarStruct;
begin
  if FConverter <> nil then
    Result := @FConverter.FHeadVarStruct
  else
    Result := @cnstSGHeadVarStruct
end;

function TsgDXFEntitySampleCustom.GetConverter: TsgDXFConverter;
begin
  Result := FConverter;
end;

procedure TsgDXFEntitySampleCustom.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
end;

procedure TsgDXFEntitySampleCustom.SetConverter(const AConverter: TsgDXFConverter);
begin
{$IFDEF CONV_REFCOUNT}
  if FConverter <> AConverter then
  begin
    if Assigned(FConverter) then
      Dec(FConverter.FRefCount);
{$ENDIF}
    FConverter := AConverter;
{$IFDEF CONV_REFCOUNT}
    if Assigned(FConverter) then
      Inc(FConverter.FRefCount);
  end;
{$ENDIF}
end;

{ TsgCADBoundaryData }

function TsgCADBoundaryData.AddBoundaryList(const AFlags: Byte): Tsg2DBoundaryList;
begin
  Result := Tsg2DBoundaryList.Create;
  FBoundaries.Add(Result);
  Result.BoundaryType := AFlags;
end;

procedure TsgCADBoundaryData.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADBoundaryData then
  begin
    ClearBoundaries;
    CopyBoundaries(TsgCADBoundaryData(Source));
  end;
end;

function TsgCADBoundaryData.BoundaryToFromNode(
  const ABoundary: Tsg2DBoundaryList;
  const ANode: TsgNodeSample;
  const AResult: IsgResultNode = nil): Integer;
var
  I: Integer;
  vFlags, vChild: TsgNodeSample;
  vObjectClass: TsgObjectClass;
  vCurve: Tsg2DCurve;
begin
  Result := cnstXML_OK;
  vFlags := ANode.GetAttributeByName(cnstXMLNames[xmlFlags].Name);
  if Assigned(vFlags) then
    ABoundary.BoundaryType := vFlags.ValueAsInt;
  for I := 0 to ANode.ChildNodesCount - 1 do
  begin
    vChild := ANode.ChildNodes[I];
    vObjectClass := TsgObjectClass(GetClassByXMLName(vChild.Name));
    if Assigned(vObjectClass) then
    begin
      vCurve := Tsg2DCurve(vObjectClass.Create);
      ABoundary.Add(vCurve);
      vCurve.FromXML(vChild, AResult);
    end;
  end;
end;

function TsgCADBoundaryData.BoundaryToXMLNode(const ABoundary: Tsg2DBoundaryList;
  const ANode: TsgNode): Integer;
var
  I: Integer;
begin
  Result := cnstXML_OK;
  ANode.AddAttribNV(cnstXMLNames[xmlFlags].Name).ValueAsInt := ABoundary.BoundaryType;
  for I := 0 to ABoundary.Count - 1 do
    ABoundary[I].ToXML(ANode);
end;

function TsgCADBoundaryData.CanUseBoundaryList(const AList: Tsg2DBoundaryList;
  const ASolidFill: Boolean): Boolean;

  function IsNotUse(ABoundaryType: Byte): Boolean;
  begin
    Result := ((ABoundaryType > 31) and (ABoundaryType and $04 = 0) and ASolidFill) or
      (ABoundaryType and 128 <> 0) or ((ABoundaryType and $18 = $08) and ASolidFill);
    // The are files, where 8'th or 6'th bits are set
  end;

begin
  Result := (AList.Count > 0) and (not IsNotUse(AList.BoundaryType));
end;

procedure TsgCADBoundaryData.ClearBoundaries(const AClearCapacity: Boolean);
begin
  TsgObjectList.ClearList(FBoundaries, AClearCapacity);
end;

procedure TsgCADBoundaryData.ClearReferences;
begin
  inherited ClearReferences;
  ClearBoundaries;
end;

procedure TsgCADBoundaryData.CopyBoundaries(const ABoundaryData: TsgCADBoundaryData);
var
  I: Integer;
  L: TObject;
  LNew: Tsg2DBoundaryList;
begin
  FBoundaries.Capacity := ABoundaryData.FBoundaries.Count;
  for I := 0 to ABoundaryData.FBoundaries.Count - 1 do
  begin
    L := ABoundaryData.FBoundaries.Items[I];
    if L = nil then
      Continue;
    if ((L is Tsg2DBoundaryList) and (Tsg2DBoundaryList(L).Count > 0)) or
       ((L is TList) and (TList(L).Count > 0)) then
    begin
      LNew := Tsg2DBoundaryList.Create;
      FBoundaries.Add(LNew);
      LNew.AssignBoundary(L);
    end;
  end;
end;

constructor TsgCADBoundaryData.Create;
begin
  inherited Create;
  FBoundaries := TsgObjectList.Create;
end;

procedure TsgCADBoundaryData.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FBoundaries);
end;

function TsgCADBoundaryData.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  vBoundary: Tsg2DBoundaryList;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlBoundary:
      begin
        vBoundary := Tsg2DBoundaryList.Create;
        FBoundaries.Add(vBoundary);
        BoundaryToFromNode(vBoundary, ANode, AResult);
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgCADBoundaryData.GenerateListOfBoundaries(const AObjects: TsgObjectList;
  AExplodePolyline: Boolean = False): TFRect;
var
  I, Cnt{$IFDEF SG_BTI}, J{$ENDIF}: Integer;
  vEnt{$IFDEF SG_BTI}, vEntSub{$ENDIF}: TsgDXFEntity;
  vOnlyPoly: Boolean;
  vActBoundary: Tsg2DBoundaryList;
{$IFDEF SG_BTI}
  vPts: TsgPoints4;
{$ENDIF}

  function GetActBoundary(const APoly: TsgCADBasePolyline): Tsg2DBoundaryList;
  begin
    if APoly.Closed then
      Result :=  AddBoundaryList(1)
    else
    begin
      if vActBoundary = nil then
        vActBoundary := AddBoundaryList(1);
      Result := vActBoundary;
    end;
  end;

  procedure AddHatchOfArcR(AArc: TsgArcR; ABoundaryList: Tsg2DBoundaryList);
  var
    vArc: Tsg2DArc;
  begin
    vArc := Tsg2DArc.Create;
    ABoundaryList.Add(vArc);
    vArc.CenterPoint := MakeF2DPoint(AArc.Center.X, AArc.Center.Y);
    vArc.Radius := AArc.Radius;
    vArc.StartParam := AArc.AngleS;
    vArc.EndParam := AArc.AngleE;
    vArc.CounterClockWise := True;
    UnionFRect(Result, vEnt.Box);
  end;

  procedure AddHatchOfArc(AArc: TsgDXFArc);
  begin
    AddHatchOfArcR(AArc.Arc, GetActBoundary(AArc));
  end;

  procedure AddHatchOfCircle(ACircle: TsgDXFCircle);
  var
    vCircle: Tsg2DArc;
    vBoundaryList: Tsg2DBoundaryList;
  begin
    vBoundaryList := GetActBoundary(ACircle);
    vCircle := Tsg2DArc.Create;
    vBoundaryList.Add(vCircle);
    vCircle.CenterPoint := MakeF2DPoint(ACircle.Point.X, ACircle.Point.Y);
    vCircle.Radius := ACircle.Radius;
    vCircle.StartParam := 0;
    vCircle.EndParam := 360;
    vCircle.CounterClockWise := True;
    UnionFRect(Result, vEnt.Box);
  end;

  procedure AddHatchOfEllipse(AEllipse: TsgDXFEllipse);
  var
    vEllipse: Tsg2DEllipse;
    vBoundaryList: Tsg2DBoundaryList;
  begin
    vBoundaryList := GetActBoundary(AEllipse);
    vEllipse := Tsg2DEllipse.Create;
    vBoundaryList.Add(vEllipse);
    vEllipse.CenterPoint := MakeF2DPoint(AEllipse.Point.X, AEllipse.Point.Y);
    vEllipse.MajorPoint := MakeF2DPoint(AEllipse.EndPoint.X, AEllipse.EndPoint.Y);
    vEllipse.Radius := AEllipse.Ratio;
    vEllipse.StartParam := AEllipse.StartAngle;
    vEllipse.EndParam := AEllipse.EndAngle;
    vEllipse.IsAngleInParam := False;
    vEllipse.CounterClockWise := True;
    UnionFRect(Result, vEnt.Box);
  end;

  procedure AddHatchOfPts(AP1,AP2: TFPoint);
  var
    vLine: Tsg2DLine;
  begin
    if vActBoundary = nil then
      vActBoundary := AddBoundaryList(1);
    vLine := Tsg2DLine.Create;
    vActBoundary.Add(vLine);
    vLine.SetStartPoint(MakeF2DPoint(AP1.X, AP1.Y));
    vLine.SetEndPoint(MakeF2DPoint(AP2.X, AP2.Y));
    UnionFRect(Result, vEnt.Box);
  end;

  procedure AddHatchOfLine(ALine: TsgDXFLine);
  begin
    AddHatchOfPts(ALine.Point, ALine.Point1);
  end;

  procedure AddHatchOfPolyBezier(ASpline: TsgDXFSpline);
  var
    I, Cnt: Integer;
    vSpline: Tsg2DSpline;
    vLine: Tsg2DLine;
    vBoundaryList: Tsg2DBoundaryList;
  begin
    vBoundaryList := GetActBoundary(ASpline);
    if ASpline.IsByAngles then
    begin
      Cnt := ASpline.PointCount - 1;
      if Cnt > 1 then
      begin
        for I := 1 to Cnt do
        begin
          vLine := Tsg2DLine.Create;
          vBoundaryList.Add(vLine);
          vLine.SetStartPoint(MakeF2DPointFrom3D(ASpline.PolyPoints[I - 1]));
          vLine.SetEndPoint(MakeF2DPointFrom3D(ASpline.PolyPoints[I]));
        end;
        if ASpline.Closed then
        begin
          vLine := Tsg2DLine.Create;
          vBoundaryList.Add(vLine);
          vLine.SetStartPoint(MakeF2DPointFrom3D(ASpline.PolyPoints[0]));
          vLine.SetEndPoint(MakeF2DPointFrom3D(ASpline.PolyPoints[Cnt]));
        end;
      end;
    end
    else
    begin
      vSpline := Tsg2DSpline.Create;
      vBoundaryList.Add(vSpline);
      vSpline.Degree := ASpline.Degree;
      Cnt := ASpline.Controls.Count - 1;
      for I := 0 to Cnt do
        vSpline.AddControl(MakeF2DPointFrom3D(ASpline.Controls[I]));
      Cnt := ASpline.Knots.Count - 1;
      for I := 0 to Cnt do
        vSpline.AddKnot(ASpline.Knots[I]);
    end;
    UnionFRect(Result, vEnt.Box);
  end;

  procedure AddHatchOfPolyline(APoly: TsgDXFPolyline);
  var
    I, Cnt: Integer;
    vPoly: Tsg2DPolyline;
    vLine: Tsg2DLine;
    vVertex: TsgDXFVertex;
    vTP: TF2DPoint;
    vBoundaryList: Tsg2DBoundaryList;
    vPoint, vPointNew: TFPoint;
  begin
    if (vOnlyPoly and not AExplodePolyline) or APoly.Closed then
    begin
      vBoundaryList := AddBoundaryList(7);
      vPoly := Tsg2DPolyline.Create;
      vBoundaryList.Add(vPoly);
      Cnt := APoly.Count - 1;
      for I := 0 to Cnt do
      begin
        vVertex := TsgDXFVertex(APoly.Entities[I]);
        vTP.X := vVertex.Point.X;
        vTP.Y := vVertex.Point.Y;
        if (I > 0) and IsEqualF2DPoints(vTP, vPoly.EndPoint) then
          Continue;
        vPoly.AddVertex(vTP);
        if Abs(vVertex.Bulge) > fAccuracy then
          vPoly.AddBulge(vVertex.Bulge);
      end;
      vPoly.Closed := not IsEqualF2DPoints(vPoly.StartPoint, vPoly.EndPoint);
      UnionFRect(Result, vEnt.Box);
    end
    else
    begin
      if APoly.PolyPoints.Count > 1 then
      begin
        if vActBoundary = nil then
          vActBoundary := AddBoundaryList(1);
        Cnt := APoly.PolyPoints.Count - 1;
        vPoint := APoly.PolyPoints.List[0];
        for I := 1 to Cnt do
        begin
          vPointNew := APoly.PolyPoints.List[I];
          if not IsEqualFPoints2D(vPoint, vPointNew) then
          begin
            vLine := Tsg2DLine.Create;
            vActBoundary.Add(vLine);
            vLine.SetStartPoint(MakeF2DPoint(vPoint.X, vPoint.Y));
            vLine.SetEndPoint(MakeF2DPoint(vPointNew.X, vPointNew.Y));
            vPoint := vPointNew;
          end;
        end;
        UnionFRect(Result, vEnt.Box);
      end;
    end;
  end;

  function IsNotExtruded(const AEnt: TsgDXFEntity): Boolean;
  begin
    if AEnt is TsgDXFPenLine then
      Result := not TsgDXFPenLine(AEnt).IsExtruded
    else
    begin
      {$IFDEF SG_BTI}
      case AEnt.EntType of
        ceInsert: Result := AEnt.GetEntTypeEx <> cnstUndefined;
      else
        Result := False;
      end;
      {$ELSE}
      Result := False;
      {$ENDIF}
    end;
  end;

begin
  Cnt := AObjects.Count - 1;
  ClearBoundaries(False);
  FBoundaries.Capacity := AObjects.Count;
  Result := cnstBadRect;
  vOnlyPoly := True;
  vActBoundary := nil;
  for I := 0 to Cnt do
  begin
    vEnt := TsgDXFEntity(AObjects[I]);
    if (vEnt <> nil) and (not (vEnt.EntType in [cePolyline, ceLWPolyline])) then
    begin
      vOnlyPoly := False;
      Break;
    end;
  end;
  for I := 0 to Cnt do
  begin
    vEnt := TsgDXFEntity(AObjects[I]);
    if (vEnt <> nil) and IsNotExtruded(vEnt) then
    begin
      case vEnt.EntType of
        ceArc:        AddHatchOfArc(TsgDXFArc(vEnt));
        ceCircle:     AddHatchOfCircle(TsgDXFCircle(vEnt));
        ceEllipse:    AddHatchOfEllipse(TsgDXFEllipse(vEnt));
        ceLine:       AddHatchOfLine(TsgDXFLine(vEnt));
        cePolyline:   AddHatchOfPolyline(TsgDXFPolyline(vEnt));
        ceLWPolyline: AddHatchOfPolyline(TsgDXFPolyline(vEnt));
        ceSpline:     AddHatchOfPolyBezier(TsgDXFSpline(vEnt));
{$IFDEF SG_BTI}
       ceInsert:
         begin
           case vEnt.GetEntTypeEx of
             cnstComplexBroad:
               if TsgDXFInsert(vEnt).IsRealCircular then
                 AddHatchOfArcR(TsgDXFInsert(vEnt).GetArcOfCenter, AddBoundaryList(1))
               else
               begin
                 TsgDXFInsert(vEnt).GetPts(vPts);
                 AddHatchOfPts(MiddleFPoint(vPts[1], vPts[2]), MiddleFPoint(vPts[3], vPts[0]));
               end;
             cnstArea, cnstComplexArea:
               begin
                 if TsgDXFInsert(vEnt).Block <> nil then
                 begin
                   for J := 0 to TsgDXFInsert(vEnt).Block.Count - 1 do
                   begin
                     vEntSub := TsgDXFInsert(vEnt).Block.Entities[J];
                     if vEntSub.EntType in [ceLWPolyline, cePolyline] then
                       AddHatchOfPolyline(TsgDXFPolyline(vEntSub));
                   end;
                 end;
               end;
           end;
         end;
{$ENDIF}
      end;
    end
    else
      vActBoundary := nil;
  end;
end;

function TsgCADBoundaryData.GetConverter: TsgDXFConverter;
begin
  if Assigned(FParentEntity) then
    Result := FParentEntity.Converter
  else
    Result := nil;
end;

function TsgCADBoundaryData.GetNodeName: string;
begin
  Result := cnstXMLNames[xmlBoundaries].Name;
end;

type
  TEdgeRef = type PF2DPoint;
  TEdgeRefArray = array of TEdgeRef;

  PEdge = ^TEdge;
  TEdge = array[Boolean] of TF2DPoint;

  TBoundsMap = class
  private
    FCount: Integer;
    FEdges: array of TEdge;
    FCurves: array of Tsg2DCurve;
    FGap: Extended;
    FMarks: array of Integer;
    function GetEdge(Index: Integer; AEnd: Boolean): TEdgeRef;
    function GetIndex(AEdge: TEdgeRef): Integer;
    function GetPair(AEdge: TEdgeRef): TEdgeRef;
    function GetIsEnd(AEdge: TEdgeRef): Boolean;
    function SplitEdgeRef(AEdge: TEdgeRef; var AIsEnd: Boolean): Integer;
    function GetMark(AEdge: TEdgeRef): Integer;
    procedure SetMark(AEdge: TEdgeRef; const AValue: Integer);
    function GetCurve(AEdge: TEdgeRef): Tsg2DCurve;
  protected
    procedure Exchange(AEdge1, AEdge2: TEdgeRef);
  public
    constructor Create(ABounds: TBoundsMap; AMark: Integer); overload;
    constructor Create(AList: Tsg2DBoundaryList; const AGap: Extended); overload;
    property Count: Integer read FCount;
    property Edge[Index: Integer; AEnd: Boolean]: TEdgeRef read GetEdge;
    property Index[AEdge: TEdgeRef]: Integer read GetIndex;
    property IsEnd[AEdge: TEdgeRef]: Boolean read GetIsEnd;
    property Pair[AEdge: TEdgeRef]: TEdgeRef read GetPair;
    property Mark[AEdge: TEdgeRef]: Integer read GetMark write SetMark;
    property Curve[AEdge: TEdgeRef]: Tsg2DCurve read GetCurve;
    function QDistance(AEdge1, AEdge2: TEdgeRef): Extended;{$IFDEF SG_INLINE} inline;{$ENDIF}
    function FindNeighbour(AEdge: TEdgeRef): TEdgeRef;
  end;

constructor TBoundsMap.Create(AList: Tsg2DBoundaryList; const AGap: Extended);
var
  I: Integer;
begin
  FGap := AGap;
  FCount := AList.Count;
  SetLength(FCurves, FCount);
  SetLength(FEdges, FCount);
  SetLength(FMarks, FCount);
  FillChar(FMarks[0], FCount * SizeOf(Integer), $FF);
  for I := 0 to FCount - 1 do
  begin
    FCurves[I] := AList[I];
    FEdges[I][False] := FCurves[I].StartPoint;
    FEdges[I][True] := FCurves[I].EndPoint;
  end;
end;

constructor TBoundsMap.Create(ABounds: TBoundsMap; AMark: Integer);
var
  I, K: Integer;
begin
  FGap := ABounds.FGap;
  K := 0;
  for I := 0 to ABounds.Count - 1 do
    Inc(K, Ord(ABounds.FMarks[I] = AMark));
  FCount := K;
  SetLength(FEdges, FCount);
  SetLength(FMarks, FCount);
  SetLength(FCurves, FCount);
  K := 0;
  for I := 0 to ABounds.Count - 1 do
    if ABounds.FMarks[I] = AMark then
    begin
      FEdges[K] := ABounds.FEdges[I];
      FCurves[K] := ABounds.FCurves[I];
      FMarks[K] := ABounds.FMarks[I];
      Inc(K);
    end;
end;

function TBoundsMap.QDistance(AEdge1, AEdge2: TEdgeRef): Extended;
begin
  Result := Sqrt(Sqr(AEdge1^.X - AEdge2^.X) + Sqr(AEdge1^.Y - AEdge2^.Y));
end;

procedure TBoundsMap.Exchange(AEdge1, AEdge2: TEdgeRef);
var
  I1, I2: Integer;
begin
  I1 := GetIndex(AEdge1);
  I2 := GetIndex(AEdge2);
  if I1 <> I2 then
  begin
    AEdge1 := GetEdge(I1, False);
    AEdge2 := GetEdge(I2, False);
    SwapF2DPoints(PEdge(AEdge1)^[False], PEdge(AEdge2)^[False]);
    SwapF2DPoints(PEdge(AEdge1)^[True], PEdge(AEdge2)^[True]);
    SwapPointers(Pointer(FCurves[I1]), Pointer(FCurves[I2]));
    SwapInts(FMarks[I1], FMarks[I2]);
  end;
end;

function TBoundsMap.FindNeighbour(AEdge: TEdgeRef): TEdgeRef;
var
  I, vIndex: Integer;
  vMinDistance: Extended;
  vDist, vDA1, vDA2: array[Boolean] of Extended;
  vDistA: Extended;
  vMinIndex: Boolean;
  vCurve1, vCurve2: Tsg2DCurve;
  A1, A2: TsgArcR;
  P1, P2: TFPoint;
  vCrossArcs: Integer;
begin
  Result := nil;
  vMinDistance := FGap;
  vCurve1 := Curve[AEdge];
  I := 0;
  vIndex := Index[AEdge];
  while I < FCount do
  begin
    if (FMarks[I] = -1) and (I <> vIndex) then
    begin
      vCurve2 := FCurves[I];

      vDist[False] := QDistance(AEdge, @FEdges[I][False]);
      vDist[True] := QDistance(AEdge, @FEdges[I][True]);

      vMinIndex := vDist[True] < vDist[False];
      if vDist[vMinIndex] < vMinDistance then
      begin
        vMinDistance := vDist[vMinIndex];
        if vMinDistance < fDoubleResolution then
          vMinDistance := 0;
        Result := @FEdges[I][vMinIndex];
      end;
// ----------------- check arc with arc intersection -----------------
      if (vCurve1.EdgeType = cnst2DCurveArc) and (vCurve2.EdgeType = cnst2DCurveArc) then
      begin
        Tsg2DArc(vCurve1).GetArcRec(A1);
        Tsg2DArc(vCurve2).GetArcRec(A2);
        vCrossArcs := IsCrossArcsAP(A2, A1, @P1, @P2);
        if vCrossArcs > 0 then
        begin
          vDistA := QDistance(AEdge, @P1);
          vDA1[False] := QDistance(@FEdges[I][False], @P1);
          vDA1[True] := QDistance(@FEdges[I][True], @P1);
          vMinIndex := vDA1[True] < vDA1[False];
          if vDA1[vMinIndex] < vDistA then
            vDistA := vDA1[vMinIndex];
          if vCrossArcs > 1 then
          begin
            vDA2[False] := QDistance(@FEdges[I][False], @P2);
            vDA2[True] := QDistance(@FEdges[I][True], @P2);
            if (vDA2[False] < vDistA) or (vDA2[True] < vDistA) then
            begin
              vMinIndex := vDA2[True] < vDA2[False];
              vDistA := vDA2[vMinIndex];
            end;
          end;
          if vDistA < vMinDistance then
          begin
            vMinDistance := vDistA;
            if vMinDistance < fDoubleResolution then
              vMinDistance := 0;
            Result := @FEdges[I][vMinIndex];
          end;
        end;
      end;
// ----------------- check arc with arc intersection -----------------
// todo: check other curves intersections combinations
    end;
    Inc(I);
  end;
end;

function TBoundsMap.GetCurve(AEdge: TEdgeRef): Tsg2DCurve;
var
  I: Integer;
begin
  Result := nil;
  I := GetIndex(AEdge);
  if I < FCount then
    Result := FCurves[I];
end;

function TBoundsMap.GetEdge(Index: Integer; AEnd: Boolean): TEdgeRef;
begin
  Result := TEdgeRef(TsgNativeInt(@FEdges[Index]) + Ord(AEnd) * SizeOf(TF2DPoint));
end;

function TBoundsMap.SplitEdgeRef(AEdge: TEdgeRef; var AIsEnd: Boolean): Integer;
var
  vOffset: TsgNativeInt;
begin
  vOffset := TsgNativeInt(AEdge) - TsgNativeInt(@FEdges[0]);
  Result := vOffset div SizeOf(TEdge);
  AIsEnd := (vOffset div SizeOf(TF2DPoint)) mod 2 = 1;
end;

function TBoundsMap.GetIndex(AEdge: TEdgeRef): Integer;
var
  vIsEnd: Boolean;
begin
  Result := SplitEdgeRef(AEdge, vIsEnd);
end;

function TBoundsMap.GetIsEnd(AEdge: TEdgeRef): Boolean;
begin
  SplitEdgeRef(AEdge, Result);
end;

function TBoundsMap.GetMark(AEdge: TEdgeRef): Integer;
var
  I: Integer;
begin
  Result := -1;
  I := GetIndex(AEdge);
  if I < FCount then
    Result := FMarks[I];
end;

function TBoundsMap.GetPair(AEdge: TEdgeRef): TEdgeRef;
var
  I: Integer;
  vIsEnd: Boolean;
begin
  I := SplitEdgeRef(AEdge, vIsEnd);
  Result := Edge[I, not vIsEnd];
end;

procedure TBoundsMap.SetMark(AEdge: TEdgeRef; const AValue: Integer);
var
  I: Integer;
begin
  I := GetIndex(AEdge);
  if I < FCount then
  begin
    if FMarks[I] <> AValue then
    begin
      FMarks[I] := AValue;
    end;
  end;
end;

procedure TsgCADBoundaryData.MakeBorderPolylines(const AConverter: TsgDXFConverter;
  const ABoundaryPolylines: TsgObjectList; const ASolidFill: Boolean;
  AProgress: IsgProgress = nil);
var
  M, N: Integer;
  vContour: TF2DPointList;
  vList,  vList1: Tsg2DBoundaryList;
  vHPGapTol: Double;
  vBoundsMap, vForgetMap: TBoundsMap;
  vHead, vTail: TEdgeRef;
  vEdgesCount: Integer;
  vEdges: TEdgeRefArray;
  vBreakLoop: Boolean;
  vContinue: Integer;
  vContourID: Integer;
  vContourCloseDistance, vContourArea: Extended;

  procedure BoundaryLoaded;
  var
    K: Integer;
    vObj: TObject;
  begin
    M := 0;
    while M < FBoundaries.Count do
    begin
      vList := nil;
      vObj := FBoundaries[M];
      if vObj is Tsg2DBoundaryList then
        vList := Tsg2DBoundaryList(FBoundaries[M])
      else
      begin
        if vObj is TList then
        begin
          vList := Tsg2DBoundaryList.Create;
          try
            FBoundaries[M] := vList;
            vList.AssignBoundary(vObj);
          finally
            vObj.Free;
          end;
        end
        else
        begin
          if vObj <> nil then
          begin
            FBoundaries[M] := nil;
            vObj.Free;
          end;
        end;
      end;
      if vList <> nil then
      begin
        K := 0;
        while K < vList.Count do
        begin
          if vList[K] <> nil then
          begin
            Tsg2DCurve(vList[K]).Loaded(Self);
            Inc(K);
          end
          else
            vList.Delete(K);
        end;
        Inc(M);
      end;
    end;
  end;

  procedure EnumAddPoints(ACurve: Tsg2DCurve; Index, ACount, ADir: Integer;
    AList: TF2DPointList);
  const
    fContourResulution = fDoubleResolution * fDoubleResolution;
  var
    P, vDir: TF2DPoint;
    vLenSqr: Extended;
  begin
    while ACount > 0 do
    begin
      P := ACurve.Points[Index];
      if AList.Count = 0 then
        AList.Add(P)
      else
      begin
        vDir := SubF2DPoint(AList.Last, P);
        vLenSqr := Sqr(vDir.X) + Sqr(vDir.Y);
        if vLenSqr > fContourResulution then
          AList.Add(P);
      end;
      Index := Index + ADir;
      Dec(ACount);
    end;
  end;

  procedure CombinePoints(ABoundsMap: TBoundsMap; AList: TF2DPointList);
  var
    L: Integer;
    vCurve: Tsg2DCurve;
  begin
    if vEdgesCount > 0 then
    begin
      L := 0;
      vCurve := ABoundsMap.Curve[vEdges[L]];
      EnumAddPoints(vCurve, 0, vCurve.Count, +1, AList);
      Inc(L);
      while L < vEdgesCount do
      begin
        vCurve := ABoundsMap.Curve[vEdges[L]];
        if ABoundsMap.IsEnd[vEdges[L]] then
          EnumAddPoints(vCurve, 0, vCurve.Count, +1, AList)
        else
          EnumAddPoints(vCurve, vCurve.Count - 1, vCurve.Count, -1, AList);
        Inc(L);
      end;
    end;
  end;

  procedure ClearPoints(ABoundsMap: TBoundsMap);
  var
    L: Integer;
  begin
    L := 0;
    while L < vEdgesCount do
    begin
      ABoundsMap.Curve[vEdges[L]].ClearPoints;
      Inc(L);
    end;
  end;


begin
  vHPGapTol := cnstCADVariables.HPGapTol;
  if vHPGapTol <= 0 then
    vHPGapTol := cnstDefHPGapTol;
  if ABoundaryPolylines <> nil then
    TsgObjectList.ClearList(ABoundaryPolylines);
  BoundaryLoaded;
  vContourID := -1;
  M := 0;
  while (M < FBoundaries.Count) and (FBoundaries[M] <> nil) do
  begin
    vList := Tsg2DBoundaryList(FBoundaries[M]);
    if not CanUseBoundaryList(vList, ASolidFill) then
    begin
      Inc(M);
      Continue;
    end;

    vBoundsMap := TBoundsMap.Create(vList, vHPGapTol);
    try
      while Assigned(vBoundsMap) and (vBoundsMap.Count > 0) do
      begin
        vContour := TF2DPointList.Create;
        ABoundaryPolylines.Add(vContour);

        Inc(vContourID);
        vEdgesCount := 0;
        SetLength(vEdges, vBoundsMap.Count);
        try
          vHead := vBoundsMap.Edge[0, True];
          vEdges[0] := vHead;
          Inc(vEdgesCount);
          vBoundsMap.Mark[vHead] := vContourID;

          vBreakLoop := False;
          while not vBreakLoop do
          begin
            vContinue := 0;
            vHead := vBoundsMap.FindNeighbour(vEdges[vEdgesCount - 1]);
            if Assigned(vHead) then
            begin
              Inc(vEdgesCount);
              vEdges[vEdgesCount - 1] := vBoundsMap.Pair[vHead];
              vBoundsMap.Mark[vHead] := vContourID;
              vContinue := 1;
            end
            else
              while not vBreakLoop do
              begin
                vContinue := 0;
                vTail := vBoundsMap.FindNeighbour(vBoundsMap.Pair[vEdges[0]]);
                if Assigned(vTail) then
                begin
                  System.Move(vEdges[0], vEdges[1], vEdgesCount * SizeOf(TEdgeRef));
                  vEdges[0] := vTail;
                  Inc(vEdgesCount);
                  vBoundsMap.Mark[vTail] := vContourID;
                  vContinue := 2;
                end;
                vBreakLoop := vContinue = 0;
              end;
            vBreakLoop := vContinue = 0;

            // check area of closed contour
            if not vBreakLoop and (vEdgesCount > 2) then
            begin
              if vBoundsMap.IsEnd[vEdges[vEdgesCount - 1]] then
                vContourCloseDistance := vBoundsMap.QDistance(vEdges[0], vEdges[vEdgesCount - 1])
              else
                vContourCloseDistance := vBoundsMap.QDistance(vBoundsMap.Pair[vEdges[0]], vEdges[vEdgesCount - 1]);
              if vContourCloseDistance < fDoubleResolution then
              begin
                CombinePoints(vBoundsMap, vContour);
                vContourArea := GetAreaOfList(vContour);
                if vContourArea < fAccuracy then
                  vContour.Clear
                else
                begin
                  vContour := nil;
                  vBreakLoop := True;
                end;
              end;
            end;

          end;
          if vContour <> nil then
            CombinePoints(vBoundsMap, vContour);
          ClearPoints(vBoundsMap);
          vForgetMap := TBoundsMap.Create(vBoundsMap, -1);

          // split vList acording vForgetMap (previous code)
          if vForgetMap.Count > 0 then
          begin
            vList1 := Tsg2DBoundaryList.Create;
            vList1.BoundaryType := vList.BoundaryType;
            for N := 0 to vForgetMap.Count - 1 do
            begin
              vList.FObjects.Remove(vForgetMap.FCurves[N]);
              vList1.Add(vForgetMap.FCurves[N]);
            end;
            FBoundaries.Insert(M + 1, vList1);
            FreeAndNil(vForgetMap);
          end;

          SwapPointers(Pointer(vBoundsMap), Pointer(vForgetMap));
          vForgetMap.Free;
        finally
          Finalize(vEdges);
          vEdgesCount := 0;
        end;
      end;
    finally
      vBoundsMap.Free;
    end;
    Inc(M);
  end;
//  ClearBoundaryData; This is commented for AssignEntity could work
end;

procedure TsgCADBoundaryData.SetParentEntity(const AValue: TsgDXFEntity);
begin
  FParentEntity := AValue;
end;

function TsgCADBoundaryData.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vBoundary: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddChildNV(cnstXMLNames[xmlBoundary].Name)
  else
    for I := 0 to FBoundaries.Count - 1 do
    begin
      vBoundary := ANode.AddChildNV(cnstXMLNames[xmlBoundary].Name);
      BoundaryToXMLNode(Tsg2DBoundaryList(FBoundaries[I]), vBoundary);
    end;
end;

{ TsgCADHatchPatternData }

function TsgCADHatchPatternData.AddPatternData(const ABasePoint: TFPoint;
  const Angle: Double; const ASign: Integer): PsgHatchPatternData;
begin
  New(Result);
  FPatterns.Add(Result);
  Result.BaseP := ABasePoint;
  Result.Offset := MakeFPoint(1, ASign * 1, 0);
  Result.LineAngle := Angle;
  Result.IsDash := False;
  Result.Lines := nil;
  Result.DashNum := 0;
end;

procedure TsgCADHatchPatternData.ApplyAngle(const AngleRel: Double);
var
  PHPD: PsgHatchPatternData;
  I: Integer;
begin
  if AngleRel = 0 then
    Exit;
  for I := FPatterns.Count - 1 downto 0 do
  begin
    PHPD := PsgHatchPatternData(FPatterns[I]);
    PHPD^.LineAngle := PHPD^.LineAngle + AngleRel;
    PHPD^.BaseP := RotateFPoint(PHPD^.BaseP, AngleRel);
    PHPD^.Offset := RotateFPoint(PHPD^.Offset, AngleRel);
  end;
end;

procedure TsgCADHatchPatternData.ApplyScale(const AScaleRel: Double);
var
  PHPD: PsgHatchPatternData;
  I, J: Integer;
begin
  if AScaleRel = 1 then
    Exit;
  for I := FPatterns.Count - 1 downto 0 do
  begin
    PHPD := PsgHatchPatternData(FPatterns[I]);
    PHPD^.BaseP.X := AScaleRel * PHPD^.BaseP.X;
    PHPD^.BaseP.Y := AScaleRel * PHPD^.BaseP.Y;
    PHPD^.BaseP.Z := 0;
    PHPD^.Offset.X := AScaleRel * PHPD^.Offset.X;
    PHPD^.Offset.Y := AScaleRel * PHPD^.Offset.Y;
    PHPD^.Offset.Z := 0;
    if PHPD^.IsDash and (PHPD^.Lines <> nil) then
      for J := PHPD^.Lines.Count - 1 downto 0 do
        PHPD^.Lines[J] := AScaleRel * PHPD^.Lines[J];
  end;
end;

procedure TsgCADHatchPatternData.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADHatchPatternData then
  begin
    ClearPatterns;
    CopyPatterns(TsgCADHatchPatternData(Source));
  end;
end;

procedure TsgCADHatchPatternData.ClearPatterns(const AClearCapacity: Boolean);
var
  I: Integer;
begin
  FAngle := 0;
  FName := '';
  FScale := 1;
  if FPatterns <> nil then
  begin
    for I := 0 to FPatterns.Count - 1 do
    begin
      PsgHatchPatternData(FPatterns.List[I])^.Lines.Free;
      Dispose(PsgHatchPatternData(FPatterns.List[I]));
    end;
    FPatterns.Count := 0;
  end;
end;

procedure TsgCADHatchPatternData.ClearReferences;
begin
  inherited ClearReferences;
  ClearPatterns;
end;

procedure TsgCADHatchPatternData.CopyPatterns(const APatterns: TsgCADHatchPatternData);
var
  I: Integer;
  vNewHPD, vOldHPD: PsgHatchPatternData;
begin
  FName := APatterns.FName;
  FAngle := APatterns.FAngle;
  FScale := APatterns.FScale;
  FPatterns.Capacity := APatterns.FPatterns.Count;
  for I := 0 to APatterns.FPatterns.Count - 1 do
  begin
    New(vNewHPD);
    FPatterns.Add(vNewHPD);
    vOldHPD := APatterns.FPatterns[I];
    vNewHPD^ := vOldHPD^;
    if vNewHPD^.Lines <> nil then
    begin
      vNewHPD^.Lines := TsgDoubleList.Create(vOldHPD^.Lines.Count);
      vNewHPD^.Lines.Assign(vOldHPD^.Lines);
    end;
  end;
end;

constructor TsgCADHatchPatternData.Create;
begin
  inherited Create;
  FAngle := 0;
  FName := '';
  FScale := 1;
  FPatterns := TList.Create;
end;

procedure TsgCADHatchPatternData.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FPatterns);
end;

function TsgCADHatchPatternData.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
var
  PHPD: PsgHatchPatternData;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlAngle:   FAngle := ANode.ValueAsDouble;
    xmlName:    FName := ANode.ValueAsStr;
    xmlScale:   FScale := ANode.ValueAsDouble;
    xmlPattern:
     begin
       New(PHPD);
       FPatterns.Add(PHPD);
       FillChar(PHPD^, SizeOf(PHPD^), 0);
       HatchPatternDataFromToXMLNode(PHPD, ANode, AResult);
     end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgCADHatchPatternData.GetConverter: TsgDXFConverter;
begin
  Result := FConverter;
end;

function TsgCADHatchPatternData.GetNodeName: string;
begin
  Result := cnstXMLNames[xmlPatterns].Name;
end;

procedure TsgCADHatchPatternData.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlPattern));
    end;
  end;
end;

{ TsgCADHatchPatternData.HatchLine

  Creates the points-list for drawing a line of hatch}

procedure TsgCADHatchPatternData.HatchLine(AList: TsgDoubleList; Pt1, Pt2,
  BasePt: TFPoint; DottedSingPts: TFPointList);
var
  vDX, vDY, vCur, vLen, vPartLen, vHatchLineAng: Double;
  vIndex, I, vTicksCount: Integer;
  vAmountPatterns: Double;
  vPt: TFPoint;
  vPatternLength, vDist1, vDist2, vKx, vKy: Extended;


  function CompareValues(const AValue1, AValue2: Double): Integer;
  begin
    Result := 0;
    if (AValue1 > AValue2) then
      Result := 1;
    if IsEqual(AValue1, AValue2, fExtendedResolution) then
      Inc(Result, 2);
  end;

  function SGFloor64(AValue: Double): Int64;
  begin
    Result := Round(AValue);
    if CompareValues(Result, AValue) = 1 then
      Result := Result - 1;
  end;

  function CheckGetAmountPatterns: Double;
  begin
    Result := SGFloor64(vDist1 / vPatternLength);
    if Result > MaxInt then
      raise EsgOverflowUsesException.Create(sHatchOverflow);
  end;

  procedure IncIndex;
  begin
    Inc(vIndex);
    vIndex := vIndex mod vTicksCount;
  end;

  function AddPt: TFPoint;
  begin
    Result.X := Pt1.X + vKx * vCur;
    Result.Y := Pt1.Y + vKy * vCur;
    Result.Z := 0.0;
    DottedSingPts.Add(Result);
    IncIndex;
  end;

begin
  vIndex := 0;
  vTicksCount := (AList.Count shr 1) shl 1;
  // Length of a pattern
  vPatternLength := 0.0;
  for I := 0 to (vTicksCount - 1) do
    vPatternLength := vPatternLength + Abs(AList[I]);

  vDX := Pt2.X - Pt1.X;
  vDY := Pt2.Y - Pt1.Y;
  vLen := Sqrt(Sqr(vDX) + Sqr(vDY)) {/ FScale};
  if (Abs(vLen) < 0.0001) or (vPatternLength = 0)
    or ((vLen / vPatternLength) > iMaxNumDottedLines) then
  begin
    // starting point
    DottedSingPts.Add(Pt1);
    // ending point
    DottedSingPts.Add(Pt2);
    Exit;
  end;

  //Hatch line angle
  if Pt1.X <> Pt2.X then
    vHatchLineAng := ArcTan(vDY / vDX)
  else
    vHatchLineAng := Pi / 2;

  //Moving the base point under bottom boundary on distance less then length of the pattern
  if not((Abs(BasePt.Y - Pt1.Y) < fAccuracy) and (Abs(BasePt.Y - Pt2.Y) < fAccuracy)) then
  begin
    if Pt1.Y < Pt2.Y then
      vDist1 := Sqrt(Sqr(Pt1.X-BasePt.X) + Sqr(Pt1.Y-BasePt.Y)) {/ FScale}
    else
      vDist1 := Sqrt(Sqr(Pt2.X-BasePt.X) + Sqr(Pt2.Y-BasePt.Y)) {/ FScale};
    if (BasePt.Y > Pt1.Y) or (BasePt.Y > Pt2.Y) then
    begin
      vAmountPatterns := SGFloor(vDist1 / vPatternLength) + 1;
      if Abs(vHatchLineAng - Pi / 2) > fAccuracy then
        if Tan(vHatchLineAng) >= 0 then
        begin
          BasePt.X := BasePt.X - vPatternLength * vAmountPatterns * Cos(vHatchLineAng);
          BasePt.Y := BasePt.Y - vPatternLength * vAmountPatterns * Sin(vHatchLineAng);
        end
        else
        begin
          BasePt.X := BasePt.X + vPatternLength * vAmountPatterns * Cos(vHatchLineAng);
          BasePt.Y := BasePt.Y + vPatternLength * vAmountPatterns * Sin(vHatchLineAng);
        end
      else
        BasePt.Y := BasePt.Y - vPatternLength * vAmountPatterns;
    end
    else
    begin
      vAmountPatterns := SGFloor(vDist1 / vPatternLength);
      if Abs(vHatchLineAng - Pi / 2) > fAccuracy then
        if Tan(vHatchLineAng) >= 0 then
        begin
          BasePt.X := BasePt.X + vPatternLength * vAmountPatterns * Cos(vHatchLineAng);
          BasePt.Y := BasePt.Y + vPatternLength * vAmountPatterns * Sin(vHatchLineAng);
        end
        else
        begin
          BasePt.X := BasePt.X - vPatternLength * vAmountPatterns * Cos(vHatchLineAng);
          BasePt.Y := BasePt.Y - vPatternLength * vAmountPatterns * Sin(vHatchLineAng);
        end
      else
        BasePt.Y := BasePt.Y + vPatternLength * vAmountPatterns;
    end;
  end
  else
  begin
    if Pt1.X < Pt2.X then
      vDist1 := Sqrt(Sqr(Pt1.X-BasePt.X) + Sqr(Pt1.Y-BasePt.Y)) {/ FScale}
    else
      vDist1 := Sqrt(Sqr(Pt2.X-BasePt.X) + Sqr(Pt2.Y-BasePt.Y)) {/ FScale};
    vAmountPatterns := CheckGetAmountPatterns;
    if (BasePt.X > Pt1.X) or (BasePt.Y > Pt2.Y) then
      BasePt.X := BasePt.X - vPatternLength * (vAmountPatterns + 1)
    else
      BasePt.X := BasePt.X + vPatternLength * vAmountPatterns;
  end;

  vDist1 := Sqrt(Sqr(Pt1.X-BasePt.X) + Sqr(Pt1.Y-BasePt.Y)) {/ FScale};
  vDist2 := Sqrt(Sqr(Pt2.X-BasePt.X) + Sqr(Pt2.Y-BasePt.Y)) {/ FScale};
  if vDist1 > vDist2 then
  begin
    vDist1 := vDist2;
    vPt := Pt1;
    Pt1 := Pt2;
    Pt2 := vPt;
    vDX := Pt2.X - Pt1.X;
    vDY := Pt2.Y - Pt1.Y;
  end;

  vCur := 0.0;
  vKx := vDX / vLen;
  vKy := vDY / vLen;
  //this accuracy is connected with the accuracy of the function sgLines.CompareValues
  if not IsEqual(vPatternLength, vDist1, fExtendedResolution) then
  begin
    I := -1;
    vPartLen := 0.0;
    repeat
      Inc(I);
      I := I mod vTicksCount;
      vPartLen := vPartLen + Abs(AList[I]);
    until vPartLen >= vDist1;
    if AList[I] >= 0 then
      AddPt;
    vCur := vPartLen - vDist1;
    if vCur >= vLen then
    begin
      vCur := vLen;
      if AList[I] >= 0 then
        AddPt;
      Exit;
    end;
    if not (AList[I] * AList[(I + 1) mod vTicksCount] > 0) then
      AddPt;
    Inc(I);
    while I <= vTicksCount - 1 do
    begin
      vCur := vCur + Abs(AList[I]);
      if vCur >= vLen then
      begin
        vCur := vLen;
        if AList[I] >= 0 then
          AddPt;
        Exit;
      end;
      if not (AList[I] * AList[(I + 1) mod vTicksCount] > 0) then
        AddPt;
      Inc(I);
    end;
  end
  else
    if AList[0] >= 0 then
      AddPt;
  vIndex := 0;
  while True do
  begin
    vCur := vCur + Abs(AList[vIndex]);
    if (Abs(vCur - vLen) < FAccuracy) or (vCur > vLen) then
    begin
      vCur := vLen;
      if AList[vIndex] >= 0 then
        AddPt;
      Exit;
    end;
    if not (AList[vIndex] * AList[(vIndex + 1) mod vTicksCount] > 0) then
      AddPt
    else
      IncIndex;
  end;
end;

type
  PE2DPoint = ^TE2DPoint;
  TE2DPoint = packed record
  case Integer of
    0: (X, Y: Extended);
    1: (V: array[0 .. 1] of Extended);
  end;
  PE2DRect = ^TE2DRect;
  TE2DRect = packed record
  case Integer of
    0: (Left, Top, Right, Bottom: Extended);
    1: (TopLeft, BottomRight: TE2DPoint);
    2: (V: array[0 .. 1] of TE2DPoint);
  end;

function IsEqualE2DPoints(const Point1, Point2: TE2DPoint;
  Epsilon: Double = fExtendedResolution): Boolean;
begin
  if Epsilon = 0 then
    Epsilon := fExtendedResolution;
  Result := IsRange(Point1.X - Point2.X, Epsilon) and
    IsRange(Point1.Y - Point2.Y, Epsilon);
end;


function NormalizeVectorE2DPoint(var APoint: TE2DPoint): Extended;
begin
{$IFDEF SGDEL_7}
  Result := NormalizeVector(APoint.V);
{$ELSE}
  Result := Sqr(APoint.X) + Sqr(APoint.Y);
  if Result > 0 then
  begin
    Result := Sqrt(Result);
    if Result <> 0 then
    begin
      APoint.X := APoint.X / Result;
      APoint.Y := APoint.Y / Result;
    end;
  end;
{$ENDIF}
end;

function TsgCADHatchPatternData.ParseLines(const AParsedLines: TF2DPointList;
  const ABoundaryPolylines: TsgObjectList; const ABox: TFRect;
  const AHatchStyle: TsgHatchStyle): TsgHatchStyle;
type
  TLineWithBasePArray = array of TLineWithBaseP;
var
  vBox: TE2DRect;
  I, K, M: Integer;
  vGlobP1, vGlobP2: TE2DPoint;
  vNewBaseP : TE2DPoint;
  vCurPattern: TsgHatchPatternData;
  xPoly: TFPointList;
  wPoly, vPoly: TLineWithBasePArray;
  wPolyCount, vPolyCount: Integer;
  wTempPoly: TF2DPointList;
  U, V, vCyclesCount : Integer;
  P1, P2, vBaseP: TFPoint;
  vFlip: Boolean;
  vMemoryUses: Integer;
  vTickCountStart: Cardinal;
  vConverter: TsgDXFConverter;
  vStopLoading: Boolean;
  vPatternLength: Extended;

  procedure CheckMemorySize(ASize: Integer);
  begin
    Inc(vMemoryUses, ASize);
    if vMemoryUses > cnstLimitByHatch then
      raise EsgLimitMemoryUsesException.Create(sHatchMemoryLimit);
  end;

  function AddLineWithBaseP(var A: TLineWithBasePArray; var ACount: Integer;
    const AP1, AP2, ABP: TF2DPoint): Integer;
  var
    Capacity, NewCapacity: Integer;
  begin
    Result := ACount;
    Capacity := Length(A);
    if ACount = Capacity then
    begin
      NewCapacity := ListGrow(Capacity);
      CheckMemorySize((NewCapacity - Capacity) * SizeOf(TLineWithBaseP));
      SetLength(A, NewCapacity);
    end;
    Inc(ACount);
    A[Result].P1 := AP1;
    A[Result].P2 := AP2;
    A[Result].BP := ABP;
  end;

  function Len(const X, Y: Extended): Extended; overload;
  begin
    Result := Sqrt(Sqr(X) + Sqr(Y));
  end;

  function Len(const AP1, AP2: TFPoint): Extended; overload;
  begin
    Result := Sqrt(Sqr(AP1.X - AP2.X) + Sqr(AP1.Y - AP2.Y));
  end;

  function Len(const AP1, AP2: TE2DPoint): Extended; overload;
  begin
    Result := Sqrt(Sqr(AP1.X - AP2.X) + Sqr(AP1.Y - AP2.Y));
  end;

  function Len(const V: TE2DPoint): Extended; overload;
  begin
    Result := Sqrt(Sqr(V.X) + Sqr(V.Y));
  end;

  function GetPatternLength(ALine: TsgDoubleList): Extended;
  var
    J: Integer;
  begin
    Result := 0;
    if ALine <> nil then
      for J := 0 to ALine.Count - 1 do
        Result := Result + Abs(ALine[J]);
  end;

  function MakeF2DPoint(const APoint: TE2DPoint): TF2DPoint;
  begin
    Result.X := APoint.X;
    Result.Y := APoint.Y;
  end;

  function MakeE2DPoint(const X, Y: Extended): TE2DPoint; overload;
  begin
    Result.X := X;
    Result.Y := Y;
  end;

  function MakeE2DPoint(const APoint: TFPoint): TE2DPoint; overload;
  begin
    Result.X := APoint.X;
    Result.Y := APoint.Y;
  end;

  procedure E2DPointAdd(const P: TE2DPoint; var ASum: TE2DPoint); overload;
  begin
    ASum.X := ASum.X + P.X;
    ASum.Y := ASum.Y + P.Y;
  end;

  function AddE2DPoint(const AP1, AP2: TE2DPoint): TE2DPoint; overload;
  begin
    Result.X := AP1.X + AP2.X;
    Result.Y := AP1.Y + AP2.Y;
  end;

  function SubE2DPoint(const AP1, AP2: TE2DPoint): TE2DPoint;
  begin
    Result.X := AP1.X - AP2.X;
    Result.Y := AP1.Y - AP2.Y;
  end;

  function ScaleE2DPoint(const P: TE2DPoint; const S: Extended): TE2DPoint;
  begin
    Result.X := P.X * S;
    Result.Y := P.Y * S;
  end;

  procedure SetPoly;
  begin
    AddLineWithBaseP(vPoly, vPolyCount, MakeF2DPoint(vGlobP1), MakeF2DPoint(vGlobP2), MakeF2DPoint(vNewBaseP));
    CheckMemorySize(SizeOf(TLineWithBaseP) + SizeOf(Pointer));
  end;

  procedure GetGlobP(ABaseP: TE2DPoint; APttOffset: TE2DPoint; ADegAng: Extended; APatternLen: Extended);
  var
    vD, vNewD, vCross, CalcBaseP1, CalcBaseP2: TE2DPoint;
    vLeftStopPoint, vRightStopPoint: PE2DPoint;
    vLeftXBorder, vRightXBorder, TanAAng, B: Extended;
    vStepCount: Extended;// this is UInt64 (value returned by function Trunc)
    Sn, Cs: Extended;

    procedure SetBase(I: Integer);
    var
      D: Double;
      V: Extended;
    begin
      D := vD.V[I];
      V := (vCross.V[I] - ABaseP.V[I]) * D;
      if V <= 0 then
        D := -D;
      ABaseP.V[I] := ABaseP.V[I] + D * vStepCount;
    end;

    procedure SetCalcBase(Coef: Extended);
    begin
      Coef := Coef * APatternLen;
      CalcBaseP1.X := ABaseP.X + Cs * Coef;
      CalcBaseP1.Y := ABaseP.Y + Sn * Coef;
      CalcBaseP2.X := ABaseP.X - Cs * Coef;
      CalcBaseP2.Y := ABaseP.Y - Sn * Coef;
    end;

    function SetBorders(Cond: Boolean): Integer;
    begin
      Result := Ord(Cond) - Ord(not Cond);
      vLeftXBorder := vBox.Right;
      vRightXBorder := vBox.Left;
      vLeftStopPoint := @vGlobP1;
      vRightStopPoint := @vGlobP2;
      if Cond then
      begin
        SwapExtendeds(vLeftXBorder, vRightXBorder);
        SwapPointers(Pointer(vLeftStopPoint), Pointer(vRightStopPoint));
      end;
      vNewBaseP := ABaseP;
    end;

    procedure Ortho(IX: Integer; const AMin, AMax: TE2DPoint);
    var
      IY, N: Integer;
      vMin, vMax, vKoef: Extended;
    begin
      IY := IX xor 1;
      if Abs(vD.V[IX]) > fAccuracy then
      begin
        vNewD := MakeE2DPoint(Abs(vD.X), Abs(vD.Y));
        vMin := Min(AMin.V[IX], AMax.V[IX]);
        vMax := Max(AMin.V[IX], AMax.V[IX]);
        N := Ceil((vMax - ABaseP.V[IX]) / (vNewD.V[IX] * 2)) shl 1;
        vKoef := 1 - Integer((vD.X * vD.Y) < 0) shl 1;
        vNewBaseP.V[IX] := ABaseP.V[IX] + (N - 1 * IX) * vNewD.V[IX];
        vNewBaseP.V[IY] := ABaseP.V[IY] + (N - 1 * IX) * vNewD.V[IY] * vKoef;
        while vNewBaseP.V[IX] >= vMin do
        begin
          vGlobP1.V[IX] := vNewBaseP.V[IX];
          vGlobP1.V[IY] := AMax.V[IY];
          vGlobP2.V[IX] := vNewBaseP.V[IX];
          vGlobP2.V[IY] := AMin.V[IY];
          SetPoly;
          vNewBaseP.V[IX] := vNewBaseP.V[IX] - vNewD.V[IX];
          vNewBaseP.V[IY] := vNewBaseP.V[IY] - vNewD.V[IY] * vKoef;
        end;
      end;
    end;

    procedure Diagonal(ASign: Integer; const ABottom, ATop: Extended);
      procedure SetGlob;
      begin
        vGlobP1.Y := ABottom;
        vGlobP1.X := vNewBaseP.X + (ABottom - vNewBaseP.Y) / TanAAng;
        vGlobP2.Y := ATop;
        vGlobP2.X := vNewBaseP.X + (ATop - vNewBaseP.Y) / TanAAng;
      end;
    begin
      while True do //into right direction from base point
      begin
        SetGlob;
        if ASign * (vRightXBorder - vRightStopPoint^.X) <= 0.0 then Break;
        SetPoly;
        vNewBaseP.X := vNewBaseP.X + vD.X;
        vNewBaseP.Y := vNewBaseP.Y + vD.Y;
      end;
      vNewBaseP := ABaseP;
      vNewBaseP.X := vNewBaseP.X - vD.X;
      vNewBaseP.Y := vNewBaseP.Y - vD.Y;
      while True do //into left direction from base point
      begin
        SetGlob;
        if ASign * (vLeftStopPoint^.X - vLeftXBorder) <= 0.0 then Break;
        SetPoly;
        vNewBaseP.X := vNewBaseP.X - vD.X;
        vNewBaseP.Y := vNewBaseP.Y - vD.Y;
      end;
    end;

  var
    vIsVertical: Boolean;
    vRadAng, vOffsLen: Extended;

  begin
    if (vBox.Top = vBox.Bottom) or (vBox.Left = vBox.Right) then
      Exit;
    vIsVertical := IsEqual(ADegAng, 90.0, fAccuracy) or IsEqual(ADegAng, 270.0, fAccuracy);
    vRadAng := Radian(ADegAng);
    vD := APttOffset;
    if vIsVertical and (vD.X = 0) then
    begin
      SwapExtendeds(vD.X, vD.Y);
      //vD := MakeE2DPoint(AffineTransformPoint(MakeFPoint(vD.X, vD.Y), BuildRotMatrix(axisZ, vRadAng, fMaxResolution)));
    end;
    TanAAng := Tan(vRadAng);
    if vD.X <> 0 then
    begin
      if not(vIsVertical) then
        if Abs(vD.Y/vD.X - TanAAng) < 0.00001 then
        begin
          vOffsLen := NormalizeVectorE2DPoint(vD);
          SinCos(Radian(FAngle), Sn, Cs);
          vD.X := Cs * vOffsLen;
          vD.Y := Sn * vOffsLen;
          if IsEqualE2DPoints(APttOffset, vD) then
            raise EsgLimitMemoryUsesException.Create(sHatchMemoryLimit);
          GetGlobP(ABaseP, vD, ADegAng, APatternLen);
          Exit;
        end;
          //raise EsgDXFHatchError.Create('Hatch parameters error');
    end
    else
      if {vIsVertical or }(vD.Y = 0) then
        Exit;//raise EsgDXFHatchError.Create('Hatch parameters error');

    SinCos(vRadAng, Sn, Cs);
    //Moving base point by OFFSET
    if not(vIsVertical) then
    begin
      B := vBox.Top - TanAAng * vBox.Left;
      if vD.X = 0 then
        vCross.X := vBox.Left
      else
        vCross.X := (ABaseP.Y - ABaseP.X * vD.Y / vD.X - B) / (TanAAng - vD.Y / vD.X);
      vCross.Y := TanAAng * vCross.X + B;
    end
    else
    begin
      vCross.X := vBox.Left;
      if (vD.Y = 0) or (vD.X = 0) then
        vCross.Y := vBox.Bottom
      else
        vCross.Y := vCross.X * vD.Y / vD.X + ABaseP.Y - ABaseP.X * vD.Y / vD.X;
    end;
    vStepCount := Trunc(Len(vCross, ABaseP) / Len(vD.X, vD.Y));
    SetBase(0);
    SetBase(1);

    //Moving base point by PATTERN
    if APatternLen <> 0.0 then
    begin
      vStepCount := Trunc(Len(vBox.TopLeft, vCross) / APatternLen);
      SetCalcBase(vStepCount);
    end
    else
    begin
      APatternLen := Len(vCross,ABaseP);
      SetCalcBase(1.0);
    end;
    if Len(vBox.TopLeft, CalcBaseP1) < Len(vBox.TopLeft, CalcBaseP2) then
      ABaseP := CalcBaseP1
    else
      ABaseP := CalcBaseP2;

    //By hatch line angle
    if Abs(Cs) < 0.001 then // vertical
    begin
      if Result = hsHorizontal then
        Result := hsCross
      else
        Result := hsVertical;
      Ortho(0, vBox.TopLeft, vBox.BottomRight);
    end
    else
      if Abs(Sn) < 0.001 then // horisontal
      begin
        if Result = hsVertical then
          Result := hsCross
        else
          Result := hsHorizontal;
        Ortho(1, vBox.BottomRight, vBox.TopLeft);
      end
      else
        if ((Cs > 0) and (Sn > 0)) or ((Cs < 0) and (Sn < 0)) then //1, 3 quadrants
        begin
          if Result = hsBDiagonal then
            Result := hsDiagCross
          else
            Result := hsFDiagonal;
          Diagonal(SetBorders(vD.Y < vd.X * TanAAng), vBox.Bottom, vBox.Top);
        end
        else //2, 4 quadrants
        begin
          if Result = hsFDiagonal then
            Result := hsDiagCross
          else
            Result := hsBDiagonal;
          Diagonal(SetBorders(vD.Y > vd.X * TanAAng), vBox.Top, vBox.Bottom);
        end;
  end;

  function CheckTime(const AStartTime: Cardinal): Boolean;
  var
    vCurInterval: Cardinal;
  begin
    Result := False;
    if Assigned(vConverter) then
      vConverter.UpdateProgressLoaded(1);
  {$IFNDEF SG_FIREMONKEY}
    vCurInterval := GetTickCount - AStartTime;
  {$ELSE}
    vCurInterval := TThread.GetTickCount - AStartTime;
  {$ENDIF}
    if vCurInterval > cnstLimitTimeByHatch then
      raise EsgLimitTimeUsesException.Create(sHatchTimeLimit);
    if Assigned(vConverter) and vConverter.LoadStopped then
    begin
      Result := True;
    end;
  end;

begin
  Result := AHatchStyle;
  vConverter := Converter;
  if Assigned(vConverter) then
    vConverter.UpdateProgressLoaded(0);
  try
  AParsedLines.Clear(False);
  vMemoryUses := 0;
{$IFNDEF SG_FIREMONKEY}
  vTickCountStart := GetTickCount;
{$ELSE}
  vTickCountStart := TThread.GetTickCount;
{$ENDIF}
  wPolyCount := 0;
  vPolyCount := 0;
  xPoly := TFPointList.Create;
  wTempPoly := TF2DPointList.Create;
  try
    vBox.Left := ABox.Left;
    vBox.Top := ABox.Top;
    vBox.Right := ABox.Right;
    vBox.Bottom := ABox.Bottom;
    vStopLoading := False;
    for K := 0 to FPatterns.Count - 1 do
    begin
      vFlip := False;
      vCurPattern := PsgHatchPatternData(FPatterns.Items[K])^;
      try
        wPolyCount := 0;
        vPatternLength := GetPatternLength(vCurPattern.Lines);
        GetGlobP(MakeE2DPoint(vCurPattern.BaseP), MakeE2DPoint(vCurPattern.Offset),
          vCurPattern.LineAngle, vPatternLength);
        try
          for U := 0 to vPolyCount - 1 do
          begin
            ParseLinesHatch(ABoundaryPolylines, @vPoly[U], wTempPoly);
            vStopLoading := CheckTime(vTickCountStart);
            if vStopLoading then
              Break;
            V := 0;
            while V <= wTempPoly.Count - 2 do
            begin
              AddLineWithBaseP(wPoly, wPolyCount, wTempPoly[V], wTempPoly[V+1],
                vPoly[U].BP);
              Inc(V, 2);
            end;
            wTempPoly.Clear;
          end;
        finally
          vPolyCount := 0;
        end;
        if vStopLoading then
          Break;
        if vCurPattern.IsDash then
        begin
          if wPolyCount = 0 then
            Continue;
          vCyclesCount := SGFloor(vCurPattern.LineAngle / 360);
          vFlip := vCurPattern.LineAngle - vCyclesCount*360 >= 180;
          if vFlip then //Rotate the pattern
            vCurPattern.Lines.Flip;

          P1.Z := 0;
          P2.Z := 0;
          vBaseP.Z := 0;
          for M := 0 to wPolyCount - 1 do
          begin
            xPoly.Clear(False);
            P1.Point2D := wPoly[M].P1;
            P2.Point2D := wPoly[M].P2;
            vBaseP.Point2D := wPoly[M].BP;
            if not (vCurPattern.Lines.Count <= 1) then
            begin
              HatchLine(vCurPattern.Lines, P1, P2, vBaseP, xPoly);
              CheckTime(vTickCountStart);
              CheckMemorySize(SizeOf(TFPoint) * xPoly.Count);
              for I := 0 to xPoly.Count - 1 do
                AParsedLines.Add(xPoly[I].Point2D);
            end
            else
            begin
              AParsedLines.Add(P1.Point2D);
              AParsedLines.Add(P2.Point2D);
            end;
          end;
        end
        else
        begin
          for M := 0 to wPolyCount - 1 do
          begin
            AParsedLines.Add(wPoly[M].P1);
            AParsedLines.Add(wPoly[M].P2);
          end;
        end;
      finally
        if AParsedLines.Count > cnstLimitByHatch div SizeOf(TF2DPoint) then
          raise EsgLimitMemoryUsesException.Create(sHatchMemoryLimit);
        if vFlip then
          vCurPattern.Lines.Flip;
      end;
    end;
  finally
    Finalize(vPoly);
    Finalize(wPoly);
    xPoly.Free;
    wTempPoly.Free;
  end;
  finally
    if Assigned(vConverter) then
      vConverter.UpdateProgressLoaded(2);
  end;
end;

procedure TsgCADHatchPatternData.SetConverter(const AConverter: TsgDXFConverter);
begin
  inherited SetConverter(AConverter);
  FConverter := AConverter;
end;

procedure TsgCADHatchPatternData.DoAngle(const AValue: Double);
var
  vAngle, vValue: Double;
begin
  if sgModAngle(AValue, vValue) then
  begin
    vAngle := (vValue - FAngle);
    ApplyAngle(vAngle);
    FAngle := vValue;
  end;
end;

procedure TsgCADHatchPatternData.DoScale(const AValue: Double);
var
  vScale: Double;
begin
  if FScale > fAccuracy then
    vScale := AValue / FScale
  else
    vScale := AValue;
  ApplyScale(vScale);
  FScale := AValue;
end;

function TsgCADHatchPatternData.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vPattern: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlName].Name).ValueAsStr := FName;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlAngle].Name).ValueData,
    FAngle, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlScale].Name).ValueData,
    FScale, xmlForViewing in AParams.Mode);
  if IsXMLHelp(AParams.Mode) then
    ANode.AddChildNV(cnstXMLNames[xmlPattern].Name)
  else
    for I := 0 to FPatterns.Count - 1 do
    begin
      vPattern := ANode.AddChildNV(cnstXMLNames[xmlPattern].Name);
      HatchPatternDataToXMLNode(FPatterns.List[I], vPattern);
    end;
end;

function TsgCADHatchPatternData.HatchPatternDataFromToXMLNode(
  const AData: PsgHatchPatternData; const ANode: TsgNodeSample;
  const AResult: IsgResultNode = nil): Integer;
var
  I: Integer;
  vAttrib, vLines, vLinesCount, vDash: TsgNodeSample;
  vId: TsgXMLId;
begin
  Result := cnstXML_OK;
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vAttrib := ANode.AttributeNodes[I];
    vId := GetXMLId(vAttrib.Name);
    case vId of
      xmlLineAngle: AData.LineAngle := vAttrib.ValueAsDouble;
      xmlBasePoint: AData.BaseP := vAttrib.ValueAsFPoint;
      xmlOffset:    AData.Offset := vAttrib.ValueAsFPoint;
      xmlIsSolid:   AData.IsDash := vAttrib.ValueAsBool;
      xmlCount:     AData.DashNum := vAttrib.ValueAsInt;
    end;
  end;
  vLines := ANode.GetChildByName(cnstXMLNames[xmlLines].Name);
  if Assigned(vLines) then
  begin
    AData.Lines := TsgDoubleList.Create;
    vLinesCount := ANode.GetAttributeByName(cnstXMLNames[xmlCount].Name);
    if Assigned(vLinesCount) then
      AData.Lines.Capacity := vLinesCount.ValueAsInt;
    for I := 0 to vLines.ChildNodesCount - 1 do
    begin
      vDash := vLines.ChildNodes[I];
      if (vDash.AttributeNodesCount > 0) and SameText(vDash.Name, cnstXMLNames[xmlDash].Name) then
        AData.Lines.Add(vDash.AttributeNodes[0].ValueAsDouble);
    end;
  end;
end;

function TsgCADHatchPatternData.HatchPatternDataToXMLNode(
  const AData: PsgHatchPatternData; const ANode: TsgNode): Integer;
var
  I: Integer;
  vNode: TsgNode;
begin
  Result := cnstXML_OK;
  ANode.AddAttribNV(cnstXMLNames[xmlLineAngle].Name).ValueAsDouble := AData.LineAngle;
  ANode.AddAttribNV(cnstXMLNames[xmlBasePoint].Name).ValueAsFPoint := AData.BaseP;
  ANode.AddAttribNV(cnstXMLNames[xmlOffset].Name).ValueAsFPoint := AData.Offset;
  ANode.AddAttribNV(cnstXMLNames[xmlIsSolid].Name).ValueAsBool := AData.IsDash;
  ANode.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := AData.DashNum;
  if Assigned(AData.Lines) and (AData.Lines.Count > 0) then
  begin
    vNode := ANode.AddChildNV(cnstXMLNames[xmlLines].Name);
    vNode.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := AData.Lines.Count;
    for I := 0 to AData.Lines.Count - 1 do
      vNode.AddChildNV(cnstXMLNames[xmlDash].Name).AddAttribNV(cnstXMLValue).ValueAsDouble := AData.Lines[I];
  end;
end;

{ TsgDXFSectionEntities }

constructor TsgDXFSectionEntities.CreateByConverter(
  const AConverter: TsgDXFConverter);
begin
  inherited CreateByConverter(AConverter);
  Name := cnstXMLNames[xmlEntities].Name;
end;

function TsgDXFSectionEntities.FromXML(const ANode: TsgNodeSample;
  const AResult: IsgResultNode = nil): Integer;
begin
  // No call inherited
  if (Converter <> nil) and (ANode.ChildNodesCount = 1) then
    Result := GetEntities.FromXML(ANode.ChildNodes[0], AResult)
  else
    Result := cnstXML_ERROR;
end;

function TsgDXFSectionEntities.GetEntities: TsgDXFEntity;
begin
  Result := Converter.Sections[csEntities];
end;

function TsgDXFSectionEntities.ToXMLWithParams(const AParentNode: TsgNode;
  const AParams: TsgXMLParams): TsgNode;
begin
  Result := inherited ToXMLWithParams(AParentNode, AParams);
  if Converter <> nil then
    GetEntities.ToXMLWithParams(Result, AParams);
end;

{ TsgMapEntities }

procedure TsgMapEntities.ActivateRegister;
var
  I: Integer;
  vSection: TsgDXFGroup;

  procedure AddEntities(const AEntity: TsgDXFEntity);
  var
    J: Integer;
  begin
    if UseEntity(AEntity) then
      FEntities.Add(AEntity);
    if FEntities.Capacity < (FEntities.Count + AEntity.Count) then
       FEntities.Capacity := FEntities.Capacity + AEntity.Count;
    for J := 0 to AEntity.Count - 1 do
      AddEntities(AEntity[J]);
  end;

begin
  if not FEntities.Sorted then
  begin
    FEntities.Count := 0;
    FEntities.Duplicates := dupAccept;
    for I := Low(cnstSectionsByFindObject) to High(cnstSectionsByFindObject) do
    begin
      vSection := FConverter.Sections[cnstSectionsByFindObject[I]];
      if not Assigned(vSection) then
        Continue;
      AddEntities(vSection);
    end;
    FEntities.Sorted := True;
    FEntities.Duplicates := dupIgnore;
  end;
end;


procedure TsgMapEntities.AddEntitiesToGeneratedList(const AEntities: TsgDXFEntity);
var
  I: Integer;
  vChildEntity: TsgDXFEntity;
begin
  FEntitiesWithGeneratedHandles.Sorted := False;
  try
    for I := 0 to AEntities.Count - 1 do
    begin
      vChildEntity := AEntities.Entities[I];
      if vChildEntity.CanHaveHandle then
      begin
        vChildEntity.SetConverter(FConverter);
        FEntitiesWithGeneratedHandles.Add(vChildEntity);
      end;
    end;
  finally
    FEntitiesWithGeneratedHandles.Sorted := True;
  end;
end;

procedure TsgMapEntities.AddEntityToGeneratedList(const AEntity: TsgDXFEntity);
begin
  FEntitiesWithGeneratedHandles.Add(AEntity);
end;

constructor TsgMapEntities.Create(const AConverter: TsgDXFConverter);
begin
  inherited Create;
  FConverter := AConverter;
  FEntities := TsgList.Create;
  FEntities.Capacity := cnstGeneratedHandlesCapacity;
  FEntities.ProcCompare := FConverter.CompareEntities;
  FEntities.Duplicates := dupAccept;
  FEntities.Sorted := False;
  FFindEntity := TsgDXFObjectEntity.Create;
end;

procedure TsgMapEntities.CreateGeneratedList;
begin
  if not Assigned(FEntitiesWithGeneratedHandles) then
  begin
    FEntitiesWithGeneratedHandles := TsgList.Create;
    FEntitiesWithGeneratedHandles.Sorted := True;
    FEntitiesWithGeneratedHandles.Duplicates := dupIgnore;
    FEntitiesWithGeneratedHandles.Capacity := cnstGeneratedHandlesCapacity;
  end;
end;

destructor TsgMapEntities.Destroy;
begin
  FreeAndNil(FEntitiesWithGeneratedHandles);
  FreeAndNil(FFindEntity);
  FreeAndNil(FEntities);
  inherited Destroy;
end;

function TsgMapEntities.GetEntityByHandle(const AHandle: UInt64): TsgDXFEntity;
var
  I, vIndex: Integer;
  vEntity: TsgDXFEntity;
  vSection: TsgDXFGroup;
begin
  Result := nil;
  if AHandle <> cnstBadHandle then
  begin
    if FEntities.Sorted then
    begin
      FFindEntity.FLinkID.Handle := AHandle;
      vIndex := FEntities.IndexOf(FFindEntity);
      if vIndex > -1 then
        Result := FEntities[vIndex];
    end;
    if Result = nil then
    begin
      for I := Low(cnstSectionsByFindObject) to High(cnstSectionsByFindObject) do
      begin
        vSection := FConverter.Sections[cnstSectionsByFindObject[I]];
        if not Assigned(vSection) then
          Continue;
        vEntity := vSection.FindEntByHandle(AHandle, -Ord(cnstSectionsByFindObject[I] <> csLayouts));
        if Assigned(vEntity) then
        begin
          Result := vEntity;
          Break;
        end;
      end;
    end;
  end;
end;

function TsgMapEntities.HasGeneratedList: Boolean;
begin
  Result := Assigned(FEntitiesWithGeneratedHandles);
end;

procedure TsgMapEntities.RegEntity(const AEntity: TsgDXFEntity);
var
  vIndex: Integer;
begin
  if UseEntity(AEntity) then
  begin
    if FEntities.Sorted then
    begin
      vIndex := FEntities.IndexOf(AEntity);
      if vIndex > -1 then
      begin
        if FEntities[vIndex] <> AEntity then
          raise Exception.Create('RegisterEntity: $' + IntToHex(AEntity.Handle, 0));
      end
      else
        FEntities.Add(AEntity);
    end
    else
      FEntities.Add(AEntity);
  end;
end;

procedure TsgMapEntities.UnActivateRegister;
begin
  FEntities.Sorted := False;
end;

procedure TsgMapEntities.UnRegEntity(const AEntity: TsgDXFEntity);
var
  vIndex: Integer;
begin
  if UseEntity(AEntity) and FEntities.Sorted then
  begin
    vIndex := FEntities.IndexOf(AEntity);
    if vIndex > -1 then
    begin
      if FEntities[vIndex] = AEntity then
        FEntities.Delete(vIndex)
      else
        raise Exception.Create('UnRegisterEntity: $' + IntToHex(AEntity.Handle, 0));
    end
    else
      UnActivateRegister;
  end;
end;

function TsgMapEntities.UseEntity(const AEntity: TsgDXFEntity): Boolean;
begin
  Result := AEntity.CanHaveHandle and (AEntity.Handle <> cnstBadHandle);
end;

function TsgMapEntities.RemoveEntityFromGeneratedList(const AEntity: TsgDXFEntity): Boolean;
var
  vIndex: Integer;
begin
  Result := False;
  vIndex := FEntitiesWithGeneratedHandles.Remove(AEntity);
  if vIndex > -1 then
    Result := True;
end;

procedure TsgMapEntities.ApplyAndFreeGeneratedList;
var
  J: Integer;
  vEntity: TsgDXFEntity;
begin
  if Assigned(FEntitiesWithGeneratedHandles) then
  begin
    try
      for J := 0 to FEntitiesWithGeneratedHandles.Count - 1 do
      begin
        vEntity := TsgDXFEntity(FEntitiesWithGeneratedHandles[J]);
        if vEntity.Handle = cnstBadHandle then
        begin
          Inc(FConverter.FMaxHandle);
          vEntity.Handle := FConverter.FMaxHandle;
        end;
      end;
    finally
      FreeAndNil(FEntitiesWithGeneratedHandles);
    end;
  end;
end;

{ TListNotifyClearWrapper }

procedure TListNotifyClearWrapper.Clear;
begin
  FList.Clear;
end;

procedure TListNotifyClearWrapper.ClearListNotify(const Obj: TObject; Action: TListNotification);
var
  Ent: TsgDXFEntity absolute Obj;
  Item: TsgOwneredItem;
begin
  DoNotify(Obj, Action);
  case Action of
    lnDeleted, lnExtracted:
      begin
        Item := TsgOwneredItem(Ent.GetNamedItem);
        if Assigned(Item) then
        begin
          if Item.RefCount = 0 then
            Ent.Free;
        end
        else
          Ent.Free;
      end;
  end;
end;

constructor TListNotifyClearWrapper.Create(const AList: TsgObjectList;
  const ADoFree: Boolean);
begin
  FList := AList;
  FDoFree := ADoFree;
  if FDoFree then
  begin
    FNotify := AList.OnNotify;
    AList.OnNotify := ClearListNotify;
  end;
end;

destructor TListNotifyClearWrapper.Destroy;
begin
  if FDoFree then
    FList.OnNotify := FNotify;
  inherited Destroy;
end;

procedure TListNotifyClearWrapper.DoNotify(const Obj: TObject; Action: TListNotification);
begin
  if Assigned(FNotify) then
    FNotify(Obj, Action);
end;

{ TListNotifyClearWrapperGroup }

procedure TListNotifyClearWrapperGroup.ClearListNotify(const Obj: TObject; Action: TListNotification);
var
  Ent: TsgDXFEntity absolute Obj;
  Item: TsgOwneredItem;
begin
  DoNotify(Obj, Action);
  case Action of
    lnExtracted, lnDeleted:
      begin
        Item := TsgOwneredItem(Ent.GetNamedItem);
        if Assigned(Item) and (Item.RefCount = 0) then
          Ent.Free;
      end;
  end;
end;

{ TsgTableItem }

{$IFDEF SG_CALC_INSTANCE_SIZES}
procedure TsgTableItem.FreeInstance;
begin
  Dec(TsgDXFEntity.TotalAllocated, InstanceSize);
  inherited FreeInstance;
end;

class function TsgTableItem.NewInstance: TObject;
begin
  Result := inherited NewInstance;
  Inc(TsgDXFEntity.TotalAllocated, InstanceSize);
end;
{$ENDIF}

function TsgTableItem.GetItem: TsgDXFEntity;
begin
  if Assigned(FItem) then
    Result := FItem.Ancestor
  else
    Result := nil;
end;

procedure TsgTableItem.SetItem(const Value: TsgDXFEntity);
begin
  if Assigned(Value) then
    SetItemObj(TsgOwneredItem(Value.GetNamedItem))
  else
    SetItemObj(nil);
end;

procedure TsgTableItem.SetItemObj(const Value: TsgOwneredItem);
begin
  if FItem <> Value then
  begin
    if Assigned(FItem) and (FItem.ObjRelease = 0) and (FItem.Owner = nil) then
      FItem.Ancestor.Free;
    FItem := Value;
    if Assigned(FItem) then
      FItem.ObjAddRef;
  end;
end;

{ TsgStyleItem }

procedure TsgStyleItem.SetItemObj(const Value: TsgOwneredItem);
begin
  if FItem <> Value then
  begin
    if Assigned(FItem) and (FItem.ObjRelease = 0) and (FItem.Owner = nil) then
      FItem.Ancestor.Free;
    FItem := Value;
    if Assigned(FNotifyChange) then
      FNotifyChange(Self);
    if Assigned(FItem) then
      FItem.ObjAddRef;
  end;
end;

{ TsgOwnwredItem }

function TsgOwneredItem.AddItem(const AItem: TObject): Integer;
begin
  Result := -1;
end;

constructor TsgOwneredItem.Create(AAncestor: TsgDXFEntity);
begin
  inherited Create;
end;

{$IFDEF SG_CALC_INSTANCE_SIZES}
procedure TsgOwneredItem.FreeInstance;
begin
  Dec(TsgDXFEntity.TotalAllocated, InstanceSize);
  inherited FreeInstance;
end;

class function TsgOwneredItem.NewInstance: TObject;
begin
  Result := inherited NewInstance;
  Inc(TsgDXFEntity.TotalAllocated, InstanceSize);
end;
{$ENDIF}

function TsgOwneredItem.RemoveItem(const AItem: TObject): Integer;
begin
  Result := -1;
end;

function TsgOwneredItem.GetAncestor: TsgDXFEntity;
begin
  Result := nil;
end;

function TsgOwneredItem.GetDescription: string;
begin
  Result := '';
end;

function TsgOwneredItem.GetName: string;
begin
  Result := '';
end;

function TsgOwneredItem.ObjAddRef: Integer;
begin
{$IFDEF AUTOREFCOUNT}
  if Assigned(Ancestor) then
    Result := TObject(Ancestor).__ObjAddRef
  else
    Result := -1;
{$ELSE}
  Inc(FRefCount);
  Result := FRefCount;
{$ENDIF}
end;

function TsgOwneredItem.ObjRelease: Integer;
begin
{$IFDEF AUTOREFCOUNT}
  if Assigned(Ancestor) then
    Result := TObject(Ancestor).__ObjRelease
  else
    Result := -1;
{$ELSE}
  Dec(FRefCount);
  Result := FRefCount;
{$ENDIF}
end;

procedure TsgOwneredItem.SetDescription(const AValue: string);
begin
end;

procedure TsgOwneredItem.SetHandle(const AValue: UInt64);
begin
  if FHandle <> AValue then
  begin
    if Assigned(FOwner) then TsgOwneredItem(FOwner).RemoveItem(Self);
    FHandle := AValue;
    if Assigned(FOwner) then TsgOwneredItem(FOwner).AddItem(Self);
  end;
end;

procedure TsgOwneredItem.SetName(const AName: string);
begin
end;

procedure TsgOwneredItem.SetOwner(const AOwner: TObject);
begin
  if FOwner <> AOwner then
  begin
    if FOwner = nil then
      ObjAddRef;
    FOwner := AOwner;
    if FOwner = nil then
      ObjRelease;
  end;
end;

{$IFDEF AUTOREFCOUNT}
function TsgOwneredItem._GetObjectRefCount: Integer;
begin
  if Ancestor = nil then
    Result := -1
  else
    Result := Ancestor.RefCount;
end;
{$ENDIF}

{ TsgNamedItem }

constructor TsgNamedItem.Create(AAncestor: TsgDXFEntity);
begin
  inherited Create(AAncestor);
  FAncestor := AAncestor;
end;

function TsgNamedItem.GetAncestor: TsgDXFEntity;
begin
  Result := FAncestor;
end;

function TsgNamedItem.GetName: string;
begin
  Result := FName;
end;

procedure TsgNamedItem.SetName(const AName: string);
var
  vNewName: string;
  vAllowChange: Boolean;
begin
  if FName <> AName then
  begin
    if Assigned(FOwner) then TsgOwneredItem(FOwner).RemoveItem(Self);
    vNewName := AName;
    vAllowChange := True;
    if Assigned(FAncestor) then
      FAncestor.NameChanging(vNewName, vAllowChange);
    if vAllowChange then
      FName := vNewName;
    if Assigned(FOwner) then TsgOwneredItem(FOwner).AddItem(Self);
  end;
end;

{ TsgDescriptedNamedItem }

function TsgDescriptedNamedItem.GetDescription: string;
begin
  Result := FDescription;
end;

procedure TsgDescriptedNamedItem.SetDescription(const AValue: string);
begin
  if FDescription <> AValue then
  begin
    if Assigned(FOwner) then TsgOwneredItem(FOwner).RemoveItem(Self);
    FDescription := AValue;
    if Assigned(FOwner) then TsgOwneredItem(FOwner).AddItem(Self);
  end;
end;

{ TsgSortedItem }

function TsgSortedItem.AddItem(const AItem: TObject): Integer;
begin
  Result := -1;
  if Assigned(AItem) then
  begin
    if (TsgOwneredItem(AItem).Name <> '') and (FSortList.SortType = mstName) and FSortList.Sorted then
      Result := FSortList.Add(AItem)
    else
    begin
      FSortList.SortType := mstInstance;
      FSortList.Sorted := False;
      Result := FSortList.Add(AItem);
    end;
  end;
end;

constructor TsgSortedItem.Create(AAncestor: TsgDXFEntity);
begin
  inherited Create(AAncestor);
  FSortList := TsgMultiSortItemsList.Create;
  FSortList.Duplicates := dupAccept;//dupIgnore;
  FSortList.Sorted := True;
end;

function TsgSortedItem.RemoveItem(const AItem: TObject): Integer;
var
  I: Integer;
begin
  Result := -1;
  if Assigned(AItem) then
    if FSortList.SortType <> mstInstance then
    begin
      Result := -1;
      I := FSortList.Count - 1;
      while I >= 0 do
      begin
        if FSortList[I] = AItem then
        begin
          FSortList.Delete(I);
          Result := I;
        end;
        Dec(I);
      end;
    end
    else
      Result := FSortList.Remove(AItem);
end;

destructor TsgSortedItem.Destroy;
begin
  FreeAndNil(FSortList);
  inherited Destroy;
end;


{ TsgBlockrecordsItem }

function TsgBlockrecordsItem.AddItem(const AItem: TObject): Integer;
begin
  Result := inherited AddItem(AItem);
  if Assigned(FBlocks) then
    FBlocks.AddItem(TsgDXFBlockRecord(TsgOwneredItem(AItem).Ancestor).Block.GetNamedItem);
end;

function TsgBlockrecordsItem.RemoveItem(const AItem: TObject): Integer;
begin
  Result := inherited RemoveItem(AItem);
  if Assigned(FBlocks) then
    FBlocks.RemoveItem(TsgDXFBlockRecord(TsgOwneredItem(AItem).Ancestor).Block.GetNamedItem);
end;

{ TsgBlockItem }

function TsgBlockItem.GetAncestor: TsgDXFEntity;
begin
  Result := TsgDXFBlockRecord(FBlockRecordLinkID.Ancestor).Block;
end;

function TsgBlockItem.GetDescription: string;
begin
  Result := FBlockRecordLinkID.Description;
end;

function TsgBlockItem.GetName: string;
begin
  Result := FBlockRecordLinkID.Name;
end;

procedure TsgBlockItem.SetDescription(const AValue: string);
begin
  FBlockRecordLinkID.Description := AValue;
end;

procedure TsgBlockItem.SetName(const AName: string);
begin
  FBlockRecordLinkID.Name := AName;
end;

{ TsgDWGPolyline }

constructor TsgDWGPolyline.Create;
begin
  inherited Create;
end;

{ TsgDXFConverterExtented }

constructor TsgConverterExtented.Create(const AOwner: TsgDXFConverter);
begin
  inherited Create;
  FOwner := AOwner;
  FHandleArray := TsgInt64List.Create;
  FHandleArray.Count := cnstMaxSaveHandleXML;
  FSelectedHandles := TsgObjectHandleList.Create;
  if not Assigned(FOwner) then
    raise Exception.Create('Does not have owner!');
end;

destructor TsgConverterExtented.Destroy;
begin
  FOwner := nil;
  FHandleArray.Free;
  FreeAndNil(FSelectedHandles);
  inherited Destroy;
end;

function TsgConverterExtented.GetIndexHandle(const AValue: string): Integer;
var
  vPos: Integer;
  vValue: string;
begin
  Result := -1;
  vValue := AValue;
  vPos := AnsiPos(cnstSignHandle, vValue);
  if vPos > 0 then
  begin
     vValue := Copy(vValue, vPos+1, Length(vValue)-vPos);
     Result := StrToInt(vValue);
  end;
  if Result >= cnstMaxSaveHandleXML then
    Result := cnstMaxSaveHandleXMLError;
end;

function TsgConverterExtented.GetSaveHandlesToNode(const ANode: TsgNode): Integer;
var
  I: Integer;
  vHandle: UInt64;
  vObj: TsgDXFEntity;
  vItem: TsgNode;
begin
  Result := FHandleArray.Count;
  for I := 0 to FHandleArray.Count - 1 do
  begin
    vHandle := FHandleArray[I];
    if vHandle <> cnstBadHandle then
    begin
      vItem := nil;
      if Assigned(FOwner) then
      begin
        vObj := FOwner.FindObjByHandle(vHandle);
        if Assigned(vObj) then
          vItem := ANode.AddChildNV(vObj.GetXMLName);
      end;
      if not Assigned(vItem) then
        vItem := ANode.AddChildNV(cnstXmlItem);
      vItem.AddAttribNV(cnstXMLNames[xmlHandleSave].Name).ValueAsStr := cnstAt + IntToStr(I);
      vItem.AddAttribNV(cnstXMLNames[xmlHandle].Name).ValueAsHandle := vHandle;
    end;
  end;
end;

function TsgConverterExtented.RestoreHandle(
  const AExtendHandle: string): Int64;
var
  vIndex: Integer;
begin
  Result := cnstBadHandle;
  vIndex := GetIndexHandle(AExtendHandle);
  if (vIndex >=0) and (vIndex < cnstMaxSaveHandleXML) then
  begin
    Result := FHandleArray[vIndex];
  end
  else
    if vIndex < 0 then
      Result := StrToInt64(AExtendHandle);
end;

procedure TsgConverterExtented.SaveHandle(const AValue: string;
  const AEntity: TsgDXFEntity);
var
  vIndex: Integer;
begin
  vIndex := GetIndexHandle(AValue);
  if (vIndex >= 0) and (vIndex < cnstMaxSaveHandleXML) then
  begin
    FOwner.SetHandle(AEntity);
    FHandleArray[vIndex] := AEntity.Handle;
  end;
end;

{ TCustomAlignedDataReader }

function TCustomAlignedDataReader.PositionAsInt64: TsgInt64;
begin
  InitInt64(FPos, Result);
end;

constructor TCustomAlignedDataReader.Create(APos: Pointer; AVersion: TsgDWGVersion);
begin
  inherited Create;
  FVersion := AVersion;
  FPos := APos;
  FStack := APos;
end;

function TCustomAlignedDataReader.GetVersion: Integer;
begin
  Result := Ord(FVersion);
end;

procedure TCustomAlignedDataReader.PopPosition;
begin
  FPos := FStack;
end;

function TCustomAlignedDataReader.Position: Pointer;
begin
  Result := FPos;
end;

procedure TCustomAlignedDataReader.PushPosition;
begin
  FStack := FPos;
end;

function TCustomAlignedDataReader.ReadByte: Byte;
begin
  Result := PByte(FPos)^;
  Inc(PByte(FPos), SizeOf(Result));
end;

function TCustomAlignedDataReader.ReadDouble: Double;
begin
  Result := PDouble(FPos)^;
  Inc(PByte(FPos), SizeOf(Result));
end;

function TCustomAlignedDataReader.ReadInteger: Integer;
begin
  Result := PInteger(FPos)^;
  Inc(PByte(FPos), SizeOf(Result));
end;

procedure TCustomAlignedDataReader.ReadRaw(const ALen: Integer;
  var AStr: sgRawByteString);
begin
  if ALen > 0 then
  begin
    SetLength(AStr, ALen);
    ReadBytes(AStr[1], ALen);
  end
  else
    AStr := '';
end;

function TCustomAlignedDataReader.ReadSmallInt: SmallInt;
begin
  Result := PSmallInt(FPos)^;
  Inc(PByte(FPos), SizeOf(Result));
end;

procedure TCustomAlignedDataReader.Seek(ASize: Integer);
begin
  Inc(PByte(FPos), ASize);
end;

procedure TCustomAlignedDataReader.UpdatePosition(ANewPos: Pointer);
begin
  FPos := ANewPos;
end;

procedure TCustomAlignedDataReader.ReadBytes(var Dest; const ACount: UInt64);
begin
  Move(FPos^, Dest, ACount);
  Inc(PByte(FPos), ACount);
end;

function TCustomAlignedDataReader.ReadHandle: UInt64;
begin
  Result := PUInt64(FPos)^;
  Inc(PByte(FPos), SizeOf(Result));
end;

function TCustomAlignedDataReader.ReadAnsiPadding: AnsiString;
var
  Len: LongInt;
  Buffer: array[0 .. 4] of AnsiChar;
begin
  Result := '';
  Buffer[4] := #0;
  repeat
    ReadBytes(Buffer[0], 4);
    Len := 0; while Buffer[Len] <> #0 do Inc(Len);
    if Len <> 0 then
    begin
      SetLength(Result, Length(Result) + Len);
      Move(Buffer[0], PAnsiChar(Result)[Length(Result) - Len], Len * SizeOf(AnsiChar));
    end;
  until Len < 4;
end;

function TCustomAlignedDataReader.ReadString: string;
var
  vLen: Integer;
  vWide: WideString;

  function DoRead: string;
  var
    vCodePage: Cardinal;
    vAnsi: sgRawByteString;
  begin
    vCodePage := sgCodePageFromDWG(ReadByte);
{$IFDEF SG_HAS_CPSTRING}
    SetCodePage(vAnsi, $FFFF, False);
{$ENDIF}
    ReadRaw(vLen, vAnsi);
{$IFDEF SG_HAS_CPSTRING}
    SetCodePage(vAnsi, vCodePage, False);
    Result := string(vAnsi);
{$ELSE}
    Result := ConvertToWideString(vAnsi, vCodePage);
{$ENDIF}
  end;

begin
  vLen := ReadSmallInt;
  if Version >= acR2007 then
  begin
    ReadWideRaw(vLen, vWide);
    Result := string(vWide);
  end
  else
  begin
{$IFDEF SG_HAS_CPSTRING}
    Result := DoRead;
{$ELSE}
    Seek(1);
    ReadRaw(vLen, Result);
{$ENDIF}
  end;
end;

function TCustomAlignedDataReader.ReadWidePadding: WideString;
var
  Len: LongInt;
  Buffer: array[0 .. 2] of WideChar;
begin
  Result := '';
  Buffer[2] := #0;
  repeat
    ReadBytes(Buffer[0], 4);
    Len := 0; while Buffer[Len] <> #0 do Inc(Len);
    if Len <> 0 then
    begin
      SetLength(Result, Length(Result) + Len);
      Move(Buffer[0], PWideChar(Result)[Length(Result) - Len], Len * SizeOf(WideChar));
    end;
  until Len < 2;
end;

procedure TCustomAlignedDataReader.ReadWideRaw(const ALen: Integer;
  var AStr: WideString);
begin
  if ALen > 0 then
  begin
    SetLength(AStr, ALen);
    ReadBytes(AStr[1], ALen shl 1);
  end
  else
    AStr := '';
end;

function TCustomAlignedDataReader.ReadWord: Word;
begin
  Result := PWord(FPos)^;
  Inc(PByte(FPos), SizeOf(Result));
end;

{ TsgDXFXRecord }

constructor TsgDXFXRecord.Create;
begin
  inherited Create;
  FData := TsgCADExtendedData.Create(TsgDWGVersion(cnstDefHeadVarStruct.Version));
end;

procedure TsgDXFXRecord.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFXRecord then
    Data := TsgDXFXRecord(Source).Data;
end;

procedure TsgDXFXRecord.ClearReferences;
begin
  inherited ClearReferences;
  TsgCADExtendedDataAccess(FData).ClearData;
end;

procedure TsgDXFXRecord.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FData);
end;

function TsgDXFXRecord.GetExtData(const AData: TsgCADExtendedData; const AAppID: string): Boolean;
begin
  Result := False;
end;

procedure TsgDXFXRecord.SetExtData(const AData: TsgCADExtendedData);
begin
  FData.AssignData(AData);
end;

function TsgDXFXRecord.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  Converter.CADExtendedDataToXMLNode(cnstBadHandle, FData, ANode);
end;

{ TsgDXFCustomColor }

procedure TsgDXFCustomColor.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFCustomColor then
    ColorCAD := TsgDXFCustomColor(Source).ColorCAD;
end;

function TsgDXFCustomColor.GetColorCAD: TsgColorCAD;
begin
  Result := FColor;
end;

procedure TsgDXFCustomColor.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AChangeList) then
    begin
      AChangeList.Add(Integer(xmlColor));
    end;
  end;
end;

procedure TsgDXFCustomColor.SetColorCAD(const Value: TsgColorCAD);
begin
  FColor := Value;
end;

function TsgDXFCustomColor.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlColor].Name).ValueData.ValueAsColorCAD := ColorCAD;
end;

function TsgDXFCustomColor.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode = nil): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlColor: ColorCAD := ANode.ValueData.ValueAsColorCAD;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

{ TsgCustomMaterialColor }

constructor TsgCustomMaterialColor.Create;
begin
  inherited Create;
end;

function TsgCustomMaterialColor.GetColor: TsgColorCAD;
begin
  Result := cnstDefHeadVarStruct.CEColor;
end;

function TsgCustomMaterialColor.GetFactor: Double;
begin
  Result := 1.0;
end;

function TsgCustomMaterialColor.GetMethod: Integer;
begin
  Result := 0;
end;

procedure TsgCustomMaterialColor.SetColor(const Value: TsgColorCAD);
begin
end;

procedure TsgCustomMaterialColor.SetFactor(const Value: Double);
begin
end;

procedure TsgCustomMaterialColor.SetMethod(const Value: Integer);
begin
end;

{ TsgMaterialColor }

procedure TsgMaterialColor.Assign(Source: TPersistent);
begin
  if Source is TsgMaterialColor then
  begin
    FColor := TsgMaterialColor(Source).FColor;
    FFactor := TsgMaterialColor(Source).FFactor;
    FMethod := TsgMaterialColor(Source).FMethod;
  end
  else
    inherited Assign(Source);
end;

constructor TsgMaterialColor.Create;
begin
  inherited Create;
  FColor := cnstDefHeadVarStruct.CEColor;
  FFactor := 1.0;
  FMethod := 0;
end;

function TsgMaterialColor.GetColor: TsgColorCAD;
begin
  Result := FColor;
end;

function TsgMaterialColor.GetFactor: Double;
begin
  Result := FFactor;
end;

function TsgMaterialColor.GetMethod: Integer;
begin
  Result := FMethod;
end;

procedure TsgMaterialColor.SetColor(const Value: TsgColorCAD);
begin
  FColor := Value;
end;

procedure TsgMaterialColor.SetFactor(const Value: Double);
begin
  FFactor := Value;
end;

procedure TsgMaterialColor.SetMethod(const Value: Integer);
begin
  FMethod := Value;
end;

{ TsgMaterialMap }

procedure TsgMaterialMap.Assign(Source: TPersistent);
begin
  if Source is TsgMaterialMap then
  begin
    FBlend := TsgMaterialMap(Source).FBlend;
    FFileName := TsgMaterialMap(Source).FFileName;
    FMapSource := TsgMaterialMap(Source).FMapSource;
    Mapper := TsgMaterialMap(Source).Mapper;
    MaterialColor := TsgMaterialMap(Source).MaterialColor;
    Xrecord := TsgMaterialMap(Source).Xrecord;
  end
  else
    inherited Assign(Source);
end;

constructor TsgMaterialMap.Create;
begin
  inherited Create;
  FBlend := 1.0;
  FMapSource := 0;
  FMapper := TsgMaterialMapper.Create;
  FMaterialColor := CreateMaterialColor;
  FXrecordItem := TsgTableItem.Create;
end;

function TsgMaterialMap.CreateMaterialColor: TsgCustomMaterialColor;
begin
  Result := TsgCustomMaterialColor.Create;
end;

destructor TsgMaterialMap.Destroy;
begin
  FMapper.Free;
  FMaterialColor.Free;
  FXrecordItem.Item := nil;
  FXrecordItem.Free;
  inherited Destroy;
end;

function TsgMaterialMap.GetXrecord: TsgDXFXRecord;
begin
  Result := TsgDXFXRecord(FXrecordItem.Item);
end;

procedure TsgMaterialMap.SetBlend(const Value: Double);
begin
  FBlend := Value;
end;

procedure TsgMaterialMap.SetFileName(const Value: string);
begin
  FFileName := Value;
end;

procedure TsgMaterialMap.SetMapper(const Value: TsgMaterialMapper);
begin
  FMapper.Assign(Value);
end;

procedure TsgMaterialMap.SetMapSource(const Value: Integer);
begin
  FMapSource := Value;
end;

procedure TsgMaterialMap.SetMaterialColor(const Value: TsgCustomMaterialColor);
begin
  FMaterialColor.Assign(Value);
end;

procedure TsgMaterialMap.SetXrecord(const Value: TsgDXFXRecord);
begin
  FXrecordItem.Item := Value;
end;

{ TsgMaterialMapper }

procedure TsgMaterialMapper.Assign(Source: TPersistent);
begin
  if Source is TsgMaterialMapper then
  begin
    FAutoTransform := TsgMaterialMapper(Source).FAutoTransform;
    FTransform := TsgMaterialMapper(Source).FTransform;
    FProjection := TsgMaterialMapper(Source).FProjection;
    FTiling := TsgMaterialMapper(Source).FTiling;
  end
  else
    inherited Assign(Source);
end;

constructor TsgMaterialMapper.Create;
begin
  inherited Create;
  FTransform.M[0, 0] := 1.0;
  FTransform.M[1, 1] := 1.0;
  FTransform.M[2, 2] := 1.0;
  FTransform.M[3, 3] := 1.0;
end;

function TsgMaterialMapper.GetAsAddress: PSingle;
begin
  Result := @FTransform.M[0, 0];
end;

function TsgMaterialMapper.GetMatrix(I, J: Integer): Single;
begin
  Result := FTransform.M[I, J];
end;

procedure TsgMaterialMapper.SetAutoTransform(const Value: Byte);
begin
  FAutoTransform := Value;
end;

procedure TsgMaterialMapper.SetMatrix(I, J: Integer; const Value: Single);
begin
  FTransform.M[I, J] := Value;
end;

procedure TsgMaterialMapper.SetProjection(const Value: Byte);
begin
  FProjection := Value;
end;

procedure TsgMaterialMapper.SetTiling(const Value: Byte);
begin
  FTiling := Value;
end;

procedure TsgMaterialMapper.SetTransform(const Value: TsgTexMatrix4f);
begin
  FTransform := Value;
end;

{ TsgDXFMaterial }

procedure TsgDXFMaterial.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFMaterial then
  begin
    Ambient := TsgDXFMaterial(Source).Ambient;
    Diffuse := TsgDXFMaterial(Source).Diffuse;
    Specular := TsgDXFMaterial(Source).Specular;
    Reflection := TsgDXFMaterial(Source).Reflection;
    Opacity := TsgDXFMaterial(Source).Opacity;
    Bump := TsgDXFMaterial(Source).Bump;
    Refraction := TsgDXFMaterial(Source).Refraction;
  end;
end;

constructor TsgDXFMaterial.Create;
begin
  inherited Create;
  FAmbient := TsgAmbientMaterialMap.Create;
  FDiffuse := TsgDiffuseMaterialMap.Create;
  FSpecular := TsgSpecularMaterialMap.Create;
  FReflection := TsgReflectionMaterialMap.Create;
  FOpacity := TsgOpacityMaterialMap.Create;
  FBump := TsgBumpMaterialMap.Create;
  FRefraction := TsgRefractionMaterialMap.Create;
end;

procedure TsgDXFMaterial.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FAmbient);
  FreeAndNil(FDiffuse);
  FreeAndNil(FSpecular);
  FreeAndNil(FReflection);
  FreeAndNil(FOpacity);
  FreeAndNil(FBump);
  FreeAndNil(FRefraction);
end;

procedure TsgDXFMaterial.SetAmbient(const Value: TsgAmbientMaterialMap);
begin
  FAmbient.Assign(Value);
end;

procedure TsgDXFMaterial.SetBump(const Value: TsgBumpMaterialMap);
begin
  FBump.Assign(Value);
end;

procedure TsgDXFMaterial.SetDiffuse(const Value: TsgDiffuseMaterialMap);
begin
  FDiffuse.Assign(Value);
end;

procedure TsgDXFMaterial.SetOpacity(const Value: TsgOpacityMaterialMap);
begin
  FOpacity.Assign(Value);
end;

procedure TsgDXFMaterial.SetReflection(const Value: TsgReflectionMaterialMap);
begin
  FReflection.Assign(Value);
end;

procedure TsgDXFMaterial.SetRefraction(const Value: TsgRefractionMaterialMap);
begin
  FRefraction.Assign(Value);
end;

procedure TsgDXFMaterial.SetSpecular(const Value: TsgSpecularMaterialMap);
begin
  FSpecular.Assign(Value);
end;

{ TsgSpecularMaterialMap }

procedure TsgSpecularMaterialMap.Assign(Source: TPersistent);
begin
  if Source is TsgSpecularMaterialMap then
  begin
    FGloss := TsgSpecularMaterialMap(Source).FGloss;
  end;
  inherited Assign(Source);
end;

constructor TsgSpecularMaterialMap.Create;
begin
  inherited Create;
  FGloss := 0.5;
end;

procedure TsgSpecularMaterialMap.SetGloss(const Value: Double);
begin
  FGloss := Value;
end;

{ TsgColoredMaterialMap }

function TsgColoredMaterialMap.CreateMaterialColor: TsgCustomMaterialColor;
begin
  Result := TsgMaterialColor.Create;
end;

{ TsgRefractionMaterialMap }

procedure TsgRefractionMaterialMap.Assign(Source: TPersistent);
begin
  if Source is TsgRefractionMaterialMap then
  begin
    FIndex := TsgRefractionMaterialMap(Source).FIndex;
  end;
  inherited Assign(Source);
end;

procedure TsgRefractionMaterialMap.SetIndex(const Value: Double);
begin
  FIndex := Value;
end;

{ TsgDiffuseMaterialMap }

procedure TsgDiffuseMaterialMap.Assign(Source: TPersistent);
begin
  if Source is TsgDiffuseMaterialMap then
  begin
    Bleed := TsgDiffuseMaterialMap(Source).Bleed;
    IndirectDump := TsgDiffuseMaterialMap(Source).IndirectDump;
    Normal1 := TsgDiffuseMaterialMap(Source).Normal1;
    Normal2 := TsgDiffuseMaterialMap(Source).Normal2;
    FReflectanceScale := TsgDiffuseMaterialMap(Source).FReflectanceScale;
    FLuminance := TsgDiffuseMaterialMap(Source).FLuminance;
    FTransmittanceScale := TsgDiffuseMaterialMap(Source).FTransmittanceScale;
  end;
  inherited Assign(Source);
end;

constructor TsgDiffuseMaterialMap.Create;
begin
  inherited Create;
  FBleed := CreateMaterialColor;
  FIndirectDump := CreateMaterialColor;
  FNormal1 := CreateMaterialColor;
  FNormal2 := CreateMaterialColor;
end;

destructor TsgDiffuseMaterialMap.Destroy;
begin
  FBleed.Free;
  FIndirectDump.Free;
  FNormal1.Free;
  FNormal2.Free;
  inherited Destroy;
end;

procedure TsgDiffuseMaterialMap.SetBleed(const Value: TsgCustomMaterialColor);
begin
  FBleed.Assign(Value);
end;

procedure TsgDiffuseMaterialMap.SetIndirectDump(
  const Value: TsgCustomMaterialColor);
begin
  FIndirectDump.Assign(Value);
end;

procedure TsgDiffuseMaterialMap.SetLuminance(const Value: Double);
begin
  FLuminance := Value;
end;

procedure TsgDiffuseMaterialMap.SetNormal1(const Value: TsgCustomMaterialColor);
begin
  FNormal1.Assign(Value);
end;

procedure TsgDiffuseMaterialMap.SetNormal2(const Value: TsgCustomMaterialColor);
begin
  FNormal2.Assign(Value);
end;

procedure TsgDiffuseMaterialMap.SetReflectanceScale(const Value: Double);
begin
  FReflectanceScale := Value;
end;

procedure TsgDiffuseMaterialMap.SetTransmittanceScale(const Value: Double);
begin
  FTransmittanceScale := Value;
end;

{ TsgOpacityMaterialMap }

procedure TsgOpacityMaterialMap.Assign(Source: TPersistent);
begin
  if Source is TsgOpacityMaterialMap then
  begin
    FPercent := TsgOpacityMaterialMap(Source).FPercent;
  end;
  inherited Assign(Source);
end;

constructor TsgOpacityMaterialMap.Create;
begin
  inherited Create;
  FPercent := 1.0;
end;

procedure TsgOpacityMaterialMap.SetPercent(const Value: Double);
begin
  FPercent := Value;
end;

{ TsgDXFScale }

procedure TsgDXFScale.AssignEntity(Source: TsgDXFEntity);
var
  vSource: TsgDXFScale absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFScale then
  begin
    FModelScale := vSource.FModelScale;
    FLayoutScale := vSource.FLayoutScale;
  end;
end;

constructor TsgDXFScale.Create;
begin
  inherited Create;
  FLayoutScale := 1;
  FModelScale := 1;
  FLinkID.Description := '1:1';
end;

function TsgDXFScale.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    sgConsts.xmlDescription: Description := ANode.ValueAsStr;
    xmlLayoutScale: LayoutScale := ANode.ValueAsDouble;
    xmlModelScale: ModelScale := ANode.ValueAsDouble;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgDXFScale.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgDescriptedNamedItem;
end;

function TsgDXFScale.GetScaleFactor: Extended;
begin
  Result := FModelScale / FLayoutScale;
end;

procedure TsgDXFScale.SetLayoutScale(const AValue: Double);
begin
  FLayoutScale := AValue;
end;

procedure TsgDXFScale.SetModelScale(const AValue: Double);
begin
  FModelScale := AValue;
end;

function TsgDXFScale.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[sgConsts.xmlDescription].Name).Value := Description;
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlLayoutScale].Name).ValueData,
    LayoutScale, xmlForViewing in AParams.Mode);
  SetDataValueAsDouble(ANode.AddAttribNV(cnstXMLNames[xmlModelScale].Name).ValueData,
    ModelScale, xmlForViewing in AParams.Mode);
end;

{ TsgDXFObjectContextData }

procedure TsgDXFObjectContextData.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFObjectContextData then
    FScaleItem.Item := TsgDXFObjectContextData(Source).FScaleItem.Item;
end;

procedure TsgDXFObjectContextData.ClearReferences;
begin
  inherited ClearReferences;
  Scale := nil;
end;

constructor TsgDXFObjectContextData.Create;
begin
  inherited Create;
  FScaleItem := TsgTableItem.Create;
end;

procedure TsgDXFObjectContextData.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FScaleItem);
end;

function TsgDXFObjectContextData.GetDescription: string;
begin
  if Assigned(Scale) then
    Result := Scale.Description
  else
    Result := inherited GetDescription;
end;

function TsgDXFObjectContextData.GetScale: TsgDXFScale;
begin
  Result := TsgDXFScale(FScaleItem.Item);
end;

procedure TsgDXFObjectContextData.SetScale(const Value: TsgDXFScale);
begin
  FScaleItem.Item := Value;
end;

function TsgDXFObjectContextData.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  if Scale <> nil then
    ANode.AddAttribNV(cnstXMLNames[xmlScale].Name).ValueAsStr := Scale.Name;
end;

{ TsgDXFRay }

procedure TsgDXFRay.ApplyExtrusionByPoint;
begin
end;

function TsgDXFRay.GetBox: TFRect;
begin
  Result.TopLeft := FStartPoint;
  Result.BottomRight := FStartPoint;
end;

function TsgDXFRay.GetDirection: TFPoint;
begin
  Result := FDirection;
end;

function TsgDXFRay.GetEntType: TsgCADEntities;
begin
  Result := ceRay;
end;

function TsgDXFRay.GetStartPoint: TFPoint;
begin
  Result := FStartPoint;
end;

procedure TsgDXFRay.SetDirection(const Value: TFPoint);
begin
  FDirection := Value;
end;

procedure TsgDXFRay.SetStartPoint(const Value: TFPoint);
begin
  FStartPoint := Value;
  Point := FStartPoint;
  Point1 := FStartPoint;
end;

procedure TsgDXFRay.UpdatePoints(const ADirection: TFPoint;
  const AViewport: TRect; const AMatrix: TFMatrix);
begin
  Point1 := DoUpdatePoints(ADirection, AViewport, AMatrix);
end;

procedure TsgDXFRay.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFRay then
  begin
    StartPoint := TsgDXFRay(Source).StartPoint;
    Direction := TsgDXFRay(Source).Direction;
  end;
end;

function TsgDXFRay.DoUpdatePoints(const ADirection: TFPoint;
  const AViewport: TRect; const AMatrix: TFMatrix): TFPoint;
var
  I: Integer;
  vScreenStartPoint, vScreenEndPoint: TFPoint;
  vL, vT, vR, vB, vS: Double;
  vNeedScale: Boolean;
  vDPU, vSize: TFPoint;
begin
  vScreenStartPoint := FPointXMat(StartPoint, AMatrix);
  vScreenEndPoint := FPointXMat(AddFPoint(StartPoint, ADirection), AMatrix);
  vDPU := SubFPoint(vScreenEndPoint, vScreenStartPoint);
  vL := AViewport.Left;
  if vScreenStartPoint.X < vL then
    vL := vScreenStartPoint.X;
  vR := AViewport.Right;
  if vScreenStartPoint.X > vR then
    vR := vScreenStartPoint.X;
  vT := AViewport.Top;
  if vScreenStartPoint.Y < vT then
    vT := vScreenStartPoint.Y;
  vB := AViewport.Bottom;
  if vScreenStartPoint.Y > vB then
    vB := vScreenStartPoint.Y;

  vSize.X := vR - vL;
  vSize.Y := vB - vT;
  vSize.Z := vSize.X;
  I := 0;
  vS := vSize.X;
  while I <= 2 do
  begin
    if not IsZero(vDPU.V[I]) then
    begin
      vS := vSize.V[I] / Abs(vDPU.V[I]);
      I := 4;
    end
    else
      Inc(I);
  end;
  if I <> 4 then
    vS := vSize.X;
  Result := AddFPoint(StartPoint, PtXScalar(ADirection, vS));
  vScreenEndPoint := FPointXMat(Result, AMatrix);
  vNeedScale := False;
  if vScreenEndPoint.X > vR then
  begin
    vS := vS * (1 - ((vScreenEndPoint.X - vR) / vSize.X));
    vNeedScale := True;
  end
  else
    if vScreenEndPoint.X < vL then
    begin
      vS := vS * (1 - ((vL - vScreenEndPoint.X) / vSize.X));
      vNeedScale := True;
    end;
  if vNeedScale then
  begin
    Result := AddFPoint(StartPoint, PtXScalar(ADirection, vS));
    vScreenEndPoint := FPointXMat(Result, AMatrix);
  end;
  vNeedScale := False;
  if vScreenEndPoint.Y > vB then
  begin
    vS := vS * (1 - ((vScreenEndPoint.Y - vB) / (vScreenEndPoint.Y - vScreenStartPoint.Y)));
    vNeedScale := True;
  end
  else
    if vScreenEndPoint.Y < vT then
    begin
      vS := vS * (1 - ((vT - vScreenEndPoint.Y) / (vScreenStartPoint.Y - vScreenEndPoint.Y)));
      vNeedScale := True;
    end;
  if vNeedScale then
    Result := AddFPoint(StartPoint, PtXScalar(ADirection, vS));
end;

{ TsgDXFXLine }

function TsgDXFXline.GetEntType: TsgCADEntities;
begin
  Result := ceXline;
end;

procedure TsgDXFXline.UpdatePoints(const ADirection: TFPoint;
  const AViewport: TRect; const AMatrix: TFMatrix);
begin
  inherited UpdatePoints(ADirection, AViewport, AMatrix);
  Point := DoUpdatePoints(Reverse(ADirection), AViewport, AMatrix);
end;

{ TsgCADSpatialFilter }

constructor TsgCADSpatialFilter.Create;
begin
  inherited Create;
  FBounds := TFPointList.Create;
  FInvBlkTransform := cnstIdentityMat;
  FClip := cnstIdentityMat;
  FExtrusion := cnstExtrusion;
end;

destructor TsgCADSpatialFilter.Destroy;
begin
  FBounds.Free;
  inherited Destroy;
end;

function TsgCADSpatialFilter.GetBoundTransformation(
  const ABlkRefTransformation: TFMatrix): TFMatrix;
begin
  Result := FMatInverse(FMatXMat(StdMat(cnstFPointSingle, Clipbdorg), Clip));
  Result := FMatXMat(Result, FMatXMat(InvBlkTransform, ABlkRefTransformation));
  Result.E0 := AddFPoint(Result.E0, Clipbdorg);
end;

function TsgCADSpatialFilter.GetExtrusion: TFPoint;
begin
  Result := FExtrusion;
end;

procedure TsgCADSpatialFilter.SetExtrusion(const Value: TFPoint);
begin
  FExtrusion := Value;
end;

{ TsgDXFAppID }

procedure TsgDXFAppID.ClearReferences;
begin
  if Converter <> nil then
    Converter.ClearEED(Handle);
  inherited ClearReferences;
end;

function GetTopInsert(const AInsert: TsgDXFInsert): TsgDXFInsert;
begin
  Result := AInsert;
  if Assigned(Result) then
    while Assigned(Result.OwnerInsert) do
      Result := Result.OwnerInsert;
end;

function CheckStyleInUse(const AConv: TsgDXFConverter; const AStyle: TsgDXFStyle;
  const ACurrentLayout:TsgDXFLayout = nil): Boolean;
var
  I, J, M, N: Integer;
  vEntities, vEnts, vPaperSpecBlock: TsgDXFEntity;

  function IsStyleInUse(const E: TObject): Boolean;
  begin
    if E.InheritsFrom(TsgDXFDimension) then
      Result := TsgDXFDimension(E).TextStyle = AStyle
    else
      if E.InheritsFrom(TsgDXFLeader) then
        Result := TsgDXFLeader(E).DimStyle.TextStyle = AStyle
      else
        if E.InheritsFrom(TsgDXFText) then
          Result := TsgDXFText(E).Style = AStyle
        else
          if E.InheritsFrom(TsgDXFMText) then
            Result := TsgDXFMText(E).Style = AStyle
          else Result := False
  end;

  function IsStyleInUseFromEntities(const E: TsgDXFEntity): Boolean;
  var
    L, K: Integer;
  begin
    Result := IsStyleInUse(E);
    K := E.Count;
    L := 0;
    while (L < K) and not Result do
    begin
      Result := IsStyleInUseFromEntities(E[L]);
      Inc(L);
    end;
  end;

begin
  Result := False;
  if Assigned(AConv) and Assigned(AStyle) then
  begin
    vEntities := AConv.Sections[csDimStyles];
    I := 0;
    M := vEntities.Count;
    while (I < M) and not Result do
    begin
      Result := TsgDXFDimensionStyle(vEntities[I]).TextStyle = AStyle;
      Inc(I);
    end;
    vPaperSpecBlock := nil;
    if (not Result) and Assigned(ACurrentLayout) then
    begin
      vPaperSpecBlock := ACurrentLayout.PaperSpaceBlock;
      I := 0;
      M := vPaperSpecBlock.Count;
      while (I < M) and not Result do
      begin
        Result := IsStyleInUseFromEntities(vPaperSpecBlock[I]);
        Inc(I);
      end;
    end;
    if not Result then
    begin
      vEntities := AConv.Sections[csBlocks];
      M := vEntities.Count;
      I := 0;
      while (I < M) and not Result do
      begin
        vEnts := vEntities[I];
        if vEnts <> vPaperSpecBlock then
        begin
          N := vEnts.Count;
          J := 0;
          while (J < N) and not Result do
          begin
            Result := IsStyleInUseFromEntities(vEnts[J]);
            Inc(J);
          end;
        end;
        Inc(I);
      end;
    end;
  end;
end;

{ TsgCADCustomApplicationBlockReference }

procedure TsgCADCustomApplicationBlockReference.ClearReferences;
var
  vAttributes: IsgGlobalPropProvider;
  V: Variant;
  vViewport: TsgDXFViewport;
begin
  inherited ClearReferences;
  if GetGlobalPropProvider(Self, False, vAttributes) then
  begin
    if vAttributes.TryGetValue(cnstViewport, V) and VarCastToObj(V, vViewport) then
      vViewport.RemoveDestroyNotification(ViewportDestroing);
    vAttributes.Clear;
  end;
end;

procedure TsgCADCustomApplicationBlockReference.Invoke(AConverter: TsgDXFConverter; Proc,
  FinishProc: TsgCADEntityProc);
var
  vCanInvoke: Boolean;
  vViewportValue: Variant;
  vViewport: TsgDXFViewport;
  vAttributes: IsgGlobalPropProvider;
  vVieportCutHandle: UInt64;
begin
  if GetGlobalPropProvider(Self, False, vAttributes) then // Only show in the viewport
  begin
    if vAttributes.TryGetValue(cnstViewport, vViewportValue) then
    begin
      case VarType(vViewportValue) of
        varInt64, varUInt64:
          begin
            if Assigned(AConverter.Params^.Viewport) then
              vVieportCutHandle := AConverter.Params^.Viewport.Handle
            else
              vVieportCutHandle := cnstBadHandle;
            vCanInvoke := vVieportCutHandle = {$IFDEF SGDEL_6}vViewportValue{$ELSE}sgVarAsUInt64(vViewportValue){$ENDIF};
          end;
      else
        vCanInvoke := VarCastToObj(vViewportValue, vViewport) and (AConverter.Params^.Viewport = vViewport);
      end;
      if vCanInvoke then
        inherited Invoke(AConverter, Proc, FinishProc);
    end;
  end;
end;

procedure TsgCADCustomApplicationBlockReference.Link(
  AConverter: TsgDXFConverter);
var
  V: Variant;
  vAttributes: IsgGlobalPropProvider;
  vViewport: TObject;
  vHandle: UInt64;
begin
  inherited Link(AConverter);
  if GetGlobalPropProvider(Self, False, vAttributes) and vAttributes.TryGetValue(cnstViewport, V) then
  begin
    case VarType(V) of
      varInt64, varUInt64:
        begin
          if AConverter.FMapExternal <> nil then
          begin
            vHandle := {$IFDEF SGDEL_6}V{$ELSE}sgVarAsUInt64(V){$ENDIF};
            vViewport := AConverter.FMapExternal.GetObj(vHandle);
            if vViewport is TsgDXFViewport then
            begin
              vAttributes[cnstViewport] := TsgDXFViewport(vViewport) as IUnknown;
              TsgDXFViewport(vViewport).AddDestroyNotification(ViewportDestroing);
            end;
          end;
        end;
    end;
  end;
end;

procedure TsgCADCustomApplicationBlockReference.ViewportDestroing(
  Sender: TObject);
var
  vAttributes: IsgGlobalPropProvider;
begin
  if GetGlobalPropProvider(Self, False, vAttributes) then
    vAttributes.RemoveItem(cnstViewport);
end;

{ TsgCADBlkRefObjectContextData }

procedure TsgCADBlkRefObjectContextData.AssignEntity(Source: TsgDXFEntity);
var
  vSource: TsgCADBlkRefObjectContextData absolute Source;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADBlkRefObjectContextData then
  begin
    FAngle := vSource.FAngle;
    FPoint := vSource.FPoint;
    FScaleFactor := vSource.FScaleFactor;
  end;
end;

function TsgCADBlkRefObjectContextData.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[xmlAngle].Name).ValueAsDouble := Angle;
  ANode.AddAttribNV(cnstXMLNames[xmlPoint].Name).ValueAsFPoint := Point;
  ANode.AddAttribNV(cnstXMLNames[xmlScaleFactor].Name).ValueAsFPoint := ScaleFactor;
end;

{$IFDEF SGDEL_2005}{$REGION 'Multileader objects implementation'}{$ENDIF}

{ TsgCustomMLeaderItem }

function TsgCustomMLeaderItem.AddStartEnd(const ALine: TsgMLeaderBreakLine): Integer;
begin
  Result := FStartEndCount;
  if Length(FStartEnd) = FStartEndCount then
    SetLength(FStartEnd, ListGrow(Length(FStartEnd)));
  FStartEnd[Result] := ALine;
  Inc(FStartEndCount);
end;

procedure TsgCustomMLeaderItem.Assign(Source: TPersistent);
begin
  if Source is TsgCustomMLeaderItem then
  begin
    FStartEnd := TsgCustomMLeaderItem(Source).FStartEnd;
    FStartEndCount := TsgCustomMLeaderItem(Source).FStartEndCount;
    FIdx := TsgCustomMLeaderItem(Source).FIdx;
  end
  else
    inherited Assign(Source);
end;

procedure TsgCustomMLeaderItem.Clear;
begin
  FStartEndCount := 0;
  SetLength(FStartEnd, 0);
end;

function TsgCustomMLeaderItem.Clone: TsgCustomMLeaderItem;
begin
  Result := TsgCustomMLeaderItemClass(ClassType).Create;
  Result.Assign(Self);
end;

constructor TsgCustomMLeaderItem.Create;
begin
end;

destructor TsgCustomMLeaderItem.Destroy;
begin
  Clear;
  inherited Destroy;
end;

function TsgCustomMLeaderItem.GetStartEnd(Index: Integer): TsgMLeaderBreakLine;
begin
  Result := FStartEnd[Index];
end;

function TsgCustomMLeaderItem.Item(Index: Integer): PsgMLeaderBreakLine;
begin
  Result := @FStartEnd[Index];
end;

procedure TsgCustomMLeaderItem.Link(AConverter: TsgDXFConverter);
begin
end;

{ TsgMLeaderLine }

procedure TsgMLeaderLine.Assign(Source: TPersistent);
begin
  inherited Assign(Source);
  if Source is TsgMLeaderLine then
  begin
    FPoints.Assign(TsgMLeaderLine(Source).FPoints);
    FSegmentIndex := TsgMLeaderLine(Source).FSegmentIndex;
    FLeaderType := TsgMLeaderLine(Source).FLeaderType;
    FColor := TsgMLeaderLine(Source).FColor;
    FLineType.Item := TsgMLeaderLine(Source).FLineType.Item;
    FLineWeight := TsgMLeaderLine(Source).FLineWeight;
    FArrowSize := TsgMLeaderLine(Source).FArrowSize;
    FArrow.Item := TsgMLeaderLine(Source).FArrow.Item;
    FOverrideFlags := TsgMLeaderLine(Source).FOverrideFlags;
  end;
end;

procedure TsgMLeaderLine.Clear;
begin
  inherited Clear;
  FPoints.Clear;
end;

constructor TsgMLeaderLine.Create;
begin
  inherited Create;
  FPoints := TFPointList.Create;
  FLineType := TsgTableItem.Create;
  FArrow := TsgTableItem.Create;
end;

destructor TsgMLeaderLine.Destroy;
begin
  FLineType.Free;
  FArrow.Free;
  inherited Destroy;
  FPoints.Free;
end;

function TsgMLeaderLine.GetArrow: TsgDXFBlockRecord;
begin
  Result := TsgDXFBlockRecord(FArrow.Item);
end;

function TsgMLeaderLine.GetLineType: TsgDXFLineType;
begin
  Result := TsgDXFLineType(FLineType.Item);
end;

procedure TsgMLeaderLine.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgMLeaderLine.SetArrow(const Value: TsgDXFBlockRecord);
begin
  FArrow.Item := Value;
end;

procedure TsgMLeaderLine.SetLineType(const Value: TsgDXFLineType);
begin
  FLineType.Item := Value;
end;

procedure TsgMLeaderLine.FromXMLNode(const ANode: TsgNodeSample; const AConv: TsgDXFConverter);
const
  cnstAttribs: array[0..8] of TsgXMLId = (xmlPoints, xmlIndex, xmlFlags,
    xmlLeaderType, xmlColor, xmlLineTypeName, xmlLineWeight, xmlArrowSize,
    xmlArrowType);
var
  I, J: Integer;
  vAttrib: TsgNodeSample;
  vEntNamed: TsgDXFEntity;
begin
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vAttrib := ANode.AttributeNodes[I];
    for J := Low(cnstAttribs) to High(cnstAttribs) do
    begin
      if SameText(vAttrib.Name, cnstXMLNames[cnstAttribs[J]].Name) then
      begin
        case cnstAttribs[J] of
          xmlPoints:     Points.FromStr(vAttrib.ValueAsStr);
          xmlIndex:      SegmentIndex := vAttrib.ValueAsInt;
          xmlFlags:      OverrideFlags := vAttrib.ValueAsInt;
          xmlLeaderType: LeaderType := vAttrib.ValueAsInt;
          xmlColor:      Color := vAttrib.ValueData.ValueAsColorCAD;
          xmlLineWeight: LineWeight := vAttrib.ValueAsDouble;
          xmlArrowSize:  ArrowSize := vAttrib.ValueAsDouble;
          xmlLineTypeName:
            begin
              if Assigned(AConv) then
              begin
                vEntNamed := AConv.LTypeByName(vAttrib.ValueAsStr);
                if Assigned(vEntNamed) then
                  LineType := TsgDXFLineType(vEntNamed);
              end;
            end;
          xmlArrowType:
            begin
              if Assigned(AConv) then
              begin
                vEntNamed := AConv.Sections[csBlockRecords].FindEntByName(vAttrib.ValueAsStr);
                if Assigned(vEntNamed) then
                  Arrow := TsgDXFBlockRecord(vEntNamed);
              end;
            end;
        end;
        Break;
      end;
    end;
  end;

end;

procedure TsgMLeaderLine.ToXMLNode(const ANode: TsgNode);
var
  vLineTypeNode, vArrowNode: TsgNodeSample;
begin
  ANode.AddAttribNV(cnstXMLNames[xmlPoints].Name).ValueAsStr := Points.ToStr();
  ANode.AddAttribNV(cnstXMLNames[xmlIndex].Name).ValueAsInt := SegmentIndex;
  ANode.AddAttribNV(cnstXMLNames[xmlFlags].Name).ValueAsInt := OverrideFlags;
  ANode.AddAttribNV(cnstXMLNames[xmlLeaderType].Name).ValueAsInt := LeaderType;
  ANode.AddAttribNV(cnstXMLNames[xmlColor].Name).ValueData.ValueAsColorCAD := Color;
  vLineTypeNode := ANode.AddAttribNV(cnstXMLNames[xmlLineTypeName].Name);
  if Assigned(LineType) then
    vLineTypeNode.ValueAsStr := LineType.Name;
  ANode.AddAttribNV(cnstXMLNames[xmlLineWeight].Name).ValueAsDouble := LineWeight;
  ANode.AddAttribNV(cnstXMLNames[xmlArrowSize].Name).ValueAsDouble := ArrowSize;
  vArrowNode := ANode.AddAttribNV(cnstXMLNames[xmlArrowType].Name);
  if Assigned(Arrow) then
    vArrowNode.ValueAsStr := Arrow.Name;
end;

{ TsgMLeader }

function TsgMLeader.AddMLeaderLine(const AMLeaderLine: TsgMLeaderLine): Integer;
begin
  Result := Length(FLines);
  SetLength(FLines, Result + 1);
  FLines[Result] := AMLeaderLine;
end;

procedure TsgMLeader.Assign(Source: TPersistent);
var
  I: Integer;
  vSource: TsgMLeader;
begin
  inherited Assign(Source);
  if Source is TsgMLeader then
  begin
    vSource := TsgMLeader(Source);
    FConnectionPoint := vSource.FConnectionPoint;
    FDirection := vSource.FDirection;
    FLandingDistance := vSource.FLandingDistance;
    ClearLines;
    for I := 0 to vSource.LinesCount - 1 do
      AddMLeaderLine(TsgMLeaderLine(vSource.Lines[I].Clone));
    FIsVertical := vSource.FIsVertical;
  end;
end;

procedure TsgMLeader.Clear;
begin
  inherited Clear;
  ClearLines;
end;

procedure TsgMLeader.ClearLines;
var
  I: Integer;
begin
  for I := High(FLines) downto Low(FLines) do FLines[I].Free;
  SetLength(FLines, 0);
end;

function TsgMLeader.GetLines(Index: Integer): TsgMLeaderLine;
begin
  Result := FLines[Index];
end;

function TsgMLeader.GetLinesCount: Integer;
begin
  Result := Length(FLines);
end;

procedure TsgMLeader.Link(AConverter: TsgDXFConverter);
var
  I: Integer;
begin
  inherited Link(AConverter);
  for I := 0 to LinesCount - 1 do
    Lines[I].Link(AConverter);
end;

procedure TsgMLeader.FromXMLNode(const ANode: TsgNodeSample; const AConv: TsgDXFConverter);
const
  cnstAttribs: array[0..3] of TsgXMLId = (xmlPoint, xmlDirection, xmlLandingGap,
    xmlVAlign);
var
  I, J, vCount: Integer;
  vAttrib, vLinesNode: TsgNodeSample;
  vMLeaderLine: TsgMLeaderLine;
begin
  for I := 0 to ANode.AttributeNodesCount - 1 do
  begin
    vAttrib := ANode.AttributeNodes[I];
    for J := Low(cnstAttribs) to High(cnstAttribs) do
    begin
      if SameText(cnstXMLNames[cnstAttribs[J]].Name, vAttrib.Name) then
      begin
        case cnstAttribs[J] of
          xmlPoint:      ConnectionPoint := vAttrib.ValueAsFPoint;
          xmlDirection:  Direction := vAttrib.ValueAsFPoint;
          xmlLandingGap: LandingDistance := vAttrib.ValueAsDouble;
          xmlVAlign:     IsVertical := vAttrib.ValueAsInt = 1;
        end;
        Break;
      end;
    end;
  end;
  vLinesNode := ANode.GetChildByName(cnstXMLNames[xmlLines].Name);
  if Assigned(vLinesNode) then
  begin
    vCount := GetAttributeInt(vLinesNode, cnstXMLNames[xmlCount].Name, -1);
    if vCount >= LinesCount then
    begin
      Dec(vCount, LinesCount);
      for I := 1 to vCount do
        AddMLeaderLine(TsgMLeaderLine.Create);
      for I := 0 to MinI(LinesCount, vLinesNode.ChildNodesCount)  -1 do
        Lines[I].FromXMLNode(vLinesNode.ChildNodes[I], AConv);
    end
    else
    begin
      ClearLines;
      for I := 0 to vLinesNode.ChildNodesCount - 1 do
      begin
        vMLeaderLine := TsgMLeaderLine.Create;
        AddMLeaderLine(vMLeaderLine);
        vMLeaderLine.FromXMLNode(vLinesNode.ChildNodes[I], AConv);
      end;
    end;
  end;
end;


procedure TsgMLeader.ToXMLNode(const ANode: TsgNode);
var
  I: Integer;
  vLines: TsgNode;
begin
  ANode.AddAttribNV(cnstXMLNames[xmlPoint].Name).ValueAsFPoint := ConnectionPoint;
  ANode.AddAttribNV(cnstXMLNames[xmlDirection].Name).ValueAsFPoint := Direction;
  ANode.AddAttribNV(cnstXMLNames[xmlLandingGap].Name).ValueAsDouble := LandingDistance;
  ANode.AddAttribNV(cnstXMLNames[xmlVAlign].Name).ValueAsInt := Ord(IsVertical);
  vLines := ANode.AddChildNV(cnstXMLNames[xmlLines].Name);
  vLines.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := LinesCount;
  for I := 0 to LinesCount - 1 do
    Lines[I].ToXMLNode(vLines.AddChildNV(cnstXMLNames[xmlItem].Name));
end;

{ TsgCADMLeaderAnnotContext }

procedure TsgCADMLeaderAnnotContext.AssignEntity(Source: TsgDXFEntity);
var
  vSource: TsgCADMLeaderAnnotContext;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADMLeaderAnnotContext then
  begin
    vSource := TsgCADMLeaderAnnotContext(Source);
    FItem.Assign(vSource.FItem);
  end;
end;

procedure TsgCADMLeaderAnnotContext.ClearReferences;
begin
  inherited ClearReferences;
  FItem.ClearReferences;
end;

constructor TsgCADMLeaderAnnotContext.Create;
begin
  inherited Create;
  FItem := TsgMLeaderContextData.Create;
end;

procedure TsgCADMLeaderAnnotContext.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FItem);
end;

function TsgCADMLeaderAnnotContext.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
var
  I, vCount, vIndex: Integer;
  vMLeader: TsgMLeader;
  vItemNode: TsgNodeSample;
  vConv: TsgDXFConverter;
  vEntNamed: TsgDXFEntity;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result = cnstXML_OK then
    Exit;
  Result := cnstXML_OK;
  vConv  := Converter;
  case AType.Id of
    xmlOverallScale: FItem.OverallScale := ANode.ValueAsDouble;
    xmlContentBasePoint: FItem.ContentBasePoint := ANode.ValueAsFPoint;
    xmlTextHeight: FItem.TextHeight := ANode.ValueAsDouble;
    xmlArrowSize: FItem.ArrowHeadSize := ANode.ValueAsDouble;
    xmlLandingGap: FItem.LandingGap := ANode.ValueAsDouble;
    xmlLeftAttachment: FItem.LeftAttachment := ANode.ValueAsInt;
    xmlRightAttachment: FItem.RightAttachment := ANode.ValueAsInt;
    xmlTextAngleType: FItem.TextAlignType := ANode.ValueAsInt;
    xmlTextAttachmentDirection: FItem.AttachmentType := ANode.ValueAsInt;
    xmlTextContext: FItem.HasTextContents := ANode.ValueAsInt = 1;
    xmlTextLabel: FItem.TextLabel := ANode.ValueAsStr;
    xmlTextNormal: FItem.TextNormal := ANode.ValueAsFPoint;
    xmlTextStyle:
      begin
        if Assigned(vConv) then
          FItem.TextStyle := vConv.StyleByName(ANode.ValueAsStr);
      end;
    xmlTextLocation: FItem.TextLocation := ANode.ValueAsFPoint;
    xmlTextDirection: FItem.TextDirection := ANode.ValueAsFPoint;
    xmlTextRotation: FItem.TextRotation := ANode.ValueAsDouble;
    xmlWidth: FItem.BoundaryWidth := ANode.ValueAsDouble;
    xmlHeight: FItem.BoundaryHeight := ANode.ValueAsDouble;
    xmlLineSpacingFactor: FItem.LineSpacingFactor := ANode.ValueAsDouble;
    xmlLineSpacingStyle: FItem.LineSpacingStyle := ANode.ValueAsInt;
    xmlTextColor: FItem.TextColor := ANode.ValueData.ValueAsColorCAD;
    xmlAlign: FItem.Alignment := ANode.ValueAsInt;
    xmlDirection: FItem.FlowDirection := ANode.ValueAsInt;
    xmlBackgroundColor: FItem.BackgroundColor := ANode.ValueData.ValueAsColorCAD;
    xmlBackgroundScaleFactor: FItem.BackgroundScaleFactor := ANode.ValueAsDouble;
    xmlBackgroundTransparency: FItem.BackgroundTransparency := ANode.ValueAsInt;
    xmlBackground: FItem.IsBackgroundEnabled := ANode.ValueAsBool;
    xmlBackgroundMask: FItem.IsBackgroundMaskFillOn := ANode.ValueAsInt = 1;
    xmlTextHeightAuto: FItem.IsTextHeightAutomatic := ANode.ValueAsBool;
    xmlColumnType: FItem.ColumnType := ANode.ValueAsInt;
    xmlColumnWidth: FItem.ColumnWidth := ANode.ValueAsDouble;
    xmlColumnGutter: FItem.ColumnGutter := ANode.ValueAsDouble;
    xmlColumnFlowReversed: FItem.ColumnFlowReversed := ANode.ValueAsBool;
    xmlColumnSize: FItem.ColumnSizes.FromStr(ANode.ValueAsStr);
    xmlWordBreak: FItem.WordBreak := ANode.ValueAsBool;
    xmlBlock: FItem.HasContentsBlock := ANode.ValueAsBool;
    xmlBlockName:
      begin
        if Assigned(vConv) then
        begin
          vEntNamed := vConv.Sections[csBlockRecords].FindEntByName(ANode.ValueAsStr);
          if Assigned(vEntNamed) then
            FItem.BlockRecord := TsgDXFBlockRecord(vEntNamed);
        end;
      end;
    xmlBlockNormal: FItem.BlkNormal := ANode.ValueAsFPoint;
    xmlBlockLocation: FItem.BlkLocation := ANode.ValueAsFPoint;
    xmlBlockScale: FItem.BlkScale := ANode.ValueAsFPoint;
    xmlBlockRotation: FItem.BlkRotation := ANode.ValueAsDouble;
    xmlBlockColor: FItem.BlockColor := ANode.ValueData.ValueAsColorCAD;
    xmlBlockMatrix: FItem.BlkMatrix := ANode.ValueData.ValueAsMatrix;
    xmlBasePoint: FItem.BasePoint := ANode.ValueAsFPoint;
    xmlBaseDirection: FItem.BaseDirection := ANode.ValueAsFPoint;
    xmlBaseVertical: FItem.BaseVertical := ANode.ValueAsFPoint;
    xmlNormalReversed: FItem.IsNormalReversed := ANode.ValueAsBool;
    xmlTopAttachment: FItem.TopAttachment := ANode.ValueAsInt;
    xmlBottomAttachment: FItem.BottomAttachment := ANode.ValueAsInt;
    xmlMLeaders:
      begin
        if AIsChild then
        begin
          vCount := GetAttributeInt(ANode, cnstXMLNames[xmlCount].Name, -1);
          if vCount = FItem.MLeadersCount then//update
          begin
            for I := 0 to vCount - 1 do
            begin
              vItemNode := ANode.ChildNodes[I];
              vIndex := GetAttributeInt(ANode, cnstXMLNames[xmlIndex].Name, -MaxWord);
              if vIndex = -MaxWord then
                vMLeader := FItem.MLeaders[I]
              else
                if (vIndex >= 0) and (vIndex < vCount) then
                  vMLeader := FItem.MLeaders[vIndex]
                else
                  vMLeader := nil;
              if Assigned(vMLeader) then
                vMLeader.FromXMLNode(vItemNode, vConv);
            end;
          end
          else//create
          begin
            FItem.Clear;
            for I := 0 to vCount - 1 do
            begin
              vItemNode := ANode.ChildNodes[I];
              if SameText(vItemNode.Name, cnstXMLNames[xmlItem].Name) then
              begin
                vMLeader := TsgMLeader.Create;
                FItem.AddMLeader(vMLeader);
                vMLeader.FromXMLNode(vItemNode, vConv);
              end;
            end;
          end;
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

procedure TsgCADMLeaderAnnotContext.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
  FItem.Link(AConverter);
end;

function TsgCADMLeaderAnnotContext.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vMLeaders, vMLeader: TsgNode;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  vMLeaders := ANode.AddChildNV(cnstXMLNames[xmlMLeaders].Name);
  vMLeaders.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := FItem.MLeadersCount;
  for I := 0 to FItem.MLeadersCount - 1 do
  begin
    vMLeader := vMLeaders.AddChildNV(cnstXMLNames[xmlItem].Name);
    FItem.MLeaders[I].ToXMLNode(vMLeader);
    SetAttributeInt(vMLeader, cnstXMLNames[xmlIndex].Name, I);
  end;
  ANode.AddAttribNV(cnstXMLNames[xmlOverallScale].Name).ValueAsDouble := FItem.OverallScale;
  ANode.AddAttribNV(cnstXMLNames[xmlContentBasePoint].Name).ValueAsFPoint := FItem.ContentBasePoint;
  ANode.AddAttribNV(cnstXMLNames[xmlTextHeight].Name).ValueAsDouble := FItem.TextHeight;
  ANode.AddAttribNV(cnstXMLNames[xmlArrowSize].Name).ValueAsDouble := FItem.ArrowHeadSize;
  ANode.AddAttribNV(cnstXMLNames[xmlLandingGap].Name).ValueAsDouble := FItem.LandingGap;
  ANode.AddAttribNV(cnstXMLNames[xmlLeftAttachment].Name).ValueAsInt := FItem.LeftAttachment;
  ANode.AddAttribNV(cnstXMLNames[xmlRightAttachment].Name).ValueAsInt := FItem.RightAttachment;
  ANode.AddAttribNV(cnstXMLNames[xmlTextAngleType].Name).ValueAsInt := FItem.TextAlignType;
  ANode.AddAttribNV(cnstXMLNames[xmlTextAttachmentDirection].Name).ValueAsInt := FItem.AttachmentType;
  ANode.AddAttribNV(cnstXMLNames[xmlTextContext].Name).ValueAsInt := Ord(FItem.HasTextContents);
  ANode.AddAttribNV(cnstXMLNames[xmlTextLabel].Name).ValueAsStr := FItem.TextLabel;
  ANode.AddAttribNV(cnstXMLNames[xmlTextNormal].Name).ValueAsFPoint := FItem.TextNormal;
  if Assigned(FItem.TextStyle) then
    ANode.AddAttribNV(cnstXMLNames[xmlTextStyle].Name).ValueAsStr := FItem.TextStyle.Name;
  ANode.AddAttribNV(cnstXMLNames[xmlTextLocation].Name).ValueAsFPoint := FItem.TextLocation;
  ANode.AddAttribNV(cnstXMLNames[xmlTextDirection].Name).ValueAsFPoint := FItem.TextDirection;
  ANode.AddAttribNV(cnstXMLNames[xmlTextRotation].Name).ValueAsDouble := FItem.TextRotation;
  ANode.AddAttribNV(cnstXMLNames[xmlWidth].Name).ValueAsDouble := FItem.BoundaryWidth;
  ANode.AddAttribNV(cnstXMLNames[xmlHeight].Name).ValueAsDouble := FItem.BoundaryHeight;
  ANode.AddAttribNV(cnstXMLNames[xmlLineSpacingFactor].Name).ValueAsDouble := FItem.LineSpacingFactor;
  ANode.AddAttribNV(cnstXMLNames[xmlLineSpacingStyle].Name).ValueAsInt := FItem.LineSpacingStyle;
  ANode.AddAttribNV(cnstXMLNames[xmlTextColor].Name).ValueData.ValueAsColorCAD := FItem.TextColor;
  ANode.AddAttribNV(cnstXMLNames[xmlAlign].Name).ValueAsInt := FItem.Alignment;
  ANode.AddAttribNV(cnstXMLNames[xmlDirection].Name).ValueAsInt := FItem.FlowDirection;
  ANode.AddAttribNV(cnstXMLNames[xmlBackgroundColor].Name).ValueData.ValueAsColorCAD := FItem.BackgroundColor;
  ANode.AddAttribNV(cnstXMLNames[xmlBackgroundScaleFactor].Name).ValueAsDouble := FItem.BackgroundScaleFactor;
  ANode.AddAttribNV(cnstXMLNames[xmlBackgroundTransparency].Name).ValueAsInt := FItem.BackgroundTransparency;
  ANode.AddAttribNV(cnstXMLNames[xmlBackground].Name).ValueAsBool := FItem.IsBackgroundEnabled;
  ANode.AddAttribNV(cnstXMLNames[xmlBackgroundMask].Name).ValueAsInt := Ord(FItem.IsBackgroundMaskFillOn);
  ANode.AddAttribNV(cnstXMLNames[xmlTextHeightAuto].Name).ValueAsBool := FItem.IsTextHeightAutomatic;
  ANode.AddAttribNV(cnstXMLNames[xmlColumnType].Name).ValueAsInt := FItem.ColumnType;
  ANode.AddAttribNV(cnstXMLNames[xmlColumnWidth].Name).ValueAsDouble := FItem.ColumnWidth;
  ANode.AddAttribNV(cnstXMLNames[xmlColumnGutter].Name).ValueAsDouble := FItem.ColumnGutter;
  ANode.AddAttribNV(cnstXMLNames[xmlColumnFlowReversed].Name).ValueAsBool := FItem.ColumnFlowReversed;
  ANode.AddAttribNV(cnstXMLNames[xmlColumnSize].Name).ValueAsStr := FItem.ColumnSizes.ToStr;
  ANode.AddAttribNV(cnstXMLNames[xmlWordBreak].Name).ValueAsBool := FItem.WordBreak;
  ANode.AddAttribNV(cnstXMLNames[xmlBlock].Name).ValueAsBool := FItem.HasContentsBlock;
  if Assigned(FItem.BlockRecord) then
    ANode.AddAttribNV(cnstXMLNames[xmlBlockName].Name).ValueAsStr := FItem.BlockRecord.Name;
  ANode.AddAttribNV(cnstXMLNames[xmlBlockNormal].Name).ValueAsFPoint := FItem.BlkNormal;
  ANode.AddAttribNV(cnstXMLNames[xmlBlockLocation].Name).ValueAsFPoint := FItem.BlkLocation;
  ANode.AddAttribNV(cnstXMLNames[xmlBlockScale].Name).ValueAsFPoint := FItem.BlkScale;
  ANode.AddAttribNV(cnstXMLNames[xmlBlockRotation].Name).ValueAsDouble := FItem.BlkRotation;
  ANode.AddAttribNV(cnstXMLNames[xmlBlockColor].Name).ValueData.ValueAsColorCAD := FItem.BlockColor;
  ANode.AddAttribNV(cnstXMLNames[xmlBlockMatrix].Name).ValueData.ValueAsMatrix := FItem.BlkMatrix;
  ANode.AddAttribNV(cnstXMLNames[xmlBasePoint].Name).ValueAsFPoint := FItem.BasePoint;
  ANode.AddAttribNV(cnstXMLNames[xmlBaseDirection].Name).ValueAsFPoint := FItem.BaseDirection;
  ANode.AddAttribNV(cnstXMLNames[xmlBaseVertical].Name).ValueAsFPoint := FItem.BaseVertical;
  ANode.AddAttribNV(cnstXMLNames[xmlNormalReversed].Name).ValueAsBool := FItem.IsNormalReversed;
  ANode.AddAttribNV(cnstXMLNames[xmlTopAttachment].Name).ValueAsInt := FItem.TopAttachment;
  ANode.AddAttribNV(cnstXMLNames[xmlBottomAttachment].Name).ValueAsInt := FItem.BottomAttachment;
end;

{ TsgCADMLeaderStyle }

procedure TsgCADMLeaderStyle.ArrowDestroing(Sender: TObject);
begin
  if Assigned(FArrowItem) and (FArrowItem.Item = Sender) then
  begin
    FArrowItem.ItemObj.ObjRelease;
    FArrowItem.FItem := nil;
  end;
end;

procedure TsgCADMLeaderStyle.AssignEntity(Source: TsgDXFEntity);
var
  vSource: TsgCADMLeaderStyle;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADMLeaderStyle then
  begin
    vSource := TsgCADMLeaderStyle(Source);
    FContentType := vSource.FContentType;
    FDrawMLeaderOrder := vSource.FDrawMLeaderOrder;
    FDrawLeaderOrder := vSource.FDrawLeaderOrder;
    FMaxNumberOfPoints := vSource.FMaxNumberOfPoints;
    FFirstSegmentAngle := vSource.FFirstSegmentAngle;
    FSecondSegmentAngle := vSource.FSecondSegmentAngle;
    FLeaderLineType := vSource.FLeaderLineType;
    FColor := vSource.FColor;
    FLineTypeItem.Item := vSource.FLineTypeItem.Item;
    FLandingEnabled := vSource.FLandingEnabled;
    FLandingGap := vSource.FLandingGap;
    FDogLegEnabled := vSource.FDogLegEnabled;
    FLandingDistance := vSource.FLandingDistance;
    FStyleDescription := vSource.FStyleDescription;
    Arrow := vSource.Arrow;
    FArrowHeadSize := vSource.FArrowHeadSize;
    FText := vSource.FText;
    FTextStyleItem.Item := vSource.FTextStyleItem.Item;
    FLeftAttachment := vSource.FLeftAttachment;
    FRightAttachment := vSource.FRightAttachment;
    FTextAngleType := vSource.FTextAngleType;
    FAttachmentDirection := vSource.FAttachmentDirection;
    FTopAttachment := vSource.FTopAttachment;
    FBottomAttachment := vSource.FBottomAttachment;
    FTextAlignmentType := vSource.FTextAlignmentType;
    FTextColor := vSource.FTextColor;
    FTextHeight := vSource.FTextHeight;
    FTextFrameEnabled := vSource.FTextFrameEnabled;
    FAlwaysAlignTextLeft := vSource.FAlwaysAlignTextLeft;
    FAlignSpace := vSource.FAlignSpace;
    BlockRecord := vSource.BlockRecord;
    FBlockColor := vSource.FBlockColor;
    FBlockScale := vSource.FBlockScale;
    FIsBlockScaleEnabled := vSource.FIsBlockScaleEnabled;
    FBlockRotation := vSource.FBlockRotation;
    FIsBlockRotationEnabled := vSource.FIsBlockRotationEnabled;
    FBlockConnectionType := vSource.FBlockConnectionType;
    FScaleFactor := vSource.FScaleFactor;
    FBreakSize := vSource.FBreakSize;
  end;
end;

procedure TsgCADMLeaderStyle.BlockrecordDestroing(Sender: TObject);
begin
  if Assigned(FBlockRecordItem) and (FBlockRecordItem.Item = Sender) then
  begin
    FBlockRecordItem.ItemObj.ObjRelease;
    FBlockRecordItem.FItem := nil;
  end;
end;

procedure TsgCADMLeaderStyle.ClearReferences;
begin
  inherited ClearReferences;
  Arrow := nil;
  BlockRecord := nil;
  FTextStyleItem.Item := nil;
  FLineTypeItem.Item := nil;
end;

constructor TsgCADMLeaderStyle.Create;
begin
  inherited Create;
  FArrowItem := TsgTableItem.Create;
  FTextStyleItem := TsgTableItem.Create;
  FBlockRecordItem := TsgTableItem.Create;
  FLineTypeItem := TsgTableItem.Create;
  FScaleFactor := 1.0;
  FBlockScale := cnstFPointSingle;
  FIsBlockRotationEnabled := True;
  FIsBlockScaleEnabled := True;
  FContentType := 2;
  FTextHeight := cnstDefHeadVarStruct.TextSize;
end;

procedure TsgCADMLeaderStyle.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FArrowItem);
  FreeAndNil(FTextStyleItem);
  FreeAndNil(FBlockRecordItem);
  FreeAndNil(FLineTypeItem);
end;

function TsgCADMLeaderStyle.FromXMLAsProperties(const ANode: TsgNodeSample;
  const AResult: IsgResultNode): Integer;
var
  vFlagsNode: TsgNodeSample;
  vPropertiesInit: TsgDXFMLeaderProps;
  vProperties: TsgStringList;
  vStr: string;
  I, vLowP, vHighP: Integer;
  P: TsgDXFMLeaderProp;
begin
  Result := FromXML(ANode, AResult);
  vFlagsNode := ANode.GetAttributeByName(cnstXMLNames[xmlFlagsStr].Name);
  if Assigned(vFlagsNode) then
  begin
    vPropertiesInit := [];
    try
      vStr := vFlagsNode.ValueAsStr;
      if Length(vStr) > 0 then
      begin
        vLowP := Ord(Low(TsgDXFMLeaderProp));
        vHighP := Ord(High(TsgDXFMLeaderProp));
        vProperties := TsgStringList.Create;
        try
          vProperties.Capacity := vHighP - vLowP + 1;
          vProperties.LineBreak := cnstEnumValuesDelimiter;
          vProperties.Text := vStr;
          vProperties.CaseSensitive := False;
          vProperties.Sorted := True;
          for P := Low(TsgDXFMLeaderProp) to High(TsgDXFMLeaderProp) do
          begin
            I := vProperties.IndexOf(cnstXMLNames[cnstMLeaderXmlId[P]].Name);
            if I > -1 then
            begin
              Include(vPropertiesInit, P);
              if vProperties.Count > 1 then
                vProperties.Delete(I)
              else
                Break;
            end;
          end;
        finally
          vProperties.Free;
        end;
      end;
    finally
      SetPropertiesInit(vPropertiesInit);
    end;
  end;
end;

function TsgCADMLeaderStyle.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
var
  P: TsgDXFMLeaderProp;
  vPropertiesInit: TsgDXFMLeaderProps;
  vConv: TsgDXFConverter;
  vLineType: TsgDXFLineType;
  vTextStyle: TsgDXFStyle;
  vBlock: TsgDXFBLock;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if (Result <> cnstXML_UNSUPPORTED) and (AType.Id in [xmlColor, xmlLineWeight, xmlLineTypeName]) then
   Exit;
  Result := cnstXML_OK;
  vConv := Converter;
  case AType.Id of
    xmlLeaderLineType:   LeaderLineType := ANode.ValueAsInt;//mlpLeaderLineType
    xmlLineColor:        ColorCAD := ANode.ValueData.ValueAsColorCAD;//mlpLineColor
    xmlLineTypeName://mlpLineType
      begin
       if Assigned(vConv) then
       begin
         vLineType := TsgDXFLineType(vConv.Sections[csLTypes].FindEntByName(ANode.ValueAsStr));
         if Assigned(vLineType) then
           LineType := vLineType;
       end;
      end;
    xmlLineWeight:      LineWeight := ANode.ValueAsDouble;//mlpLineWeight
    xmlLanding:         LandingEnabled := ANode.ValueAsInt = 1;//mlpEnabledLanding
    xmlLandingGap:      LandingGap := ANode.ValueAsDouble;//mlpLandingGap
    xmlDogLeg:          DogLegEnabled := ANode.ValueAsInt = 1;//mlpEnabledDogLeg
    xmlDogLegLen:       LandingDistance := ANode.ValueAsDouble;//mlpDogLegLen
    xmlArrowType://mlpArrow
      begin
        if Assigned(vConv) then
        begin
          vBlock := vConv.BlockByName(ANode.ValueAsStr);
           if Assigned(vBlock) then
             Arrow := vBlock.BlockRecord;
        end;
      end;
    xmlArrowSize:       ArrowHeadSize := ANode.ValueAsDouble;//mlpArrowSize
    xmlContentType:     ContentType := ANode.ValueAsInt;//mlpContentType
    xmlTextStyle://mlpTextStyle
      begin
        if Assigned(vConv) then
        begin
          vTextStyle := TsgDXFStyle(vConv.Sections[csStyles].FindEntByName(ANode.ValueAsStr));
           if Assigned(vTextStyle) then
             TextStyle := vTextStyle;
        end;
      end;
    xmlLeftAttachment:       LeftAttachment := ANode.ValueAsInt;//mlpTextLeftAttachment
    xmlTextAngleType:        TextAngleType := ANode.ValueAsInt;//mlpTextAngleType
    xmlTextAlignment:        TextAlignmentType := ANode.ValueAsInt;//mlpTextAlignmentType
    xmlTextColor:            TextColor := ANode.ValueData.ValueAsColorCAD;//mlpTextColor
    xmlTextHeight:           TextHeight := ANode.ValueAsDouble;//mlpTextHeight
    xmlTextFrame:            TextFrameEnabled := ANode.ValueAsInt = 1;//mlpEnabledTextFrame
    xmlUseDefMText:          Text := ANode.ValueAsStr;//mlpEnabledUseDefMText
    xmlBlockName://mlpBlock
      begin
        if Assigned(vConv) then
        begin
          vBlock := vConv.BlockByName(ANode.ValueAsStr);
           if Assigned(vBlock) then
             BlockRecord := vBlock.BlockRecord;
        end;
      end;
    xmlBlockColor:           BlockColor := ANode.ValueData.ValueAsColorCAD;//mlpBlockColor
    xmlBlockScale:           BlockScale := ANode.ValueAsFPoint;//mlpBlockScale
    xmlBlockRotation:        BlockRotation := ANode.ValueAsDouble;//mlpBlockRotation
    xmlBlockConnectionType:  BlockConnectionType := ANode.ValueAsInt;//mlpBlockConnectionType
    xmlFPointScale:          ScaleFactor := ANode.ValueAsDouble;//mlpScale
    xmlRightAttachment:      RightAttachment := ANode.ValueAsInt;//mlpTextRightAttachment
    xmlTextSwitchAlignment:  AlwaysAlignTextLeft := ANode.ValueAsInt = 1;//mlpTextSwitchAlignmentType
    xmlTextAttachmentDirection: AttachmentDirection := ANode.ValueAsInt;//mlpTextAttachmentDirection
    xmlTopAttachment:        TopAttachment := ANode.ValueAsInt;//mlpTextTopAttachment
    xmlBottomAttachment:     BottomAttachment := ANode.ValueAsInt;//mlpTextBottomAttachment
    //not IsProperties
    xmlMLeaderOrder:        DrawMLeaderOrder := ANode.ValueAsInt;
    xmlLeaderOrder:         DrawLeaderOrder := ANode.ValueAsInt;
    xmlMaxNumberOfPoints:   MaxNumberOfPoints := ANode.ValueAsInt;
    xmlFirstSegmentAngle:   FirstSegmentAngle := ANode.ValueAsDouble;
    xmlSecondSegmentAngle:  SecondSegmentAngle := ANode.ValueAsDouble;
    xmlStyleDescription:    StyleDescription := ANode.ValueAsStr;
    xmlAlignSpace:          AlignSpace := ANode.ValueAsDouble;
    xmlBlockScaleEnabled:   IsBlockScaleEnabled := ANode.ValueAsInt = 1;
    xmlBlockRotationEnabled:IsBlockRotationEnabled := ANode.ValueAsInt = 1;
    xmlBreakSize:           BreakSize := ANode.ValueAsDouble;
    xmlFlagsStr:
      begin
        if not IsProperties then
          Result := cnstXML_UNSUPPORTED;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
  if IsProperties then
  begin
    if Result = cnstXML_OK then
    begin
      vPropertiesInit := PropertiesInit;
      for P := Low(cnstMLeaderXmlId) to High(cnstMLeaderXmlId) do
      begin
        if cnstMLeaderXmlId[P] = AType.Id then
        begin
          Include(vPropertiesInit, P);
          SetPropertiesInit(vPropertiesInit);
          Break;
        end;
      end;
    end;
  end;
end;

function TsgCADMLeaderStyle.GetArrow: TsgDXFBlockRecord;
begin
  Result := TsgDXFBlockRecord(FArrowItem.Item);
end;

function TsgCADMLeaderStyle.GetBlockRecord: TsgDXFBlockRecord;
begin
  Result := TsgDXFBlockRecord(FBlockRecordItem.Item);
end;

function TsgCADMLeaderStyle.GetColorCAD: TsgColorCAD;
begin
  Result := FColor;
end;

function TsgCADMLeaderStyle.GetLineType: TsgDXFLineType;
begin
  Result := TsgDXFLineType(FLineTypeItem.Item);
end;

function TsgCADMLeaderStyle.GetLineWeight: Double;
begin
  Result := FLineWeight;
end;

function TsgCADMLeaderStyle.GetPropertiesInit: TsgDXFMLeaderProps;
begin
  Result := [];
end;

function TsgCADMLeaderStyle.GetTextStyle: TsgDXFStyle;
begin
  Result := TsgDXFStyle(FTextStyleItem.Item);
end;

function TsgCADMLeaderStyle.IsProperties: Boolean;
begin
  Result := False;
end;

procedure TsgCADMLeaderStyle.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
end;

procedure TsgCADMLeaderStyle.LoadedInternal(AConverter: TsgDXFConverter);
begin
  inherited LoadedInternal(AConverter);
  if IsZero(FScaleFactor, fExtendedResolution) then
    FScaleFactor := 1.0;
end;

procedure TsgCADMLeaderStyle.SetArrow(const Value: TsgDXFBlockRecord);
begin
  if FArrowItem.Item <> Value then
  begin
    if FArrowItem.Item is TsgDXFBlockRecord then
      TsgDXFBlockRecord(FArrowItem.Item).RemoveDestroyNotification(ArrowDestroing);
    FArrowItem.Item := Value;
    if FArrowItem.Item is TsgDXFBlockRecord then
      TsgDXFBlockRecord(FArrowItem.Item).AddDestroyNotification(ArrowDestroing);
  end;
end;

procedure TsgCADMLeaderStyle.SetBlockRecord(const Value: TsgDXFBlockRecord);
begin
  if FBlockRecordItem.Item <> Value then
  begin
    if FBlockRecordItem.Item is TsgDXFBlockRecord then
      TsgDXFBlockRecord(FBlockRecordItem.Item).RemoveDestroyNotification(BlockrecordDestroing);
    FBlockRecordItem.Item := Value;
    if FBlockRecordItem.Item is TsgDXFBlockRecord then
      TsgDXFBlockRecord(FBlockRecordItem.Item).AddDestroyNotification(BlockrecordDestroing);
  end;
end;

procedure TsgCADMLeaderStyle.SetColorCAD(const Value: TsgColorCAD);
begin
  FColor := Value;
end;

procedure TsgCADMLeaderStyle.SetConsistentStyle(const AStyle: TsgCADMLeaderStyle);
var
  I: TsgDXFMLeaderProp;
  vPropertiesInit: TsgDXFMLeaderProps;
begin
  vPropertiesInit := PropertiesInit;
  if vPropertiesInit <> [] then
  begin
    for I := Low(TsgDXFMLeaderProp) to High(TsgDXFMLeaderProp) do
      if I in vPropertiesInit then
        case I of
          mlpLeaderLineType: AStyle.LeaderLineType := Self.LeaderLineType;
          mlpLineColor: AStyle.ColorCAD := Self.ColorCAD;
          mlpLineType: AStyle.LineType := Self.LineType;
          mlpLineWeight: AStyle.LineWeight := Self.LineWeight;
          mlpEnabledLanding: AStyle.LandingEnabled := Self.LandingEnabled;
          mlpLandingGap: AStyle.LandingGap := Self.LandingGap;
          mlpEnabledDogLeg: AStyle.DogLegEnabled := Self.DogLegEnabled;
          mlpDogLegLen: AStyle.LandingDistance := Self.LandingDistance;
          mlpArrow: AStyle.Arrow := Self.Arrow;
          mlpArrowSize: AStyle.ArrowHeadSize := Self.ArrowHeadSize;
          mlpContentType: AStyle.ContentType := Self.ContentType;
          mlpEnabledTextFrame: AStyle.TextFrameEnabled := Self.TextFrameEnabled;
          mlpEnabledUseDefMText: AStyle.Text := Self.Text;
          mlpBlock: AStyle.BlockRecord := Self.BlockRecord;
          mlpBlockColor: AStyle.BlockColor := Self.BlockColor;
          mlpBlockScale: AStyle.BlockScale := Self.BlockScale;
          mlpBlockRotation: AStyle.BlockRotation := Self.BlockRotation;
          mlpBlockConnectionType: AStyle.BlockConnectionType := Self.BlockConnectionType;
          mlpScale: AStyle.ScaleFactor := Self.ScaleFactor;
          mlpTextStyle: AStyle.TextStyle := Self.TextStyle;
          mlpTextAngleType: AStyle.TextAngleType := Self.TextAngleType;
          mlpTextAlignmentType: AStyle.TextAlignmentType := Self.TextAlignmentType;
          mlpTextColor: AStyle.TextColor := Self.TextColor;
          mlpTextHeight: AStyle.TextHeight := Self.TextHeight;          
          mlpTextSwitchAlignmentType: AStyle.AlwaysAlignTextLeft := Self.AlwaysAlignTextLeft;//?
          mlpTextAttachmentDirection: AStyle.AttachmentDirection := Self.AttachmentDirection;
          mlpTextLeftAttachment: AStyle.LeftAttachment := Self.LeftAttachment;
          mlpTextTopAttachment: AStyle.TopAttachment := Self.TopAttachment;
          mlpTextRightAttachment: AStyle.RightAttachment := Self.RightAttachment;          
          mlpTextBottomAttachment: AStyle.BottomAttachment := Self.BottomAttachment;
        end;
  end;
end;
procedure TsgCADMLeaderStyle.SetLineType(const AValue: TsgDXFLineType);
begin
  FLineTypeItem.Item := AValue;
end;

procedure TsgCADMLeaderStyle.SetLineWeight(Value: Double);
begin
  FLineWeight := Value;
end;

procedure TsgCADMLeaderStyle.SetPropertiesInit(const AValue: TsgDXFMLeaderProps);
begin
end;

procedure TsgCADMLeaderStyle.SetTextStyle(const Value: TsgDXFStyle);
begin
  FTextStyleItem.Item := Value;
end;

function TsgCADMLeaderStyle.ToXMLAsProperties(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  vPropertiesInit: TsgDXFMLeaderProps;
  vProperties: TsgStringList;
  P: TsgDXFMLeaderProp;
  vStr: string;
  vLen: Integer;
begin
  if IsFullPropsOrXMLHelp(AParams.Mode) or (PropertiesInit <> []) then
  begin
    Result := ToXMLNode(ANode, AParams);
    ANode.RemoveAttributeByName(cnstXMLNames[xmlName].Name);
    if IsFullProps(AParams.Mode) then
    begin
      vPropertiesInit := PropertiesInit;
      vProperties := TsgStringList.Create;
      try
        vProperties.Capacity := Ord(High(TsgDXFMLeaderProp)) - Ord(Low(TsgDXFMLeaderProp)) + 1;
        vProperties.LineBreak := cnstEnumValuesDelimiter;
        for P := Low(TsgDXFMLeaderProp) to High(TsgDXFMLeaderProp) do
        begin
          if P in vPropertiesInit then
            vProperties.Add(cnstXMLNames[cnstMLeaderXmlId[P]].Name);
        end;
        vStr := vProperties.Text;
        vLen := Length(vStr);
        while (vLen > 0) and (vStr[vLen] = cnstEnumValuesDelimiter) do
        begin
          Dec(vLen);
          SetLength(vStr, vLen);
        end;
        ANode.AddAttribNV(cnstXMLNames[xmlFlagsStr].Name).ValueAsStr := vStr;
      finally
        vProperties.Free;
      end;
    end;
  end
  else
    Result := cnstXML_OK;
end;

function TsgCADMLeaderStyle.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  vPropertiesInit: TsgDXFMLeaderProps;

  function AddStyleAttrib(const AStyleVal: TsgDXFMLeaderProp;
    const AType: TsgDataType; const AValue: Pointer): TsgNodeSample;
  var
    vXmlId: TsgXMLId;
  begin
    Result := nil;
    if (vPropertiesInit = []) or (AStyleVal in vPropertiesInit) then
    begin
      vXmlId := cnstMLeaderXmlId[AStyleVal];
      if vXmlId <> xmlUndefined then
      begin
        Result := ANode.AddAttribNV(cnstXMLNames[vXmlId].Name);
        if AType <> dtUndefined then
          Result.ValueData.SetValueTyped(AType, AValue);
      end;
    end;
  end;

  procedure AddStyleAttribInt(const AStyleVal: TsgDXFMLeaderProp; const AValue: Integer);
  begin
    AddStyleAttrib(AStyleVal, dtInteger, @AValue);
  end;

  procedure AddStyleAttribDouble(const AStyleVal: TsgDXFMLeaderProp; const AValue: Double);
  begin
    AddStyleAttrib(AStyleVal, dtDouble, @AValue);
  end;

  procedure AddStyleAttribColorCAD(const AStyleVal: TsgDXFMLeaderProp; const AValue: TsgColorCAD);
  begin
    AddStyleAttrib(AStyleVal, dtColorCAD, @AValue);
  end;

  procedure AddStyleAttribStr(const AStyleVal: TsgDXFMLeaderProp; const AValue: string);
  var
    vAttrib: TsgNodeSample;
  begin
    vAttrib := AddStyleAttrib(AStyleVal, dtUndefined, nil);
    if Assigned(vAttrib) then
      vAttrib.ValueAsStr := AValue;
  end;

begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlColor].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlLineWeight].Name);
  ANode.RemoveAttributeByName(cnstXMLNames[xmlLineTypeName].Name);
  if IsFullProps(AParams.Mode) then
    vPropertiesInit := []
  else
    vPropertiesInit := PropertiesInit;
  AddStyleAttribInt(mlpLeaderLineType, LeaderLineType);
  AddStyleAttribColorCAD(mlpLineColor, ColorCAD);
  if Assigned(LineType) then
    AddStyleAttribStr(mlpLineType, LineType.Name);
  AddStyleAttribDouble(mlpLineWeight, LineWeight);
  AddStyleAttribInt(mlpEnabledLanding, Ord(LandingEnabled));
  AddStyleAttribDouble(mlpLandingGap, LandingGap);
  AddStyleAttribInt(mlpEnabledDogLeg, Ord(DogLegEnabled));
  AddStyleAttribDouble(mlpDogLegLen, LandingDistance);
  if Assigned(Arrow) then
    AddStyleAttribStr(mlpArrow, Arrow.Name);
  AddStyleAttribDouble(mlpArrowSize, ArrowHeadSize);
  AddStyleAttribInt(mlpContentType, ContentType);
  if Assigned(TextStyle) then
    AddStyleAttribStr(mlpTextStyle, TextStyle.Name);
  AddStyleAttribInt(mlpTextLeftAttachment, LeftAttachment);
  AddStyleAttribInt(mlpTextAngleType, TextAngleType);
  AddStyleAttribInt(mlpTextAlignmentType, TextAlignmentType);
  AddStyleAttribColorCAD(mlpTextColor, TextColor);
  AddStyleAttribDouble(mlpTextHeight, TextHeight);
  AddStyleAttribInt(mlpEnabledTextFrame, Ord(TextFrameEnabled));
  AddStyleAttribStr(mlpEnabledUseDefMText, Text);
  if Assigned(BlockRecord) then
    AddStyleAttribStr(mlpBlock, BlockRecord.Name);
  AddStyleAttribColorCAD(mlpBlockColor, BlockColor);
  AddStyleAttrib(mlpBlockScale, dtTFPoint, @FBlockScale);
  AddStyleAttribDouble(mlpBlockRotation, BlockRotation);
  AddStyleAttribInt(mlpBlockConnectionType, BlockConnectionType);
  AddStyleAttribDouble(mlpScale, ScaleFactor);
  AddStyleAttribInt(mlpTextRightAttachment, RightAttachment);
  AddStyleAttribInt(mlpTextSwitchAlignmentType, Ord(AlwaysAlignTextLeft));
  AddStyleAttribInt(mlpTextAttachmentDirection, AttachmentDirection);
  AddStyleAttribInt(mlpTextTopAttachment, TopAttachment);
  AddStyleAttribInt(mlpTextBottomAttachment, BottomAttachment);
  if not IsProperties then
  begin
    ANode.AddAttribNV(cnstXMLNames[xmlMLeaderOrder].Name).ValueAsInt := DrawMLeaderOrder; 
    ANode.AddAttribNV(cnstXMLNames[xmlLeaderOrder].Name).ValueAsInt := DrawLeaderOrder;
    ANode.AddAttribNV(cnstXMLNames[xmlMaxNumberOfPoints].Name).ValueAsInt := MaxNumberOfPoints;
    ANode.AddAttribNV(cnstXMLNames[xmlFirstSegmentAngle].Name).ValueAsDouble := FirstSegmentAngle;
    ANode.AddAttribNV(cnstXMLNames[xmlSecondSegmentAngle].Name).ValueAsDouble := SecondSegmentAngle;
    ANode.AddAttribNV(cnstXMLNames[xmlStyleDescription].Name).ValueAsStr := StyleDescription;
    ANode.AddAttribNV(cnstXMLNames[xmlAlignSpace].Name).ValueAsDouble := AlignSpace;
    ANode.AddAttribNV(cnstXMLNames[xmlBlockScaleEnabled].Name).ValueAsInt := Ord(IsBlockScaleEnabled);
    ANode.AddAttribNV(cnstXMLNames[xmlBlockRotationEnabled].Name).ValueAsInt := Ord(IsBlockRotationEnabled);
    ANode.AddAttribNV(cnstXMLNames[xmlBreakSize].Name).ValueAsDouble := BreakSize;
  end;  
end;

  { TsgCADMLeaderProperties }

procedure TsgCADMLeaderProperties.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADMLeaderProperties then
    FPropertiesInit := TsgCADMLeaderProperties(Source).FPropertiesInit;
end;

function TsgCADMLeaderProperties.GetPropertiesInit: TsgDXFMLeaderProps;
begin
  Result := FPropertiesInit;
end;

function TsgCADMLeaderProperties.IsProperties: Boolean;
begin
  Result := True;
end;

procedure TsgCADMLeaderProperties.SetPropertiesInit(const AValue: TsgDXFMLeaderProps);
begin
  FPropertiesInit := AValue;
end;

{ TsgCADMultiLeader }

procedure TsgCADMultiLeader.AssignEntity(Source: TsgDXFEntity);
var
  I: Integer;
  vSource: TsgCADMultiLeader;
begin
  inherited AssignEntity(Source);
  if Source is TsgCADMultiLeader then
  begin
    vSource := TsgCADMultiLeader(Source);
    FStyleItem.Item := vSource.FStyleItem.Item;
    Properties.AssignEntity(vSource.Properties);
    SetLength(FArrows, Length(vSource.FArrows));
    for I := Low(vSource.FArrows) to High(vSource.FArrows) do
      FArrows[I] := vSource.FArrows[I];
    SetLength(FLabels, Length(vSource.FLabels));
    for I := Low(vSource.FLabels) to High(vSource.FLabels) do
      FLabels[I] := vSource.FLabels[I];
    FIsTextDirectionNegative := vSource.FIsTextDirectionNegative;
    FLeaderExtendedToText := vSource.FLeaderExtendedToText;
    FContext.AssignEntity(vSource.FContext);
    FJustification := vSource.FJustification;
    FTextAlignIPE := vSource.FTextAlignIPE;
  end;
end;

procedure TsgCADMultiLeader.ClearReferences;
begin
  inherited ClearReferences;
  FStyleItem.Item := nil;
  SetLength(FArrows, 0);
  SetLength(FLabels, 0);
  FContext.Clear;
end;

constructor TsgCADMultiLeader.Create;
begin
  inherited Create;
  FStyleItem := TsgTableItem.Create;
  FContext := TsgCADMLeaderAnnotContext.Create;
end;

procedure TsgCADMultiLeader.FreeReferences;
var
  vBlock: TsgDXFBlock;
begin
  inherited FreeReferences;
  FreeAndNil(FStyleItem);
  FreeAndNil(FProperties);
  FreeAndNil(FContext);
  vBlock := nil;
  if FRenderObject is TsgDXFInsert then
    vBlock := TsgDXFInsert(FRenderObject).Block;
  FreeAndNil(FRenderObject);
  FreeAndNil(vBlock);
end;

function TsgCADMultiLeader.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
var
  vConv: TsgDXFConverter;
  vStyles, vStyle: TsgDXFEntity;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    xmlProperties:
      begin
        if AIsChild then
          Properties.FromXMLAsProperties(ANode, AResult);
      end;
    xmlStyleName:
      begin
        vConv := Converter;
        if Assigned(vConv) then
        begin
          vStyles := vConv.Sections[csObjects].FindEntByName(cnstObjectsMLEADERSTYLES);
          if Assigned(vStyles) then
          begin
            vStyle := vStyles.FindEntByName(ANode.ValueAsStr);
            if vStyle is TsgCADMLeaderStyle then
              Style := TsgCADMLeaderStyle(vStyle);
          end;
        end;
      end;
    xmlDirectionSign:  IsTextDirectionNegative := ANode.ValueAsInt = 1;
    xmlExtendedToText: LeaderExtendedToText := ANode.ValueAsInt = 1;
    xmlJustification:  IsTextDirectionNegative := ANode.ValueAsInt = 1;
    xmlTextAlignIPE:   LeaderExtendedToText := ANode.ValueAsInt = 1;
    xmlArrows:
      begin
        if AIsChild then
        begin
        end;
      end;
    xmlLabels:
      begin
        if AIsChild then
        begin
        end;
      end;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgCADMultiLeader.FromXMLSubEntities(const ANode: TsgNodeSample;
  const AResult: IsgResultNode): Integer;

  procedure FromXmlNode(const AEnt: TsgDXFEntity);
  var
    vNode: TsgNode;
  begin
    if Assigned(AEnt) then
    begin
      vNode := TsgNode(ANode.GetChildByName(AEnt.GetXMLName));
      if Assigned(vNode) then
        Result := AEnt.FromXML(vNode, AResult);
    end;
  end;

begin
  Result := cnstXML_OK;
  FromXmlNode(Context);
  //FromXmlNode(RenderObject);
end;

function TsgCADMultiLeader.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vArrows, vLabels, vItem: TsgNode;
  vLabel: TsgMLeaderLabel;
begin
  Result := inherited ToXMLNode(ANode,  AParams);
  if HasProperties then
    Properties.ToXMLAsProperties(ANode.AddChildNV(cnstXMLNames[xmlProperties].Name), AParams);
  vArrows := ANode.AddChildNV(cnstXMLNames[xmlArrows].Name);
  vArrows.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := High(FArrows) - Low(FArrows) + 1;
  for I := Low(FArrows) to High(FArrows) do
    FArrows[I].ToXMLWithParams(vArrows, AParams);
  vLabels := ANode.AddChildNV(cnstXMLNames[xmlLabels].Name);
  vLabels.AddAttribNV(cnstXMLNames[xmlCount].Name).ValueAsInt := High(FLabels) - Low(FLabels) + 1; 
  for I := Low(FLabels) to High(FLabels) do    
  begin  
    vItem := vLabels.AddChildNV(cnstXMLNames[xmlItem].Name); 
    vLabel := FLabels[I];
    if Assigned(vLabel.Attdef) then
      vLabel.Attdef.ToXMLWithParams(vItem, AParams);
    vItem.AddAttribNV(cnstXMLNames[xmlText].Name).ValueAsStr := vLabel.Text;
    vItem.AddAttribNV(cnstXMLNames[xmlIndex].Name).ValueAsInt := vLabel.Id;
    vItem.AddAttribNV(cnstXMLNames[xmlWidth].Name).ValueAsDouble := vLabel.Width;        
  end;
  if Assigned(Style) then  
    ANode.AddAttribNV(cnstXMLNames[xmlStyleName].Name).ValueAsStr := Style.Name;
  ANode.AddAttribNV(cnstXMLNames[xmlDirectionSign].Name).ValueAsInt := Ord(IsTextDirectionNegative);
  ANode.AddAttribNV(cnstXMLNames[xmlExtendedToText].Name).ValueAsInt := Ord(LeaderExtendedToText);    
  ANode.AddAttribNV(cnstXMLNames[xmlJustification].Name).ValueAsInt := Ord(IsTextDirectionNegative);
  ANode.AddAttribNV(cnstXMLNames[xmlTextAlignIPE].Name).ValueAsInt := Ord(LeaderExtendedToText);
end;

procedure TsgCADMultiLeader.ToXMLSubEntities(const AParentNode: TsgNode;
  const AParams: TsgXMLParams);
var
  vSubEntities, vInsertNode: TsgNode;
  vParams: TsgXMLParams;
begin
  if SameText(AParentNode.Name, cnstXMLNames[xmlSubEntities].Name) then
    vSubEntities := AParentNode
  else
    vSubEntities := AParentNode.AddChildNV(cnstXMLNames[xmlSubEntities].Name);
  FContext.ToXMLWithParams(vSubEntities, AParams);
  if IsFullProps(AParams.Mode) and Assigned(RenderObject) then
  begin
    RenderObject.ToXMLWithParams(vSubEntities, AParams);
    if RenderObject.IsInsert and Assigned(TsgDXFInsert(RenderObject).Block) and (vSubEntities.ChildNodesCount > 0) then
    begin
      vInsertNode := TsgNode(vSubEntities.ChildNodes[vSubEntities.ChildNodesCount - 1]);
      if Assigned(vInsertNode) and SameText(vInsertNode.Name, RenderObject.GetXMLName) then
      begin
        vParams := AParams;
        vParams.Mode := vParams.Mode + [xmAddSubEntities, xmNoSubEntitiesNode];
        TsgDXFInsert(RenderObject).Block.ToXMLWithParams(vInsertNode, vParams);
      end;
    end;
  end;
end;

function TsgCADMultiLeader.GetBox: TFRect;
begin
  Result := RenderObject.Box;
end;

function TsgCADMultiLeader.GetConsistentStyle: TsgCADMLeaderStyle;
begin
  Result := TsgCADMLeaderStyle.Create;
  if Assigned(Style) then
  begin
    Result.AssignEntity(Style);
    Result.Annotative := Style.Annotative;
    if HasProperties then
      Properties.SetConsistentStyle(Result);
  end
  else
    Result.AssignEntity(Properties);
end;

function TsgCADMultiLeader.GetEntType: TsgCADEntities;
begin
  Result := ceMLeader;
end;

function TsgCADMultiLeader.GetRenderObject: TsgDXFEntity;
begin
  if not Assigned(FRenderObject) then
  begin
    FRenderObject := TsgDXFInsert.Create;
    FRenderObject.AssignEntity(Self);
    TsgDXFInsert(FRenderObject).BlockRecord := TsgDXFBlockRecord.Create;
    TsgDXFInsert(FRenderObject).Block.SetOwner(FRenderObject);
    TsgDXFInsert(FRenderObject).BlockRecord.SetOwner(Self);
  end;
  Result := FRenderObject;
end;

function TsgCADMultiLeader.GetLineType: TsgDXFLineType;
begin
  Result := Properties.LineType;
end;

function TsgCADMultiLeader.GetLineWeight: Double;
begin
  Result := Properties.LineWeight;
end;

function TsgCADMultiLeader.GetOverrideFlags: TsgDXFMLeaderProps;
begin
  Result := [];
  if HasProperties then
    Result := Properties.PropertiesInit;
end;

function TsgCADMultiLeader.GetProperties: TsgCADMLeaderStyle;
begin
  if not Assigned(FProperties) then
    FProperties := TsgCADMLeaderProperties.Create;
  Result := FProperties;
end;

function TsgCADMultiLeader.GetStyle: TsgCADMLeaderStyle;
begin
  Result := TsgCADMLeaderStyle(FStyleItem.Item);
end;

function TsgCADMultiLeader.HasProperties: Boolean;
begin
  Result := Assigned(FProperties);
end;

procedure TsgCADMultiLeader.Invoke(AConverter: TsgDXFConverter; Proc,
  FinishProc: TsgCADEntityProc);
begin
  if Assigned(FRenderObject) then
  begin
    if IsInvoke(AConverter) then
    begin
      if Assigned(Proc) then
        Proc(Self);
      try
        TsgDXFInsert(FRenderObject).Invoke(AConverter, Proc, FinishProc);
      finally
        if Assigned(FinishProc) then
          FinishProc(Self);
      end;
    end;
  end
  else
    inherited Invoke(AConverter, Proc, FinishProc);
end;

procedure TsgCADMultiLeader.Link(AConverter: TsgDXFConverter);
begin
  inherited Link(AConverter);
  Properties.Link(AConverter);
  FContext.Link(AConverter);
end;

procedure TsgCADMultiLeader.LoadedInternal(AConverter: TsgDXFConverter);
var
  vMLeaderGenerator: TsgMLeaderGenerator;
begin
  inherited LoadedInternal(AConverter);
  vMLeaderGenerator := TsgMLeaderGenerator.Create(Self, AConverter);
  try
    vMLeaderGenerator.Generate;
  finally
    vMLeaderGenerator.Free;
  end;
end;

procedure TsgCADMultiLeader.SetLineType(const Value: TsgDXFLineType);
begin
  Properties.LineType := Value;
end;

procedure TsgCADMultiLeader.SetLineWeight(Value: Double);
begin
  Properties.LineWeight := Value;
end;

procedure TsgCADMultiLeader.SetOverrideFlags(const Value: TsgDXFMLeaderProps);
begin
  TsgCADMLeaderProperties(Properties).SetPropertiesInit(Value);
end;

procedure TsgCADMultiLeader.SetStyle(const Value: TsgCADMLeaderStyle);
begin
  FStyleItem.Item := Value;
  if HasProperties and Assigned(Value) then
  begin
    Properties.AssignEntity(Value);
  end;
end;

{ TsgMLeaderContextData }

function TsgMLeaderContextData.AddMLeader(AMLeader: TsgMLeader): Integer;
begin
  Result := Length(FMLeaders);
  SetLength(FMLeaders, Result + 1);
  FMLeaders[Result] := AMLeader;
end;

procedure TsgMLeaderContextData.Assign(Source: TPersistent);
var
  I: Integer;
  vSource: TsgMLeaderContextData;
begin
  if Source is TsgMLeaderContextData then
  begin
    vSource := TsgMLeaderContextData(Source);
    Clear;
    for I := 0 to vSource.MLeadersCount - 1 do
      AddMLeader(TsgMLeader(vSource.MLeaders[I].Clone));
    FOverallScale := vSource.FOverallScale;
    FContentBasePoint := vSource.FContentBasePoint;
    FTextHeight := vSource.FTextHeight;
    FArrowHeadSize := vSource.FArrowHeadSize;
    FLandingGap := vSource.FLandingGap;
    FLeftAttachment := vSource.FLeftAttachment;
    FRightAttachment := vSource.FRightAttachment;
    FTextAlignType := vSource.FTextAlignType;
    FAttachmentType := vSource.FAttachmentType;
    FHasTextContents := vSource.FHasTextContents;
    FTextLabel := vSource.FTextLabel;
    FTextNormal := vSource.FTextNormal;
    FStyleItem.Item := vSource.FStyleItem.Item;
    FTextLocation := vSource.FTextLocation;
    FTextDirection := vSource.FTextDirection;
    FTextRotation := vSource.FTextRotation;
    FBoundaryWidth := vSource.FBoundaryWidth;
    FBoundaryHeight := vSource.FBoundaryHeight;
    FLineSpacingFactor := vSource.FLineSpacingFactor;
    FLineSpacingStyle := vSource.FLineSpacingStyle;
    FTextColor := vSource.FTextColor;
    FAlignment := vSource.FAlignment;
    FFlowDirection := vSource.FFlowDirection;
    FBackgroundColor := vSource.FBackgroundColor;
    FBackgroundScaleFactor := vSource.FBackgroundScaleFactor;
    FBackgroundTransparency := vSource.FBackgroundTransparency;
    FIsBackgroundEnabled := vSource.FIsBackgroundEnabled;
    FIsBackgroundMaskFillOn := vSource.FIsBackgroundMaskFillOn;
    FColumnType := vSource.FColumnType;
    FIsTextHeightAutomatic := vSource.FIsTextHeightAutomatic;
    FColumnWidth := vSource.FColumnWidth;
    FColumnGutter := vSource.FColumnGutter;
    FColumnFlowReversed := vSource.FColumnFlowReversed;
    FColumnSizes.Assign(vSource.FColumnSizes);
    FWordBreak := vSource.FWordBreak;
    FHasContentsBlock := vSource.FHasContentsBlock;
    FBlockRecordItem.Item := vSource.FBlockRecordItem.Item;
    FBlkNormal := vSource.FBlkNormal;
    FBlkLocation := vSource.FBlkLocation;
    FBlkScale := vSource.FBlkScale;
    FBlkRotation := vSource.FBlkRotation;
    FBlockColor := vSource.FBlockColor;
    FBlkMatrix := vSource.FBlkMatrix;
    FBasePoint := vSource.FBasePoint;
    FBaseDirection := vSource.FBaseDirection;
    FBaseVertical := vSource.FBaseVertical;
    FIsNormalReversed := vSource.FIsNormalReversed;
    FTopAttachment := vSource.FTopAttachment;
    FBottomAttachment := vSource.FBottomAttachment;
  end
  else
    inherited Assign(Source);
end;

procedure TsgMLeaderContextData.BlockrecordDestroing(Sender: TObject);
begin
  if Assigned(FBlockRecordItem) and (FBlockRecordItem.Item = Sender) then
  begin
    FBlockRecordItem.ItemObj.ObjRelease;
    FBlockRecordItem.FItem := nil;
  end;
end;

procedure TsgMLeaderContextData.Clear;
var
  I: Integer;
begin
  for I := High(FMLeaders) downto Low(FMLeaders) do
    FreeAndNil(FMLeaders[I]);
  SetLength(FMLeaders, 0);
end;

procedure TsgMLeaderContextData.ClearReferences;
begin
  BlockRecord := nil;
  FStyleItem.Item := nil;
end;

constructor TsgMLeaderContextData.Create;
begin
  FBaseDirection := cnstXOrtAxis;
  FBaseVertical := cnstYOrtAxis;
  FOverallScale := 1.0;
  FBlkMatrix := cnstIdentityMat;
  FBlkScale := cnstFPointSingle;
  FBlkNormal := cnstZOrtAxis;
  FLineSpacingFactor := 1.0;
  FTextNormal := cnstZOrtAxis;
  FTextDirection := cnstXOrtAxis;
  FBlockRecordItem := TsgTableItem.Create;
  FStyleItem := TsgTableItem.Create;
  FColumnSizes := TsgDoubleList.Create;
end;

destructor TsgMLeaderContextData.Destroy;
begin
  ClearReferences;
  Clear;
  FBlockRecordItem.Free;
  FStyleItem.Free;
  FColumnSizes.Free;
  inherited Destroy;
end;

function TsgMLeaderContextData.GetBlockRecord: TsgDXFBlockRecord;
begin
  Result := TsgDXFBlockRecord(FBlockRecordItem.Item);
end;

function TsgMLeaderContextData.GetMLeaders(Index: Integer): TsgMLeader;
begin
  Result := FMLeaders[Index];
end;

function TsgMLeaderContextData.GetMLeadersCount: Integer;
begin
  Result := Length(FMLeaders);
end;

function TsgMLeaderContextData.GetTextStyle: TsgDXFStyle;
begin
  Result := TsgDXFStyle(FStyleItem.Item);
end;

procedure TsgMLeaderContextData.Link(AConverter: TsgDXFConverter);
var
  I: Integer;
begin
  //inherited Link(AConverter);
  for I := 0 to MLeadersCount - 1 do
    MLeaders[I].Link(AConverter);
end;

procedure TsgMLeaderContextData.SetBlockRecord(const Value: TsgDXFBlockRecord);
begin
  if FBlockRecordItem.Item <> Value then
  begin
    if Assigned(FBlockRecordItem.Item) then
      FBlockRecordItem.Item.RemoveDestroyNotification(BlockrecordDestroing);
    FBlockRecordItem.Item := Value;
    if Assigned(FBlockRecordItem.Item) then
      FBlockRecordItem.Item.AddDestroyNotification(BlockrecordDestroing);
  end;
end;

procedure TsgMLeaderContextData.SetTextStyle(const Value: TsgDXFStyle);
begin
  FStyleItem.Item := Value;
end;

{$IFDEF SGDEL_2005}{$ENDREGION}{$ENDIF}

{ TsgTextLinesCollection }

function TsgTextLinesCollection.DoAddPt(const P): Integer;
var
  Pt: TFPoint;
  M: PFMatrix;
begin
  M := PFMatrix(Transformation);
  Pt.X := TFPoint(P).X * M^.M[0, 0] + TFPoint(P).Y * M^.M[1, 0] + M^.M[3, 0];
  Pt.Y := TFPoint(P).X * M^.M[0, 1] + TFPoint(P).Y * M^.M[1, 1] + M^.M[3, 1];
  Pt.Z := TFPoint(P).X * M^.M[0, 2] + TFPoint(P).Y * M^.M[1, 2] + M^.M[3, 2];
  Result := DoAddPtDirrect(Pt);
end;

function TsgTextLinesCollection.DoAddPtDirrect(const P): Integer;
begin
  TFPointList(Poly).Add(TFPoint(P));
  Result := inherited DoAddPtDirrect(P);
end;

{ TsgTextCurvesFPointListCollection }

function TsgTextCurvesFPointListCollection.DoAddPtDirrect(const P): Integer;
begin
  Result := inherited DoAddPtDirrect(P);
  TFPointList(TsgObjectList(Poly).Last).Add(TFPoint(P));
end;

procedure TsgTextCurvesFPointListCollection.ChangeItemsCount(ADelta: Integer);
var
  vObj: TObject;
begin
  while ADelta > 0 do
  begin
    TsgObjectList(Poly).Add(TFPointList.Create);
    Dec(ADelta);
  end;
  while (ADelta < 0) and (Poly.Count > 0) do
  begin
    vObj := TsgObjectList(Poly).Last;
    Poly.Count := Poly.Count - 1;
    vObj.Free;
    Inc(ADelta);
  end;
end;

function TsgTextCurvesFPointListCollection.NewCollection: TAddPt;
begin
  Result := inherited NewCollection;
  TsgObjectList(Poly).Add(TFPointList.Create);
end;

{ TsgEntitiesList }

function TsgEntitiesList.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := TsgDXFEntity(inherited Items[AIndex]);
end;

procedure TsgEntitiesList.SetEntity(const AIndex: Integer;
  const Value: TsgDXFEntity);
begin
  inherited Items[AIndex] := Value;
end;

{ TsgVertexesList }

function TsgVertexesList.GetBulge(const AIndex: Integer): Double;
begin
  Result := TsgDXFVertex(Items[AIndex]).Bulge;
end;

function TsgVertexesList.GetFPoint(const AIndex: Integer): TFPoint;
begin
  Result := TsgDXFVertex(Items[AIndex]).Point;
end;

function TsgVertexesList.GetFPointCount: Integer;
begin
  Result := Count;
end;

{ TsgDXFMesh }

procedure TsgDXFMesh.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgDXFMesh then
  begin
    Vertices := TsgDXFMesh(Source).Vertices;
    VertexIndices := TsgDXFMesh(Source).VertexIndices;
    TexCoords := TsgDXFMesh(Source).TexCoords;
  end;
end;

constructor TsgDXFMesh.Create;
begin
  inherited Create;
  FVertices := TFPointList.Create;
  FVertexIndices := TsgIntegerList.Create;
  FTexCoords := TFPointList.Create;
end;

function TsgDXFMesh.ExtractFaceIndices(AVertexIndices: Pointer): Integer;
var
  I, J: Integer;
  vFace: PsgInlineFace;
  vInlineFaceIndices: TsgInlineFaceIndices;
  vP: PsgIntegerArray;
begin
  GetFaceIndices(vInlineFaceIndices, nil);
  Result := 0;
  if Assigned(AVertexIndices) then
  begin
    vP := PsgIntegerArray(AVertexIndices);
    for I := Low(vInlineFaceIndices) to High(vInlineFaceIndices) do
    begin
      vFace := PsgInlineFace(vInlineFaceIndices[I]);
      Dec(PByte(vFace), SizeOf(vFace^.Count));
      vP^[Result] := vFace^.Indices[0];
      vP^[Result + 1] := vFace^.Indices[1];
      vP^[Result + 2] := vFace^.Indices[2];
      Inc(Result, 3);
      for J := 3 to vFace^.Count - 1 do
      begin
        vP^[Result] := vP^[Result - 3];
        vP^[Result + 1] := vFace^.Indices[J - 1];
        vP^[Result + 2] := vFace^.Indices[J];
        Inc(Result, 3);
      end;
    end;
  end
  else
    for I := Low(vInlineFaceIndices) to High(vInlineFaceIndices) do
    begin
      vFace := PsgInlineFace(vInlineFaceIndices[I]);
      Dec(PByte(vFace), SizeOf(vFace^.Count));
      Inc(Result, 3);
      if vFace^.Count > 3 then
        Inc(Result, (vFace^.Count - 3) * 3);
    end;
  Result := Result div 3;
end;

procedure TsgDXFMesh.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FVertices);
  FreeAndNil(FVertexIndices);
  FreeAndNil(FTexCoords);
end;

function TsgDXFMesh.GetEntType: TsgCADEntities;
begin
  Result := ceMesh;
end;

function TsgDXFMesh.GetFaceIndices(out AInlineFaceIndices: TsgInlineFaceIndices;
  ACountIndicesByFace: PInteger = nil): Integer;
type
  PsgInlineFaceIndices = ^TsgInlineFaceIndices;
var
  I, J: Integer;
  vTmp: TsgInlineFaceIndices;
  P: PsgInlineFaceIndices;
  F: PsgInlineFace;
begin
  Result := 0;
  I := 0;
  while I < FVertexIndices.Count - 2 do
  begin
    Inc(I, FVertexIndices[I] + 1);
    Inc(Result);
  end;
  if Assigned(ACountIndicesByFace) or (@AInlineFaceIndices <> nil) then
  begin
    if @AInlineFaceIndices <> nil then P := @AInlineFaceIndices else P := @vTmp;
    SetLength(P^, Result);
    I := 0;
    J := 0;
    while I < FVertexIndices.Count - 2 do
    begin
      F := PsgInlineFace(@FVertexIndices.List^[I]);
      P^[J] := @F^.Indices;
      Inc(I, F^.Count + 1);
      Inc(J);
    end;
    if Assigned(ACountIndicesByFace) then
      if Length(P^) > 0 then
      begin
        J := 0;
        ACountIndicesByFace^ := PsgInlineFace(IntPtr(P^[J]) - SizeOf(F^.Count))^.Count;
        Inc(J);
        while (J <= High(P^)) and (ACountIndicesByFace^ = PsgInlineFace(IntPtr(P^[J]) - SizeOf(F^.Count))^.Count) do Inc(J);
        if J <= High(P^) then ACountIndicesByFace^ := -(ACountIndicesByFace^ + 1);
      end
      else
        ACountIndicesByFace^ := 0;
  end;
end;

procedure TsgDXFMesh.GetXMLIdsChangingHiding(const AChangeList,
  AHideList: TsgIntegerList; AProgID: TsgProgID);
begin
  inherited GetXMLIdsChangingHiding(AChangeList, AHideList, AProgID);
  if AProgID = piCADNavigator then
  begin
    if Assigned(AHideList) then
    begin
      AHideList.Add(Integer(xmlPoint));
    end;
  end;
end;

function TsgDXFMesh.GroupExists: Boolean;
begin
  Result := False;
end;

procedure TsgDXFMesh.LoadedInternal(AConverter: TsgDXFConverter);
var
  I: Integer;
  E: TsgDXFEntity;
begin
  inherited LoadedInternal(AConverter);
  E := GetExtensionDictionary(cnstADSK_XREC_SUBDVERTEXTEXCOORDS);
  if E is TsgDXFXRecord then
  begin
    FTexCoords.Count := 0;
    I := 0;
    while I < TsgDXFXRecord(E).Data.DataCount do
    begin
      FTexCoords.Add(MakeFPoint(TsgDXFXRecord(E).Data.DataDouble[I],
        TsgDXFXRecord(E).Data.DataDouble[I+1], TsgDXFXRecord(E).Data.DataDouble[I+2]));
      Inc(I, 3);
    end;
  end;
end;

procedure TsgDXFMesh.SetTexCoords(const Value: TFPointList);
begin
  FTexCoords.Assign(Value);
end;

procedure TsgDXFMesh.SetVertexIndices(const Value: TsgIntegerList);
begin
  FVertexIndices.Assign(Value);
end;

procedure TsgDXFMesh.SetVertices(const Value: TFPointList);
begin
  FVertices.Assign(Value);
end;

procedure TsgDXFMesh.UpdateBox;
var
  I: Integer;
begin
  inherited UpdateBox;
  if Count = 0 then
    for I := 0 to Vertices.Count - 1 do
      ExpandFRect(FBox, Vertices[I]);
end;

{ TsgCADGroup }

procedure TsgCADGroup.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  if Source is TsgCADGroup then
  begin
    FUnnamed := TsgCADGroup(Source).FUnnamed;
    FSelectable := TsgCADGroup(Source).FSelectable;
  end;
end;

procedure TsgCADGroup.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  FItems.Clear;
end;

constructor TsgCADGroup.Create;
begin
  inherited;
  FItems := TsgEntitiesList.Create;
end;

function TsgCADGroup.DeleteEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := FItems[AIndex];
  FItems.Delete(AIndex);
end;

procedure TsgCADGroup.ExchangeEntity(AIndex1, AIndex2: Integer);
begin
  FItems.Exchange(AIndex1, AIndex2);
end;

procedure TsgCADGroup.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FItems);
end;

function TsgCADGroup.FromXMLNode(const AType: TsgXMLType;
  const ANode: TsgNodeSample; const AIsChild: Boolean;
  const AResult: IsgResultNode): Integer;
begin
  Result := inherited FromXMLNode(AType, ANode, AIsChild, AResult);
  if Result <> cnstXML_UNSUPPORTED then
    Exit;
  Result := cnstXML_OK;
  case AType.Id of
    sgConsts.xmlDescription: Description := ANode.ValueAsStr;
  else
    Result := cnstXML_UNSUPPORTED;
  end;
end;

function TsgCADGroup.GetCount: Integer;
begin
  Result := FItems.Count;
end;

function TsgCADGroup.GetEntity(const AIndex: Integer): TsgDXFEntity;
begin
  Result := TsgDXFEntity(FItems[AIndex]);
end;

function TsgCADGroup.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgDescriptedNamedItem;
end;

function TsgCADGroup.IndexOfEntity(const AEntity: TsgDXFEntity): Integer;
begin
  Result := FItems.IndexOf(AEntity);
end;

function TsgCADGroup.InsertEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity): Boolean;
var
  C: Integer;
begin
  C := FItems.Count;
  FItems.Insert(AIndex, AEntity);
  Result := FItems.Count > C;
end;

procedure TsgCADGroup.SetEntity(const AIndex: Integer;
  const AEntity: TsgDXFEntity);
begin
  FItems[AIndex] := AEntity;
end;

function TsgCADGroup.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstXMLNames[sgConsts.xmlDescription].Name).Value := Description;
end;

procedure TsgCADGroup.ToXMLSubEntities(const AParentNode: TsgNode; const AParams: TsgXMLParams);
var
  vParams: TsgXMLParams;
begin
  vParams := AParams;
  vParams.Mode := vParams.Mode + [xmOnlyChildNodes];
  inherited ToXMLSubEntities(AParentNode, vParams);
end;

{ TsgMultiSortItemsList }

function TsgMultiSortItemsList.CmpDescription(const Item1,
  Item2: Pointer): Integer;
begin
  Result := TsgTypeComparer.CmpStr(TsgOwneredItem(Item1^).Description, TsgOwneredItem(Item2^).Description, False);
end;

function TsgMultiSortItemsList.CmpHandle(const Item1,
  Item2: Pointer): Integer;
begin
  Result := TsgTypeComparer.CmpUInt64(TsgOwneredItem(Item1^).Handle, TsgOwneredItem(Item2^).Handle);
end;

function TsgMultiSortItemsList.CmpName(const Item1,
  Item2: Pointer): Integer;
begin
  Result := TsgTypeComparer.CmpStr(TsgOwneredItem(Item1^).Name, TsgOwneredItem(Item2^).Name, False);
end;

constructor TsgMultiSortItemsList.Create;
begin
  inherited Create;
  FSearchElem := TsgDescriptedNamedItem.Create(nil);
end;

destructor TsgMultiSortItemsList.Destroy;
begin
  FSearchElem.Free;
  inherited Destroy;
end;

function TsgMultiSortItemsList.GetByDescription(
  const ADescription: string): TsgOwneredItem;
var
  I: Integer;
begin
  Result := nil;
  if ADescription <> '' then
  begin
    SortType := mstDescription;
    Sorted := True;
    FSearchElem.Description := ADescription;
    if FindBase(@FSearchElem, I) then
      Result := TsgOwneredItem(Items[I]);
  end;
end;

function TsgMultiSortItemsList.GetByHandle(AHandle: UInt64): TsgOwneredItem;
var
  I: Integer;
begin
  Result := nil;
  if AHandle <> cnstBadHandle then
  begin
    SortType := mstHandle;
    Sorted := True;
    FSearchElem.Handle := AHandle;
    if FindBase(@FSearchElem, I) then
      Result := TsgOwneredItem(Items[I]);
  end;
end;

function TsgMultiSortItemsList.GetByName(const AName: string): TsgOwneredItem;
var
  I: Integer;
begin
  Result := nil;
  if AName <> '' then
  begin
    SortType := mstName;
    Sorted := True;
    FSearchElem.Name := AName;
    if FindBase(@FSearchElem, I) then
      Result := TsgOwneredItem(Items[I]);
  end;
end;

function TsgMultiSortItemsList.GetSortType: TsgMultiSortType;
var
  vProc: TsgObjProcCompare;
begin
  Result := mstCustom;
  vProc := ProcCompare;
  if IsEqualMethods(vProc, TsgPointerTypeComparer.CmpPointer) then
    Result := mstInstance
  else
    if IsEqualMethods(vProc, CmpName) then
      Result := mstName
    else
      if IsEqualMethods(vProc, CmpHandle) then
        Result := mstHandle
      else
        if IsEqualMethods(vProc, CmpDescription) then
          Result := mstDescription;
end;

class function TsgMultiSortItemsList.IsEqualMethods(const AProc1,
  AProc2: TsgObjProcCompare): Boolean;
begin
  Result := IsEqualMethod(TMethod(AProc1), TMethod(AProc2));
end;

procedure TsgMultiSortItemsList.SetSortType(const Value: TsgMultiSortType);
begin
  if Value <> GetSortType then
  begin
    Flags := Flags and not cnstSortedBit;
    case Value of
      mstInstance: ProcCompare := TsgPointerTypeComparer.CmpPointer;
      mstName: ProcCompare := CmpName;
      mstHandle: ProcCompare := CmpHandle;
      mstDescription: ProcCompare := CmpDescription;
    end;
  end;
end;

{ TsgDXFClass }

function TsgDXFClass.GetFlags: Integer;
begin
  Result := FFlags;
end;

function TsgDXFClass.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgDescriptedNamedItem;
end;

procedure TsgDXFClass.SetFlags(const Value: Integer);
begin
  FFlags := Value;
end;

{ TsgCADCustomIrdRecord }

function TsgCADCustomIrdRecord.AddAttributes(ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := cnstXML_OK;
end;

procedure TsgCADCustomIrdRecord.Clear(const ADoFree: Boolean);
begin
  inherited Clear(ADoFree);
  ClearValues;
end;

procedure TsgCADCustomIrdRecord.ClearValues;
begin
end;

class procedure TsgCADCustomIrdRecord.FinalizeIdrData(
  var AIdrData: TsgIrdFieldData);
begin
  case AIdrData.DataType of
    dtString:
      sgUnicodeStr(Pointer(AIdrData.VStr)) := '';
    dtTFPoint:
      if AIdrData.VFPoint <> nil then
      begin
        FreeMem(AIdrData.VFPoint);
        AIdrData.VFPoint := nil;
      end;
  end;
end;

procedure TsgCADCustomIrdRecord.FreeReferences;
var
  vAttributes: IsgGlobalPropProvider;
begin
  inherited FreeReferences;
  if GetGlobalPropProvider(Self, False, vAttributes) then
    vAttributes.RemoveItem(cnst_ird_data);
end;

class function TsgCADCustomIrdRecord.GetDataType(const AIrdClassName: string;
  out ADataType: TsgDataType): Boolean;
begin
  if AIrdClassName = 'ClassChar' then
    ADataType := dtString
  else if AIrdClassName = 'ClassReal' then
    ADataType := dtDouble
  else if AIrdClassName = 'ClassPoint' then
    ADataType := dtTFPoint
  else if (AIrdClassName = 'ClassNumeric') then
    ADataType := dtInteger
  else if (AIrdClassName = 'ClassLong') then
    ADataType := dtInteger
  else
    ADataType := dtUndefined;
  Result := ADataType <> dtUndefined;
end;

function TsgCADCustomIrdRecord.GetLinkClass: TsgOwneredItemClass;
begin
  Result := TsgIrdDescriptedNamedItem;
end;

class function TsgCADCustomIrdRecord.ReadString(var P: PWideChar;
  out S: sgUnicodeStr): Integer;
var
  vStart: PWideChar;
begin
  vStart := P;
  while P^ <> #0 do Inc(P);
  Result := P - vStart;
  SetString(S, vStart, Result);
  Inc(P);
end;

{ TsgCADIrdDscRecord }

procedure TsgCADIrdDscRecord.ClearValues;
var
  I: Integer;
begin
  inherited ClearValues;;
  for I := 0 to High(FFieldDefs) do
    FinalizeIdrData(FFieldDefs[I].Data);
  SetLength(FFieldDefs, 0);
end;

function TsgCADIrdDscRecord.AddAttributes(ANode: TsgNode; const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vField: TsgNode;
  vAttr: TsgNodeAttrib;
begin
  Result := inherited AddAttributes(ANode, AParams);
  for I := 0 to High(FFieldDefs) do
  begin
    vField := ANode.AddChildNV(FFieldDefs[I].Name);
    vField.AddAttribNV(cnstXMLNames[sgConsts.xmlDescription].Name, FFieldDefs[I].Description);
    vField.AddAttribNV('Type', cnstDataTypes[FFieldDefs[I].Data.DataType].Name);
    vAttr := vField.AddAttribNV('DefaultValue');
    case FFieldDefs[I].Data.DataType of
      dtInteger: vAttr.ValueAsInt := FFieldDefs[I].Data.VInt32;
      dtString: vAttr.ValueAsStr := string(sgUnicodeStr(FFieldDefs[I].Data.VStr));
      dtPoint:
        if Assigned(FFieldDefs[I].Data.VFPoint) then
          SetDataValueAsFPoint(vAttr.ValueData, FFieldDefs[I].Data.VFPoint^, xmlForViewing in AParams.Mode);
      dtDouble: vAttr.ValueAsDouble := FFieldDefs[I].Data.VDouble;
    end;
  end;
end;

function TsgCADIrdDscRecord.ToXMLNode(const ANode: TsgNode; const AParams: TsgXMLParams): Integer;
const
  cnstTableName = 'TableName';
begin
  Result := inherited ToXMLNode(ANode, AParams);
  ANode.AddAttribNV(cnstTableName, FTableName);
  if Description <> '' then
    ANode.AddAttribNV(cnstXMLNames[sgConsts.xmlDescription].Name, Description);
  AddAttributes(ANode, AParams);
end;

procedure TsgCADIrdDscRecord.Link(AConverter: TsgDXFConverter);
type
  PIdrDataItem = ^TIdrDataItem;
  TIdrDataItem = packed record
    Size: Integer;
    HasData: WideChar;//#1 ??
    Data: record end;
    Tail: array[0 .. 3] of WideChar;
  end;
var
  I: Integer;
  vAttributes: IsgGlobalPropProvider;
  vData: Variant;
  P: PIdrDataItem;
  S: array[0 .. 5] of sgUnicodeStr;
begin
  inherited Link(AConverter);
  if GetGlobalPropProvider(Self, False, vAttributes) and
     vAttributes.TryGetValue(cnst_ird_data, vData) then
  begin
    vAttributes.RemoveItem(cnst_ird_data);
    P := PIdrDataItem(TVarData(vData).VArray^.Data);
    FTableFlags := Ord(PWideChar(P)^);
    Inc(PWideChar(P), 2);
    for I := Low(S) to High(S) do
      ReadString(PWideChar(P), S[I]);
    if FTableFlags and $3000 = $3000 then
    begin
      FTableName := string(S[0]);
      Description := string(S[4]);
      SetLength(FFieldDefs, Ord(PWideChar(P)^));
      I := 0;
      Inc(PWideChar(P), 3);
    end
    else
    begin
      I := 0;
      SetLength(FFieldDefs, 1);
      FFieldDefs[I].Name := S[0];
      FTableName := string(FFieldDefs[I].Name);
      FFieldDefs[I].Description := S[4];
      Description := string(FFieldDefs[I].Description);
      GetDataType(FFieldDefs[I].Name, FFieldDefs[I].Data.DataType);
      Inc(I);
      Inc(PWideChar(P));
    end;
    while I < Length(FFieldDefs) do
    begin
      ReadString(PWideChar(P), S[0]);// field name
      ReadString(PWideChar(P), S[1]);// "Class...";
      ReadString(PWideChar(P), S[3]);// "Ird"
      ReadString(PWideChar(P), S[4]);// description
      GetDataType(S[1], FFieldDefs[I].Data.DataType);
      case FFieldDefs[I].Data.DataType of
        dtTFPoint: GetMem(FFieldDefs[I].Data.VFPoint, SizeOf(TFPoint));
      end;
      FFieldDefs[I].Name := S[0];
      FFieldDefs[I].Description := S[4];
      if P^.Size > 0 then
      begin
        case FFieldDefs[I].Data.DataType of
          dtInteger: FFieldDefs[I].Data.VInt32 := PInteger(@P^.Data)^;
          dtString: SetString(sgUnicodeStr(FFieldDefs[I].Data.VStr),
            PWideChar(@P^.Data), P^.Size div SizeOf(WideChar) - 2);
          dtDouble: FFieldDefs[I].Data.VDouble := PDouble(@P^.Data)^;
          dtTFPoint: FFieldDefs[I].Data.VFPoint^ := PFPoint(@P^.Data)^;
        end; { case }
      end;
      Inc(PByte(P), P^.Size + SizeOf(P^.Tail));
      Inc(I);
    end;
  end;
end;

{ TsgCADIrdObjRecord }

function TsgCADIrdObjRecord.AddAttributes(ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
var
  I: Integer;
  vField: TsgNode;
  vAttr: TsgNodeAttrib;
begin
  Result := inherited AddAttributes(ANode, AParams);
  if Assigned(IrdDscRecord) then
    for I := 0 to High(FValues) do
    begin
      vField := ANode.AddChildNV(string(IrdDscRecord.FFieldDefs[I].Name));
      //vField.AddAttribNV(cnstXMLNames[TsgXMLId.xmlDescription].Name, FFieldDefs[I].Description);
      vField.AddAttribNV('Type', cnstDataTypes[FValues[I].DataType].Name);
      vAttr := vField.AddAttribNV('Value');
      case FValues[I].DataType of
        dtInteger: vAttr.ValueAsInt := FValues[I].VInt32;
        dtString: vAttr.ValueAsStr := string(sgUnicodeStr(Pointer(FValues[I].VStr)));
        dtPoint:
          if Assigned(FValues[I].VFPoint) then
            SetDataValueAsFPoint(vAttr.ValueData, FValues[I].VFPoint^, xmlForViewing in AParams.Mode);
        dtDouble: vAttr.ValueAsDouble := FValues[I].VDouble;
      end;
    end;
end;

procedure TsgCADIrdObjRecord.ClearReferences;
begin
  inherited ClearReferences;
  IrdDscRecord := nil;
end;

procedure TsgCADIrdObjRecord.ClearValues;
var
  I: Integer;
begin
  inherited ClearValues;
  for I := 0 to High(FValues) do
    FinalizeIdrData(FValues[I]);
  SetLength(FValues, 0);
end;

constructor TsgCADIrdObjRecord.Create;
begin
  inherited Create;
  FIrdDscRecordItem := TsgTableItem.Create;
end;

procedure TsgCADIrdObjRecord.FreeReferences;
begin
  inherited FreeReferences;
  FreeAndNil(FIrdDscRecordItem);
end;

function TsgCADIrdObjRecord.GetIrdDscRecord: TsgCADIrdDscRecord;
begin
  Result := TsgCADIrdDscRecord(FIrdDscRecordItem.Item);
end;

//procedure TsgCADIrdObjRecord.IrdDscRecordDestroyed(Sender: TObject);
//begin
//  ClearValues;
//end;

procedure TsgCADIrdObjRecord.Link(AConverter: TsgDXFConverter);
var
  I: Integer;
  vHasIrdData: Boolean;
  vIrdDsc: TsgCADIrdDscRecord;
  vAttributes: IsgGlobalPropProvider;
  vData: Variant;
  P: PWideChar;
begin
  inherited Link(AConverter);
  vHasIrdData := GetGlobalPropProvider(Self, False, vAttributes) and
     vAttributes.TryGetValue(cnst_ird_data, vData) and
     (TVarData(vData).VType and varArray <> 0);
  if vHasIrdData then
    vAttributes.RemoveItem(cnst_ird_data);
  vIrdDsc := IrdDscRecord;
  if vHasIrdData and Assigned(vIrdDsc) then
  begin
    P := PWideChar(TVarData(vData).VArray^.Data);
    Inc(P);
    I := 0;
    SetLength(FValues, Length(vIrdDsc.FFieldDefs));
    while I < Length(vIrdDsc.FFieldDefs) do
    begin
      FValues[I].DataType := vIrdDsc.FFieldDefs[I].Data.DataType;
      case FValues[I].DataType of
        dtInteger:
          begin
            FValues[I].VInt32 := PInteger(P)^;
            Inc(P, SizeOf(Integer) div SizeOf(WideChar));
          end;
        dtString: ReadString(P, sgUnicodeStr(Pointer(FValues[I].VStr)));
        dtDouble:
          begin
            FValues[I].VDouble := PDouble(P)^;
            Inc(P, SizeOf(Double) div SizeOf(WideChar));
          end;
        dtTFPoint:
          begin
            GetMem(FValues[I].VFPoint, SizeOf(TFPoint));
            FValues[I].VFPoint^ := PFPoint(P)^;
            Inc(P, SizeOf(TFPoint) div SizeOf(WideChar));
          end;
      end;
      Inc(I);
    end;
  end;
end;

procedure TsgCADIrdObjRecord.SetIrdDscRecord(const Value: TsgCADIrdDscRecord);
begin
//  if FIrdDscRecordItem.Item <> Value then
//  begin
//    if Assigned(FIrdDscRecordItem.Item) then
//      FIrdDscRecordItem.Item.RemoveDestroyNotification(IrdDscRecordDestroyed);
    FIrdDscRecordItem.Item := Value;
//    if Assigned(FIrdDscRecordItem.Item) then
//      FIrdDscRecordItem.Item.AddDestroyNotification(IrdDscRecordDestroyed);
//  end;
end;

function TsgCADIrdObjRecord.ToXMLNode(const ANode: TsgNode;
  const AParams: TsgXMLParams): Integer;
begin
  Result := inherited ToXMLNode(ANode, AParams);
  //AddAttributes(ANode, AParams);
end;

procedure ProcInit;
begin
{$IFDEF SG_GLOBALHANDLE}
  GlobalListItemInfo := TsgDXFConverter.ObjToString;
  {$ENDIF}
  GlobalAutoCorrectSymbolTableRecordNames := False;
  GlobalCheckNameLayer := True;
  LoadEntityProc := nil;
  ExternalEntities := nil;
  StdLines := TsgLines.Create;
  MacroStrings := TStringList.Create;
  GlobalLoadingXRefsStack := TList.Create;
  XRefFileClasses := nil;
{$IFDEF SG_BTI}
  RegisterEntityClass(cnstGroupTypeName[gtBTI], Ord(ceAttrib), TsgAttrib);
{$ENDIF}
  GlobalsgTypes.AddClass(Tsg2DCurve);
  GlobalsgTypes.AddClass(Tsg2DLine);
  GlobalsgTypes.AddClass(Tsg2DArc);
  GlobalsgTypes.AddClass(Tsg2DEllipse);
  GlobalsgTypes.AddClass(Tsg2DSpline);
  GlobalsgTypes.AddClass(Tsg2DPoints);
  GlobalsgTypes.AddClass(Tsg2DPolyline);
  GlobalsgTypes.AddClass(Tsg2DBoundaryList);
  GlobalsgTypes.AddClass(TsgCADHatch, 10);
  GlobalsgTypes.AddClass(TsgCADCurvePolygon, 5);
  GlobalsgTypes.AddClass(TsgCADPolyPolygon, 3);
  GlobalsgTypes.AddClass(TsgCADGradientPolygon, 4);
  GlobalsgTypes.AddClass(TsgCADHelix, 43);
  GlobalsgTypes.AddClass(TsgCADMPolygon, 11);
  GlobalsgTypes.AddClass(TsgCADFill, 3);
  GlobalsgTypes.AddClass(TsgCADWipeout, 28);
  GlobalsgTypes.AddClass(TsgDXFAcadTable, 1);
  GlobalsgTypes.AddClass(TsgDXFAcadTableStyle);
  GlobalsgTypes.AddClass(TsgDXFArc, 60);
  GlobalsgTypes.AddClass(TsgDXFAttdef, 13);
  GlobalsgTypes.AddClass(TsgDXFAttrib, 14);
  GlobalsgTypes.AddClass(TsgDXFBlock);
  GlobalsgTypes.AddClass(TsgDXFDimensionStyle);
  GlobalsgTypes.AddClass(TsgDXFConverter);
  GlobalsgTypes.AddClass(TsgDXFCircle, 16);
  GlobalsgTypes.AddClass(TsgDXFDictionary);
  GlobalsgTypes.AddClass(TsgDXFDimension, 18);
  GlobalsgTypes.AddClass(TsgDXFEntity);
  GlobalsgTypes.AddClass(TsgDXFEllipse, 19);
  GlobalsgTypes.AddClass(TsgDXFField);
  GlobalsgTypes.AddClass(TsgDXFFieldList);
  GlobalsgTypes.AddClass(TsgDXFGroup);
  GlobalsgTypes.AddClass(TsgDXFInsert, 23);
  GlobalsgTypes.AddClass(TsgDXFImageDef);
  GlobalsgTypes.AddClass(TsgDXFImageEnt, 29);
  GlobalsgTypes.AddClass(TsgDXFLayer);
  GlobalsgTypes.AddClass(TsgDXFLayout);
  GlobalsgTypes.AddClass(TsgDXFLeader, 30);
  GlobalsgTypes.AddClass(TsgDXFLine, 31);
  GlobalsgTypes.AddClass(TsgDXFLineType);
  GlobalsgTypes.AddClass(TsgDXFLWPolyline, 32);
  GlobalsgTypes.AddClass(TsgDXFMText, 33);
  GlobalsgTypes.AddClass(TsgDXFTolerance, 45);
  GlobalsgTypes.AddClass(TsgDXFObjectEntity, 34);
  GlobalsgTypes.AddClass(TsgDXFOle2Frame, 53);
  GlobalsgTypes.AddClass(TsgDXFOwneredItem);
  GlobalsgTypes.AddClass(TsgDXFPenEntity, 35);
  GlobalsgTypes.AddClass(TsgDXFPenLine, 36);
  GlobalsgTypes.AddClass(TsgDXFPoint, 37);
  GlobalsgTypes.AddClass(TsgDXFPolyline, 38);
  GlobalsgTypes.AddClass(TsgDXFProxy);
  GlobalsgTypes.AddClass(TsgDXFRay, 39);
  GlobalsgTypes.AddClass(TsgDXFRegion, 40);
  GlobalsgTypes.AddClass(TsgDXFSection);
  GlobalsgTypes.AddClass(TsgDXFShape, 41);
  GlobalsgTypes.AddClass(TsgDXFSolid, 42);
  GlobalsgTypes.AddClass(TsgDXFSortEntsTable);
  GlobalsgTypes.AddClass(TsgDXFSpline, 43);
  GlobalsgTypes.AddClass(TsgDXFTable);
  GlobalsgTypes.AddClass(TsgDXFText, 44);
  GlobalsgTypes.AddClass(TsgDXFTrace, 46);
  GlobalsgTypes.AddClass(TsgDXF3dFace, 47);
  GlobalsgTypes.AddClass(TsgDXF3dFace, 48);
  GlobalsgTypes.AddClass(TsgDXFXline, 49);
  GlobalsgTypes.AddClass(TsgDXFStyle);
  GlobalsgTypes.AddClass(TsgDXFVertex);
  GlobalsgTypes.AddClass(TsgDXFViewport);
  GlobalsgTypes.AddClass(TsgDXFVport);
  GlobalsgTypes.AddClass(TsgDXFXref, 50);
  GlobalsgTypes.AddClass(TsgDWGPolyline, 38);
  GlobalsgTypes.AddClass(TsgDXFInsertXref);
  GlobalsgTypes.AddClass(TsgDXFSectionHeader);
  GlobalsgTypes.AddClass(TsgDXFSectionTables);
  GlobalsgTypes.AddClass(TsgDXFBlockRecords);
  GlobalsgTypes.AddClass(TsgDXFSectionBlocks);
  GlobalsgTypes.AddClass(TsgDXFSectionObjects);
  GlobalsgTypes.AddClass(TsgDXFSectionEntities);
  GlobalsgTypes.AddClass(TsgDXFPenTableItem);
  GlobalsgTypes.AddClass(TsgDXFAppID);
  GlobalsgTypes.AddClass(TsgDXFBlockRecord);
  GlobalsgTypes.AddClass(TsgMLineStyle);
  GlobalsgTypes.AddClass(TsgMLineEntry);
  GlobalsgTypes.AddClass(TsgCADRasterVariables);
  GlobalsgTypes.AddClass(TsgCADWipeoutVariables);
  GlobalsgTypes.AddClass(TsgCADClipInsert, 6);
  GlobalsgTypes.AddClass(TsgDXFPlotSettings);
//  GlobalsgTypes.AddClass(TsgFlatEntity, 8);
  GlobalsgTypes.AddClass(TsgFlatPoly, 9);
  GlobalsgTypes.AddClass(TsgFlatPoly3D);
  GlobalsgTypes.AddClass(TsgFlatHatch, 7);
  GlobalsgTypes.AddClass(TsgCADMInsert, 26);
  GlobalsgTypes.AddClass(TsgCADMLine, 27);
  GlobalsgTypes.AddClass(TsgMVertex);
  GlobalsgTypes.AddClass(TsgDXFBody, 15);
  GlobalsgTypes.AddClass(TsgDXFCustomVertex, 17);
  GlobalsgTypes.AddClass(TsgDXFEntitySample, 20);
  GlobalsgTypes.AddClass(TsgSVGMText, 55);
  GlobalsgTypes.AddClass(TsgDXFViewport, 51);
  GlobalsgTypes.AddClass(TsgDXFVport, 52);
//  GlobalsgTypes.AddClass(TsgSVGInsert, 56);
  GlobalsgTypes.AddClass(TsgDXF3DSolid, 57);
  GlobalsgTypes.AddClass(TsgDXFSurface, 58);
  GlobalsgTypes.AddClass(TsgCADMultiLeader);
  GlobalsgTypes.Sort;

{$IFDEF SG_INTERNAL_TEST_AB3DKERNEL}
  GlobalBrepParser := TList.Create;
{$ENDIF}
end;

procedure ProcFinalize;
begin
  ClearObjects(XRefFileClasses);
  XRefFileClasses.Free;
  GlobalLoadingXRefsStack.Free;
  StdLines.Free;
  MacroStrings.Free;
  ExternalEntitiesFree;
{$IFDEF SG_INTERNAL_TEST_AB3DKERNEL}
  FreeList(GlobalBrepParser);
{$ENDIF}
end;

{ TsgEntityProxy }

procedure TsgObjEntity3D.AssignEntity(Source: TsgDXFEntity);
begin
  inherited AssignEntity(Source);
  FInspArea := -2;
  FInspVolume := -1;
  FFaceGeomType := -1;
  FAlpaBlend := -1;
  FInspColor := clByBlock;
  FreeAndNil(FFaceGeom);
  if Source is TsgObjEntity3D then
  begin
    FOriginalEntity := TsgObjEntity3D(Source).FOriginalEntity;
    FInspectorEntity := TsgObjEntity3D(Source).FInspectorEntity;
    FPathKey := TsgObjEntity3D(Source).FPathKey;
    FHandle := TsgObjEntity3D(Source).FHandle;
    FInspArea := TsgObjEntity3D(Source).FInspArea;
    FInspVolume := TsgObjEntity3D(Source).FInspVolume;
    FAlpaBlend := TsgObjEntity3D(Source).FAlpaBlend;
    FInspColor := TsgObjEntity3D(Source).FInspColor;
    UpdateInspectorProps;
  end;
end;

function TsgObjEntity3D.CanDraw: Boolean;
begin
  Result := True;
end;

constructor TsgObjEntity3D.Create;
begin
  inherited Create;
  FInspArea := -2;
  FInspVolume := -1;
  FFaceGeomType := -1;
end;

destructor TsgObjEntity3D.Destroy;
begin
  FreeAndNil(FFaceGeom);
  inherited Destroy;
end;

function TsgObjEntity3D.FromXML(const ANode: TsgNodeSample;
  const AResult: IsgResultNode): Integer;
var
  vObject: IsgXMLObject;
  vNode: TsgNodeSample;
  vPathKey: string;
  vIsPathKeyBuild, vIsPathKeyModified: Boolean;
begin
  //No inherited !!!
  Result := cnstXML_ERROR;
  if Supports(FOriginalEntity, IsgXMLObject, vObject) then
  begin
    vIsPathKeyBuild := False;
    vIsPathKeyModified := False;
    vNode := nil;
    try
      vNode := TsgNode(ANode).GetAttributeByName(sgConsts.cnstXMLNames[xmlPathKey].Name);
      if Assigned(vNode) then
      begin
        vPathKey := vNode.ValueAsStr;
        if (Length(vPathKey) > 0) and (vPathKey[1] = '-') then
        begin
          vIsPathKeyModified := True;
          vNode.ValueAsHandle := GetPathKeyShort
        end;
      end
      else
      begin
        TsgNode(ANode).AddAttribNV(
          sgConsts.cnstXMLNames[xmlPathKey].Name).ValueAsHandle := GetPathKeyShort;
        vIsPathKeyBuild := True;
      end;
      vObject.FromNode(ANode);
    finally
      if vIsPathKeyBuild then
        TsgNode(ANode).RemoveAttributeByName(
          sgConsts.cnstXMLNames[xmlPathKey].Name, True)
      else
        if vIsPathKeyModified and Assigned(vNode) then
          vNode.ValueAsStr := vPathKey;
    end;
    Result := cnstXML_OK;
  end;
end;

function TsgObjEntity3D.GetAlphaBlend: Integer;
begin
  Result := FAlpaBlend;
end;

function TsgObjEntity3D.GetArea: Double;
begin
  Result := FInspArea;
end;

function TsgObjEntity3D.GetBox: TFRect;
begin
  Result := FInspBox;
end;

function TsgObjEntity3D.GetColorInt: TsgColorCAD;
begin
  if FInspColor = clByBlock then
    Result := cnstColorCADByBlock
  else
    Result := MakeColorCAD(acRGBColor, FInspColor);
end;

function TsgObjEntity3D.GetCustomColorInt: TsgColorCAD;
begin
  if FInspColor = clByBlock then
    Result := cnstColorCADByBlock
  else
    Result := MakeColorCAD(acRGBColor, FInspCustomColor);
end;

function TsgObjEntity3D.GetEntType: TsgCADEntities;
begin
  Result := ceEntity3D;
end;

function TsgObjEntity3D.GetFaceGeom: TsgNodeSample;
begin
  Result := FFaceGeom;
end;

function TsgObjEntity3D.GetFaceType: Integer;
begin
  Result := FFaceGeomType;
end;

function TsgObjEntity3D.GetInsName: string;
begin
  Result := FInpName;
end;

function TsgObjEntity3D.GetInspectorEntity: TsgDXFEntity;
begin
  Result := FInspectorEntity;
end;

function TsgObjEntity3D.GetPathKeyShort: UInt64;
begin
  Result := 0;
  if (Length(FPathKey) > 0) and (FPathKey[1] = '-') then
    Result := sgComparer.GetHashCodeStr(FPathKey)
  else
  begin
    if Length(FPathKey) > 0 then
      Result := StrToInt64(FPathKey);
  end;
end;

function TsgObjEntity3D.GetSize: TFPoint;
begin
  Result := FInspSize;
end;

function TsgObjEntity3D.GetVolume: Double;
begin
  Result := FInspVolume;
end;

procedure TsgObjEntity3D.RefreshInspectorProps;
begin
  UpdateInspectorProps(True);
end;

procedure TsgObjEntity3D.SetAlphaBlend(const AValue: Integer);
var
  vNode: TsgNode;
begin
  if (FAlpaBlend < 0) or (not IsValInParamI(AValue, 0, 100)) then Exit;
  FAlpaBlend := AValue;
  vNode := TsgNode.Create;
  try
    vNode.Name := 'SetParams';
    vNode.AddAttribNV(cnstXMLNames[xmlAlphaBlend].Name).ValueAsInt := 100 - FAlpaBlend;
    FromXML(vNode);
  finally
    FreeAndNil(vNode);
  end;
end;

procedure TsgObjEntity3D.SetColorInt(const AVAlue: TsgColorCAD);
var
  vNode: TsgNode;
  vColorInt: INteger;
begin
  if IsEqualColorCAD(AVAlue, cnstColorCADByBlackWhite) or
     IsEqualColorCAD(AVAlue, cnstColorCADByBlock) or
     IsEqualColorCAD(AVAlue, cnstColorCADByLayer) then
   Exit;

  vColorInt := ConvertColorCADToRGB(AVAlue);
  if FInspColor = vColorInt then Exit;
  FlagsChanges := FlagsChanges or 1;
  FInspColor := vColorInt;
  vNode := TsgNode.Create;
  try
    vNode.Name := 'SetParams';
    vNode.AddAttribNV(cnstXMLNames[xmlColor].Name).ValueData.ValueAsColorCAD := MakeColorCAD(acRGBColor, FInspColor);
    vNode.AddAttribNV(cnstXMLNames[xmlColorCustom].Name).ValueData.ValueAsColor := FInspColor;
    FromXML(vNode);
  finally
    FreeAndNil(vNode);
  end;
end;

procedure TsgObjEntity3D.SetCustomColorInt(const AVAlue: TsgColorCAD);
var
  vNode: TsgNode;
  vColorInt: INteger;
begin
  if IsEqualColorCAD(AVAlue, cnstColorCADByBlackWhite) or
     IsEqualColorCAD(AVAlue, cnstColorCADByBlock) or
     IsEqualColorCAD(AVAlue, cnstColorCADByLayer) then
   Exit;

  vColorInt := ConvertColorCADToRGB(AVAlue);
  if FInspCustomColor = vColorInt then Exit;
  FInspCustomColor := vColorInt;
  vNode := TsgNode.Create;
  try
    vNode.Name := 'SetParams';
    vNode.AddAttribNV(cnstXMLNames[xmlColorCustom].Name).ValueData.ValueAsColor := FInspCustomColor;
    FromXML(vNode);
  finally
    FreeAndNil(vNode);
  end;
end;

procedure TsgObjEntity3D.SetHandle(const AValue: UInt64);
begin
  FHandle := AValue;
end;

procedure TsgObjEntity3D.SetInspectorEntity;
begin
  FInspectorEntity := nil;
  if Assigned(FOriginalEntity) then
  begin
    if FOriginalEntity is TsgDXFEntity then
      FInspectorEntity := TsgDXFEntity(FOriginalEntity)
    else
    begin
      if (Length(FPathKey) > 0) and (FPathKey[1] = '-') then
        FInspectorEntity := TsgSupportPathKey.GetDXFEntityByPathStrKey(FPathKey);
    end;
  end;
  UpdateInspectorProps;
end;

procedure TsgObjEntity3D.SetOrgEntityAndKey(const AEntity: TObject;
  const APathKey: string);
begin
  FOriginalEntity := AEntity;
  FPathKey := APathKey;
  SetInspectorEntity;
end;

procedure TsgObjEntity3D.SetPathKey(const Value: String);
begin
  FPathKey := Value;
  SetInspectorEntity;
end;

function TsgObjEntity3D.ToXMLWithParams(const AParentNode: TsgNode;
  const AParams: TsgXMLParams): TsgNode;
var
  vObject: IsgXMLObject;
  vNode: TsgNode;
  vParams: TsgXMLParams;
begin
  //No inherited !!!
  Result := nil;
  if Supports(FOriginalEntity, IsgXMLObject, vObject) then
  begin
    vNode := TsgNode.Create;
    try
      vNode.AddAttribNV(sgConsts.cnstXMLNames[xmlPathKey].Name).ValueAsHandle := GetPathKeyShort;
      vParams := AParams;
      vParams.NodeData := vNode;
      Result := vObject.ToNode(AParentNode, vParams);
    finally
      vNode.Free;
    end;
  end;
end;

procedure TsgObjEntity3D.UpdateInspectorProps(const AUpdate: Boolean = False);
{$IFNDEF SG_NO_USE_KERNEL3D}
var
  I, vIndex: Integer;
  vNodeRoot, vEntNode, vSubEntNode, vNodeItem: TsgNode;
  vNodeBox, vNodeSize, vFaceGeom, vAttrib, vNodeColors: TsgNodeSample;
  vParams: TsgXMLParams;
//  vRemove: Boolean;
//  vXml: TStringList;
begin
  FInpName := '';
  FInspArea := -1;
  FInspVolume := -1;
  FInspBox := cnstBadRect;
  FInspSize := cnstFPointZero;
  if not AUpdate then
  begin
    FreeAndNil(FFaceGeom);
    FFaceGeomType := -1;
  end;
  if Assigned(FOriginalEntity) then
  begin
    vFaceGeom := nil;
    vNodeItem := nil;
    vNodeRoot := TsgNode.Create;
    try
      vNodeRoot.Name := GetXMLName;
      vParams.Mode := [xmlForViewing, xmlModGeometry];
      if Assigned(FOriginalEntity) and (FOriginalEntity is TsgModTopoFace) then
        vParams.Mode := vParams.Mode + [xmAddSubEntities, xmOnlyChildNodes{, xmNoSubEntitiesNode}];
      vParams.NodeData := nil;
      ToXMLWithParams(vNodeRoot, vParams);
//      vXml := TStringList.Create;
//      try
//        vXml.Text := SaveNodeToXMLString(vNodeRoot);
//        vXml.SaveToFile('d:\NodeRoot.xml');
//      finally
//        vXml.Free;
//      end;
      if vNodeRoot.ChildNodesCount > 0 then
      begin
        vEntNode := TsgNode(vNodeRoot.ChildNodes[0]);
        FInspArea := GetAttributeFloat(vEntNode, cnstXMLNames[xmlArea].Name, FInspArea);
        FInspVolume := GetAttributeFloat(vEntNode, cnstXMLNames[xmlVolume].Name, FInspVolume);
        FInpName := GetAttributeStr(vEntNode, cnstXMLNames[xmlName].Name, FInpName);
        FAlpaBlend := GetAttributeInt(vEntNode, cnstXMLNames[xmlAlphaBlend].Name, FAlpaBlend);
        if FAlpaBlend >= 0 then//invalid value
          FAlpaBlend := 100 - FAlpaBlend;
        // Colors block
        FInspColor := clByBlock;
        vNodeColors := vEntNode.GetAttributeByName(sgConsts.cnstXMLNames[xmlColor].Name);
        if Assigned(vNodeColors) then
          FInspColor :=  vNodeColors.ValueData.ValueAsColorCAD.Color;
        vNodeColors := vEntNode.GetAttributeByName(sgConsts.cnstXMLNames[xmlColorVector].Name);
        if Assigned(vNodeColors) then
        begin
          FInspColor :=   RGBFromFloat(Point4dMake(vNodeColors.ValueAsFPoint), nil).Color;
        end;
        FInspCustomColor := GetAttributeColor(vEntNode, cnstXMLNames[xmlColorCustom].Name, clByBlock);
        //
        vNodeBox := vEntNode.GetAttributeByName(cnstXMLNames[xmlBox3d].Name);
        if Assigned(vNodeBox) then
          FInspBox := vNodeBox.ValueAsFRect;
        vNodeSize := vEntNode.GetAttributeByName(cnstXMLNames[xmlSize].Name);
        if Assigned(vNodeSize) then
          FInspSize := vNodeSize.ValueAsFPoint;
        if not AUpdate then
        begin
          vSubEntNode := nil;
          if xmAddSubEntities in vParams.Mode then
            vSubEntNode := TsgNode(vEntNode.GetChildByName(cnstXMLNames[xmlSubEntities].Name));
          if Assigned(vSubEntNode) and (vSubEntNode.ChildNodesCount > 0) then
          begin
            for I := 0 to vSubEntNode.ChildNodesCount - 1 do
            begin
              vNodeItem := TsgNode(vSubEntNode.ChildNodes[I]);
              vIndex := GetAttributeInt(vNodeItem, cnstXmlSurfaceType, -1);
              if vIndex > -1 then
              begin
                FFaceGeomType := vIndex;
                vFaceGeom := vNodeItem;
                Break;
              end;
            end;
          end;
          if Assigned(vFaceGeom) and (FFaceGeomType >= Ord(Low(TsgSurfType))) and (FFaceGeomType <= Ord(High(TsgSurfType))) then
          begin
            FFaceGeom := TsgNode.Create;
            //FFaceGeom.Assign(vNodeItem);
            FFaceGeom.Name := vNodeItem.Name;
            for I := vNodeItem.AttributeNodesCount - 1 downto 0 do
            begin
              vAttrib := vNodeItem.AttributeNodes[I];
              if IndexOfStrings(vAttrib.Name, cnstIngoreNames3D) < 0 then
              begin
                if vAttrib.Name <> cnstXmlSurfaceType then
                begin
                  vNodeItem.Attributes.Delete(I);
                  TsgNode(FFaceGeom).AddAttrib(vAttrib);
                end;
              end;
            end;
            TsgNode(FFaceGeom).Attributes.SortNodes(TsgNodeSample.SameNodeNames);
          end
          else
            FFaceGeomType := -1;
        end;
      end;
    finally
      vNodeRoot.Free;
    end;
    if (Length(FInpName) = 0) and IsEntity(FOriginalEntity) and TsgDXFEntity(FOriginalEntity).IsInsert then
    begin
      vIndex := TsgDXFInsert(FOriginalEntity).IndexAttribOfName(cnstBrepOriginalName);
      if vIndex > -1 then
        FInpName := TsgDXFAttrib(TsgDXFInsert(FOriginalEntity).Attribs[vIndex]).Value;
    end;
  end;
{$ELSE}
begin
{$ENDIF}
end;

{ TsgSupportPathKey }

class function TsgSupportPathKey.GetDXFEntityByPathStrKey(
  APathStrKey: string): TsgDXFEntity;
var
  I: Integer;
  vObjList: TsgObjectList;
begin
  Result := nil;
  if Length(APathStrKey) = 0 then
    Exit;
  if not (APathStrKey[1] = '-') then
    Exit;

  vObjList := TsgObjectList.Create;
  try
    GetObjectListByPathStrKey(APathStrKey, vObjList);
    for I := vObjList.Count - 1 downto 0 do
      if vObjList[I] is TsgDXFEntity then
      begin
        Result := TsgDXFEntity(vObjList[I]);
        Break;
      end;
  finally
    vObjList.Free;
  end;
end;

class procedure TsgSupportPathKey.GetObjectListByPathStrKey(APathStrKey: string;
  AObjectList: TsgObjectList);
var
  I: Integer;
  vStrPath: TsgStringList;
  vObject: TObject;
begin
  if Assigned(AObjectList) then
  begin
    vStrPath := TsgStringList.Create;
    try
      vStrPath.LineBreak := '-';
      vStrPath.Text := APathStrKey;
      DeleteEmptyStrings(vStrPath);
      for I := 0 to vStrPath.Count - 1 do
      begin
        vObject := TObject(StrToInt64(vStrPath[I]));
        if Assigned(vObject) then
          AObjectList.Add(vObject)
      end;
    finally
      vStrPath.Free;
    end;
  end;
end;

class function TsgSupportPathKey.GetPathKeyByFullXMLNode(
  const AXMLNode: TsgNodeSample): string;
var
  vOwner: TsgNodeSample;
  vEntity: TObject;
begin
  Result := '';
  if not Assigned(AXMLNode) then
    Exit;
  vOwner := AXMLNode.Owner;
  while Assigned(vOwner) do
  begin
    vEntity := TsgNodeAccess(vOwner).Entity;
    vOwner := vOwner.Owner;
    Result := GetPathKeyByObject(vEntity) + Result;
  end;
  Result := GetPathKeyByObject(TsgNodeAccess(AXMLNode).Entity) + Result;
end;

class function TsgSupportPathKey.GetPathKeyByObject(AObject: TObject): string;
var
  vIEntity: IsgXMLSupportBuildKey;
  vXMLObject: IsgXMLObject;
begin
  Result := '';
  if not Assigned(AObject) then
    Exit;
  if not Supports(AObject, IsgXMLSupportBuildKey, vIEntity) then
    Exit;
  if vIEntity.IsUsedInKeyConstruction = False then
    Exit;
  if not Supports(AObject, IsgXMLObject, vXMLObject) then
    Exit;
  Result := '-'+ IntToStr(UInt64(AObject));
end;

class function TsgSupportPathKey.GetPathKeyByObjectList(
  AObjectList: TsgObjectList): string;
var
  I: Integer;
  vPathKey: string;
begin
  Result := '';
  for I := 0 to AObjectList.Count - 1 do
  begin
    vPathKey := GetPathKeyByObject(AObjectList[I]);
    if Length(vPathKey) <> 0 then
      Result := vPathKey + Result;
  end;
end;

initialization
  ProcInit;

finalization
  ProcFinalize;

end.
